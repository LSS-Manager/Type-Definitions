/*
 File:               application-e88092dab62208086a358353d5e4354d.js
 Server:             en_GB
 Time:               2021-06-13T20:19:07+02:00
 Formatter:          https://github.com/beautify-web/js-beautify
 Formatter Version:  1.13.0
 Formatter Settings: {"indent_size":"4","indent_char":" ","max_preserve_newlines":"1","preserve_newlines":true,"keep_array_indentation":true,"break_chained_methods":true,"indent_scripts":"normal","brace_style":"collapse","space_before_conditional":true,"unescape_strings":false,"jslint_happy":true,"end_with_newline":false,"wrap_line_length":"110","indent_inner_html":true,"comma_first":false,"e4x":false,"indent_empty_lines":false}
 */

function check_and_enable_apng_support() {
    const e = new Image;

    const t = document.createElement("canvas")
      .getContext("2d");

    e.onload = () => {
        t.drawImage(e, 0, 0), self.apng_supported = 0 === t.getImageData(0, 0, 1, 1)
          .data[3]
    }, e.src =
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg=="
}

function searchMission() {
    const e = $("#search_input_field_missions")
        .attr("search_class");

    const t = $("#search_input_field_missions")
      .val()
      .toUpperCase();

    $(`.${e}`)
      .each(function () {
          $(this)
            .attr("search_attribute")
            .toUpperCase().includes(t) ? $(this)
            .removeClass("searchHelperInvisble") : $(this)
            .addClass("searchHelperInvisble")
      }), missionScrollUpdate()
}

function mission_overview_timer_call() {
    let e = 0;

    const t = (new Date)
      .getTime();

    "undefined" != typeof mission_overview_last_count && (e = t - mission_overview_last_count),
      mission_overview_last_count = t, $(".mission_overview_countdown[timeleft!=0]")
      .each(function () {
          let t = $(this)
            .attr("timeleft");
          t > 0 && (t -= e, 0 >= t ? (t = 0, $(this)
            .html("")) : $(this)
            .html(`${I18n.t("javascript.mission_start_in")} ${formatTime(Math.round(t / 1e3), !
    1)}`), $(this)
            .attr("timeleft", t))
      })
}

function successfullMessage(e) {
    $("#important_messages_success")
      .html(e), $("#important_messages_success")
      .show(), setTimeout(() => {
        $("#important_messages_success")
          .hide()
    }, 2e3)
}

function aao_building_check(e, t) {
    if (e.length <= 0) return !0;
    if (t.attr("building_id").includes("_")) {
        const i = t.attr("building_id")
            .split("_");

        let n = !1;
        return $.each(i, (t, i) => {
            e.includes(parseInt(i)) && (n = !0)
        }), n;
    }
    return e.includes(parseInt(t.attr("building_id"))) ? !0 : !1;
}

function aao_check(e, t, i) {
    let n = -3;
    if (i > 0) {
        n = 0;
        let o;
        if (e.includes("vehicle_type_id_")) {
            const s = e.substring(16);
            o = $(`${aao_source_element} input`)
              .filter(function () {
                  return $(this)
                    .attr("vehicle_type_id") === s
              })
        } else o = $(`${aao_source_element} input`)
          .filter(function () {
              return $(this)
                .attr(e) > 0
          });
        o.each(function () {
            if (i > 0) {
                var o = [];
                if ("" != t.attr("building_ids")) var o = jQuery.parseJSON(t.attr("building_ids"));
                aao_building_check(o, $(this)) && !$(this)
                  .is(":checked") && !$(this)
                  .is(":disabled") && $(this)
                  .attr("ignore_aao") <= 0 && ($(this)
                    .attr("vehicle_type_ignore_default_aao") <= 0 || e.includes("custom_")
                ) && (i -= "wasser_amount" == e || "wasser_amount_tlf" == e ? $(this)
                  .attr(e) : 1), 0 >= i && (n = $(`#vehicle_sort_${$(this)
  .val()}`)
                  .attr("timevalue"))
            }
        })
    }
    return i > 0 ? !1 : {
        max_time: n
    }
}

function aaoNextAvailable(e, t) {
    let i = -1;
    return $(`${aao_source_element} input[${e}|=1]`)
      .each(function () {
          if (-1 == i) {
              var n = [];
              if ("" != t.attr("building_ids")) var n = jQuery.parseJSON(t.attr("building_ids"));
              if (aao_building_check(n, $(this)) && !$(this)
                .prop("checked") && !$(this)
                .prop("disabled") && $(this)
                .attr("ignore_aao") <= 0 && ($(this)
                .attr("vehicle_type_ignore_default_aao") <= 0 || e.includes("custom_"))) {
                  const o = $(this)
                    .val();
                  i = parseInt($(`#vehicle_sort_${o}`)
                    .attr("sortvalue"))
              }
          }
      }), i;
}

function aao(e, t, i, n) {
    if (n > 0) {
        let o;
        if (e.includes("vehicle_type_id_")) {
            const s = e.substring(16);
            o = $(`${aao_source_element} input`)
              .filter(function () {
                  return $(this)
                    .attr("vehicle_type_id") === s
              })
        } else o = $(`${aao_source_element} input`)
          .filter(function () {
              return $(this)
                .attr(e) > 0
          });
        o.each(function () {
            if (n > 0) {
                var i = [];
                if ("" != t.attr("building_ids")) var i = jQuery.parseJSON(t.attr("building_ids"));
                aao_building_check(i, $(this)) && !$(this)
                  .prop("checked") && !$(this)
                  .prop("disabled") && $(this)
                  .attr("ignore_aao") <= 0 && ($(this)
                    .attr("vehicle_type_ignore_default_aao") <= 0 || e.includes("custom_")
                ) && ("grtw0" == e && $(`#vehicle_mode_${$(this)
  .val()}_0`)
                  .prop("checked", !0)
                  .change(), "grtw1" == e && $(`#vehicle_mode_${$(this)
  .val()}_1`)
                  .prop("checked", !0)
                  .change(), n -= "wasser_amount" == e || "wasser_amount_tlf" == e ? $(this)
                  .attr(e) : 1, $(this)
                  .prop("checked", !0), $(this)
                  .change())
            }
        })
    }
    return n > 0 ? `${I18n.t("javascript.missed_vehicle")} ${n} ${i}. ` : "";
}

function mission_participation_add(e) {
    $(`#mission_participant_${e}`)
      .removeClass("hidden"), $(`#mission_participant_new_${e}`)
      .addClass("hidden")
}

function vehicleDistance(e, t, i, n, o, s, a) {
    return s > 0 ? (vehicleDistanceDraw(t, i, e, s), !0) : 1 != e ? (url =
      `https://www.leitstellenspiel.de/osrmroute/viaroute?loc=${t},${i}&loc=${n},${o}`, $
      .get(url, s => {
        if ("undefined" != typeof s.code && "Ok" == s.code && (0 == s.routes[0].distance ? s
          .status = -1 : (s.route_summary = {}, s.route_summary.total_time = s.routes[0]
          .duration, s.status = 200)), 200 != s.status)
            return vehicleDistanceLeitstellenspiel(e, t, i, n, o, a), !0;
        let r = TIME_MODIFIER_NORMAL;
        ("undefined" == typeof a || 1 == a) && (r = TIME_MODIFIER_SONDERRECHTE);
        let l = Math.round(s.route_summary.total_time * r);
        const c = vehicleDistanceDirectTimeToObject(20, t, i, n, o, a);
        l > c && (l = vehicleDistanceDirectTimeToObject(30, t, i, n, o, a)), vehicleDistanceDraw(
          t, i, e, l), reload_table()
    }), !0) : (vehicleDistanceDirect(190, e, t, i, n, o, a), void 0);
}

function vehicleDistanceLeitstellenspiel(direct_move, source_latitude, source_longitude, target_latitude,
                                         target_longitude, sonderrechte) {
    $.get(`/distance/${String(source_latitude)
  .replace(".", "o")}/${String(source_longitude)
  .replace(".", "o")}/${direct_move}/${String(target_latitude)
  .replace(".", "o")}/${String(target_longitude)
  .replace(".", "o")}/v3/${sonderrechte ? "1" : "0"}`,
      data => {
          eval(data), reload_table()
      })
}

function vehicleDistanceDirectTimeToObject(e, t, i, n, o, s) {
    let a = distance(t, i, n, o) / 1e3;
    .1 > a && (a = .1);
    let r = TIME_MODIFIER_NORMAL;
    return ("undefined" == typeof s || 1 == s) && (r = TIME_MODIFIER_SONDERRECHTE), Math.round(60 * (a / (e /
      60)) * r)
}

function vehicleDistanceDraw(e, t, i, n) {
    $(`.alarm_distance_${String(e)
  .replace(".", "_")}_${String(t)
  .replace(".", "_")}_${i}`)
      .each(function () {
          let e = parseInt($(this)
            .attr("start_delay"));
          isNaN(e) && (e = 0);
          const t = n + e;
          $(this)
            .html(formatTimeDescription(t, !0)), $(this)
            .attr("sortValue", t)
            .attr("timevalue", t)
      })
}

function vehicleDistanceDirect(e, t, i, n, o, s, a) {
    const r = vehicleDistanceDirectTimeToObject(e, i, n, o, s, a);
    vehicleDistanceDraw(i, n, t, r), reload_table()
}

function allianceChatHeaderInfo(e) {
    $("#alliance_chat_header_info")
      .html(e), e.length > 0 ? $("#alliance_chat_header_info")
      .show() : $("#alliance_chat_header_info")
      .hide()
}

function allianceChat(e) {
    let t = "";
    let i = !1;
    (e.message.toUpperCase().includes(`@${username.toUpperCase()}`) || e.message.toUpperCase().includes("@all ".toUpperCase()) || e.message.toUpperCase().includes("@all:".toUpperCase()) || e.message.toUpperCase().includes("@admin".toUpperCase()) && (alliance_admin || alliance_coadmin) || "0" != e.whisper) && (t =
      "chatToSelf", "0" != e.whisper && (t = "chatWhisper", splitMessage = e.message.split(" "),
      splitMessage[0] = `<a username='${splitMessage[0]}' class='alliance_chat_private_username'><img class='alliance_chat_private_username' src='/images/icons8-privacy.svg'/></a><a href='/profile/${e.whisper}' class='lightbox-open label label-warning'>${splitMessage[0]}</a>`, e.message =
      splitMessage.join(" ")), audio_chat_highlight && 1 != e.ignore_audio && user_id != e.user_id && !
      i && (play("chat_message_highlight"), i = !0), !$("body")
      .hasClass("bigMap") || missionMarkerBulkAdd || $("#chat_outer")
      .hasClass("fadeIn") || $("#bigMapMenuChatButton")
      .addClass("bigMapMenuButtonBlack"));
    const n = e.iso_timestamp ? e.iso_timestamp : "";
    let o = `<li class='${t}' data-message-time='${n}'><span class='mission_chat_message_username' title='${e.date_hidden}'>[${e.date}] <img username='${e.username}' class='alliance_chat_copy_username' src='/images/icons8-reply.svg'><a username='${e.username}' class='alliance_chat_private_username'> <img class='alliance_chat_private_username' src='/images/icons8-privacy.svg' /></a> <a href='/profile/${e.user_id}' class='lightbox-open `;
    "true" == e.alliance_admin ? o += "label label-info" : "true" == e.alliance_coadmin && (o +=
      "label label-default"), audio_chat && 1 != e.ignore_audio && user_id != e.user_id && !i && (play(
      "chat_message"), i = !0), o = `${o}'>${e.username}:</a></span>`, e.mission_id && (o = `${o}<a href='/missions/${e.mission_id}' class='lightbox-open'><span class='glyphicon glyphicon-bell'></span>`, "undefined" != typeof e
      .mission_caption && e.mission_caption && (o = `${o}[${e.mission_caption}]`), o += "</a> "),
      o = `${o} ${e.message}</li>`, $("#mission_chat_messages")
      .prepend(o), !$("body")
      .hasClass("bigMap") || missionMarkerBulkAdd || $("#chat_outer")
      .hasClass("fadeIn") || $("#bigMapMenuChatButton")
      .addClass("bigMapMenuButtonGreen")
}

function waterCalculatorSetPercent(e, t, i) {
    const n = 100 - i;
    t > n && (t = n), t > 0 ? e.css("width", `${t}%`)
      .show() : e.css("width", "0%")
      .hide()
}

function waterCalculator(e) {
    let t = 0;
    $(".progress-bar-mission-window-water")
      .each(function () {
          t = $(this)
            .data("need_water")
      });

    const i = $(`#mission_water_bar_at_mission_${e}`)
        .data("water-has");

    const n = $(`#mission_water_bar_driving_${e}`)
      .data("water-has");

    const o = $(`#mission_water_bar_selected_${e}`)
      .data("water-has");

    const s = $(`#mission_water_bar_at_mission_${e}`)
      .data("water-modifier") / 100;

    const a = $(`#mission_water_bar_driving_${e}`)
      .data("water-modifier") / 100;

    const r = $(`#mission_water_bar_selected_${e}`)
      .data("water-modifier") / 100;

    const l = i + i * s;
    const c = n + n * (a + s) + i * a;
    const u = o + o * (r + a + s) + i * r + n * r;
    const d = t - (l + c + u);
    let h = parseInt(100 * (l / t));
    let p = parseInt(100 * (c / t));
    let m = parseInt(100 * (u / t));
    const f = parseInt(100 * (d / t));
    const _ = 100 - (h + p + m + f);
    _ > 0 && (h > 0 ? h += _ : p > 0 ? p += _ : m > 0 ? m += _ : f > 0 && (m += _)),
      waterCalculatorSetPercent($(`#mission_water_bar_at_mission_${e}`), h, 0), waterCalculatorSetPercent($(
      `#mission_water_bar_driving_${e}`), p, h), waterCalculatorSetPercent($(
      `#mission_water_bar_selected_${e}`), m, p + h), waterCalculatorSetPercent($(
      `#mission_water_bar_missing_${e}`), 100, m + p + h), $(`#mission_water_bar_at_mission_${e}`)
      .html(I18n.t("javascript.water_on_site", {
          amount: number_format(parseInt(l))
      })), $(`#mission_water_bar_driving_${e}`)
      .html(I18n.t("javascript.water_approaching", {
          amount: number_format(parseInt(c))
      })), $(`#mission_water_bar_selected_${e}`)
      .html(I18n.t("javascript.water_selected", {
          amount: number_format(parseInt(u))
      })), $(`#mission_water_bar_missing_${e}`)
      .html(I18n.t("javascript.water_missing", {
          amount: number_format(parseInt(d))
      })), m + p + h >= 100 ? ($(`#mission_water_bar_selected_${e}`)
      .addClass("progress-bar-success")
      .removeClass("progress-bar-danger"), $(`#mission_water_progress_${e}`)
      .addClass("progress-glow-success")
      .removeClass("progress-glow-danger")) : ($(`#mission_water_bar_selected_${e}`)
      .addClass("progress-bar-danger")
      .removeClass("progress-bar-success"), $(`#mission_water_progress_${e}`)
      .addClass("progress-glow-danger")
      .removeClass("progress-glow-success"))
}

function missionWindowHasUpdate(e) {
    $(`#mission_bar_holder_${e}`)
      .addClass("col-xs-3 col-md-6"), $(`#mission_reload_request_${e}`)
      .show()
}

function missionAlarmTrailerCheck(e) {
    return $(`input.vehicle_checkbox[trailer=1][fms=2]${"undefined" != typeof e ? `[building_id=${e}]` : ""}:checked`)
      .each(function () {
        let e = !1;

        const t = $(this)
          .val();

        if ($(`input.vehicle_checkbox[fms=2][trailer_vehicle_id=${$(this)
  .val()}]`)
          .length >= 1) e = !0;
        else if ("1" == $(this)
          .attr("tractive_random")) {
            const i = jQuery.parseJSON($(this)
                .attr("possible_tractive"));

            const n = `[building_id=${$(this)
  .attr("building_id")}]`;

            const o = $(this)
              .attr("tractive_building_random");

            $.each(i, (i, s) => {
                e || ($(`.vehicle_checkbox${n}[vehicle_type_id=${s}][fms=2][trailer_vehicle_id=0]`)
                  .each(function () {
                      e || (e = !0, $(`.vehicle_checkbox[value=${$(this)
  .val()}]`)
                        .attr("trailer_vehicle_id", t))
                  }), e || "1" != o || $(`.vehicle_checkbox[vehicle_type_id=${s}][fms=2][trailer_vehicle_id=0]`)
                  .each(function () {
                      e || (e = !0, $(`.vehicle_checkbox[value=${$(this)
  .val()}]`)
                        .attr("trailer_vehicle_id", t))
                  }))
            })
        } else $(`.vehicle_checkbox[value=${$(this)
  .attr("tractive_vehicle_id")}]`)
          .attr("trailer_vehicle_id", t)
    }), $(`input.vehicle_checkbox[trailer=1][fms=2]${"undefined" != typeof e ? `[building_id=${e}]` : ""}`)
      .each(function () {
        let e = !1;

        const t = $(this)
          .prop("checked");

        if (!t) {
            if ($(this)
              .val(), "1" == $(this)
              .attr("tractive_random")) {
                const i = jQuery.parseJSON($(this)
                    .attr("possible_tractive"));

                const n = `[building_id=${$(this)
  .attr("building_id")}]`;

                const o = $(this)
                  .attr("tractive_building_random");

                $.each(i, (t, i) => {
                    e || ($(`.vehicle_checkbox${n}[vehicle_type_id=${i}][fms=2][trailer_vehicle_id=0]`)
                      .length >= 1 && (e = !0), e || "1" != o || $(
                      `.vehicle_checkbox[vehicle_type_id=${i}][fms=2][trailer_vehicle_id=0]`)
                      .length >= 1 && (e = !0))
                })
            } else $(`#vehicle_checkbox_${$(this)
  .attr("tractive_vehicle_id")}[fms=2][trailer_vehicle_id=0]`)
              .length >= 1 && (e = !0);
            e ? ($(`.vehicle_not_tractive_message_${$(this)
  .val()}`)
              .css("display", "none"), $(this)
              .attr("disabled", !1)) : ($(this)
              .attr("disabled", !0), $(`.vehicle_not_tractive_message_${$(this)
  .val()}`)
              .css("display", "inline"))
        }
    }), !0;
}

function mapkitDeselectAnnotation() {
    map.selectedAnnotation = null
}

function mapExpand(e) {
    mapViewExpandedWindow = window.open("/?mapview=true", "mapWindow",
      "width=600,height=400,status=yes,scrollbars=yes,resizable=yes"), e ? $("#map")
      .hide() : $("#map_outer")
      .hide(), $("#map_expand_button")
      .hide(), $("#map_adress_search")
      .hide(), mapViewExpanded = !0, $("#restore_map")
      .show(), $("#arrow_location_select")
      .hide(), $("#radio_outer")
      .removeClass("col-sm-4"), $("#radio_outer")
      .addClass("col-sm-12")
}

function mapViewOnly() {
    $("#navbar-mobile-footer")
      .hide(), $("#navbar-mobile-footer")
      .removeClass("visible-xs"), $("#col_navbar_holder")
      .hide(), $("#map_outer")
      .removeClass("col-sm-8"), $("#map_outer")
      .addClass("col-sm-12"), $("#level_upgrade_hint")
      .hide(), $("#bigMapMenu")
      .hide(), $("#map")
      .height($(window)
        .height())
      .width($(window)
        .width()), "undefined" == typeof mapkit && map.invalidateSize()
}

function mapViewDesignBigMap() {
    $("#navbar-mobile-footer")
      .hide(), $("#navbar-mobile-footer")
      .removeClass("visible-xs"), $("#map_outer")
      .removeClass("col-sm-8"), $("#map_outer")
      .addClass("col-sm-12"), mapViewResizeDesignBigMap()
}

function mapViewResize() {
    $("#map")
      .height($(window)
        .height())
      .width($(window)
        .width()), "undefined" == typeof mapkit && map.invalidateSize()
}

function mapViewResizeDesignBigMap() {
    $("#map")
      .height($(window)
        .height() - parseInt($("#col_navbar_holder")
        .height()))
      .width($(window)
        .width()), $("#map_outer")
      .height($(window)
        .height() - parseInt($("#col_navbar_holder")
        .height()))
      .width($(window)
        .width()), "undefined" == typeof mapkit && map.invalidateSize()
}

function mapViewRestore() {
    mapViewExpanded && ($("#map_outer")
      .show(), $("#map")
      .show(), $("#map_adress_search")
      .show(), $("#map_expand_button")
      .show(), $("#restore_map")
      .hide(), $("#radio_outer")
      .addClass("col-sm-4"), $("#radio_outer")
      .removeClass("col-sm-12"), mapViewExpanded = !1, "undefined" == typeof mapkit && map
      .invalidateSize(), mapViewExpandedWindow.close())
}

function vehicleSelectionReset() {
    $(".vehicle_checkbox")
      .attr("checked", !1), $(".vehicle_checkbox:first")
      .change()
}

function aaoNearSelection(e, t, i, n, o, s) {
    for (missing = ""; n > 0;) {
        const a = aaoNextAvailable(t, s);
        const r = aaoNextAvailable(i, s);
        const l = aaoNextAvailable(e, s);
        - 1 != r && -1 != a && -1 != l ? a > l || r > l ? missing += aao(e, s,
              o[1], 1) : (missing += aao(t, s, o[1], 1), missing += aao(i, s, o[1], 1)) : -1 != r && -1 !=
            a ? (missing += aao(t, s, o[1], 1), missing += aao(i, s, o[1], 1)) : -1 != l ? missing += aao(e,
              s, o[1], 1) : (missing += aao(o[0], s, o[1], n), n = 0), n -= 1
    }
    return missing
}

function aaoClickHandler(e) {
    let t = "";
    const i = $(e);
    "true" == i.attr("reset") && vehicleSelectionReset(), $.each(aao_types, (e, n) => {
        if ("naw_or_rtw_and_nef" == n[0] || "naw_or_rtw_and_nef_or_rth" == n[0]) {
            let o = "nef";
            "naw_or_rtw_and_nef" == n[0] && (o = "nef_only");
            var s = i.attr(n[0]);
            t += aaoNearSelection("naw", o, "rtw", s, n, i)
        } else if ("hlf_or_rw_and_lf" == n[0]) {
            var s = i.attr(n[0]);
            t += aaoNearSelection("hlf_only", "rw_only", "lf_only", s, n, i)
        } else {
            var s = i.attr(n[0]);
            t += aao(n[0], i, n[1], s)
        }
    });
    const n = i.attr("custom");
    if ("" != n) {
        const o = jQuery.parseJSON(n);
        $.each(o, (e, n) => {
            t += aao(`custom_${md5(e)}`, i, e, n)
        })
    }
    const s = i.attr("vehicle_type_ids");
    var a = i.attr("vehicle_type_captions");
    if (void 0 !== s && void 0 !== a) {
        const r = jQuery.parseJSON(s);
        var a = jQuery.parseJSON(a);
        $.each(r, (e, n) => {
            const o = a[e];
            t += aao(`vehicle_type_id_${e}`, i, o, n)
        })
    }
    return "" != t ? ("undefined" != typeof pressedKeys && (pressedKeys = {}), alert(t)) : aao_available(i
      .attr("aao_id"), !0), !1
}

function vehicleGroupClickHandler(vehicle_group_element) {
    const missing = [];

    const vehicle_group_id = $(vehicle_group_element)
      .attr("vehicle_group_id");

    const vehicle_ids = eval($(`#vehicle_group_${vehicle_group_id}`)
      .attr("vehicles"));

    return $.each(vehicle_ids, (e, t) => {
        $(`#vehicle_checkbox_${t[0]}`)
          .length <= 0 || $(`#vehicle_checkbox_${t[0]}`)
          .is(":disabled") ? missing.push(t[1]) : ($(`#vehicle_checkbox_${t[0]}`)
          .prop("checked", !0), $(`#vehicle_checkbox_${t[0]}`)
          .change())
    }), missing.length > 0 && ("undefined" != typeof pressedKeys && (pressedKeys = {}), alert(`${I18n.t(
  "javascript.missed_vehicle")} ${missing.join(", ")}. `)), !1;
}

function saveFcm() {}

function radioMessage(e) {
    if ($("#radio_no_message")
      .hide(), "vehicle_fms" == e.type) {
        alliance_message = !1, e.user_id != user_id && (alliance_message = !0, e.fms_text = `[${I18n.t(
  "map.alliance")}] ${e.fms_text}`);
        let t = "";
        let i = "";
        if ("" != e.additionalText && (e.fms_text = e.additionalText, e.fms = 5, e.fms_real = 5, "nl_NL" ==
        I18n.locale && (e.fms = 7), t =
          `<a href='#' class='btn btn-xs btn-success radio_message_close' vehicle_id='${e.id}'>${I18n.t("javascript.understand")}</a> `), 5 == e.fms_real ? (target =
          "radio_messages_important", e.user_id == user_id && $("body")
          .hasClass("bigMap") && !$("#radio_outer")
          .hasClass("fadeIn") && $("#bigMapMenuRadioButton")
          .addClass("bigMapMenuButtonGreen")) : target = "radio_messages", $(`.radio_message_vehicle_${e.id}`)
          .remove(), "" != e.mission_id && e.mission_id > 0 && (i = `<a href='/missions/${e.mission_id}' class='btn btn-xs btn-default lightbox-open'>${I18n.t("javascript.to_mission")}</a> `
        ), "" != e.target_building_id && e.target_building_id > 0) {
            let n = buildingCaption(e.target_building_id);
            n || (n = I18n.t("javascript.to_building")), i = `<a href='/buildings/${e.target_building_id}' class='btn btn-xs btn-default lightbox-open'>${n}</a> `
        }
        $(`#${target}`)
          .prepend(`<li ${alliance_message && alliance_ignore_fms ? "style='display:none'" : ""} class='radio_message_vehicle_${e.id} ${alliance_message ? "radio_message_alliance" :
      ""}'><span title='${e.fms_text}' class='building_list_fms building_list_fms_${e
      .fms_real}' >${e.fms}</span><img src='/images/icons8-location_off.svg' class='vehicle_search ' vehicle_id='${e
      .id}'> <a href='/vehicles/${e.id}' class='btn btn-xs btn-default lightbox-open'>${e
      .caption}</a> ${i}${t}${e.fms_text}</li>`), alliance_message && alliance_ignore_fms ||
        (audio && 5 == e.fms_real ? "de_DE" == I18n.locale ? play("fms5") : play("doorbell") : audio &&
          play("funk"))
    } else if ("sicherheitswache" == e.type) {
        if (message = "", target = "radio_messages", e.user_id != user_id) return !0;
        message = e.success ?
          `<div class="alert alert-success alert-dismissible" role="alert"><button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>${message}${I18n.t("javascript.sicherheitswache_success", {
    caption: e.caption,
    credits: e.credits
})}</div>` :
          `<div class="alert alert-danger alert-dismissible" role="alert"><button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">&times;</span></button>${message}${I18n.t("javascript.sicherheitswache_error", {
    caption: e.caption,
    credits: e.credits
})}</div>`, $(`#${target}`)
          .prepend(`<li class=''>${message}</li>`)
    }
}

function vehicleSearch(e) {
    if (mapViewExpanded) return mapViewExpandedWindow.vehicleSearch(e);
    let t = !1;
    $.each(mission_vehicles, (i, n) => {
        !n.vehicle_marker_deleted && n.visible && n.vehicle_id == e && (t = !0, "undefined" !=
        typeof mapkit ? map.setCenterAnimated(new mapkit.Coordinate(n.latitude, n.longitude),
          !0) : map.setView([n.latitude, n.longitude]))
    }), t || alert(I18n.t("javascript.not_found_map"))
}

function missionLabel() {
    $.each(mission_markers, (e, t) => {
        t.getTooltip()
          .options.permanent = mission_label, mission_label ? t.openTooltip() : t.closeTooltip()
    })
}

function vehicleLabel() {
    $.each(mission_vehicles, (e, t) => {
        t.vehicle_marker_deleted || (vehicle_label ? t.openTooltip() : t.closeTooltip())
    })
}

function setTitle() {
    "" == title_default && (title_default = document.title), document.title = $(window)
      .is(":focus") ? "Focus" : "Kein Focus"
}

function mapMoveToSearch() {
    $.getJSON(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${$("#map_adress_search")
  .val()}`,
      e => {
          e.length <= 0 ? alert(I18n.t("javascript.location_not_found")) : $.each(e, (e, {lat, lon}) => {
              "undefined" == typeof mapkit ? map.panTo([lat, lon]) : map.setCenterAnimated(
                new mapkit.Coordinate(parseFloat(lat), parseFloat(lon)), !0)
          })
      })
}

function mapIsVisible(e) {
    if ("undefined" != typeof mapkit) {
        const t = parseFloat(map.region.center.latitude) - parseFloat(map.region.span.latitudeDelta);
        const i = parseFloat(map.region.center.latitude) + parseFloat(map.region.span.latitudeDelta);
        const n = parseFloat(map.region.center.longitude) - parseFloat(map.region.span.longitudeDelta);
        const o = parseFloat(map.region.center.longitude) + parseFloat(map.region.span.longitudeDelta);
        return t <= e[0] && i >= e[0] && n <= e[1] && o >= e[1] ? !0 : !1
    }
    const s = map.getBounds();
    return s.contains(e)
}

function buildingLoadContent(url) {
    $("#buildings")
      .html(I18n.t("common.loading")), buildingResetContentPossible = !1, building_eval_unload && (eval(
      building_eval_unload), building_eval_unload = null), $.ajax({
        url,
        cache: !1
    })
      .success(e => {
          $("#buildings")
            .html(e), tutorial.callBuildingLoadContentListener(!0), bigMapWindowSizeChanged()
      })
}

function buildingResetContent() {
    buildingLoadContent("/buildings"), buildingResetContentPossible = !0
}

function buildingResetContentWhenPossible() {
    buildingResetContentPossible && buildingResetContent()
}

function buildingMarkerReset() {
    leitstelle_latitude = !1, leitstelle_longitude = !1, leitstelles = [], $.each(building_markers, (e, t) => {
        "undefined" == typeof mapkit ? map.removeLayer(t) : map.removeAnnotation(t)
    }), $.each(building_timers, (e, t) => {
        window.clearTimeout(t)
    }), mobile_bridge_use && mobileBridgeAdd("building_remove_all", {}), building_markers = Array(),
      building_markers_cache = Array()
}

function iconAnchorCalculate(e) {
    return [e[0] / 2, e[1]]
}

function eventAnnounce(e) {
    if (window.clearTimeout(eventTimer), e.end_in > 0) {
        eventRunning = !0;
        let t = `<div class='alert alert-info'>${e.running_text} ${I18n.t("javascript.finish_in")} ${formatTime(e.end_in)}.`;
        null != e.start_username && (t = `${t} ${I18n.t("javascript.start_username")} ${e
  .start_username}`), t += "</div>", $("#eventInfo")
          .html(t)
    }
    e.end_in = e.end_in - 1, e.start_in = e.start_in - 1, e.end_in > 0 ? eventTimer = window.setTimeout(
      () => {
          eventAnnounce(e)
      }, 1e3) : (eventRunning = !1, $("#navbar-inner")
      .removeClass("navbar-inner-event"), $("#eventInfo")
      .html(""))
}

function alliance_ignore_fms_set(e, t) {
    alliance_ignore_fms = e, alliance_ignore_fms ? ($("#alliance_radio_off")
      .show(), $("#alliance_radio_on")
      .hide(), $(".radio_message_alliance")
      .hide()) : ($("#alliance_radio_on")
      .show(), $("#alliance_radio_off")
      .hide(), $(".radio_message_alliance")
      .show()), t && $.ajax({
        url: `profile/alliance_ignore_fms/${alliance_ignore_fms ? "1" : "0"}`,
        cache: !1,
        type: "POST"
    })
}

function premium(e) {
    1 == e && ($("#premium_a")
      .hide("fast"), $("#premium_b")
      .hide("fast"), $("#premium_c")
      .hide("fast")), user_premium = e
}

function zoom_change() {
    building_maps_redraw(), building_load_alliance()
}

function map_moved() {
    building_maps_redraw(), building_load_alliance()
}

function building_load_alliance() {
    if ("undefined" != typeof mapkit) var min_lat = parseFloat(map.region.center.latitude) - parseFloat(map
        .region.span.latitudeDelta),
      max_lat = parseFloat(map.region.center.latitude) + parseFloat(map.region.span.latitudeDelta),
      min_lng = parseFloat(map.region.center.longitude) - parseFloat(map.region.span.longitudeDelta),
      max_lng = parseFloat(map.region.center.longitude) + parseFloat(map.region.span.longitudeDelta);
    else {
        if (!map.hasLayer(map_filters_service.getMapFiltersLayers()
          .alliance_members)) return !0;
        const bounds = map.getBounds();
        var min_lat = 0;
        var max_lat = 0;
        var min_lng = 0;
        var max_lng = 0;
        bounds.getNorth() < bounds.getSouth() ? (min_lat = bounds.getNorth(), max_lat = bounds.getSouth()) : (
          max_lat = bounds.getNorth(), min_lat = bounds.getSouth()), bounds.getWest() < bounds
          .getEast() ? (min_lng = bounds.getWest(), max_lng = bounds.getEast()) : (max_lng = bounds.getWest(),
          min_lng = bounds.getEast())
    }
    $.get(`/building_alliance/${min_lat.toString()
  .replace(".", "o")}/${min_lng.toString()
  .replace(".", "o")}/${max_lat.toString()
  .replace(".", "o")}/${max_lng.toString()
  .replace(".", "o")}`,
      data => {
          eval(data), building_maps_redraw()
      })
}

function building_load_alliance_app(min_lat, max_lat, min_lng, max_lng) {
    return alliance_member_buildings_show ? ($.get(`/building_alliance/${min_lat.toString()
  .replace(".", "o")}/${min_lng.toString()
  .replace(".", "o")}/${max_lat.toString()
  .replace(".", "o")}/${max_lng.toString()
  .replace(".", "o")}`,
      data => {
          eval(data), building_maps_redraw()
      }), void 0) : !0;
}

function building_maps_redraw() {
    visibles = new Array, building_markers_new = new Array, $.each(building_markers, (e, t) => {
        let i = [];
        if ("undefined" == typeof mapkit) i = t.getLatLng();
        else {
            const n = t.coordinate;
            i = [n.latitude, n.longitude]
        }
        mapIsVisible(i) ? (visibles.push(t.building_id), building_markers_new.push(t)) :
          "undefined" == typeof mapkit ? map.removeLayer(t) : map.removeAnnotation(t)
    }), building_markers = building_markers_new, $.each(building_markers_cache, (e, t) => {
        -1 == $.inArray(t.id, visibles) && mapIsVisible([t.latitude, t.longitude]) &&
        building_maps_draw(t)
    })
}

function building_maps_draw(e) {
    let t = 5e3;
    if ("undefined" != typeof e.user_id && "undefined" != typeof user_id && user_id != e.user_id && (t = 1e3),
    "undefined" != typeof mapkit) {
        var i = new mapkit.ImageAnnotation(new mapkit.Coordinate(e.latitude, e.longitude), {
            url: {
                1: flavouredAsset(e.building_marker_image)
            }
        });
        i.title = e.name, i.addEventListener("select", () => {
            lightboxOpen(`/buildings/${e.id}`), setTimeout(mapkitDeselectAnnotation, 1e3)
        }), map.addAnnotation(i), i.element.className = "mapkit-marker"
    } else {
        map_layer = map_filters_service.getFilterLayerByBuildingParams(e);
        var i = L.marker([e.latitude, e.longitude], {
            zIndexOffset: t,
            title: e.name,
            icon: icon_empty
        })
          .bindTooltip(e.name)
          .addTo(map_layer);
        "undefined" != typeof e.opacity && i.setOpacity(e.opacity), iconMapGenerate(e.building_marker_image,
          i), i.on("click", () => {
            lightboxOpen(`/buildings/${e.id}`)
        })
    }
    i.building_id = e.id, building_markers.push(i)
}

function buildingCaption(e) {
    let t = !1;
    return $.each(building_markers_cache, (i, {id, name}) => {
        id == e && (t = name)
    }), t;
}

function buildingVehicleGraphicCacheAdd({vgi, id}) {
    "undefined" != typeof vgi && "" != vgi && null != vgi && (buildingVehicleGraphicCache[id] = vgi)
}

function buildingMarkerAdd(e) {
    let t = !1;
    return $.each(building_markers_cache, (i, {id}) => {
        id == e.id && (t = !0)
    }), buildingVehicleGraphicCacheAdd(e), t ? !0 : (building_marker_image = getBuildingMarkerIcon(e), e
      .building_marker_image = building_marker_image, 0 == mobile_bridge_use &&
    constructBuildingListElement(e), 1 == mobile_bridge_use && 4 == mobile_version && (e.name = e.name
      .replace("%", ""), e.app_icon_path = String(building_marker_image).includes("//") ? building_marker_image : currentHostname() + building_marker_image,
      mobileBridgeAdd("building_add", e)), building_markers_cache.push(e), void 0);
}

function constructBuildingListElement(e) {
    if (e.user_id == user_id) {
        1 == mobile_bridge_use && 4 == mobile_version && (e.name = e.name.replace("%", ""),
          building_marker_image = getBuildingMarkerIcon(e), e.app_icon_path = String(
          building_marker_image).includes("//") ? building_marker_image : currentHostname() + building_marker_image);
        let t = `<li  class='building_list_li' building_type_id='${e.building_type}' leitstelle_building_id='${e.lbid}'><div class='building_list_caption' id='building_list_caption_${e.id}' >${e
    .detail_button}<img class='building_marker_image' building_id='${e.id}' src='${building_marker_image}'><a href='' class='map_position_mover' data-latitude='${e
    .latitude}' data-longitude='${e.longitude}'>${e.name}</a>`;
        0 == e.show_vehicles_at_startpage && (t += hideVehicleBuildingHelpText(e.id)), t += "</div>";
        let i = `<li>${I18n.t("common.loading")}</li>`;
        "undefined" != typeof buildingVehicleCache[e.id] && (i = buildingVehicleCache[e.id].join(""),
          buildingVehicleCache[e.id] = []), t = `${t}<ul id='vehicle_building_${e.id}' class='building_list_vehicles' data-vehicles-loaded='0' data-building_id='${e.id}' `, 0 ==
        e.show_vehicles_at_startpage && (t += "style='display: none' "), t = `${t}>${i}</ul></li>`, e
          .building_type == BUILDING_TYPE_LEITSTELLE && (leitstelle_latitude = e.latitude,
          leitstelle_longitude = e.longitude, leitstelles.push([e.latitude, e.longitude])),
          buildingMarkerBulkContentCache.push(t)
    }
}

function getBuildingMarkerIcon(e) {
    return e.user_id == user_id ? building_marker_image = e.icon : e.building_type ==
    BUILDING_TYPE_FEUERWEHRSCHULE ? building_marker_image = "/images/building_fireschool_other.png" : e
      .building_type == BUILDING_TYPE_FEUERWACHE ? building_marker_image =
      "/images/building_fire_other.png" : e.building_type == BUILDING_TYPE_RETTUNGSWACHE ?
      building_marker_image = "/images/building_rettungswache_other.png" : e.building_type ==
      BUILDING_TYPE_RETTUNGSSCHULE ? building_marker_image = "/images/building_rettungsschule_other.png" : e
        .building_type == BUILDING_TYPE_CLINIC ? building_marker_image = "/images/building_clinic_other.png" :
        e.building_type == BUILDING_TYPE_HOSPITAL ? building_marker_image =
          "/images/building_hospital_other.png" : e.building_type ==
        BUILDING_TYPE_NOTARZTHUBSCHRAUBERLANDEPLATZ ? building_marker_image =
          "/images/building_helipad_other.png" : e.building_type ==
        BUILDING_TYPE_POLIZEIHUBSCHRAUBERLANDEPLATZ ? building_marker_image =
          "/images/building_helipad_other.png" : e.building_type == BUILDING_TYPE_POLIZEIWACHE || e
          .building_type == BUILDING_TYPE_POLIZEIZELLE ? building_marker_image =
          "/images/building_polizeiwache_other.png" : e.building_type == BUILDING_TYPE_LEITSTELLE ?
          building_marker_image = "/images/building_leitstelle_other.png" : e.building_type ==
          BUILDING_TYPE_POLIZEISCHULE ? building_marker_image = "/images/building_polizeischule_other.png" : e
            .building_type == BUILDING_TYPE_THW ? building_marker_image = "/images/building_thw_other.png" : e
            .building_type == BUILDING_TYPE_THW_BUNDESSCHULE ? building_marker_image =
            "/images/building_thw_school_other.png" : e.building_type == BUILDING_TYPE_BEREITSCHAFTSPOLIZEI ?
            building_marker_image = "/images/building_bereitschaftspolizei_other.png" : e.building_type ==
            BUILDING_TYPE_POLIZEISONDEREINHEITEN ? building_marker_image =
              "/images/building_polizeisondereinheiten_other.png" : e.building_type == BUILDING_TYPE_SEG ?
              building_marker_image = "/images/building_seg_other.png" : e.building_type ==
              BUILDING_TYPE_BEREITSTELLUNGSRAUM ? building_marker_image =
                "/images/building_bereitstellungsraum_other.png" : e.building_type == BUILDING_TYPE_WASSERRETTUNG ?
                building_marker_image = "/images/building_wasserwacht_other.png" : e.building_type ==
                BUILDING_TYPE_FIRE_BOAT_DOCK ? building_marker_image = "/images/building_fire_boat_dock_other.png" : e
                  .building_type == BUILDING_TYPE_RESCUE_BOAT_DOCK ? building_marker_image =
                  "/images/building_rescue_boat_dock_other.png" : e.building_type == BUILDING_TYPE_RESCUE_DOG_UNIT ?
                  building_marker_image = "/images/building_rescue_dog_unit_other.png" : e.building_type ==
                  BUILDING_TYPE_FIRE_AVIATION_STATION ? building_marker_image =
                    "/images/building_fire_aviation_station_other.png" : e.building_type ==
                  BUILDING_TYPE_FEDERAL_POLICE_STATION ? building_marker_image =
                    "/images/building_federal_police_other.png" : e.building_type ==
                  BUILDING_TYPE_HOME_RESPONSE_LOCATION ? building_marker_image =
                    "/images/building_home_response_location_other.png" : e.building_type ==
                  BUILDING_TYPE_COMMERCE_POLICE ? building_marker_image = "/images/building_commerce_police_other.png" :
                    e.building_type == BUILDING_TYPE_BOMB_DISPOSAL ? building_marker_image =
                      "/images/building_bomb_disposal_other.png" : e.building_type == BUILDING_TYPE_COMPLEX ?
                      building_marker_image = "/images/building_complex_other.png" : e.building_type ==
                      BUILDING_TYPE_COMPLEX_SMALL ? building_marker_image = "/images/building_complex_other.png" : e
                        .building_type == BUILDING_TYPE_WATER_RESCUE_SCHOOL ? building_marker_image =
                        "/images/building_water_rescue_school_other.png" : e.building_type ==
                      BUILDING_TYPE_HAZARD_RESPONSE_EMS ? building_marker_image =
                        "/images/building_hazard_response_ems_other.png" : e.building_type == BUILDING_TYPE_WATER_RESCUE_2 &&
                        (building_marker_image = "/images/building_wasserwacht_other.png"), flavouredAsset(
      building_marker_image)
}

function spliceLatLngs(e, t) {
    if ("undefined" != typeof mapkit) {
        var i = e.points;
        i.splice(0, t), e.points = i
    } else {
        var i = e.getLatLngs();
        i.splice(0, t), e.setLatLngs(i)
    }
}

function buildingMarkerBulkContentCacheDraw() {
    $("#building_list")
      .append(buildingMarkerBulkContentCache.join("")), buildingMarkerBulkContentCache = [],
      buildingsVehicleLoadVisible()
}

function currentHostname() {
    return 1 == mobile_bridge_use && 4 == mobile_version ? String(window.location.hostname).includes("192.168") ? `${location.protocol}//${window.location.hostname}:${window.location
  .port}` : `${location.protocol}//${window.location.hostname}` : "";
}

function iconMapGenerate(e, t) {
    const i = flavouredAsset(e);
    const n = new Image;
    n.src = i, $(n)
      .load(() => {
          t.setIcon(L.icon({
              iconUrl: i,
              iconSize: [n.width, n.height],
              iconAnchor: iconAnchorCalculate([n.width, n.height])
          }))
      })
}

function iconMapVehicleGenerate(e, t, i) {
    const n = new Image;
    n.src = e;
    const o = new Image;
    o.src = t, $(n)
      .load(() => {
          const t = L.icon({
              iconUrl: e,
              iconSize: [n.width, n.height],
              iconAnchor: iconAnchorCalculate([n.width, n.height])
          });
          i.setIcon(t), i.icon_normal = t
      }), $(o)
      .load(() => {
          const e = L.icon({
              iconUrl: t,
              iconSize: [o.width, o.height],
              iconAnchor: iconAnchorCalculate([o.width, o.height])
          });
          i.icon_sonderrechte = e
      })
}

function missionMarkerBlukDraw() {
    $.each(patientBulkCache, (e, t) => {
        let i = "";
        $.each(t, (e, t) => {
            i += t
        }), $(`#mission_patients_${e}`)
          .append(i)
    }), $.each(prisonerBulkCache, (e, t) => {
        let i = "";
        $.each(t, (e, t) => {
            i += t
        }), $(`#mission_prisoners_${e}`)
          .append(i)
    }), patientBulkCache = {}, prisonerBulkCache = {}
}

function missionMarkerReset() {
    $.each(mission_markers, (e, t) => {
        "undefined" == typeof mapkit ? map.removeLayer(t) : map.removeAnnotation(t)
    }), mission_markers = Array(), $.each(mission_timers, (e, {timer}) => {
        window.clearInterval(timer)
    }), $.each(patient_timers, () => {
        patient_timers = []
    }), mission_timers = Array()
}

function buildingsVehicleLoadVisible() {
    if ($("#building_panel_body")
      .length <= 0) return !0;

    const e = $("#building_panel_body")
        .offset()
        .top - 3 * $("#building_panel_body")
        .height();

    const t = $("#building_panel_body")
      .offset()
      .top + 3 * $("#building_panel_body")
      .height();

    if ($("#building_panel_body")
      .is(":visible")) {
        const i = [];
        $(".building_list_vehicles:visible")
          .each(function () {
              const n = $(this)
                .offset()
                .top;
              n > e && t > n && "0" == $(this)
                .data("vehicles-loaded") && ($(this)
                .data("vehicles-loaded", "1"), i.push($(this)
                .data("building_id")))
          }), i.length > 0 && batchBuildingsVehicleLoad(i)
    }
}

function buildingsVehicleLoad(building_id) {
    $.get(`/buildings/${building_id}/vehiclesMap`, data => {
        buildingVehicleCache[building_id] = [], eval(data), vehicleContent = "", "undefined" !=
        typeof buildingVehicleCache[building_id] && (vehicleContent = buildingVehicleCache[
          building_id].join(""), buildingVehicleCache[building_id] = []), $(
          `#vehicle_building_${building_id}`)
          .html(vehicleContent)
    })
}

function batchBuildingsVehicleLoad(building_id_array) {
    $.post("/buildings/vehiclesMap", {
        building_ids: building_id_array
    }, data => {
        for (var idx = 0; idx < building_id_array.length; idx++) buildingVehicleCache[
          building_id_array[idx]] = [];
        eval(data);
        for (var idx = 0; idx < building_id_array.length; idx++) {
            const building_id = building_id_array[idx];
            let vehicleContent = "";
            "undefined" != typeof buildingVehicleCache[building_id] && (vehicleContent =
                buildingVehicleCache[building_id].join(""), buildingVehicleCache[building_id] = []
            ), $(`#vehicle_building_${building_id}`)
              .html(vehicleContent)
        }
    })
}

function progressBarScrollUpdate() {
    const e = [];
    $(".progress-striped-inner-active")
      .each(function () {
          $(this)
            .visible(!0) || e.push($(this)
            .attr("id"))
      }), $(e.map(e => `#${e}`)
      .join(", "))
      .addClass("progress-striped-inner-active-resource-safe")
      .removeClass("progress-striped-inner-active");
    const t = [];
    $(".progress-striped-inner-active-resource-safe")
      .each(function () {
          $(this)
            .visible(!0) && t.push($(this)
            .attr("id"))
      }), $(t.map(e => `#${e}`)
      .join(", "))
      .removeClass("progress-striped-inner-active-resource-safe")
      .addClass("progress-striped-inner-active"), missionScrollUpdate()
}

function missionScrollUpdate() {
    const e = $("#missions-panel-body")
        .offset()
        .top - 5 * $("#missions-panel-body")
        .height();

    const t = $("#missions-panel-body")
      .offset()
      .top + 5 * $("#missions-panel-body")
      .height();

    $("#missions_outer")
      .is(":visible") && $(".missionSideBarEntry")
      .each(function () {
          $(this)
            .hasClass("missionSideBarEntryScrollInvisible") ? $(this)
            .offset()
            .top < t && $(this)
            .offset()
            .top > e && $(this)
            .removeClass("missionSideBarEntryScrollInvisible")
            .css("height", "auto") : ($(this)
            .offset()
            .top > t || $(this)
            .offset()
            .top < e) && ($(this)
            .css("height", `${$(this)
    .height()}px`), $(this)
            .addClass("missionSideBarEntryScrollInvisible"))
      })
}

function patientMarkerAddCombined({mission_id, count, untouched, errors}) {
    let t = `<div class='col-md-12' id='mission_patient_summary_${mission_id}'>`;
    t += "<img src='/images/icons8-dizzy_person_2.svg' class='mission_list_patient_icon'><strong>", t += count, t = `${t} ${I18n.t("javascript.patient")}</strong>`, untouched > 0 && (t = `${t} - ${untouched}`, t = `${t} ${I18n.t("javascript.patient_untouched")}</strong>`), $.each(errors,
      (e, i) => {
          t = `${t}<div class='alert alert-danger'><strong>${i}x</strong> ${e}</div>`
      }), t += "</div>", missionMarkerBulkAdd ? ("undefined" == typeof patientBulkCache[mission_id] &&
    (patientBulkCache[mission_id] = {}), patientBulkCache[mission_id][0] = t) : $(
      `#mission_patients_${mission_id}`)
      .html(t)
}

function patientMarkerAdd(e) {
    $(`#mission_patient_summary_${e.mission_id}`)
      .hide();
    let t = "progress  patient_progress";
    let i = "progress-striped-inner ";
    if (e.miliseconds_by_percent > 0 && (t = "progress patient_progress", i =
      "progress-striped-inner progress-striped-inner-active-resource-safe "), $(`#patient_${e.id}`)
      .length > 0) patientTimerDelete(e.id), $(`#patient_bar_outer_${e.id}`)
      .attr("class", t), $(`#patient_bar_striper_${e.id}`)
      .attr("class", i), $(`#patient_bar_${e.id}`)
      .css("width", `${e.live_current_value}%`), e.missing_text ? ($(`#patients_missing_${e.id}`)
      .html(e.missing_text), $(`#patients_missing_${e.id}`)
      .attr("class", "alert alert-danger")) : ($(`#patients_missing_${e.id}`)
      .html(""), $(`#patients_missing_${e.id}`)
      .attr("class", "")), e.target_percent <= 0 ? $(`#patient_bar_${e.id}`)
      .removeClass("progress-bar-warning")
      .addClass("progress-bar-danger") : $(`#patient_bar_${e.id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-warning");
    else {
        let n = `<div style='max-width:250px' class=' col-md-6 small'  id='patient_${e.id}'>${e.name} <div id='patient_bar_outer_${e.id}' class='${t}'><div id='patient_bar_${e.id}' class='progress-bar `;
        n += e.target_percent <= 0 ? "progress-bar-danger" : "progress-bar-warning", n = `${n}' style='width: ${e.live_current_value}%;'><div id='patient_bar_striper_${e.id}' class='${i}'></div></div></div><div  id='patients_missing_${e.id}'`, e
          .missing_text && (n += "class='alert alert-danger'"), n += ">", e.missing_text && (n += e
          .missing_text), n += "</div></div>", missionMarkerBulkAdd ? ("undefined" ==
        typeof patientBulkCache[e.mission_id] && (patientBulkCache[e.mission_id] = {}),
          patientBulkCache[e.mission_id][e.id] = n) : $(`#mission_patients_${e.mission_id}`)
          .append(n)
    }
    e.miliseconds_by_percent > 0 && patient_timers.push({
        patient_id: e.id,
        miliseconds_by_percent: e.miliseconds_by_percent,
        params: e
    }), e.live_current_value <= 0 && patientFinish(e), missionMarkerBulkAdd || progressBarScrollUpdate()
}

function prisonerMarkerAdd({id, name, mission_id}) {
    if ($(`#prisoner_${id}`)
      .length > 0);
    else {
        const t = `<div id='prisoner_${id}' class='small col-md-6'>${name}</div>`;
        missionMarkerBulkAdd ? ("undefined" == typeof prisonerBulkCache[mission_id] && (prisonerBulkCache[mission_id] = {}), prisonerBulkCache[mission_id][id] = t) : $(`#mission_prisoners_${mission_id}`)
          .append(t)
    }
}

function leiststelleMinDistance(e, t) {
    let i = -1;
    return $.each(leitstelles, (n, o) => {
        const s = Math.round(distance(o[0], o[1], e, t));
        (-1 == i || i > s) && (i = s)
    }), i;
}

function missionMarkerDistanceUpdate() {
    $.each(mission_markers, (e, t) => {
        if (user_id != t.user_id) {
            let i = 0;
            let n = 0;
            let o = 0;
            "undefined" == typeof mapkit ? (position = t.getLatLng(), n = position.lat, o = position
              .lng) : (position = t.coordinate, n = position.latitude, o = position.longitude),
            0 != leitstelle_latitude && (i = leiststelleMinDistance(n, o)),
              alliance_mission_distance !== !1 && i > alliance_mission_distance ? $(`#mission_${t
  .mission_id}`)
                .addClass("mission_alliance_distance_hide") : $(`#mission_${t.mission_id}`)
                .removeClass("mission_alliance_distance_hide")
        }
    })
}

function missionVehiclesShowNotInvolved(e) {
    temp_vehicles_not_involved = Array(), $.each(vehicles_not_involved, (t, i) => {
        if (i.mid == e) {
            const n = new Date;
            i.dd = i.dd + Math.floor((n - i.involved_created_at) / 1e3), vehicleDrive(i)
        } else temp_vehicles_not_involved.push(i)
    }), vehicles_not_involved = temp_vehicles_not_involved
}

function missionInvolved(e, t) {
    $.each(mission_markers, (i, n) => {
        n.mission_id == e && (t && !n.involved && (n.involved = t, missionVehiclesShowNotInvolved(e)),
          n.involved = t)
    })
}

function missionMarkerAdd(e) {
    bar_class = "progress mission_progress";
    let t = "progress-striped-inner";
    let i = 0;
    let n = !1;
    let o = e.caption;
    e.date_end > 0 && (t = "progress-striped-inner progress-striped-inner-active-resource-safe");
    let s = "";
    s = "undefined" != typeof mission_graphics[e.mtid] && null != mission_graphics[e.mtid] && "undefined" !=
    typeof mission_graphics[e.mtid][e.vehicle_state] && "" != mission_graphics[e.mtid][e.vehicle_state] ?
      mission_graphics[e.mtid][e.vehicle_state] : `/images/${e.icon}.png`;
    let a = "red";
    1 == e.vehicle_state && (a = "yellow"), 2 == e.vehicle_state && (a = "green"), e.user_id != user_id && (
      0 != leitstelle_latitude && (i = leiststelleMinDistance(e.latitude, e.longitude)), null == e
        .user_id ? (e.caption = `[${I18n.t("map.alliance_event")}] ${e.caption}`, o = `${o} ${I18n
  .t("map.alliance_event")}`) : (e.caption = `[${I18n.t("map.alliance")}] ${e.caption}`, o =
        `${o} ${I18n.t("map.alliance")}`), alliance_mission_distance !== !1 && i >
      alliance_mission_distance && (n = !0)), 1 == mobile_bridge_use && currentMarkerTypeFilterTurnedOn(
      e.filter_id) && (4 == mobile_version && (e.app_icon_path = String(s).includes("//") ? s : currentHostname() + s), mobileBridgeAdd("mission", e));
    let r = e.caption;
    "" != e.captionOld && (r = `<small id='mission_old_caption_${e.id}'><s>${e.captionOld}</s></small> ${r}`), "" != e.address && (r = `${r}, <small  id='mission_address_${e.id}'>${e.address}</small>`, o = `${o} ${e.address}`);
    let l = 0;
    if (e.sw_start_in > 0 && (l = 1e3 * e.sw_start_in, "undefined" == typeof mission_overview_timer && (
      mission_overview_timer = setInterval(mission_overview_timer_call, 1e3))), $(`#mission_${e.id}`)
      .length > 0) missionTimerDelete(e.id), $(`#mission_bar_outer_${e.id}`)
      .attr("class", bar_class), $(`#mission_bar_striper_${e.id}`)
      .attr("class", t), $(`#mission_vehicle_state_${e.id}`)
      .attr("src", s), $(`#mission_bar_${e.id}`)
      .css("width", `${e.live_current_value}%`), $(`#mission_${e.id}`)
      .attr("search_attribute", o), $(`#mission_${e.id}`)
      .attr("data-overlay-index", e.overlay_index), $(`#mission_panel_${e.id}`)
      .removeClass("mission_panel_red"), $(`#mission_panel_${e.id}`)
      .removeClass("mission_panel_yellow"), $(`#mission_panel_${e.id}`)
      .removeClass("mission_panel_green"), $(`#mission_panel_${e.id}`)
      .addClass(`mission_panel_${a}`), (e.live_current_value > 0 || e.patients_count > 0 || e
      .prisoners_count > 0) && setTimeout(() => {
        $(`#mission_${e.id}`)
          .removeClass("mission_deleted")
    }, 1e3), $(`#mission_overview_countdown_${e.id}`)
      .attr("timeleft", l), 0 >= l && $(`#mission_overview_countdown_${e.id}`)
      .html(""), $(`#mission_caption_${e.id}`)
      .html(r), e.missing_text ? ($(`#mission_missing_${e.id}`)
      .html(e.missing_text), $(`#mission_missing_${e.id}`)
      .attr("class", "alert alert-danger")) : ($(`#mission_missing_${e.id}`)
      .html(""), $(`#mission_missing_${e.id}`)
      .attr("class", "")), e.missing_text_short ? ($(`#mission_missing_short_${e.id}`)
      .html(e.missing_text_short), $(`#mission_missing_short_${e.id}`)
      .attr("class", "alert alert-danger")) : ($(`#mission_missing_short_${e.id}`)
      .html(""), $(`#mission_missing_short_${e.id}`)
      .attr("class", "")), e.alliance_id && $(`#mission_panel_${e.id}`)
      .addClass("panel-success");
    else {
        let c = "#mission_list";
        e.kt ? (c = "#mission_list_krankentransporte", $("#ktw_no_transports")
          .hide()) : e.sw ? c = "#mission_list_sicherheitswache" : e.user_id != user_id && null != e
          .user_id ? ($("#alliance_no_mission")
          .hide(), c = "#mission_list_alliance") : e.user_id != user_id && null == e.user_id ? ($(
          "#alliance_no_mission")
          .hide(), c = "#mission_list_alliance_event") : $("#emergency_no")
          .hide();
        let u = "";
        let d = "";
        e.missing_text && (u = "alert alert-danger", d = e.missing_text);
        let h = "";
        let p = "";
        e.missing_text_short && (h = "alert alert-danger", p = e.missing_text_short);
        let m = "";
        e.alliance_id && (m = "panel-success");
        let f = "";

        const _ = $("#missions-panel-body")
          .offset()
          .top;

        _ + 5 * $("#missions-panel-body")
          .height(), f = "missionSideBarEntryScrollInvisible", o = o.replace(/'/g, "&#039;"), $(c)
          .append(`<div search_attribute='${o}' id='mission_${e.id}' mission_id='${e.id}' mission_type_id='${e.mtid}' class='missionSideBarEntry missionSideBarEntrySearchable ${f}' latitude='${e
      .latitude}' longitude='${e.longitude}' target_latitude='${e.tlat}' target_longitude='${e.tlng}' data-overlay-index='${e.overlay_index}'><div id='mission_panel_${e.id}' class='panel panel-default ${m} mission_panel_${a}'><div id='mission_panel_heading_${e.id}' class='panel-heading'><a href='/missions/${e.id}' class='btn btn-default btn-xs lightbox-open' id='alarm_button_${e.id}'> ${I18n.t(
      "javascript.alarm")}</a> <span id='mission_participant_${e.id}' class='glyphicon glyphicon-user hidden'></span><span id='mission_participant_new_${e.id}' class='glyphicon glyphicon-asterisk'></span> <a href='' id='mission_caption_${e.id}' class='map_position_mover' target_latitude='${e.tlat}' target_longitude='${e.tlng}' data-latitude='${e.latitude}' data-longitude='${e.longitude}'>${r}</a></div><div class='panel-body'><div class='row'><div class='col-xs-1'><img src='${s}' id='mission_vehicle_state_${e.id}' class='mission_vehicle_state'></div><div class='col-xs-11'><div class='mission_overview_countdown' id='mission_overview_countdown_${e.id}' timeleft='${l}'></div><div id='mission_bar_outer_${e.id}' class='${bar_class}'><div id='mission_bar_${e.id}' class='progress-bar progress-bar-danger' role='progressbar' aria-valuemin='0' aria-valuemax='100' style='width: ${e.live_current_value}%;'><div class='${t}' id='mission_bar_striper_${e.id}'></div></div></div><div  id='mission_missing_${e.id}' class='${u}'>${d}</div><div  id='mission_missing_short_${e.id}' class='${h}'>${p}</div><div id='mission_patients_${e.id}' class='row'></div><div class='mission_prisoners' id='mission_prisoners_${e.id}'></div></div></div></div></div>`), tutorial.callNewMissionListener(!0)
    }
    let g = !1;
    if ($.each(mission_markers, (t, i) => {
        i.mission_id == e.id && ("undefined" != typeof mapkit ? (i.url = {
            1: s
        }, i.opacity = 1, i.title = e.caption, i.subtitle = e.address) : (i.setIcon(
          icon_empty), i.setOpacity(1), iconMapGenerate(s, i), i.setTooltipContent(r)), i
          .vehicle_state = e.vehicle_state, g = !0)
    }), !g && "undefined" != typeof L) {
        if ("undefined" != typeof mapkit) {
            var v = new mapkit.ImageAnnotation(new mapkit.Coordinate(e.latitude, e.longitude), {
                url: {
                    1: s
                }
            });
            v.title = e.caption, v.subtitle = e.address, map.addAnnotation(v), v.element.className =
              "mapkit-marker", v.addEventListener("select", () => {
                $(`#alarm_button_${e.id}`)
                  .click(), setTimeout(mapkitDeselectAnnotation, 1e3)
            })
        } else {
            var v = L.marker([e.latitude, e.longitude], {
                zIndexOffset: 1e4,
                title: e.name,
                icon: icon_empty
            })
              .bindTooltip(r, {
                  permanent: mission_label,
                  opacity: 1
              });
            "undefined" != typeof map && v.addTo(map_filters_service.getFilterLayerByMissionParams(e)),
              iconMapGenerate(s, v), v.on("click", () => {
                $(`#alarm_button_${e.id}`)
                  .click()
            })
        }
        v.mission_id = e.id, v.user_id = e.user_id, v.vehicle_state = e.vehicle_state, v.krankentransport = e
          .kt, v.sicherheitswache = e.sw, v.involved = !0, mission_markers.push(v)
    }
    n && $(`#mission_${e.id}`)
      .addClass("mission_alliance_distance_hide"), e.date_end > 0 && missionTimerStart(e),
      missionSelectionUpdateButtons(), e.live_current_value <= 0 && missionFinish(e),
    missionMarkerBulkAdd || (progressBarScrollUpdate(), "" != $("#search_input_field_missions")
      .val() && searchMission())
}

function missionTimerStart(e) {
    e.date_start = unix_timestamp(), e.date_diff = unix_timestamp() - e.date_now, e.date_end_calc = e
      .date_end + e.date_diff, e.live_current_value_start = e.live_current_value, mission_timers.push({
        mission_id: e.id,
        timer: window.setInterval(() => {
            missionTimer(e)
        }, 1e3)
    })
}

function missionTimerDelete(e) {
    $.each(mission_timers, (t, {mission_id, timer}) => {
        mission_id == e && window.clearInterval(timer)
    })
}

function patientTimerDelete(e) {
    let t = null;
    return $.each(patient_timers, (i, {patient_id}) => {
        patient_id == e && (t = i)
    }), null != t && patient_timers.splice(t, 1), !0;
}

function missionTimer(e) {
    e.live_current_value > e.tv ? (sum_time = e.date_end_calc - e.date_start, done_time = unix_timestamp() - e
      .date_start, percent_done = done_time / sum_time, percent_todo = 1 - percent_done,
      saved_current_value = e.live_current_value_start, e.live_current_value = Math.ceil(percent_todo *
      (saved_current_value - e.tv)) + e.tv, ($(`#mission_bar_${e.id}`)
      .visible(!0) || Math.random() < .3) && $(`#mission_bar_${e.id}`)
      .css("width", `${e.live_current_value}%`)) : e.live_current_value <= 0 ? missionFinish(e) : $(
      `#mission_bar_striper_${e.id}`)
      .removeClass("progress-striped-inner-active")
      .removeClass("progress-striped-inner-active-resource-safe")
}

function patientBarColor({target_percent, id}) {
    target_percent <= 0 ? ($(`#patient_bar_${id}`)
      .removeClass("progress-bar-warning")
      .addClass("progress-bar-danger"), $(`#mission_patients_${id}`)
      .removeClass("progress-bar-warning")
      .addClass("progress-bar-danger")) : ($(`#patient_bar_${id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-warning"), $(`#mission_patients_${id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-warning"))
}

function patientTimer() {
    const e = Date.now();
    "undefined" == typeof patient_timer_last_call && (patient_timer_last_call = e);
    const t = e - patient_timer_last_call;
    patient_timer_last_call = e, "number" == typeof t && 0 / 0 != t && $.each(patient_timers, (e, i) => {
        const n = i.params;
        if (n.live_current_value > n.target_percent) {
            const o = t / n.miliseconds_by_percent;
            $(`#patient_bar_${n.id}`)
              .visible(!0) && $(`#patient_bar_${n.id}`)
              .css("width", `${Math.round(n.live_current_value)}%`), n.live_current_value = n
              .live_current_value - o
        } else n.live_current_value < 0 && patientFinish(n)
    })
}

function patientTimerMission(e) {
    e.live_current_value > e.target_percent ? ($(`#mission_patients_${e.id}`)
      .css("width", `${e.live_current_value}%`), e.live_current_value = e.live_current_value - 1, window
      .setTimeout(() => {
          patientTimerMission(e)
      }, e.miliseconds_by_percent)) : e.live_current_value < 0 && $(`#mission_patients_${e.id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-success")
      .css("width", "100%")
}

function patientFinish({id}) {
    $(`#patient_bar_${id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-success")
      .css("width", "100%")
}

function patientDelete(e) {
    $(`#patient_${e}`)
      .remove(), patientTimerDelete(e)
}

function prisonerDelete(e) {
    $(`#prisoner_${e}`)
      .remove()
}

function missionFinish({patients_count, prisoners_count, id}) {
    patients_count <= 0 && prisoners_count <= 0 && ($(`#mission_bar_${id}`)
      .removeClass("progress-bar-danger")
      .addClass("progress-bar-success")
      .css("width", "100%"), missionDelete(id))
}

function missionDelete(e) {
    1 == mobile_bridge_use && 4 == mobile_version && mobileBridgeAdd("mission_delete", {
        id: e
    }), $(`#mission_${e}`)
      .addClass("mission_deleted"), missionTimerDelete(e);
    const t = [];
    $.each(mission_markers, (i, n) => {
        n.mission_id == e ? "undefined" == typeof mapkit ? n.remove() : map.removeAnnotation(n) : t
          .push(n)
    }), mission_markers = t, missionSelectionUpdateButtons()
}

function vehicleMarkerAdd(e) {
    e.building_id = e.b, e.caption = e.c, e.vehicle_type_id = e.t;
    let t = "";
    1 == e.fms_real ? t = I18n.t("fms.ready_traveling") : 2 == e.fms_real ? t = I18n.t("fms.ready_home") :
      3 == e.fms_real ? t = I18n.t("fms.going") : 4 == e.fms_real ? t = I18n.t("fms.on_place") : 5 == e
        .fms_real ? t = I18n.t("fms.on_destination") : 6 == e.fms_real ? t = I18n.t("fms.not_ready") : 7 == e
        .fms_real ? t = I18n.t("fms.patient_transported") : 8 == e.fms_real ? t = I18n.t(
        "fms.on_destination") : 9 == e.fms_real ? t = I18n.t("fms.waiting_for_vehicle") : 0 == e.fms_real && (
        t = "Notruf");
    let i = `<img src="/images/icons8-location_off.svg" class="vehicle_search" vehicle_id="${e.id}"><span title="${t}" class=" building_list_fms building_list_fms_${e.fms_real}">${e.fms}</span>  <a href="/vehicles/${e.id}" class="label label-default vehicle_building_list_button lightbox-open" id="vehicle_button_${e
    .id}" vehicle_type_id="${e.vehicle_type_id}">${e.caption}</a>`;
    if ((3 == e.fms_real || 4 == e.fms_real) && (i += `<a href="/vehicles/${e.id}/backalarm" class="btn btn-default btn-xs backalarm">${I18n.t("javascript.backalarm")}</a>`,
      e.back_alarm), $(`#vehicle_overview_vehicle_${e.id}`)
      .html(e.fms)
      .attr("class", `building_list_fms building_list_fms_${e.fms_real}`)
      .attr("title", t), "undefined" == typeof L) return !0;
    if ($(`#vehicle_list_${e.id}`)
      .length > 0 && ("undefined" == typeof e.bulkInsert || !e.bulkInsert)) $(`#vehicle_list_${e.id}`)
      .html(i);
    else {
        let n = `<li class="building_list_vehicle_element" vehicle_id="${e.id}" id="vehicle_list_${e
  .id}">`;
        n += i, n += "</li>", "undefined" != typeof e.bulkInsert && e.bulkInsert ? ("undefined" ==
        typeof buildingVehicleCache[e.building_id] && (buildingVehicleCache[e.building_id] = []),
          buildingVehicleCache[e.building_id].push(n)) : $(`#vehicle_building_${e.building_id}`)
          .append(n)
    }
}

function vehicleDrive(e) {
    e.isr = flavouredAsset(e.isr), e["in"] = flavouredAsset(e["in"]);
    const t = new Date;
    let i = !0;
    if ("" == e.mid || alliance_show_not_involved_vehicle || $.each(mission_markers, (n, {mission_id, involved}) => mission_id != e.mid || involved ? void 0 : (e.involved_created_at = t,
      vehicles_not_involved.push(e), i = !1, !1)), !i) return !1;
    if ($.each(vehicle_delay_timers, (t, {vehicle_id, timer}) => {
        vehicle_id == e.id && window.clearTimeout(timer)
    }), e.dd >= 0) vehicleDriveAdd(e);
    else {
        const n = -1e3 * e.dd;
        vehicle_delay_timers.push({
            vehicle_id: e.id,
            timer: setTimeout(() => {
                vehicleDriveAdd(e)
            }, n)
        })
    }
}

function vehicleDriveAdd(params) {
    if (0 == params.vom) return !0;
    if (mapViewExpanded) return !0;
    if (!mobile_show_vehicle && 1 == mobile_bridge_use) return !0;
    if (!show_vehicle && 0 == mobile_bridge_use) return !0;
    const vehicle_marker = null;
    if ($.each(mission_vehicles, (e, t) => {
        t.vehicle_id == params.id && ("undefined" == typeof mapkit ? map.removeLayer(t) : map
          .removeAnnotation(t), mission_vehicles[e].vehicle_marker_deleted = !0, ("undefined" ==
          typeof route_show || 1 == route_show) && "undefined" != typeof t.polyline && (
          "undefined" == typeof mapkit ? map.removeLayer(t.polyline) : map.removeOverlay(t
            .polyline)))
    }), "undefined" == typeof routes[params.rh]) {
        if ("-1" == params.s) return $.get(`/vehicles/${params.id}/routing`, data => {
            eval(data)
        }), !0;
        routes[params.rh] = eval(params.s)
    }
    if (("undefined" == typeof route_show || 1 == route_show) && "undefined" != typeof routes[params.rh]) {
        const lineArray = [];
        if (jQuery.each(routes[params.rh], (e, t) => {
            lineArray.push([t[0], t[1]])
        }), "undefined" != typeof mapkit) {
            const coords = lineArray.map(e => new mapkit.Coordinate(e[0], e[1]));

            const style = new mapkit.Style({
                lineWidth: 2,
                lineJoin: "round",
                strokeColor: "#FF0000"
            });

            params.polyline = new mapkit.PolylineOverlay(coords, {
                style
            }), map.addOverlay(params.polyline)
        } else params.polyline = L.polyline(lineArray, {
            color: "red",
            opacity: 1,
            weight: 3
        })
          .addTo(map)
    }
    vehicleCreateOnMap(vehicle_marker, params), building_maps_redraw()
}

function vehicle_image_reload() {
    $(".vehicle_image_reload")
      .each(function () {
          if ("false" == $(this)
            .attr("image_replace_allowed")) return !0;
          if ("undefined" != typeof $(this)
            .attr("vehicle_graphic_id") && "" != $(this)
            .attr("vehicle_graphic_id")) {
              const e = $(this)
                .attr("vehicle_graphic_id");
              "undefined" != typeof vehicle_graphics_sorted[e] && "undefined" !=
              typeof vehicle_graphics_sorted[e][$(this)
                .attr("vehicle_type_id")] && null != vehicle_graphics_sorted[e][$(this)
                .attr("vehicle_type_id")] && $(this)
                .attr("src", vehicle_graphics_sorted[e][$(this)
                  .attr("vehicle_type_id")][0])
          } else "undefined" != typeof vehicle_graphics[$(this)
            .attr("vehicle_type_id")] && null != vehicle_graphics[$(this)
            .attr("vehicle_type_id")] && $(this)
            .attr("src", vehicle_graphics[$(this)
              .attr("vehicle_type_id")][0])
      })
}

function vehicleCreateOnMap(e, t) {
    if ("true" == t.ioverwrite || "undefined" == typeof user_id || t.user_id != user_id)
        if ("undefined" != typeof buildingVehicleGraphicCache[t.b]) {
            const i = buildingVehicleGraphicCache[t.b];
            "undefined" != typeof vehicle_graphics_sorted[i] && "undefined" != typeof vehicle_graphics_sorted[
              i][t.vtid] && null != vehicle_graphics_sorted[i][t.vtid] && (t["in"] = flavouredAsset(
              vehicle_graphics_sorted[i][t.vtid][0]), t.isr = flavouredAsset(
              vehicle_graphics_sorted[i][t.vtid][1]), t.apng_sonderrechte = flavouredAsset(
              vehicle_graphics_sorted[i][t.vtid][2]))
        } else "undefined" != typeof vehicle_graphics[t.vtid] && null != vehicle_graphics[t.vtid] && (t[
          "in"] = flavouredAsset(vehicle_graphics[t.vtid][0]), t.isr = flavouredAsset(vehicle_graphics[t
          .vtid][1]), t.apng_sonderrechte = flavouredAsset(vehicle_graphics[t.vtid][2]));
    if (null == e) {
        if ("undefined" != typeof mapkit) {
            var e = new mapkit.ImageAnnotation(new mapkit.Coordinate(0, 0), {
                url: {
                    1: t["in"]
                }
            });
            e.icon_normal = t["in"], e.icon_sonderrechte = t.isr, map.addAnnotation(e), e.element.className =
              "mapkit-marker", e.addEventListener("select", () => {
                "undefined" == typeof user_id ? $("#signup_from")
                  .effect("highlight", {}, 500) : lightboxOpen(`/vehicles/${t.id}`), setTimeout(
                  mapkitDeselectAnnotation, 1e3)
            })
        } else {
            var e = L.marker([0, 0], {
                title: t.name,
                icon: icon_empty
            })
              .addTo(map);
            iconMapVehicleGenerate(t["in"], t.isr, e), e.on("click", () => {
                "undefined" == typeof user_id ? $("#signup_from")
                  .effect("highlight", {}, 500) : lightboxOpen(`/vehicles/${t.id}`)
            })
        }
        e.visible = !1, e.apng_sonderrechte = "undefined" != typeof t.apng_sonderrechte && "true" == t
          .apng_sonderrechte ? !0 : !1, e.vehicle_marker_deleted = !1, mission_vehicles.push(e),
          setInterval(() => {
              vehicleSonderrechte(e)
          }, 1e3)
    }
    e.title = "undefined" == typeof user_id || t.user_id == user_id ? t.caption : `[${I18n.t(
  "map.alliance")}] ${t.caption}`, t.dd < 0 && (t.dd = 0);
    const n = new Date;
    e.url_arrive = `/vehicles/${t.id}/arrive`, "undefined" == typeof mapkit && e.setIcon(icon_empty), e
      .user_id = t.user_id, e.sonderrechte = t.sr, e.rh = t.rh, e.polyline = t.polyline, e.current_step = 0,
      e.timer_steps = n.getTime() - 1e3 * t.dd, e.vehicle_id = t.id, "undefined" == typeof mapkit ? e
      .bindTooltip(`<span class='vehicleMarkerLabelFms building_list_fms_${t.fms_real}'>${t.fms}</span>${e.title}`, {
          permanent: vehicle_label,
          opacity: 1
      }) : e.title = e.title, 4 == mobile_version && (String(t["in"]).includes("//") ? (e.app_icon_path_normal = t["in"], e.app_icon_path_sonderrechte = t.isr) : (e
      .app_icon_path_normal = currentHostname() + t["in"], e.app_icon_path_sonderrechte =
      currentHostname() + t.isr)), e.visible || (e.visible = !0, "undefined" == typeof mapkit && e
      .setOpacity(1), vehicle_markers.push(e), vehicle_marker_id = vehicle_markers.length - 1,
      vehicleDriveReal(vehicle_marker_id))
}

function vehicleSonderrechte(e) {
    let t = [];
    "undefined" != typeof mapkit ? (coordinate = e.coordinate, t[0] = coordinate.latitude, t[1] = coordinate
      .longitude) : t = e.getLatLng(), mapIsVisible(t) && "undefined" != typeof e.icon_normal &&
    "undefined" != typeof e.icon_sonderrechte && (1 == e.sonderrechte ? "undefined" != typeof e
      .apng_sonderrechte && e.apng_sonderrechte && apng_supported ? 1 != e.sonderrechte_status && (
      "undefined" != typeof mapkit ? e.url = {
          1: e.icon_sonderrechte
      } : e.setIcon(e.icon_sonderrechte), e.sonderrechte_status = 1) : "undefined" != typeof e
      .sonderrechte_status && 1 == e.sonderrechte_status ? ("undefined" != typeof mapkit ? e.url = {
        1: e.icon_normal
    } : e.setIcon(e.icon_normal), e.sonderrechte_status = 0) : ("undefined" != typeof mapkit ? e
      .url = {
        1: e.icon_sonderrechte
    } : e.setIcon(e.icon_sonderrechte), e.sonderrechte_status = 1) : "undefined" != typeof e
      .sonderrechte_status && 1 == e.sonderrechte_status && ("undefined" != typeof mapkit ? e.url = {
        1: e.icon_normal
    } : e.setIcon(e.icon_normal), e.sonderrechte_status = 0))
}

function vehicleDriveReal(e) {
    const t = vehicle_markers[e];
    if (t.vehicle_marker_deleted) return !0;
    const i = new Date;
    0 == t.timer_steps && (t.timer_steps = i.getTime());
    let n = 40;
    if ("undefined" != typeof routes[t.rh] && null != routes[t.rh] && "undefined" != typeof routes[t.rh][t
      .current_step]) {
        if (start_lat = routes[t.rh][t.current_step][0], start_lng = routes[t.rh][t.current_step][1],
        "undefined" != typeof routes[t.rh][t.current_step + 1]) {
            let o = 0;
            do
                if (end_lat = routes[t.rh][t.current_step + 1][0], end_lng = routes[t.rh][t.current_step + 1][
                  1], offset_step = 100 * ((i.getTime() - t.timer_steps) / (1e3 * routes[t.rh][t
                  .current_step][2])), offset_step >= 100) {
                    const s = i.getTime() - t.timer_steps;
                    const a = 1e3 * routes[t.rh][t.current_step][2];
                    const r = s - a;
                    t.current_step++, t.timer_steps = i.getTime() - r, o += 1
                } while (offset_step >= 100 && "undefined" != typeof routes[t.rh][t.current_step + 1]);
            ("undefined" == typeof route_show || 1 == route_show) && "undefined" !=
            typeof t.polyline && o > 0 && ("undefined" == typeof t.delete_step_counter_cache && (t
              .delete_step_counter_cache = 0), "undefined" == typeof t.latitude || mapIsVisible([t
              .latitude, t.longitude]) ? (spliceLatLngs(t.polyline, o + t
              .delete_step_counter_cache), t.delete_step_counter_cache = 0) : t
              .delete_step_counter_cache = t.delete_step_counter_cache + o), "undefined" !=
            typeof routes[t.rh][t.current_step] && "undefined" != typeof routes[t.rh][t.current_step +
            1] && (start_lat = routes[t.rh][t.current_step][0], start_lng = routes[t.rh][t.current_step][
              1], end_lat = routes[t.rh][t.current_step + 1][0], end_lng = routes[t.rh][t
              .current_step + 1][1], offset_step = 100 * ((i.getTime() - t.timer_steps) / (1e3 *
              routes[t.rh][t.current_step][2])), diff_jb = end_lat - start_lat, diff_kb = end_lng -
              start_lng, current_lat = start_lat + diff_jb * (offset_step / 100), current_lng =
              start_lng + diff_kb * (offset_step / 100), t.latitude = current_lat, t.longitude =
              current_lng, 1 == mobile_bridge_use && 4 == mobile_version ? mobileBridgeAdd(
              "vehicle_move", {
                  id: t.vehicle_id,
                  title: t.title,
                  sonderrechte: t.sonderrechte,
                  latitude: t.latitude,
                  longitude: t.longitude,
                  app_icon_path_normal: t.app_icon_path_normal,
                  app_icon_path_sonderrechte: t.app_icon_path_sonderrechte
              }) : (isNaN(current_lat) || isNaN(current_lng), mapIsVisible([current_lat,
                current_lng]) && ("undefined" != typeof mapkit ? t.coordinate = new mapkit
              .Coordinate(current_lat, current_lng) : t.setLatLng([current_lat, current_lng])),
              mapIsVisible([current_lat, current_lng]) ? (1 == t.performance_invisible && (t
                .performance_invisible = !1, "undefined" == typeof mapkit ? t.addTo(map) : map
                .addAnnotation(t)), "undefined" == typeof mapkit && (vehicle_label ? t
                .openTooltip() : t.closeTooltip())) : (n = 1e3, "undefined" == typeof mapkit ? (t
                .closeTooltip(), map.removeLayer(t)) : 0 == t.performance_invisible && map
                .removeAnnotation(t), t.performance_invisible = !0), new_position = null))
        } else t.current_step++;
        setTimeout(() => {
            vehicleDriveReal(e)
        }, n)
    } else vehicleArrive(t)
}

function allianceChatBanCountdown(e, t) {
    window.clearTimeout(alliance_chat_ban_countdown_timer), 0 >= e ? ($("#mission_chat_ban_message")
      .hide(), $("#alliance_chat_message")
      .show()) : ($("#mission_chat_ban_message")
      .show(), $("#mission_chat_ban_message_timer")
      .html(formatTime(e, !1)), $("#mission_chat_ban_message_admin")
      .html(t), $("#alliance_chat_message")
      .hide(), e -= 1, alliance_chat_ban_countdown_timer = setTimeout(() => {
        allianceChatBanCountdown(e, t)
    }, 1e3))
}

function missionCountdown(e, t) {
    0 > e || ($(`#mission_countdown_${t}`)
      .html(formatTime(e, !1)), e -= 1, setTimeout(() => {
        missionCountdown(e, t)
    }, 1e3))
}

function taskCountdown(e, t) {
    0 > e || ($(`#task_countdown_${t}`)
      .html(formatTime(e, !1)), e -= 1, setTimeout(() => {
        taskCountdown(e, t)
    }, 1e3))
}

function vehicleArrivalCountdown(e, t, i) {
    0 > e ? $(`#vehicle_drive_${t}`)
      .html(`${I18n.t("javascript.arrival")}... <a href='#' class='btn btn-xs btn-default' onclick='window.location.reload();'>${I18n.t(
      "javascript.reload")}</a>`) : (i > 0 ? $(`#vehicle_drive_${t}`)
      .html(I18n.t("javascript.start_in") + formatTime(i, !1)) : $(`#vehicle_drive_${t}`)
      .html(formatTime(e, !1)), e -= 1, i -= 1, setTimeout(() => {
        vehicleArrivalCountdown(e, t, i)
    }, 1e3))
}

function extensionCountdown(e, t) {
    0 > e || ($(`#extension_countdown_${t}`)
      .html(formatTime(e, !1)), e -= 1, setTimeout(() => {
        extensionCountdown(e, t)
    }, 1e3))
}

function educationCountdown(e, t) {
    0 > e ? $(`#education_schooling_${t}`)
      .html(I18n.t("javascript.few_seconds")) : ($(`#education_schooling_${t}`)
      .html(formatTime(e, !1)), e -= 1, setTimeout(() => {
        educationCountdown(e, t)
    }, 1e3))
}

function highlightElement(e) {
    e.removeClass("highlight"), setTimeout(() => {
        e.addClass("highlight")
    }, 10)
}

function creditsUpdate(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("credits", {
        value: number_format(e)
    });
    const t = `${I18n.t("javascript.credits")}: ${number_format(e)}`;

    const i = $("#navigation_top")
      .html();

    $("#navigation_top")
      .html(t), "" != i && i != t && highlightElement($("#navigation_top"))
}

function tasksUpdate(e, t) {
    e > 0 ? $("#completed_tasks_counter")
      .html(e) : 1 == t && $("#completed_tasks_counter")
      .html(I18n.t("javascript.new")), e > 0 ? ($("#completed_tasks_counter")
      .removeClass("hidden"), $("#menu_profile")
      .addClass("alliance_forum_new")) : 1 == t ? ($("#completed_tasks_counter")
      .removeClass("hidden"), $("#menu_profile")
      .addClass("alliance_forum_new")) : ($("#completed_tasks_counter")
      .addClass("hidden"), $("#menu_profile")
      .removeClass("alliance_forum_new"))
}

function updateSaleCountDown() {
    if (null != saleTimeout && (clearTimeout(saleTimeout), saleTimeout = null), sale_count_down > Date
      .now()) {
        const e = sale_count_down - Date.now();
        const t = `% ${count_down_title} ${getFormattedDuration(e)} %`;
        $("#sale_countdown")
          .html(t), $("#sale_countdown_mobile")
          .html(t), saleTimeout = setTimeout(updateSaleCountDown, 1e3)
    } else {
        $("#coins_top")
          .removeClass("saleHighlight");
        const i = $("#sale_countdown");
        i && i.remove();
        const n = $("#sale_countdown_mobile");
        n && n.remove()
    }
}

function setupSaleTimer(e, t, i) {
    const n = i - t;
    const o = i - Date.now();
    o > 0 ? (updateSaleCountdownTimer(e, o), updateSaleCountdownProgressBar(e, o, n), setTimeout(() => {
        setupSaleTimer(e, t, i)
    }, 1e3)) : saleEnded(e)
}

function saleEnded(e) {
    e.find(".sale_countdown_timer")
      .html(I18n.t("javascript.sale_ended", {
          defaultValue: "Sale ended"
      })), e.find("button")
      .attr("disabled", "disabled"), e.fadeOut()
}

function updateSaleCountdownTimer(e, t) {
    const i = `${I18n.t("javascript.time_left", {
    defaultValue: "Time left:"
})} ${getFormattedDuration(t)}`;
    e.find(".sale_countdown_timer")
      .html(i)
}

function updateSaleCountdownProgressBar(e, t, i) {
    const n = Math.floor(100 / i * t);
    e.find(".sale_countdown_progress_bar")
      .animate({
          width: `${n}%`
      }, 500)
}

function getFormattedDuration(e) {
    const t = Math.floor(e / 864e5);
    const i = Math.floor(e % 864e5 / 36e5);
    const n = Math.floor(e % 36e5 / 6e4);
    const o = Math.floor(e % 6e4 / 1e3);
    let s = "";
    return t > 0 && (s = `${t + I18n.t("javascript.days")
  .charAt(0)}:`), `${s + padding(i)}:${padding(n)}:${padding(o)}`;
}

function coinsUpdate(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("coins", {
        value: number_format(e)
    });
    let t = `${I18n.t("javascript.coins")}: ${number_format(e)}`;
    if (sale_count_down > Date.now()) t += "<div id='sale_countdown' />", $("#coins_top")
      .addClass("saleHighlight"), 0 === $("#sale_countdown_mobile")
      .length && ($(".navbar-header")
      .append("<div id='sale_countdown_mobile' />"), $("#sale_countdown_mobile")
      .on("click", () => {
          mobileBridgeAdd("coins_window", {})
      })), updateSaleCountDown(), $("#coins_top")
      .html(t);
    else {
        const i = $("#coins_top")
          .html();
        $("#coins_top")
          .html(t), "" != i && i != t && highlightElement($("#coins_top"))
    }
}

function messageUnreadUpdate(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("pn", {
        value: number_format(e)
    });
    const t = number_format(e);

    const i = $("#message_top")
      .html();

    $("#message_top")
      .html(t), e > 0 ? ($("#message_top")
      .addClass("message_new"), $("#main-navbar-toggle")
      .addClass("message_new")) : ($("#message_top")
      .removeClass("message_new"), $("#main-navbar-toggle")
      .removeClass("message_new")), "" != i && i != t && highlightElement($("#message_top"))
}

function number_format(e, t) {
    const i = ",";
    const n = ".";
    x = new Array, s = 0 > e ? "-" : "", e = Math.abs(e)
      .toFixed(t)
      .split("."), r = e[0].split("")
      .reverse();
    for (let o = 1; o <= r.length; o++) x.unshift(r[o - 1]), 0 == o % 3 && o != r.length && x.unshift(n);
    return s + x.join("") + (e[1] ? i + e[1] : "")
}

function formatTimeDescription(e) {
    if (total_rest = e, e > 0) {
        if (countdown_message = "", e >= 86400) {
            const t = Math.floor(e / 86400);
            e -= 86400 * t, countdown_message += `${t} ${I18n.t("javascript.days")} `
        }
        if (e >= 3600) {
            let i = Math.floor(e / 3600);
            e -= 3600 * i, 10 > i && (i = `0${i}`), countdown_message += `${i} ${I18n.t(
  "javascript.hours")} `
        }
        let n = Math.floor(e / 60);
        e -= 60 * n, 10 > n && (n = `0${n}`), countdown_message += `${n} ${I18n.t("javascript.minutes")} `, countdown_message += 10 > e ? `0${e}` : e, countdown_message += ` ${I18n.t(
  "javascript.secounds")}`
    } else countdown_message = I18n.t("javascript.now");
    return countdown_message
}

function formatTime(e, t) {
    if (total_rest = e, e > 0) {
        if (countdown_message = "", e >= 86400) {
            const i = Math.floor(e / 86400);
            if (e -= 86400 * i, countdown_message += `${i} ${I18n.t("javascript.days")} - `,
            "undefined" != typeof t && 1 == t) return countdown_message
        }
        if (e >= 3600) {
            let n = Math.floor(e / 3600);
            if (e -= 3600 * n, 10 > n && (n = `0${n}`), countdown_message += `${n}:`, "undefined" !=
            typeof t && 1 == t) return countdown_message
        }
        let o = Math.floor(e / 60);
        if (e -= 60 * o, 10 > o && (o = `0${o}`), countdown_message += `${o}:`, "undefined" != typeof t &&
        1 == t) return countdown_message;
        if (countdown_message += 10 > e ? `0${e}` : e, "undefined" != typeof t && 1 == t)
            return countdown_message
    } else countdown_message = "00";
    return countdown_message
}

function vehicleArrive(e) {
    "undefined" != typeof e.polyline && ("undefined" != typeof mapkit ? map.removeOverlay(e.polyline) : map
      .removeLayer(e.polyline)), "undefined" != typeof mapkit ? map.removeAnnotation(e) : map
      .removeLayer(e), e.vehicle_marker_deleted = !0, 1 == mobile_bridge_use && 4 == mobile_version &&
    mobileBridgeAdd("vehicle_remove", {
        id: e.vehicle_id
    })
}

function rand(e, t) {
    const i = arguments.length;
    return 0 === i && (e = 0, t = 32768), Math.floor(Math.random() * (t - e + 1)) + e
}

function missionSpeed(e) {
    mission_speed = e, 6 == mission_speed ? $("#mission_speed_pause")
      .show() : $("#mission_speed_pause")
      .hide()
}

function missionRequest() {
    let e = 0;
    $.each(mission_markers, (t, i) => {
        1 == i.opacity && i.user_id == user_id && e++
    });
    let t = mission_count_max;
    eventRunning && (t = 2 * t), 6 != mission_speed && "undefined" != typeof mission_count_max && t > e && $
      .ajax({
          url: "/mission-generate",
          cache: !1,
          error({status}) {
              401 == status && (window.location.href = "/")
          }
      }), timeout = 0 == mission_speed ? rand(12e4, 22e4) : 2 == mission_speed ? rand(31e3, 45e3) : 3 ==
    mission_speed ? rand(21e3, 25e3) : 4 == mission_speed ? rand(25e4, 35e4) : 5 == mission_speed ? rand(
      5e5, 7e5) : rand(31e3, 12e4), setTimeout("missionRequest()", timeout)
}

function lightboxShowClose(e) {
    e ? ($("#lightbox_close")
      .show(), $(`#lightbox_iframe_${iframe_lightbox_number}`)
      .css("height", `${parseInt($("#lightbox_box")
    .css("height")) - 34}px`), $("#lightbox_box")
      .css("border", "1px solid #e3e3e3")) : ($("#lightbox_close")
      .hide(), $(`#lightbox_iframe_${iframe_lightbox_number}`)
      .css("height", `${parseInt($("#lightbox_box")
    .css("height")) - 2}px`), $("#lightbox_box")
      .css("border", "1px solid #424242"))
}

function lighboxCalculateHeight() {}

function lightboxOpen(e) {
    if (1 == mobile_bridge_use) mobileBridgeAdd("lightbox_open", {
        url: e
    });
    else {
        const t = parseInt($("#lightbox_background")
            .css("width"));

        const i = parseInt($("#lightbox_background")
          .css("height"));

        let n = i - 100;
        592 > n && (n = i - 30);
        let o = t - 70;
        862 > o && (o = t - 0);
        const s = o - 2;
        const a = n - 34;
        const r = (t - o) / 2;
        $("#lightbox_box")
          .css("width", `${o}px`), $("#lightbox_box")
          .css("height", `${n}px`), $("#lightbox_box")
          .attr("iframeWidth", s), $("#lightbox_box")
          .attr("iframeHeight", a), $("#lightbox_box")
          .show(), $("#lightbox_box")
          .append(`<iframe class="lightbox_iframe" style="width:${s}px;height:${a}px" id="lightbox_iframe_${iframe_lightbox_number}"></iframe>`), $(`#lightbox_iframe_${iframe_lightbox_number}`)
          .attr("src", e), $(`#lightbox_iframe_${iframe_lightbox_number}`)
          .show(), $("#lightbox_background")
          .show(), $("#lightbox_box")
          .css("left", `${r}px`), $("#lightbox_box")
          .css("top", `${(i - n) / 2}px`), $(`#lightbox_iframe_${iframe_lightbox_number}`)
          .load(function () {
              $(this)
                .contents()
                .find("#iframe-inside-container")
                .css("height", a)
                .css("width", s)
          }), setTimeout('$("#lightbox_iframe_" + iframe_lightbox_number).focus();', 100)
    }
}

function lightboxAdjust() {
    const e = $("#lightbox_box")
        .attr("iframeWidth");

    const t = $("#lightbox_box")
      .attr("iframeHeight");

    $(`#lightbox_iframe_${iframe_lightbox_number}`)
      .contents()
      .find("#iframe-inside-container")
      .css("height", t)
      .css("width", e)
}

function lightboxClose() {
    setTimeout(`$("#lightbox_iframe_${iframe_lightbox_number}").remove();`, 5e3), $(
      "#lightbox_background")
      .hide(), $("#lightbox_box")
      .hide(), $(`#lightbox_iframe_${iframe_lightbox_number}`)
      .hide(), iframe_lightbox_number += 1, tutorial.callLightBoxCloseListener()
}

function distance(e, t, i, n) {
    temp1 = i - e, temp2 = n - t;
    const o = 6371;
    const s = temp1 * Math.PI / 180;
    const a = temp2 * Math.PI / 180;

    const r = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(e * Math.PI / 180) * Math.cos(i * Math.PI / 180) *
      Math.sin(a / 2) * Math.sin(a / 2);

    const l = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1 - r));
    const c = o * l;
    return final = 1e3 * c
}

function allianceMenu(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("alliance_menu", {
        show: e
    }), e ? ($(".alliance_true")
      .show(), $(".alliance_false")
      .hide()) : ($(".alliance_true")
      .hide(), $(".alliance_false")
      .show())
}

function allianceCandidatureCount(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("alliance_candidature_count", {
        value: e
    });
    const t = `(${number_format(e)})`;

    const i = $("#alliance_candidature_count")
      .html();

    $("#alliance_candidature_count")
      .html(t), (alliance_coadmin || alliance_admin) && (e > 0 ? $("#menu_alliance")
      .addClass("alliance_apply_new") : $("#menu_alliance")
      .removeClass("alliance_apply_new")), "" != i && i != t && highlightElement($("#menu_alliance"))
}

function allianceMessageNew(e) {
    e ? ($("#alliance_message_new")
      .show(), $("#menu_alliance")
      .addClass("alliance_message_new"), $("#main-navbar-toggle")
      .addClass("alliance_message_new")) : ($("#alliance_message_new")
      .hide(), $("#menu_alliance")
      .removeClass("alliance_message_new"), $("#main-navbar-toggle")
      .removeClass("alliance_message_new"))
}

function allianceNewsNew(e) {
    e ? ($("#alliance_news_new")
      .show(), $("#menu_alliance")
      .addClass("alliance_forum_new"), $("#main-navbar-toggle")
      .addClass("alliance_forum_new")) : ($("#alliance_news_new")
      .hide(), $("#menu_alliance")
      .removeClass("alliance_forum_new"), $("#main-navbar-toggle")
      .removeClass("alliance_forum_new"))
}

function allianceForumNew(e) {
    e ? ($("#alliance_forum_new")
      .show(), $("#menu_alliance")
      .addClass("alliance_forum_new"), $("#main-navbar-toggle")
      .addClass("alliance_forum_new")) : ($("#alliance_forum_new")
      .hide(), $("#menu_alliance")
      .removeClass("alliance_forum_new"), $("#main-navbar-toggle")
      .removeClass("alliance_forum_new"))
}

function newsNew(e) {
    e ? ($("#news_li")
      .addClass("news_new"), $("#main-navbar-toggle")
      .addClass("news_new"), highlightElement($("#news"))) : ($("#news_li")
      .removeClass("news_new"), $("#main-navbar-toggle")
      .removeClass("news_new"))
}

function graphicPackNewMessages(e) {
    0 == e && ($("#graphic_packs")
      .find(".badge")
      .hide(), 0 == $("ul[aria-labelledby='menu_profile']")
      .find(".badge:visible")
      .size() && $("#menu_profile")
      .removeClass("graphic_new_comments"))
}

function play(e) {
    if (1 == mobile_bridge_use && 4 == mobile_version) return mobileBridgeAdd("play", {
        sound: e
    }), !0;
    if (!mobile_bridge_use && window.HTMLAudioElement) try {
        let t = new Audio("");
        t.canPlayType("audio/mp3") ? t = new Audio(`/audio/${e}.mp3`) : t.canPlayType("audio/ogg") &&
          (t = new Audio(`/audio/${e}.ogg`)), t.play()
    } catch (i) {}
}

function isLoggedIn() {
    return "undefined" == typeof user_id || isNaN(user_id) ? !1 : !0
}

function mobileShow(e) {
    if ("account" == e) mobileBridgeAdd("account_show", {});
    else {
        $(".overview_outer")
          .hide(), $(`#${e}_outer`)
          .show(), $(".mobile-navbar-selector")
          .addClass("btn-default")
          .removeClass("btn-success"), $(`.mobile-navbar-selector[target_element=${e}]`)
          .removeClass("btn-default")
          .addClass("btn-success"), progressBarScrollUpdate();
        const t = $(window)
          .height() - 71 - $("#navbar-mobile-footer")
          .outerHeight();
        "map" == e && ($("#map")
          .height(t), "undefined" == typeof mapkit && map.invalidateSize()), "missions" == e && $(
          "#missions-panel-body")
          .height(t - $(".missions-panel-head")
            .outerHeight(!0)), "buildings" == e && ($("#building_panel_body")
          .css("max-height", "initial"), $("#building_panel_body")
          .css("padding-bottom", "15px"), $("#building_panel_body")
          .height(t - $("#building_panel_heading")
            .outerHeight(!0) - 50)), "chat" == e && ($("#chat_panel_body")
          .css("max-height", "initial"), $("#chat_panel_body")
          .css("padding-bottom", "15px"), $("#chat_panel_body")
          .height(t - $("#chat_panel_heading")
            .outerHeight(!0) - 50)), "radio" == e && ($("#radio_panel_body")
          .css("max-height", "initial"), $("#radio_panel_body")
          .css("padding-bottom", "15px"), $("#radio_panel_body")
          .height(t - $("#radio_panel_heading")
            .outerHeight(!0) - 50))
    }
}

function mobileBridgeRequest() {
    const e = mobile_bridge_content.splice(0, 50);
    const t = JSON.stringify(e);
    return t
}

function mobileBridgeAdd(e, t) {
    let i = !1;
    1 == mobile_bridge_use && 4 == mobile_version && "vehicle_move" == e && $.each(mobile_bridge_content,
      (n, o) => {
          "vehicle_move" == o.f && o.p.id == t.id && (i = !0, mobile_bridge_content[n] = {
              f: e,
              p: t
          })
      }), i || mobile_bridge_content.push({
        f: e,
        p: t
    })
}

function mobileDirectBridgeCall() {}

function showNewBuildingDialog() {
    1 == mobile_bridge_use && 4 == mobile_version && mobileDirectBridgeCall("showNewBuildingDialog")
}

function hideFAQButton(e) {
    1 == mobile_bridge_use && 4 == mobile_version && mobileDirectBridgeCall("hideFAQButton", e)
}

function checkDesign(e) {
    1 != e && 4 != e || $("body")
      .hasClass("dark") ? 1 != e && 4 != e && $("body")
      .hasClass("dark") && ($("body")
      .removeClass("dark", 500), "undefined" != typeof mapkit && (map.colorScheme = mapkit.Map
      .ColorSchemes.Light)) : ($("body")
      .addClass("dark", 500), "undefined" != typeof mapkit && (map.colorScheme = mapkit.Map.ColorSchemes
      .Dark)), 2 != e || $("body")
      .hasClass("bright") ? 2 != e && $("body")
      .hasClass("bright") && $("body")
      .removeClass("bright", 500) : ($("body")
      .addClass("bright", 500), "undefined" != typeof mapkit && (map.colorScheme = mapkit.Map
      .ColorSchemes.Light))
}

function tellParent(e) {
    1 == mobile_bridge_use ? mobileBridgeAdd("tell_main", {
        jscode: e
    }) : top.eval(e)
}

function missionSelectionOnly(e) {
    const t = ["mission_select_emergency", "mission_select_krankentransport", "mission_select_alliance",
        "mission_select_alliance_event", "mission_select_sicherheitswache"];
    $.each(t, (t, i) => {
        e.attr("id") == i ? missionSelectionActive($(`#${i}`)) : missionSelectionDeactive($(`#${i}`))
    }), missionSelectionSave()
}

function missionSelectionUpdateButtons() {
    if (missionMarkerBulkAdd) return !0;
    let e = 0;
    let t = 0;
    let i = 0;
    let n = 0;
    let o = 0;
    let s = 0;
    let a = 0;
    let r = 0;
    let l = 0;
    let c = 0;
    $.each(mission_markers, (u, d) => {
        d.krankentransport ? (i++, 0 == d.vehicle_state && n++) : d.sicherheitswache ? (l++, 0 == d
          .vehicle_state && c++) : d.user_id != user_id && null != d.user_id ? (o++, 0 == d
          .vehicle_state && s++) : d.user_id != user_id && null == d.user_id ? (a++, 0 == d
          .vehicle_state && r++) : (e++, 0 == d.vehicle_state && t++)
    }), $("#mission_select_emergency")
      .html(
        `<img class="icon icons8-Siren-Filled" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAADcElEQVRoQ+2Z/XETMRDF91WAUwFQAaQCoAJIBSQVABUQKoBUgFNBQgVABSQVQCogqeAxz0ge5aw7Sau7GYax/rFnrK/frvbtSoY5Gsm1mb00s0MAvxxT7AwhuTKzn2Z2DuBt65xoHaD+AeR1WPTYM8dwDMlTM3vvndML8ihYT/t53OuVxBvyims+F8jcXun1hvbTAzKLV+bwRhfIwCsnACQAzY2kYuyzNzbigm6PBBCd6WMAn5oJkgEkpVJrALfeebpAvIsuMW4PsoRVe+b8fzxCUmWB2imAc49VSD43szdmpk8JQE27MrNLMzvzBjlJVReqCFYgqQmfhJVVN1UDhRwg6XxVs/ORPlIqrXlWO0cCoFymdrM5WkHLRfYwAToCIMhsCxBfzeypmd2ZmSRYElpVRAYvKofIqmoaezIFQ1JrXZjZFiAYYX0vRgZAk0mOpDau43Qtj9QCDDeaJET9JOPpuI0ZLybPmwgQO2aDXdYC8G1iwrQ8USk/6rma45LA3AI4KHgluzeXaiXe0N1hrjJehntmZq5yxwvyI8TGiynP1Xgj9gllykdvzeUFoTYAwDU+BxiCX+LxHYBkvKk1b4RkjI87ALU5o7ipoIK/zawYJ7nJPCCylttyhUB2e9oDEiXwC4CeRLjDlCTnZiX0gMRHgg8A9H22RjIqV7OIeECUsPQU5JLJwtFyG8kD4rZayXXJI0Sztz0gUhb3s00pa3uFZAck6LkybLa8JulWlgqPREW8AnCYqctkQD3iSWjulVBbkACgTjEZ7cRAkrSuAagSnb1NGWpQYApER3ADpPuINp4CbErynCL1Zt8aapK6nzwws4PchSvEkV5d1EftL1C0QHKnEET2WSYJRh275ofmSpCimIQqQOtvgQSie4U2PgqQFHbxDtKsKjUQ6kOyWt4ToFWTavUkrAYQVy5pBZm9fM8ok6sEagVZTHqT4+sqSqtBlirfMx6J14Smcr4FxGWp2thI+3mSbguI6+w6QeJbW3UV3ALiUhMnSDGXDOdtAdEfOXpMe9f7f0gJLnmlqc5XLSDNVipteOx3TwXRArJY+Z5RrmZhGQUhGZOf17BLjLsEcJSbeApkk/z+tTb2llYEmfMRrscopdyyB+mxrmfs3iMlC3is2jOmtJ9ijPQsvsRYj2rFTL7Efrxzjr43/wE/Kgjg5EADGQAAAABJRU5ErkJggg==" width="15" height="15"> (${t}/${e})`), $("#mission_select_krankentransport")
      .html(
        `<img class="icon icons8-Ambulance" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAC/UlEQVR4Xu2b7VUVMRCGZypQK0AqECsQKhArUCpAKsAOwArECsAOoALsQKgAOhjPe84sZ2/YbCab5N7dbPL3ZjOZJ28yk4/LtPLCK/efGoCmgJUTaFNgDgIQkfdEdEFEB9qfv0R0xswPpfu3cwWo8/dE9NZx9pmIPpaGMAcAN0T02TPSf5j5uKQK5gDgaWD0O58fmHm/dgAy5iAzFx2koo1bRk5E5gEg1BGLMzusc8LMV1Psvyhg4QAQMY6YGeEzqtQCAE5PCps1AQAEKABKAAxT8QIovfqaeheoJCI/iOjcqXbLzEfW9hcNAE6KCBa/r47DV8x8YoGweAAKAdL/4DiMvcRlCEItALCPuB2AEAyPVQBQFWAnCQhveqMeDI/VAOhBwM6yX0bD49YBuAlX7mgjIt+I6JcDwRseqwOgSjCHxyoBxITHagFYw2PtAILhsWoAI+GRusW3GIDU7XXO6CAiyBE2wuOqAKgSNk6eGgA9a1zFFNiJAny7sNKZYKzdYgqI7Uho25r6uw98A9CR3ZY0t2XHVUxTgHMBUzwMtjUgddXK/P1spkBmv8zNZQOgDxpOiQj39njZgYKXHLjn/1n6QcNU+1kAiAiesXwPYL9k5jPz0ERUTLGfDEBEcM6G8zZLMV9MWBrTVDbJfhIAEcEFA2QfUzAdQmoxtZfD/mQAOuf+OT191KmAc3iUQyICpD2n3n7qmpDLfgoAd/Th/IF7AysiOH7C8XMfQrIKBkZ/kv1oACPa/MLMWPFfFRFBZLg26Xp6pSz2g5ngSP/e+e7fPXKd7urwl1nsNwChE6HVTQGfwwOLELI+PGHdeIaiiyBOXrvsEE2WWASz2g++E/TMa3QCMf5OwX3SMNh3Hj+VCoPZ7AcBaBa2+ETIp3ATAIUw9BbH1+5vZramzaYo4XkLlGzfDCBCCcnzPmI9GqoaZT8KgELAPMf8R9LTZX3IzpAcYSdY9E8OuiZlsx8NwKTXBVVqABY0WEW62hRQBOuCGm0KWNBgFenq6hXwH/kYT1/4UtMbAAAAAElFTkSuQmCC" width="15" height="15"> (${n}/${i})`), $("#mission_select_alliance")
      .html(
        `<img class="icon icons8-Sell" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAADz0lEQVRoQ+2a7VEUQRCGuyPQDIQIJAM1AjECIQIxAjUCIQIhAy4CIQIhAiECMYK2nq2eq7m92Z3euzmPHztVV1fAbE+//fbX9KISXGb2VkR+iMhB8JHW2x5E5FRVb0qCNXqamf3eI4ik5oOqHm4LxBCgqmHwUSNF9pnZ6PlhpWqCIspss6d2fnMgZvbSY+k4qPi1+/7T2P59APkpIiSGKWuhqqPA9wGk82UROVRVMs3gMjMyIEmkGnv7AEJ6fDOFDhF5lowQI5ci8j4IZiEiJ6r6vGIkqPzkbf/dtSZrGHxgBtI3VM0iQcNuvK12fvOCuLGmlQdnILNr7ci3ZteaXWt2rXELzDFSiBG60xc78pyo2EdVLU5xplR2bn2056+ipzbe9+jt/nbjoMZKNRcXZqT5yY0FzkAaG3RrcVVGfE7F/ZtxzVFvbHonInxuVPVqE218pvzJ5SKfYP42NOMdOmMQiI9qvjgABgq1RXpmyMzArbrMDKW/j8zATvxssmUaaHweGlKsAXELASAfst166r1TVRjoloNlH4emEdClqp4OIXGGYeCr7/krIucico1sMxsbJzFx4Tk8BEMwN7tgfrYEYmYffVMqOBxA3TivDdocFGB47cAqgim8mrjgTKxcGLViPACmuvFnhOYPWgBA4UEAyozOmvqCzSwHgwIYYVFQ8t6LW8eumRF/GAEXwoDMuToXLTyLfvyNz5mzcwuQNOJkA9aBhY2Xg8EQeTuDQVKcXakqgEtKwgIgulFrASD6ITu5NjI7pgACqqdtAeTI3Yooy+d1wCqwsFRywM2WADMgsMgZi2r6DSgxusWVIiEQnCkD9cHB2DsP9r6brbCQMUnGAwRGONo5kDGUnoLxCBINMUXM8DNrxc0yFvJ3mYA4pubsFUimXIpTfrXiZr14oCwkoCsJowkQM/vllTlZlW/uDrX3I7gbbOTKYeGV5wppm8qf6lCHtRUQXCIS1GOetqacx9cgC7mwJkA8AFMwp36M79qNkpQPewT0ZBY2AuKBiWL3UwvllMw3hYVJQAqVn+cpmrjCaAxMAeCs9v+7Ys3dhmTWul8KTmoeyRLk+/z9YBNAm7JQZcTbDApO6n3OUuX3jpeMQbZJi5/pQif1Zs4CBZCzUrMaZiEChIaMVnnwRWUBECDog0KABtoQDLa8JkxxzaJr+SEHEaGeBACQXK4KyMzSfSQxvtaGTAHRrI5kgYqL5YCIIS5MtBt0s6n4kZpZMA4LWyeNZnWk1wvlgErGpX4AIHQtjrDTHEgGCKvTnfKdWIIZGFreKSJKRvb8A3bBPSGKFTO6AAAAAElFTkSuQmCC" width="15" height="15"> (${s}/${o})`), $("#mission_select_alliance_event")
      .html(
        `<img class="icon icons8-Event-Accepted" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAD4UlEQVRoQ+1Zi1EUQRB9HYESgRqBRwQSgkQgRCBEIEQgRqBEIEQgRCBE4BGBGMGz3tq9zs3tsXO7c7cFxVRR5bm7vf368/qzhidy7IngQBEQknsAvgJ4DWAO4NDMrsYYobbMUiC/HEToPjezNyOBVJVZCoRS2syMZPvvkUCqymyBZK7u1DEFMgZE+myBzKJQToHkrl7SteCla+MrlNkbyimQlSGThtO2Q6v0faVA7gG8SMx9Z2ZisMGHZJHM2kBEv98AvAJwB+CgEv32yqwKZLDZKzz4DKSCETciQuz2kOClZN+IFhWErg2k74EKOq0l4jlHnj2SBAzJl95kquiNOpOGFskjB3I2CgWAqYH8dCC7jxYIyRmABgiAXTO7GQNmMo+QVP/0wZU/N7ODxwrkN4Am2QHcm9nOowNCUtbXkuLWlX/riwp5adDZWGh5Dpwk84la/Pwc+n8IVH5i+/IHwElfDm0MiLRyMFIoHbZCYSkYQ5fCrOvonr0+EP6uomVH0YTYpYkXPYFR+KjwHZtZZwh5yH323FHYCURRsdyoR1JgGUspVE6z658UQkNZbGtA3P2q5LK4zk5Y270W4SWPrV3ptw3kPYDvYiszm5HUby30LkiqICr89vV7XeraNhBZ+iOAL76gaIAAkOJaVjTXzKzpwR46JFVMxYTqEPQXR/l3YWaXXc8PTvYsD9SSpC8VK+mkrHZjZit7L/eiwrNvzaTNo8J0wbujgZDUi7WljHOtdZH/kBXfJdfa/MkMIQDhLXlQHr4Kena6l5d0j1ZSOmdmdhxyagCJai4vaN+1YCm3tADJO/ocsUDRJCMspVMvIfiIEMTShmsNIFJMvZVAdNYGZy/dp96rbSIdpEhCp7hTzjrshkRqAJmVVGhpKgXSe0nG4rzXE/68DKZiKjYMym8W3KOBPMxBq68mDWbxHpnkD2e0UzM7IanEV84cTgkk5pZSb6gBVVgqF+XZeeKV8ymBBGX35kai8EKzmeTKzZRAlrpakurLLrM8ClZUnHax3j85EcWlrcDQnMify9+XMFjbSbvFlRdK8s4QbOUkQPIPL7V07pPThJZTtGpKzPuqRyqCAtE5+yehdZt/DI0PL30vr3l9wdLOZgIU7c21mXVNoaLzoOD/yV5TsxJZCf0ufeh0S0cHsHIIS+rQftF39hLFhtyT1IGl+O9buybeaOrQ1EBijqnXogyxaI1nslH5yMw006w8JDXbxKS53DTWUGqojAyM2g4pqiRv1q2eMxoHlNwxrywMapOGVgrc64gAxLyxyi6aV+S57sFqqDVrP+dsJrrVX4DSCkne0ajbOff/BWtayMaN4VNfAAAAAElFTkSuQmCC" width="15" height="15"> (${r}/${a})`), $("#mission_select_sicherheitswache")
      .html(
        `<img class="icon icons8-Clock-Filled" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAE8klEQVRoQ8Waj5EVNwzGpQoSKkioIFBBuAqSVBCoAKggUEG4CgIVBCoIV0GggkAFQAVifjvy4bdr+d/uTjxzM+/d83r1WZ8+y7JVDm5m9r2I/CQi90SEz/zxmfZORD77H5/fqyrfD2t6xEhmhsG/i8iDzPjeoQH2VkReqSqfd7VpQO6JX0TkmYj8uMuKbw9/8PHezHpuCpCZPfYXQ6czGjR8pqrXo4MPAXJq/TVBq1G7Un8o+GiEit2A3CsvZi3b+dyTXm91ATIzvPKw06g3rmYEOjP8WkR+9mdvfBxiLgkIcdjTXqrqo1bHKiAP/H86KPZeRPDe63Uwm9lLV0BsQckuJsbfwf/4Q+5rjQm6qglGC9C/DTAfRQQ64IVi87h74j++qMWDmQGKifmuguqdqt6Pfg8BddDsOS+fldfKBKCcLAUoadRC+hUBmRkz+mcw2hf3ClQ6rbm3iN2oPVXVjUhtADlFoFqpAebBiIyaGQKQxruvqiyeXc1tQVwiCjLeRXZRAlSLm80ALcvMDPr84f2eqyrfu1tjgjfxdAGoQTUWuGGa7QUE8gb9Lqh3C8jl8z/PjtczeK2qSam6Z9eN2eWh9DIzI15KQkGadDeJUw4IySwFIdJ8b1bNVoYMUy4DhPoRf6V4umVPDgjvlLLmKaplhhDUKVOY9nSDeh9U9S59FkCVwGMDljZnQ1QLAN2oKinPdDMzVK2UUSyClQBF/Cxq/Yg1ZpZ76AhA0Rq5eD8BiqT6zmzsnOghYulTYVIXCVdXt1IHdo2/jnij1NfM8tjc7SEPEXLHUpZ+B0Bwmox63aYVKR/IzCz7fhSgfCnIX3cFoIiTpOnwf1dbAapmyr0vMjOY83eh/1MARWhZrLrzroBupdh8q6pXvcYH47K8QOUtqyorMN4BEOoxXF6qTBRGTKmnLy/khQhDSf6v8VAuq6UJ2ewye2a3Me5ULHXYevN/ASL/IkaHPN8LKFpUKWhAueq2OfJWI3PnsWFQrsiIGJRL6VRuwkK5M0UhSlOSEc2ix4wonC3bjI/Mokw/lFb4ViVn/Uxl7Vxk+9SFNRnjGQkCVEosKX/91iM29KmwallYo9zokNRnlTXwLna9pbSlq5DogOLUxztEXN+dnAYxkBcf8y7N9anigGWrc/r2oaKCkRhVN5QV9bzYPrCJK5WuDsm9KqCibX9YXTKzaKvzbYPntGPNKanQri14K9CD8m8xk6hUfz6q6lI+6CmSXFRVWgbO/F4oKG62Lo2qVLFIUquq7Cpu9IB0UMQVNN8UIytJ9BdVvT1JPL3Q2AOm1Weq0JgtgLV0ZbgU3DK29XujFLypSo0W64cTypbBtd8dDOWB6HC6Xax3xasdp9DlVOVzGyJJT3PQd5ySUS9azVMXth2o0aE3QVzN2JXWaunhprN1JNlK/wHDkeSryuLJop0fp4SbOjPjNgoTVbv/UK3mtgAxcJQh5xgwEo8ycxce6zw0BggUa5WdOZzmwC1kRe+xfot+OTgy4XR/h5MLnl0f65ORpGP93mJmV22jC1CnUOwRtNazzSw8DdANyEFBCWa8dZ+gZWDv71Ds4UgxZQhQpoAoEOlJ7T5Br9GlfhxOc3lp+CrOFCD3FoIB/wFWytJnABFzjLe5kdI72DSg/AW+oqNSBPooHaEVSsoWfKhOVwJ5CKAVuHQls+eKJpn1oQvzV++Yjk+9aieJAAAAAElFTkSuQmCC" width="15" height="15"> (${c}/${l})`)
}

function missionSelection(e) {
    e.hasClass("btn-success") ? missionSelectionDeactive(e) : missionSelectionActive(e),
      missionSelectionSave()
}

function missionSelectionActive(e) {
    e.addClass("btn-success")
      .removeClass("btn-danger"), $(`#${e.attr("classShow")} > .missionSideBarEntry`)
      .removeClass("missionSideBarEntryScrollInvisible")
      .css("height", "auto"), $(`#${e.attr("classShow")}`)
      .show(), progressBarScrollUpdate()
}

function missionSelectionDeactive(e) {
    e.removeClass("btn-success")
      .addClass("btn-danger"), $(`#${e.attr("classShow")}`)
      .hide(), progressBarScrollUpdate()
}

function missionSelectionSave() {
    deactive_buttons = [], $(".mission_selection")
      .each(function () {
          $(this)
            .hasClass("btn-danger") && deactive_buttons.push($(this)
            .attr("id"))
      }), mc_storage.setToCookieStorage(STORAGE_KEY_DEACTIVE_MISSION_SELECTION, deactive_buttons)
}

function missionSelectionLoad() {
    deactive_selection = mc_storage.get(STORAGE_KEY_DEACTIVE_MISSION_SELECTION), deactive_selection && (
      "string" == typeof deactive_selection && (deactive_selection = deactive_selection.split(",")), $
        .each(deactive_selection, (e, t) => {
            missionSelectionDeactive($(`#${t}`))
        }))
}

function leitstelleSelectionOnly(e) {
    $(".leitstelle_selection")
      .each(function () {
          e.attr("id") == $(this)
            .attr("id") ? leitstelleSelectionActive($(this)) : leitstelleSelectionDeactive($(this))
      })
}

function leitstelleSelection(e) {
    e.hasClass("btn-success") ? leitstelleSelectionDeactive(e) : leitstelleSelectionActive(e)
}

function leitstelleSelectionActive(e) {
    leitstelle_building_id = e.attr("leitstelle"), e.addClass("btn-success")
      .removeClass("btn-danger"), $(`.building_list_li[leitstelle_building_id='${leitstelle_building_id}']`)
      .removeClass("hideLeitstelle")
}

function leitstelleSelectionDeactive(e) {
    leitstelle_building_id = e.attr("leitstelle"), e.removeClass("btn-success")
      .addClass("btn-danger"), $(`.building_list_li[leitstelle_building_id='${leitstelle_building_id}']`)
      .addClass("hideLeitstelle")
}

function buildingSelectionOnly(e, t) {
    const i = ["building_selection_wasserrettung", "building_selection_feuerwehr", "building_selection_rettung",
        "building_selection_polizei", "building_selection_schule", "building_selection_leitstelle",
        "building_selection_thw"];
    $.each(i, (t, i) => {
        e.attr("id") == i ? buildingSelectionActive($(`#${i}`)) : buildingSelectionDeactive($(`#${i}`))
    }), buildingSelectionSave(), buildingsVehicleLoadVisible(), t && t()
}

function buildingSelection(e, t) {
    e.hasClass("btn-success") ? buildingSelectionDeactive(e) : buildingSelectionActive(e),
      buildingSelectionSave(), buildingsVehicleLoadVisible(), t && t()
}

function buildingSelectionActive(button) {
    building_type_ids = eval(button.attr("building_type_ids")), button.addClass("btn-success")
      .removeClass("btn-danger"), $.each(building_type_ids, (e, t) => {
        $(`.building_list_li[building_type_id='${t}']`)
          .addClass("category_selected")
          .show()
    })
}

function buildingSelectionDeactive(button) {
    building_type_ids = eval(button.attr("building_type_ids")), "undefined" != typeof building_type_ids && (
      button.removeClass("btn-success")
        .addClass("btn-danger"), $.each(building_type_ids, (e, t) => {
          $(`.building_list_li[building_type_id='${t}']`)
            .removeClass("category_selected")
            .hide()
      }))
}

function buildingSelectionSave() {
    deactive_buttons = [], $(".building_selection")
      .each(function () {
          $(this)
            .hasClass("btn-danger") && deactive_buttons.push($(this)
            .attr("id"))
      }), mc_storage.setToCookieStorage(STORAGE_KEY_DEACTIVE_BUILDING_SELECTION, deactive_buttons)
}

function buildingSelectionLoad() {
    deactive_selection = mc_storage.get(STORAGE_KEY_DEACTIVE_BUILDING_SELECTION), deactive_selection && (
      "string" == typeof deactive_selection && (deactive_selection = deactive_selection.split(",")), $
        .each(deactive_selection, (e, t) => {
            buildingSelectionDeactive($(`#${t}`))
        })), buildingsVehicleLoadVisible()
}

function searchStations() {
    const e = $(".stations_search_field")
        .val()
        .toLowerCase();

    const t = $(".building_list_li.category_selected");
    t.each(function () {
        const t = $(this)
          .attr("search_attribute")
          .toLowerCase().includes(e);
        $(this)
          .toggle(t)
    })
}

function vehicle_group_available(vehicle_group_id, calculate_time) {
    let all_ok = !0;
    let max_time = -1;

    const vehicle_ids = eval($(`#vehicle_group_${vehicle_group_id}`)
      .attr("vehicles"));

    "undefined" == typeof calculate_time && (calculate_time = !1), "undefined" != typeof vehicle_ids && $
      .each(vehicle_ids, (e, t) => {
          if ($(`#vehicle_checkbox_${t[0]}`)
            .length <= 0 || $(`#vehicle_checkbox_${t[0]}`)
            .is(":disabled")) all_ok = !1;
          else {
              const i = $(`#vehicle_sort_${t[0]}`)
                .attr("timevalue");
              max_time = aao_maxtime(max_time, {
                  max_time: i
              })
          }
      }), max_time > 0 && all_ok ? $(`#vehicle_group_timer_${vehicle_group_id}`)
      .html(formatTime(max_time)) : $(`#vehicle_group_timer_${vehicle_group_id}`)
      .html("-"), all_ok ? ($(`#available_${vehicle_group_id}`)
      .attr("class", "label label-success"), $(`#available_${vehicle_group_id}`)
      .html("<span class='glyphicon glyphicon-ok' aria-hidden='true'></span>")) : ($(`#available_${vehicle_group_id}`)
      .html("<span class=' glyphicon glyphicon-remove' aria-hidden='true'></span>"), $(`#available_${vehicle_group_id}`)
      .attr("class", "label label-danger"))
}

function aao_maxtime(e, t) {
    if (!t) return e;
    if (-2 == e) return -2;
    if ("undefined" == typeof t.max_time) return -2;
    const i = parseInt(t.max_time);
    return i > e || -1 == e && i >= 0 ? i : e
}

function aao_available(e, t) {
    let i = !0;
    let n = -1;
    "undefined" == typeof t && (t = !1);
    const o = $(`#aao_${e}`);
    if (t || !$(`#available_aao_${e}`)
      .hasClass("label-success")) {
        $.each(aao_types, (e, t) => {
            const s = o.attr(t[0]);
            if (s > 0)
                if ("hlf_or_rw_and_lf" == t[0]) {
                    var a = aao_check("hlf_only", o, s);
                    var r = aao_check("rw_only", o, s);
                    var l = aao_check("lf_only", o, s);
                    if ((a || r) && l) {
                        if (a && r && l) {
                            var c = aao_maxtime(-1, a);
                            var u = aao_maxtime(-1, r);
                            var d = aao_maxtime(-1, l);
                            u >= c || d >= c ? n = aao_maxtime(n, a) : (n = aao_maxtime(n, r), n =
                              aao_maxtime(n, l))
                        }
                        if (!a && r && l) {
                            var u = aao_maxtime(-1, r);
                            var d = aao_maxtime(-1, l);
                            n = aao_maxtime(n, r), n = aao_maxtime(n, l)
                        }
                        if (a && (!r || !l)) {
                            var c = aao_maxtime(-1, a);
                            n = aao_maxtime(n, a)
                        }
                    } else i = !1
                } else if ("naw_or_rtw_and_nef" == t[0] || "naw_or_rtw_and_nef_or_rth" == t[0]) {
                    let h = "nef";
                    "naw_or_rtw_and_nef" == t[0] && (h = "nef_only");
                    var a = aao_check("naw", o, s);
                    var r = aao_check(h, o, s);
                    var l = aao_check("rtw", o, s);
                    if (a || r && l) {
                        if (a && r && l) {
                            var c = aao_maxtime(-1, a);
                            var u = aao_maxtime(-1, r);
                            var d = aao_maxtime(-1, l);
                            u >= c || d >= c ? n = aao_maxtime(n, a) : (n = aao_maxtime(n, r), n =
                              aao_maxtime(n, l))
                        }
                        if (!a && r && l) {
                            var u = aao_maxtime(-1, r);
                            var d = aao_maxtime(-1, l);
                            n = aao_maxtime(n, r), n = aao_maxtime(n, l)
                        }
                        if (a && (!r || !l)) {
                            var c = aao_maxtime(-1, a);
                            n = aao_maxtime(n, a)
                        }
                    } else i = !1
                } else {
                    const p = aao_check(t[0], o, s);
                    n = aao_maxtime(n, p), p || (i = !1)
                }
        });
        const s = o.attr("custom");
        if ("" != s) {
            const a = jQuery.parseJSON(s);
            $.each(a, (e, t) => {
                const s = aao_check(`custom_${md5(e)}`, o, t);
                n = aao_maxtime(n, s), s || (i = !1)
            })
        }
        const r = o.attr("vehicle_type_ids");
        if (void 0 !== r) {
            const l = jQuery.parseJSON(r);
            $.each(l, (e, t) => {
                const s = aao_check(`vehicle_type_id_${e}`, o, t);
                n = aao_maxtime(n, s), s || (i = !1)
            })
        }
        n > 0 && i ? $(`#aao_timer_${e}`)
          .html(formatTime(n)) : $(`#aao_timer_${e}`)
          .html("-"), i ? ($(`#available_aao_${e}`)
          .attr("class", "label label-success"), $(`#available_aao_${e}`)
          .html("<span class='glyphicon glyphicon-ok' aria-hidden='true'></span>")) : ($(
          `#available_aao_${e}`)
          .html("<span class=' glyphicon glyphicon-remove' aria-hidden='true'></span>"), $(
          `#available_aao_${e}`)
          .attr("class", "label label-danger"))
    }
}

function unix_timestamp() {
    return Date.now() / 1e3
}

function osrm_geometry_decode(e, t) {
    t = 10 ** -t;
    for (var i = e.length, n = 0, o = 0, s = 0, a = []; i > n;) {
        let r;
        let l = 0;
        let c = 0;
        do r = e.charCodeAt(n++) - 63, c |= (31 & r) << l, l += 5; while (r >= 32);
        const u = 1 & c ? ~(c >> 1) : c >> 1;
        o += u, l = 0, c = 0;
        do r = e.charCodeAt(n++) - 63, c |= (31 & r) << l, l += 5; while (r >= 32);
        const d = 1 & c ? ~(c >> 1) : c >> 1;
        s += d, a.push([o * t, s * t])
    }
    return a
}

function change_state(e) {
    "register" == current_state ? (params = e ? "slow" : {
        duration: 0
    }, $(".login-form .signup")
      .hide(params), $(".login-form .login")
      .show(params), $(".navbar .login-button")
      .hide(), $(".navbar .signup-button")
      .show(), current_state = "login") : ($(".login-form .login")
      .hide(params), $(".login-form .signup")
      .show(params), $(".navbar .signup-button")
      .hide(), $(".navbar .login-button")
      .show(), current_state = "register")
}

function bigMapWindowSizeChanged() {
    if ($("body")
      .hasClass("bigMap")) {
        let e = parseInt($("#missions_outer")
          .height());
        e = e - parseInt($(".missions-panel-head")
          .height()) - 15, $("#missions-panel-body")
          .css("height", `${e}px`), e = parseInt($("#buildings_outer")
          .height()), e = e - parseInt($("#building_panel_heading")
          .height()) - 15, $("#building_panel_body")
          .css("height", `${e}px`), e = parseInt($("#chat_outer")
          .height()), e = e - parseInt($("#chat_panel_heading")
          .height()) - 15, $("#chat_panel_body")
          .css("height", `${e}px`), e = parseInt($("#radio_outer")
          .height()), e = e - parseInt($("#radio_panel_heading")
          .height()) - 15, $("#radio_panel_body")
          .css("height", `${e}px`), bigMapWindowPositionSave()
    }
}

function bigMapWindowPositionSave() {
    const e = {};
    e.m = bigMapWindowPositionGet($("#missions_outer")), e.b = bigMapWindowPositionGet($("#buildings_outer")),
      e.c = bigMapWindowPositionGet($("#chat_outer")), e.r = bigMapWindowPositionGet($("#radio_outer")),
      mc_storage.setToCookieStorage(STORAGE_KEY_BIG_MAP_WINDOW_POSITIONS, e)
}

function bigMapWindowPositionRestore() {
    const e = mc_storage.get(STORAGE_KEY_BIG_MAP_WINDOW_POSITIONS);
    "undefined" != typeof e && (bigMapWindowPositionRestoreWindow($("#missions_outer"), e.m),
      bigMapWindowPositionRestoreWindow($("#buildings_outer"), e.b), bigMapWindowPositionRestoreWindow(
      $("#chat_outer"), e.c), bigMapWindowPositionRestoreWindow($("#radio_outer"), e.r)),
      bigMapWindowSizeChanged(), buildingsVehicleLoadVisible()
}

function bigMapWindowPositionRestoreWindow(e, t) {
    "number" == typeof t[0] && t[0] > 100 && e.css("width", `${t[0]}px`), "number" == typeof t[1] && t[1] >
    20 && e.css("height", `${t[1]}px`), "number" == typeof t[2] && t[2] < window.innerWidth && t[2] >=
    0 && e.css("left", `${t[2]}px`), "number" == typeof t[3] && (t[3] < window.innerHeight && t[3] > $(
      "#col_navbar_holder")
      .height() - 5 ? e.css("top", `${t[3]}px`) : e.css("top", `${$("#col_navbar_holder")
  .height()}px`)), "boolean" == typeof t[4] && t[4] && e.addClass("fadeIn animated")
}

function bigMapWindowPositionGet(e) {
    return [parseInt(e.css("width")), parseInt(e.css("height")), parseInt(e.css("left")), parseInt(e.css(
      "top")), e.hasClass("fadeIn")]
}

function bigMapMenuOpenClose(e) {
    e.hasClass("fadeIn") ? bigMapMenuClose(e) : bigMapMenuOpen(e)
}

function bigMapMenuOpen(e) {
    $("body")
      .hasClass("bigMap") && (e.addClass("animated fadeIn")
      .removeClass("fadeOut"), bigMapWindowInfront(e), bigMapWindowSizeChanged()),
      buildingsVehicleLoadVisible()
}

function bigMapMenuClose(e) {
    $("body")
      .hasClass("bigMap") && (e.addClass("animated fadeOut")
      .removeClass("fadeIn"), bigMapWindowSizeChanged())
}

function bigMapWindowInfront(e) {
    const t = 2e3;
    let i = t;
    const n = 2050;
    $(".bigMapWindow")
      .each(function () {
          const e = parseInt($(this)
            .css("zIndex"));
          e > i && (i = e)
      }), i > n && ($(".bigMapWindow")
      .css("zIndex", t), i = t + 1), e.css("zIndex") != i && e.css("zIndex", i + 1)
}

function padding(e) {
    return (`0${e.toString()}`)
      .substr(-2);
}

function toggleVehicleBuilding(e) {
    let t = 0;
    $(`#vehicle_building_${e}`)
      .is(":visible") ? ($(`#building_list_caption_${e}`)
      .append(hideVehicleBuildingHelpText(e)), $(`#vehicle_building_${e}`)
      .hide()) : ($(`#hidden_vehicle_list_caption_${e}`)
      .remove(), $(`#vehicle_building_${e}`)
      .show(), t = 1), buildingsVehicleLoadVisible(), $.ajax({
        type: "POST",
        url: `/buildings/${e}/showVehiclesAtStartpage`,
        data: {
            show: t
        }
    })
}

function hideVehicleBuildingHelpText(e) {
    return `<span class="hidden_vehicle_list_caption" building_id="${e}" id="hidden_vehicle_list_caption_${e}"><br /><small>${I18n.t(
    "javascript.vehicles_not_visible")}</small></span>`;
}

function setClientId(e) {
    mc_storage.setToCookieStorage(STORAGE_KEY_MOBILE_CLIENT_ID, e), $("#mobile-client-id")
      .html(e)
}

function allianceChannelUpdate(e) {
    const t = JSON.parse(e);
    void 0 !== t.old_channel && null !== t.old_channel && subscriptions.forEach(e => {
        e._channels.includes(t.old_channel) && e.unsubscribe()
    }), faye_subscribe(t)
}

function faye_subscribe(channel_update) {
    faye.addExtension({
        outgoing(e, t) {
            return "/meta/subscribe" !== e.channel ? t(e) : (e.ext = e.ext || {}, e.ext[
              channel_update.new_channel] = channel_update.auth_token, t(e), void 0)
        }
    }), subscriptions.push(faye.subscribe(channel_update.new_channel, data => {
        eval(data)
    }))
}

function openExternalTelegramURL(e) {
    mobileBridgeAdd("openExternalURL", {
        url: e
    })
}

function setupTimer(e) {
    if (e.$timer.length) {
        const t = new Date(e.$timer.data("end-time"));
        if (isDateValid(t) && !(Date.now() >= t)) {
            updateTimer({
                $timer: e.$timer,
                endTime: t,
                format: e.format
            });
            const i = setInterval(() => {
                const n = Date.now() <= t;
                n ? updateTimer({
                    $timer: e.$timer,
                    endTime: t,
                    format: e.format
                }) : (clearInterval(i), e.onTimerEnd())
            }, 1e3);
        }
    }
}

function updateTimer({endTime, format, $timer}) {
    const t = endTime - Date.now();
    const i = "long" == format ? formatTime(Math.round(t / 1e3)) : getFormattedDuration(t);
    $timer.text(i)
}

function isDateValid(e) {
    return e instanceof Date && !isNaN(e)
}

function flavouredAsset(e, t) {
    function i(e, t) {
        const i = flavourAssetOverrides[gameFlavour] || [];
        return t ? i.find(({from, scope}) => from === e && scope === t) : i.find(({from, scope}) => from === e && !scope);
    }
    const n = i(e, t);
    return n ? n.to : e
}

function updateDailyBonusIcon() {
    $("#daily-bonus")
      .find(".bonus-active")
      .removeClass("bonus-active")
}

function switchWorld(e) {
    const t = e;
    const i = {};
    return ["utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content"].forEach(e => {
        const t = mc_storage.get(e);
        t && (i[e] = t)
    }), window.location.href = `${t}?${$.param(i)}`, !1;
}

function updateButtonState(e, t) {
    function i(e, t) {
        e.toggleClass("disabled button-loading", !t)
          .attr("disabled", !t)
    }

    function n(e) {
        e.removeClass("button-loading")
          .addClass("disabled")
          .attr("disabled", !0)
    }
    t === BUTTON_STATES.loading ? i(e, !1) : t === BUTTON_STATES.enabled ? i(e, !0) : t == BUTTON_STATES
      .disabled && n(e)
}

function missionPositionMarkerAdd(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("poi", [e])
}

function missionPositionMarkerDelete(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("poi_delete", {
        poi_id: e
    })
}

function deleteMissionPosition(e) {
    $.ajax({
        url: `/mission_positions/${e}`,
        type: "POST",
        data: {
            _method: "delete"
        },
        cache: !1,
        success() {
            missionPositionMarkerDelete(e)
        }
    })
}

function initMapFiltersCollection(e) {
    mobile_map_filters_collection = e
}

function getMapFilterOptions() {
    return map_filter_options = {}, $.ajax({
        type: "GET",
        url: "/map_filters",
        cache: !1,
        success(e) {
            $.each(e, (e, {section_lable, filters}) => {
                map_filters_section_lable = section_lable, map_filter_options[
                  map_filters_section_lable] = filters
            }), mobileBridgeAdd("map_filter_options", map_filter_options)
        }
    }), map_filter_options;
}

function updateMapFilterOptions(e) {
    map_filters = Object.values(e)
      .reduce((e, t) => e.concat(t), []), $.ajax({
        type: "PUT",
        url: "/map_filters/update_collection",
        data: {
            map_filters
        },
        cache: !1,
        success({cleared_map_filters, buildings, missions, pois}) {
            1 == mobile_bridge_use && (clearMap(cleared_map_filters),
              alliance_member_buildings_show = map_filters.find(({filter_id}) => "alliance_members" == filter_id)
                .checked, buildings.length > 0 && $.each(buildings, (e, t) => {
                mobileBridgeAdd("building_add", t)
            }), missions.length > 0 && $.each(missions, (e, t) => {
                mobileBridgeAdd("mission", t)
            }), pois.length > 0 && $.each(pois, (e, t) => {
                missionPositionMarkerAdd(t)
            }))
        }
    })
}

function clearMap(e) {
    1 == mobile_bridge_use && mobileBridgeAdd("clear_map", {
        cleared_filters: e
    })
}

function currentMarkerTypeFilterTurnedOn(e) {
    const t = mobile_map_filters_collection.find(({filter_id}) => filter_id === e);
    const i = void 0 != t ? t.checked : "undefined";
    return "undefined" !== i ? i : !0
}
Object.values || (Object.values = e => Object.keys(e)
  .map(t => e[t])), Array.prototype.includes || (Array.prototype.includes = function (e) {
    return !!~this.indexOf(e)
}), Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
    value(e) {
        if (null == this) throw TypeError('"this" is null or not defined');
        const t = Object(this);
        const i = t.length >>> 0;
        if ("function" != typeof e) throw TypeError("predicate must be a function");
        for (let n = arguments[1], o = 0; i > o;) {
            const s = t[o];
            if (e.call(n, s, o, t)) return s;
            o++
        }
        return void 0
    },
    configurable: !0,
    writable: !0
}), function (e) {
    "undefined" != typeof module && module.exports ? module.exports = e(this) : "function" ==
    typeof define && define.amd ? define("i18n", (t => () => e(t))(this)) : this.I18n = e(this)
}(e => {
    const t = e && e.I18n || {};
    const i = Array.prototype.slice;

    const n = e => (`0${e.toString()}`)
      .substr(-2);

    const o = {
        day_names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        abbr_day_names: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        month_names: [null, "January", "February", "March", "April", "May", "June", "July",
            "August", "September", "October", "November", "December"],
        abbr_month_names: [null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
            "Oct", "Nov", "Dec"],
        meridian: ["AM", "PM"]
    };

    const s = {
        precision: 3,
        separator: ".",
        delimiter: ",",
        strip_insignificant_zeros: !1
    };

    const a = {
        unit: "$",
        precision: 2,
        format: "%u%n",
        sign_first: !0,
        delimiter: ",",
        separator: "."
    };

    const r = {
        unit: "%",
        precision: 3,
        format: "%n%u",
        separator: ".",
        delimiter: ""
    };

    const l = [null, "kb", "mb", "gb", "tb"];

    const c = {
        defaultLocale: "en_US",
        locale: "en_US",
        defaultSeparator: ".",
        placeholder: /(?:\{\{|%\{)(.*?)(?:\}\}?)/gm,
        fallbacks: !1,
        translations: {},
        missingBehaviour: "message",
        missingTranslationPrefix: ""
    };

    return t.reset = function () {
        this.defaultLocale = c.defaultLocale, this.locale = c.locale, this.defaultSeparator = c
          .defaultSeparator, this.placeholder = c.placeholder, this.fallbacks = c.fallbacks,
          this.translations = c.translations, this.missingBehaviour = c.missingBehaviour, this
          .missingTranslationPrefix = c.missingTranslationPrefix
    }, t.initializeOptions = function () {
        "undefined" == typeof this.defaultLocale && null !== this.defaultLocale && (this
          .defaultLocale = c.defaultLocale), "undefined" == typeof this.locale && null !==
        this.locale && (this.locale = c.locale), "undefined" == typeof this
          .defaultSeparator && null !== this.defaultSeparator && (this.defaultSeparator = c
          .defaultSeparator), "undefined" == typeof this.placeholder && null !== this
          .placeholder && (this.placeholder = c.placeholder), "undefined" == typeof this
          .fallbacks && null !== this.fallbacks && (this.fallbacks = c.fallbacks),
        "undefined" == typeof this.translations && null !== this.translations && (this
          .translations = c.translations)
    }, t.initializeOptions(), t.locales = {}, t.locales.get = function (e) {
        let i = this[e] || this[t.locale] || this["default"];
        return "function" == typeof i && (i = i(e)), i instanceof Array == !1 && (i = [i]), i
    }, t.locales["default"] = e => {
        let i;
        const n = [];
        const o = [];
        return e && n.push(e), !e && t.locale && n.push(t.locale), t.fallbacks && t
          .defaultLocale && n.push(t.defaultLocale), n.forEach(e => {
            i = e.split("-")[0], ~o.indexOf(e) || o.push(e), t.fallbacks && i && i !==
            e && !~o.indexOf(i) && o.push(i)
        }), n.length || n.push("en_US"), o;
    }, t.pluralization = {}, t.pluralization.get = function (e) {
        return this[e] || this[t.locale] || this["default"]
    }, t.pluralization["default"] = e => {
        switch (e) {
            case 0:
                return ["zero", "other"];
            case 1:
                return ["one"];
            default:
                return ["other"]
        }
    }, t.currentLocale = function () {
        return this.locale || this.defaultLocale
    }, t.isSet = e => void 0 !== e && null !== e, t.lookup = function (e, t) {
        t = this.prepareOptions(t);
        let i;
        let n;
        let o;

        const s = this.locales.get(t.locale)
          .slice();

        for (s[0], e = this.getFullScope(e, t); s.length;)
            if (i = s.shift(), n = e.split(this.defaultSeparator), o = this.translations[i]) {
                for (; n.length && (o = o[n.shift()], void 0 !== o && null !== o););
                if (void 0 !== o && null !== o) return o
            }return this.isSet(t.defaultValue) ? t.defaultValue : void 0
    }, t.meridian = function () {
        const e = this.lookup("time");
        const t = this.lookup("date");
        return e && e.am && e.pm ? [e.am, e.pm] : t && t.meridian ? t.meridian : o.meridian
    }, t.prepareOptions = function(...args) {
        for (var e, t = i.call(args), n = {}; t.length;)
            if (e = t.shift(), "object" == typeof e)
                for (const o in e) e.hasOwnProperty(o) && (this.isSet(n[o]) || (n[o] = e[o]));
        return n
    }, t.createTranslationOptions = function(e, {defaults, defaultValue}) {
        let i = [{
            scope: e
        }];
        return this.isSet(defaults) && (i = i.concat(defaults)), this.isSet(defaultValue) &&
        (i.push({
            message: defaultValue
        }), delete defaultValue), i;
    }, t.translate = function (e, t) {
        t = this.prepareOptions(t);
        let i;
        const n = this.createTranslationOptions(e, t);

        const o = n.some(function (e) {
            return this.isSet(e.scope) ? i = this.lookup(e.scope, t) : this.isSet(e
              .message) && (i = e.message), void 0 !== i && null !== i ? !0 : void 0
        }, this);

        return o ? ("string" == typeof i ? i = this.interpolate(i, t) : i instanceof Object &&
          this.isSet(t.count) && (i = this.pluralize(t.count, i, t)), i) : this
          .missingTranslation(e, t)
    }, t.interpolate = function (e, t) {
        t = this.prepareOptions(t);
        let i;
        var n;
        let o;
        let s;
        const a = e.match(this.placeholder);
        if (!a) return e;
        for (var n; a.length;) i = a.shift(), o = i.replace(this.placeholder, "$1"), n = this
          .isSet(t[o]) ? t[o].toString()
          .replace(/\$/gm, "_#$#_") : o in t ? this.nullPlaceholder(i, e) : this
          .missingPlaceholder(i, e), s = new RegExp(i.replace(/\{/gm, "\\{")
          .replace(/\}/gm, "\\}")), e = e.replace(s, n);
        return e.replace(/_#\$#_/g, "$")
    }, t.pluralize = function (e, t, i) {
        i = this.prepareOptions(i);
        let n;
        let o;
        let s;
        let a;
        let r;
        if (n = t instanceof Object ? t : this.lookup(t, i), !n) return this.missingTranslation(t,
          i);
        for (o = this.pluralization.get(i.locale), s = o(e); s.length;)
            if (a = s.shift(), this.isSet(n[a])) {
                r = n[a];
                break
            }return i.count = String(e), this.interpolate(r, i)
    }, t.missingTranslation = function (e, t) {
        if ("guess" == this.missingBehaviour) {
            const i = e.split(".")
              .slice(-1)[0];
            return (this.missingTranslationPrefix.length > 0 ? this.missingTranslationPrefix :
              "") + i.replace("_", " ")
              .replace(/([a-z])([A-Z])/g, (e, t, i) => `${t} ${i.toLowerCase()}`);
        }
        const n = this.getFullScope(e, t);
        const o = [this.currentLocale(), n].join(this.defaultSeparator);
        return `[missing "${o}" translation]`;
    }, t.missingPlaceholder = e => `[missing ${e} value]`, t.nullPlaceholder = function(...args) {
        return t.missingPlaceholder(...args);
    }, t.toNumber = function (e, t) {
        t = this.prepareOptions(t, this.lookup("number.format"), s);
        let i;
        let n;
        const o = 0 > e;

        const a = Math.abs(e)
          .toFixed(t.precision)
          .toString();

        const r = a.split(".");
        const l = [];
        let c = t.format || "%n";
        const u = o ? "-" : "";
        for (e = r[0], i = r[1]; e.length > 0;) l.unshift(e.substr(Math.max(0, e.length - 3), 3)),
          e = e.substr(0, e.length - 3);
        return n = l.join(t.delimiter), t.strip_insignificant_zeros && i && (i = i.replace(/0+$/,
          "")), t.precision > 0 && i && (n += t.separator + i), c = t.sign_first ? `%s${c}` : c.replace("%n", "%s%n"), n = c.replace("%u", t.unit)
          .replace("%n", n)
          .replace("%s", u);
    }, t.toCurrency = function (e, t) {
        return t = this.prepareOptions(t, this.lookup("number.currency.format"), this.lookup(
          "number.format"), a), this.toNumber(e, t)
    }, t.localize = function (e, t, i) {
        switch (i || (i = {}), e) {
            case "currency":
                return this.toCurrency(t);
            case "number":
                return e = this.lookup("number.format"), this.toNumber(t, e);
            case "percentage":
                return this.toPercentage(t);
            default:
                let n;
                return n = e.match(/^(date|time)/) ? this.toTime(e, t) : t.toString(), this
                  .interpolate(n, i)
        }
    }, t.parseDate = e => {
        let t;
        let i;
        let n;
        if ("object" == typeof e) return e;
        if (t = e.toString()
          .match(
            /(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}):(\d{2}):(\d{2})([\.,]\d{1,3})?)?(Z|\+00:?00)?/
          )) {
            for (let o = 1; 6 >= o; o++) t[o] = parseInt(t[o], 10) || 0;
            t[2] -= 1, n = t[7] ? 1e3 * (`0${t[7]}`) : null, i = t[8] ? new Date(Date.UTC(t[1], t[
              2], t[3], t[4], t[5], t[6], n)) : new Date(t[1], t[2], t[3], t[4], t[5], t[6],
              n)
        } else "number" == typeof e ? (i = new Date, i.setTime(e)) : e.match(
          /([A-Z][a-z]{2}) ([A-Z][a-z]{2}) (\d+) (\d+:\d+:\d+) ([+-]\d+) (\d+)/) ? (i =
          new Date, i.setTime(Date.parse([RegExp.$1, RegExp.$2, RegExp.$3, RegExp.$6, RegExp
          .$4, RegExp.$5].join(" ")))) : e.match(/\d+ \d+:\d+:\d+ [+-]\d+ \d+/) ? (i =
          new Date, i.setTime(Date.parse(e))) : (i = new Date, i.setTime(Date.parse(e)));
        return i
    }, t.strftime = function (e, i) {
        let s = this.lookup("date");
        const a = t.meridian();
        s || (s = {}), s = this.prepareOptions(s, o);
        const r = e.getDay();
        const l = e.getDate();
        const c = e.getFullYear();
        const u = e.getMonth() + 1;
        const d = e.getHours();
        let h = d;
        const p = d > 11 ? 1 : 0;
        const m = e.getSeconds();
        const f = e.getMinutes();
        const _ = e.getTimezoneOffset();
        const g = Math.floor(Math.abs(_ / 60));
        const v = Math.abs(_) - 60 * g;

        const b = (_ > 0 ? "-" : "+") + (g.toString()
          .length < 2 ? `0${g}` : g) + (v.toString()
          .length < 2 ? `0${v}` : v);

        return h > 12 ? h -= 12 : 0 === h && (h = 12), i = i.replace("%a", s.abbr_day_names[r]),
          i = i.replace("%A", s.day_names[r]), i = i.replace("%b", s.abbr_month_names[u]), i = i
          .replace("%B", s.month_names[u]), i = i.replace("%d", n(l)), i = i.replace("%e", l),
          i = i.replace("%-d", l), i = i.replace("%H", n(d)), i = i.replace("%-H", d), i = i
          .replace("%I", n(h)), i = i.replace("%-I", h), i = i.replace("%m", n(u)), i = i
          .replace("%-m", u), i = i.replace("%M", n(f)), i = i.replace("%-M", f), i = i.replace(
          "%p", a[p]), i = i.replace("%S", n(m)), i = i.replace("%-S", m), i = i.replace(
          "%w", r), i = i.replace("%y", n(c)), i = i.replace("%-y", n(c)
          .replace(/^0+/, "")), i = i.replace("%Y", c), i = i.replace("%z", b)
    }, t.toTime = function (e, t) {
        const i = this.parseDate(t);
        const n = this.lookup(e);
        return i.toString()
          .match(/invalid/i) ? i.toString() : n ? this.strftime(i, n) : i.toString()
    }, t.toPercentage = function (e, t) {
        return t = this.prepareOptions(t, this.lookup("number.percentage.format"), this.lookup(
          "number.format"), r), this.toNumber(e, t)
    }, t.toHumanSize = function (e, t) {
        for (var i, n, o = 1024, s = e, a = 0; s >= o && 4 > a;) s /= o, a += 1;
        return 0 === a ? (i = this.t("number.human.storage_units.units.byte", {
            count: s
        }), n = 0) : (i = this.t(`number.human.storage_units.units.${l[a]}`), n = 0 === s -
        Math.floor(s) ? 0 : 1), t = this.prepareOptions(t, {
            unit: i,
            precision: n,
            format: "%n%u",
            delimiter: ""
        }), this.toNumber(s, t);
    }, t.getFullScope = function (e, t) {
        return t = this.prepareOptions(t), e.constructor === Array && (e = e.join(this
          .defaultSeparator)), t.scope && (e = [t.scope, e].join(this.defaultSeparator)), e
    }, t.t = t.translate, t.l = t.localize, t.p = t.pluralize, t;
}), I18n.translations || (I18n.translations = {}), I18n.translations.de_DE = {
    common: {
        add: "Hinzufügen",
        back: "Zurück",
        cancel: "Abbrechen",
        change_saved: "Änderung gespeichert",
        coins_spend: "Möchtest Du wirklich Coins dafür ausgeben?",
        congratulations: "Glückwunsch!",
        content: "Inhalt",
        copy: "Kopieren",
        credits: "Credits",
        "delete": "Löschen",
        details: "Details",
        edit: "Bearbeiten",
        error: "Fehler",
        is_offline: "%{user} ist offline.",
        is_offline_long: "%{user} ist bereits länger offline.",
        is_offline_with_duration: "%{user} ist offline: %{duration}",
        is_online: "%{user} ist online.",
        loading: "Lade...",
        name: "Name",
        none: "Keine",
        of: "von",
        off: "Aus",
        on: "An",
        save: "Speichern",
        search: "Suchen",
        show: "Anzeigen",
        user_not_found: "User nicht gefunden",
        wrong_key: "Key falsch"
    },
    javascript: {
        alarm: "Alarm",
        arrival: "Ankunft",
        backalarm: "Rückalarmieren",
        coins: "Coins",
        credits: "Credits",
        days: "Tage",
        few_seconds: "In wenigen Sekunden",
        finish_in: "Ende in:",
        hours: "Std.",
        location_not_found: "Ort nicht gefunden.",
        messages: "Nachrichten",
        minutes: "Min.",
        missed_vehicle: "Es fehlen:",
        mission_start_in: "Beginn in:",
        "new": "Neu",
        not_found_map: "Das Fahrzeug wurde auf der Karte nicht gefunden",
        now: "Sofort",
        patient: "Patienten",
        patient_untouched: "unbehandelte Patienten",
        poi_delete: 'Wirklich den POI: "%{caption}" löschen?',
        reload: "Neuladen",
        sale: "Sale",
        sale_ended: "Sonderangebote beendet",
        secounds: "Sek.",
        sicherheitswache_error: 'Die Sicherheitswache "%{caption}" wurde nicht erfolgreich durchgeführt, weil nicht alle Voraussetzung erfüllt waren.',
        sicherheitswache_success: 'Die Sicherheitswache "%{caption}" wurde erfolgreich durchgeführt. Du erhältst %{credits} Credits.',
        start_in: "Ausrücken in: ",
        start_username: "Gestartet von:",
        time_left: "Verbleibende Zeit:",
        to_building: "Zum Gebäude",
        to_mission: "Zum Einsatz",
        understand: "Verstanden",
        user_not_found: "Der Spieler wurde nicht gefunden. ",
        vehicles_not_visible: "Fahrzeuge ausgeblendet.",
        water_approaching: "Anfahrt: %{amount} l.",
        water_missing: "Fehlen: %{amount} l.",
        water_on_site: "Einsatzstelle: %{amount} l.",
        water_selected: "Ausgewählt: %{amount} l."
    },
    map: {
        alliance: "Verband",
        alliance_chat: "Chat",
        alliance_chat_banned: "Du bist im Verbandschat gebannt.",
        alliance_chat_banned_admin: "Gebannt von:",
        alliance_chat_banned_timeleft: "Restzeit:",
        alliance_chat_radio_off: "Verbandsfunk: Aus",
        alliance_chat_radio_on: "Verbandsfunk: An",
        alliance_event: "Event",
        alliance_missions: "Verbandseinsätze",
        alliance_missions_event: "Event",
        ambulance: "Krankentransporte",
        attended: "Beantwortet",
        cancel_alliance_event: "Verbands-Event abbrechen",
        cancel_alliance_event_confirm: "Möchtest du das Verbands-Event wirklich abbrechen?",
        challenges: "",
        chat_history: "Chatverlauf",
        congratulations: "Herzlichen Glückwunsch! Du kannst jetzt befördert werden.",
        create_alliance_event: "Verbands-Event starten",
        create_alliance_operation: "Verbands-Großeinsatz erstellen",
        emergency: "Notfälle",
        finishing: "Wird beendet",
        join_alliance_infos: "Wenn du in einem Verband bist, können andere Spieler dir Einsätze freigeben.",
        map: "Karte",
        map_filters: {
            all_buildings: "Gebäude",
            all_missions: "Einsätze",
            alliance_buildings: "Verbandsgebäude",
            alliance_members: "Gebäude von Verbandsmitgliedern",
            alliance_missions: "Vom Verband geteilt",
            ambulance_station_missions: "Rettungswache",
            ambulance_station_small_missions: "Rettungswache (Kleinwache)",
            building_complex: "Gebäudekomplex",
            buildings_section: "Wachen",
            clinic_missions: "Klinik",
            dispatch_center_missions: "Leitstelle",
            factory_fire_brigade_missions: "Werkfeuerwehr",
            fire_school_missions: "Feuerwehrschule",
            firehouse_missions: "Feuerwache",
            firehouse_small_missions: "Feuerwache (Kleinwache)",
            hospital_missions: "Notaufnahme",
            map_filters: "Points of Interest (POIs)",
            mission_positions: "Points of Interest (POIs)",
            mission_positions_section: "POIs",
            missions_section: "Einsätze",
            police_copter_station_missions: "Polizeihubschrauberstation",
            police_school_missions: "Polizeischule",
            police_small_missions: "Polizeiwache (Kleinwache)",
            police_special_forces: "Polizei-Sondereinheiten",
            police_station_missions: "Polizeiwache",
            prison_missions: "Polizeizellen (Nur für den Verband)",
            rapid_deployment_group: "Schnelleinsatzgruppe (SEG)",
            rapid_deployment_group_missions: "Schnelleinsatzgruppe (SEG)",
            rescue_copter_station_missions: "Rettungshubschrauber-Station",
            riot_police: "Bereitschaftspolizei",
            riot_police_missions: "Bereitschaftspolizei",
            staging_area_missions: "Bereitstellungsraum",
            technical_aid_organization: "THW",
            technical_aid_organization_missions: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Meine Gebäude",
            user_missions: "Meine Einsätze",
            water_watch: "Wasserrettung",
            water_watch_missions: "Wasserrettung"
        },
        message: "Nachricht",
        mission: "Einsätze",
        missions_filtered_out: "Einige Einsätze könnten herausgefiltert worden sein. Bitte überprüfe deinen Kartenfilter.",
        no_alliance_chat_impossible: "Du bist in keinem Verband. Der Chat ist nur innerhalb eines Verbandes möglich.",
        no_alliance_missions: "Es liegen keine Verbandseinsätze vor. ",
        no_ambulance_missions: "Es liegen keine Krankentransporte vor. Krankentransporte können auftreten, sobald Du einen KTW und ein Krankenhaus besitzt.",
        no_emergency_missions: "Es liegen keine Notfalleinsätze vor. Notfalleinsätze können ab der ersten Wache auftreten.",
        no_radio_messages: "Es sind keine Funksprüche eingegangen.",
        radio_messages: "Funk",
        restore_map: "Karte wiederherstellen",
        show_informations: "Grün = Die Einsätze werden in der Leiste angezeigt. Rot = Die Einsätze werden nicht angezeigt.",
        sicherheitswache: "Geplante Einsätze",
        transport: "Transporte",
        unattended: "Unbeantwortet"
    },
    fms: {
        going: "Auf Anfahrt",
        not_ready: "Nicht einsatzbereit",
        on_destination: "Am Transportziel",
        on_place: "Beim Einsatzort",
        patient_transported: "Patient aufgenommen",
        prisoner_transported: "Gefangenen aufgenommen",
        ready_home: "Einsatzbereit auf Wache",
        ready_traveling: "Einsatzbereit über Funk",
        talking_wish: "Sprechwunsch",
        waiting_for_vehicle: "Warte auf Zugfahrzeug"
    },
    intervention_order: {
        back: "Zurück",
        category: "Kategorie",
        colour: "Farbe",
        column: "Spalte",
        column_number: "Spaltennummer",
        column_number_hint: "Wenn eine Spaltennummer vergeben wird, dann wird der AAO-Eintrag in der entsprechenden Spalte bei der Alarmierung angezeigt.",
        create_intervention_order: "Neue Alarm und Ausrückeordnung anlegen",
        "delete": "Löschen",
        delete_all: "AAO komplett löschen",
        delete_all_confirm: "Wirklich die komplette AAO löschen? Auch bestehende exportierte Einträge, sind anschließend nicht mehr verfügbar!",
        description: "Bezeichnung",
        edit: "Bearbeiten",
        "export": {
            "export": "Exportieren",
            "import": "Importieren",
            import_done: "Die gewählten Einträge wurden importiert und in deine AAO geschrieben.",
            saved: "AAO-Exportiert",
            saved_text: "Deine AAO wurde für den Export vorbereitet. Über den Link kann ein anderer Spieler die AAO bei sich importieren. Solltest du deine AAO in der Zwischenzeit verändern, so wird diese Änderung auch im Export automatisch übernommen. "
        },
        hotkey_hint: "Wähle einen Tastencode für diese Auswahl an Fahrzeugen. Im Alarmierungsfenster kannst du dann mit ALT + Taste deiner Wahl (bzw. im Firefox: ALT + SHIFT + Taste deiner Wahl - bzw. unter Mac OS: CTRL + ALT + Taste deiner Wahl) direkt diese Fahrzeugauswahl aufrufen. ",
        intervention_order: "Alarm und Ausrückeordnung bearbeiten",
        name: "Name",
        no_intervention_created: "Du hast noch keine Alarm und Ausrückeordnung angelegt.",
        options: "Optionen",
        reset: "Bisherige Auswahl im Alarmierungsfenster zurücksetzen",
        reset_hint: "Wenn man sich bei der Fahrzeugauswahl im Alarmierenfenster verklickt hat, kann man mithilfe dieses Buttons seine bisherige Auswahl wieder zurücksetzen. ",
        save: "Speichern",
        station: "Wache",
        station_hint: "Wenn ein Gebäude gewählt wurde, werden nur Fahrzeuge des entsprechenden Gebäudes ausgewählt.",
        successfully_created: "Alarm und Ausrückeordnung erfolgreich angelegt.",
        successfully_deleted: "Alarm und Ausrückeordnung gelöscht",
        successfully_updated: "Alarm und Ausrückeordnung erfolgreich gespeichert.",
        vehicles: {
            ab_atemschutz_only: "AB-Atemschutz",
            ab_einsatzleitung_only: "AB-Einsatzleitung",
            ab_gefahrgut_only: "AB-Gefahrgut",
            ab_oel_only: "AB-Öl",
            ab_ruest: "AB Rüst",
            ab_ruest_rw: "AB Rüst oder Rüstwagen oder HLF",
            abl2wasser_only: "AB-Schlauch",
            ambulance: "Rettungswagen",
            ambulance_or_rapid_responder: "",
            arff: "Flugfeldlöschfahrzeug",
            battalion_chief_unit: "Einsatzleitfahrzeuge 1",
            boot: "Boote (Allgemein)",
            dekon_p: "Dekon-P oder AB-Dekon-P",
            division_chief_unit: "Einsatzleitfahrzeuge 2",
            dlk_or_tm50: "DLK oder TM 50",
            elw1_or_elw2: "ELW 1, ELW 2 oder AB-Einsatzleitung",
            elw2_or_ab_elw: "ELW 2 oder AB-Einsatzleitung",
            elw3: "ELW 3",
            elw_airport: "",
            emergency_ambulance: "Notarzteinsatzfahrzeug oder Rettungshubschrauber",
            fire_truck: "Löschfahrzeuge oder Tanklöschfahrzeuge",
            fireboat: "",
            fly_car: "",
            fukw: "FüKw (Führungskraftwagen)",
            fustw_or_police_motorcycle: "Funkstreifenwagen oder Polizeimotorrad",
            fwk: "Feuerwehrkran",
            gefkw: "GefKw (Gefangenenkraftwagen)",
            gkw: "Gerätekraftwagen (GKW)",
            grtw: "GRTW",
            grtw0: "GRTW (7 Patienten - ohne Notarzt)",
            grtw1: "GRTW (3 Patienten - inkl. Notarzt)",
            grukw: "GruKw (Gruppenkraftwagen)",
            gw_atemschutz_only: "GW-A",
            gw_gefahrgut: "GW-Gefahrgut oder AB-Gefahrgut",
            gw_gefahrgut_only: "GW-Gefahrgut",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "GW-Öl",
            gw_san: "GW-San",
            gw_taucher: "GW-Taucher",
            gw_wasserrettung: "GW-Wasserrettung",
            gw_werkfeuerwehr: "GW-Werkfeuerwehr",
            gwl2wasser_only: "Schlauchwagen",
            helicopter_bucket: "Außenlastbehälter (allgemein)",
            hems: "",
            hlf_only: "HLF",
            hlf_or_rw_and_lf: "HLF oder RW und LF",
            hondengeleider: "",
            k9: "Diensthundeführerkraftwagen",
            kdow_lna: "KdoW-LNA",
            kdow_orgl: "KdoW-OrgL",
            ktw_b: "KTW Typ B",
            ktw_or_rtw: "KTW oder RTW",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Löschfahrzeuge",
            long_distance_ambulance: "Krankentransportwagen",
            mask_service_unit: "GW-A oder AB-Atemschutz",
            mek_mtf: "MEK - MTF",
            mek_zf: "MEK - ZF",
            mtw: "MTW",
            mzb: "Mehrzweckboot",
            naw: "NAW",
            naw_or_critical_transport: "NAW oder ITW",
            naw_or_rtw_and_nef: "NAW oder ITW oder NEF+RTW",
            naw_or_rtw_and_nef_or_rth: "NAW oder ITW oder NEF/RTH+RTW",
            nef_only: "Notarzteinsatzfahrzeug",
            oil_unit: "GW-Öl oder AB-Öl",
            only_ab_dekon_p: "AB-Dekon-P ",
            only_dekon_p: "Dekon-P",
            ovd_p: "",
            police_car: "Funkstreifenwagen",
            police_motorcycle: "Polizeimotorrad",
            polizeihubschrauber: "Polizeihubschrauber",
            rescue_dogs: "Anhänger Hundetransport oder Rettungshundefahrzeug",
            rescue_dogs_seg: "Rettungshundefahrzeug",
            rescue_dogs_thw: "Anhänger Hundetransport",
            rescue_vehicle: "Rüstwagen oder HLF",
            rescue_vehicle_only: "Rüstwagen",
            rescueboat: "",
            rettungstreppe: "Rettungstreppe",
            rth_only: "Rettungshubschrauber",
            schlauchwagen: "Schlauchwagen oder AB-Schlauch",
            seg_elw: "ELW 1 (SEG)",
            sek_mtf: "SEK - MTF",
            sek_zf: "SEK - ZF",
            swat: "",
            swat_armored_vehicle: "",
            swat_suv: "",
            thw_anh_mzab: "Anh MzAB",
            thw_anh_mzb: "Anh MzB",
            thw_anh_schlb: "Anh SchlB",
            thw_brmg_r: "Radlader groß (BRmG R)",
            thw_dle: "Anhänger Drucklufterzeugung (Anh DLE)",
            thw_lkw: "Lastkraftwagen-Kipper 9 t (LKW K 9)",
            thw_lkw_7_lkr_19_tm: "LKW 7 Lkr 19 tm",
            thw_mlw5: "Mannschaftslastwagen Typ V (MLW 5)",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Tauchkraftwagen",
            thw_tauchkraftwagen_or_gw_taucher: "Tauchkraftwagen oder GW-Taucher",
            tlf_only: "Tanklöschfahrzeuge",
            tm50: "TM 50",
            turboloescher: "Turbolöscher",
            turntable_ladder: "Drehleitern",
            ulf: "ULF mit Löscharm",
            wasserwerfer: "Wasserwerfer",
            water_amount: "Liter Wasser",
            water_amount_tlf: "Liter Wasser - Nur TLF"
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Nun gib deinem Gebäude einen Namen! Dieser sollte erkennbar und erweiterbar sein! Z.B. "Feuerwache #0001". Wenn du damit fertig bist, klicke auf "Weiter"!',
                        build_with_credits: "Baue jetzt dein Gebäude mit Credits!",
                        new_building: 'Klicke auf "Neues Gebäude bauen"!',
                        select_building: "Wähle den Gebäudetyp aus, mit dem du starten möchtest. Wir empfehlen dir, mit Feuerwachen zu beginnen! In jedem Fall ist es ratsam, mit einer kleinen Wache zu starten!",
                        select_position: "Schiebe die blaue Markierung dorthin, wo du dein erstes Gebäude bauen möchtest!"
                    },
                    pick_location: "Suche dir einen Ort zum Anfangen aus! Tippe den Names des Ortes in die Suchleiste ein oder wähle ihn direkt auf der Karte aus! Wie wäre es mit deiner Heimat?",
                    welcome: "Hallo, willkommen beim Leitstellenspiel! Zum Start haben wir eine kleine Anleitung vorbereitet."
                },
                mobile: {
                    build_building: {
                        add_name: 'Nun gibst du deinem Gebäude einen Namen! Dieser sollte erkennbar und erweiterbar sein! Z.B. "Feuerwache #0001". Wenn du damit fertig bist, klicke auf "Weiter"!',
                        build_with_credits: "Baue jetzt dein Gebäude mit Credits!",
                        new_building: 'Zuerst suchen wir uns einen Ort für dein neues Gebäude! <br /> <br /> Dazu klickst du auf "Neues Gebäude bauen"!',
                        select_building: "Jetzt suchst du den Gebäudetyp aus, mit dem du starten möchtest. Wir empfehlen dir, mit Feuerwachen zu beginnen! In jedem Fall ist es ratsam, mit einer kleinen Wache zu starten!"
                    },
                    welcome: "Hallo, willkommen beim Leitstellenspiel! Zum Start haben wir eine kleine Anleitung vorbereitet."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Dies ist das Alarmierungsfenster. Von hier aus kannst du Fahrzeuge zu Einsätzen schicken!",
                        dispatch_menu_buttons: 'Dies sind deine beiden Alarmierungsoptionen! Der erste "Alarm"-Button schickt die ausgewählten Fahrzeuge zum Einsatz. Der Zweite wechselt zusätzlich auch zum nächsten Einsatz. Klicke jetzt den ersten Button.',
                        dispatch_menu_mission_general: "Hier siehst du generelle Informationen zum Einsatz, wie Name, Adresse und Icon. Bist du am Einsatz beteiligt, springt die Farbe des Icons von rot auf gelb.",
                        dispatch_menu_mission_progress: "Hier siehst du wie weit der Einsatz bereits fortgeschritten ist, wie viele Einsatzkräfte vor Ort sind und wie viel Zeit noch benötigt wird um den Einsatz abzuschließen!",
                        dispatch_menu_mission_specific: "Hier erhältst du mehr Informationen zum Einsatz, z.B. welche Fahrzeuge unterwegs sind und welche sich bereits am Einsatzort befinden.",
                        dispatch_menu_vehicle_list: "Hier siehst du die Liste deiner verfügbaren Fahrzeuge. Du kannst ein Fahrzeug auswählen, indem du es anklickst!"
                    },
                    mobile: {
                        dispatch_menu: "Dies ist das Alarmierungsfenster. Von hier aus kannst du Fahrzeuge zu Einsätzen schicken!",
                        dispatch_menu_buttons: 'Dies sind deine beiden Alarmierungsoptionen! Der erste "Alarm"-Button schickt die ausgewählten Fahrzeuge zum Einsatz. Der Zweite wechselt zusätzlich auch zum nächsten Einsatz. Tippe jetzt den ersten Button.',
                        dispatch_menu_mission_general: "Hier siehst du generelle Informationen zum Einsatz, wie Name, Adresse und Icon. Bist du am Einsatz beteiligt, springt die Farbe des Icons von rot auf gelb.",
                        dispatch_menu_mission_progress: "Hier siehst du wie weit der Einsatz bereits fortgeschritten ist, wie viele Einsatzkräfte vor Ort sind und wie viel Zeit noch benötigt wird um den Einsatz abzuschließen!",
                        dispatch_menu_mission_specific: "Hier erhältst du mehr Informationen zum Einsatz, z.B. welche Fahrzeuge unterwegs sind und welche sich bereits am Einsatzort befinden.",
                        dispatch_menu_vehicle_list: "Hier siehst du die Liste deiner verfügbaren Fahrzeuge. Du kannst hier ein Fahrzeug auswählen, indem du es anklickst!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Öffne das Alarmierungsfenster, indem du auf einen  "Alarm"-Button klickst!',
                        first_mission: "Super, du hast dein ersten Gebäude gebaut! Schau, die ersten Einsätze wurden dir bereits gemeldet!"
                    },
                    mobile: {
                        dispatch_button: 'Öffne das Alarmierungsfenster, indem du auf einen  "Alarm"-Button klickst!',
                        first_mission: "Super, du hast dein ersten Gebäude gebaut! Schau, die ersten Einsätze wurden dir bereits gemeldet!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Großartig, du bist auf dem Weg ein hervorragender Einsatzleiter zu werden! Hier hast du %{coins} Coins als Starthilfe! </br> Dein Leitstellenspiel-Team"
                },
                mobile: {
                    general: "Großartig, du bist auf dem Weg ein hervorragender Einsatzleiter zu werden! Hier hast du %{coins} Coins als Starthilfe! </br> Dein Leitstellenspiel-Team"
                }
            },
            tips: {
                browser: {
                    contact: "Wenn du Fragen hast kannst du dir unsere FAQ ansehen und das Forum oder unsere Facebook-Seite besuchen!",
                    general: "Als Nächstes empfehlen wir dir, eine Leitstelle zu bauen. Außerdem solltest du weitere Wachen bauen. Je mehr Wachen, desto mehr Einsätze tauchen auf. Tipp: Zu Beginn empfehlen wir kleine Wachen.",
                    join_alliance: "Darüber hinaus empfehlen wir dir, einem Verband beizutreten. Gemeinsam macht es mehr Spaß und andere Mitglieder können dir mit deinen Einsätzen helfen.",
                    summary: "Das waren die Grundlagen vom Leitstellenspiel! Beende Einsätze, sammle Credits, kaufe mehr Fahrzeuge, und baue dein Rettungsnetzwerk aus! Viel Spaß! </br> Dein Leitstellenspiel-Team"
                },
                mobile: {
                    contact: "Wenn du Fragen hast kannst du dir unsere FAQ ansehen und das Forum oder unsere Facebook-Seite besuchen!",
                    general: "Als Nächstes empfehlen wir dir, eine Leitstelle zu bauen. Außerdem solltest du weitere Wachen bauen. Je mehr Wachen, desto mehr Einsätze tauchen auf. Tipp: Zu Beginn empfehlen wir kleine Wachen.",
                    join_alliance: "Darüber hinaus empfehlen wir dir, einem Verband beizutreten. Gemeinsam macht es mehr Spaß und andere Mitglieder können dir mit deinen Einsätzen helfen.",
                    summary: "Das waren die Grundlagen vom Leitstellenspiel! Beende Einsätze, sammle Credits, kaufe mehr Fahrzeuge, und baue dein Rettungsnetzwerk aus! Viel Spaß! </br> Dein Leitstellenspiel-Team"
                }
            }
        },
        commons: {
            collect: "Einsammeln",
            "continue": "Nein",
            end: "Ende",
            next: "Weiter",
            prev: "Zurück",
            skip: "Ja",
            skip_hint: "Möchtest du das Tutorial wirklich abbrechen? Es kann später nicht noch einmal abgerufen werden. Du wirst KEINE Belohnung für den Abschluss des Tutorials erhalten."
        },
        rewards: {
            log: "Belohnung für das Beenden des Tutorials."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Nun gib deinem Gebäude einen Namen! Dieser sollte erkennbar und erweiterbar sein! Z.B. "Polizeiwache #0001". Wenn du damit fertig bist, klicke auf "Weiter"!',
                            select_building: "Wähle den Gebäudetyp aus, mit dem du starten möchtest. Wir empfehlen dir, mit Polizeiwachen zu beginnen! In jedem Fall ist es ratsam, mit einer kleinen Wache zu starten!"
                        },
                        welcome: "Hallo, willkommen beim Polizei Leitstellenspiel! Ich werde dir einige Tipps für einen guten Start geben!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Nun gib deinem Gebäude einen Namen! Dieser sollte erkennbar und erweiterbar sein! Z.B. "Polizeiwache #0001". Wenn du damit fertig bist, klicke auf "Weiter"!',
                            select_building: "Wähle den Gebäudetyp aus, mit dem du starten möchtest. Wir empfehlen dir, mit Polizeiwachen zu beginnen! In jedem Fall ist es ratsam, mit einer kleinen Wache zu starten!"
                        },
                        welcome: "Hallo, willkommen beim Polizei Leitstellenspiel! Ich werde dir einige Tipps für einen guten Start geben!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Großartig, du bist auf dem Weg ein hervorragender Einsatzleiter zu werden! Hier hast du %{coins} Coins als Starthilfe! </br> Dein Polizei Leitstellenspiel-Team"
                    },
                    mobile: {
                        general: "Großartig, du bist auf dem Weg ein hervorragender Einsatzleiter zu werden! Hier hast du %{coins} Coins als Starthilfe! </br> Dein Polizei Leitstellenspiel-Team"
                    }
                },
                tips: {
                    browser: {
                        summary: "Das waren die Grundlagen vom Polizei Leitstellenspiel! Beende Einsätze, sammle Credits, kaufe mehr Fahrzeuge, und baue dein Rettungsnetzwerk aus! Viel Spaß! </br> Dein Polizei Leitstellenspiel-Team"
                    },
                    mobile: {
                        summary: "Das waren die Grundlagen vom Polizei Leitstellenspiel! Beende Einsätze, sammle Credits, kaufe mehr Fahrzeuge, und baue dein Rettungsnetzwerk aus! Viel Spaß! </br> Dein Polizei Leitstellenspiel-Team"
                    }
                }
            }
        }
    }
}, I18n.translations.en_US = {
    common: {
        add: "Add",
        back: "Back",
        cancel: "Cancel",
        change_saved: "Changes saved",
        coins_spend: "Do you really want to spend these coins?",
        congratulations: "Congratulations!",
        content: "Content",
        copy: "Copy",
        credits: "Credits",
        "delete": "Delete",
        details: "Details",
        edit: "Edit",
        error: "Error",
        is_offline: "%{user} is offline.",
        is_offline_long: "Long time: %{user} is offline",
        is_offline_with_duration: "%{user} is offline: %{duration}",
        is_online: "%{user} is online.",
        loading: "Loading...",
        name: "Name",
        none: "None",
        of: "of",
        off: "Off",
        on: "On",
        save: "Save",
        search: "Search",
        show: "Show",
        user_not_found: "User not found",
        wrong_key: "Wrong key"
    },
    javascript: {
        alarm: "Dispatch",
        arrival: "Arrival",
        backalarm: "Cancel",
        coins: "Coins",
        credits: "Credits",
        days: "days",
        few_seconds: "in few seconds",
        finish_in: "Finish in:",
        hours: "H",
        location_not_found: "Not found",
        messages: "Messages",
        minutes: "min.",
        missed_vehicle: "It lacks:",
        mission_start_in: "Starts in:",
        "new": "New",
        not_found_map: "The vehicle hasn't been found on the map",
        now: "Now",
        patient: "Patient",
        patient_untouched: "Untreated patients",
        poi_delete: "Are you sure you want to delete the POI: %{caption}?",
        reload: "Reload",
        sale: "Sale",
        sale_ended: "Sale ended",
        secounds: "sec.",
        sicherheitswache_error: 'The security guard "%{caption}" was not successful, because not all the criteria were met.',
        sicherheitswache_success: 'The security guard "%{caption}" has been successfully carried out. Receive %{credits} Credits.',
        start_in: "Start in: ",
        start_username: "Starter:",
        time_left: "Time left:",
        to_building: "View Building",
        to_mission: "View Mission",
        understand: "Acknowledge",
        user_not_found: "The player was not found.",
        vehicles_not_visible: "Vehicles not visible. ",
        water_approaching: "Approaching: %{amount} gal.",
        water_missing: "Missing: %{amount} gal.",
        water_on_site: "On scene: %{amount} gal.",
        water_selected: "Selected: %{amount} gal."
    },
    map: {
        alliance: "Alliance",
        alliance_chat: "Chat",
        alliance_chat_banned: "You are currently banned from the alliance chat.",
        alliance_chat_banned_admin: "Banned by:",
        alliance_chat_banned_timeleft: "Time remaining:",
        alliance_chat_radio_off: "Alliance Radio: Off",
        alliance_chat_radio_on: "Alliance Radio: On",
        alliance_event: "Event",
        alliance_missions: "Alliance Missions",
        alliance_missions_event: "Event",
        ambulance: "Ambulance",
        attended: "Attended",
        cancel_alliance_event: "Cancel alliance event",
        cancel_alliance_event_confirm: "Do you really want to cancel the alliance event?",
        challenges: "",
        chat_history: "Chat History",
        congratulations: "Congratulations! You can now be promoted.",
        create_alliance_event: "Start alliance event",
        create_alliance_operation: "Create a large scale alliance mission",
        emergency: "Emergency",
        finishing: "Finishing",
        join_alliance_infos: "If you are in an alliance, other players can freely give you missions.",
        map: "Map",
        map_filters: {
            all_buildings: "Buildings",
            all_missions: "Missons",
            alliance_buildings: "Alliance Buildings",
            alliance_members: "Members",
            alliance_missions: "Shared by Alliance",
            ambulance_station_missions: "Ambulance Station",
            ambulance_station_small_missions: "Ambulance station (Small station)",
            building_complex: "Building Complex",
            buildings_section: "Stations",
            clinic_missions: "Clinic",
            dispatch_center_missions: "Dispatch Center",
            factory_fire_brigade_missions: "Factory Fire Brigade",
            federal_police_missions: "Federal Police Station",
            fire_school_missions: "Fire academy",
            firehouse_missions: "Fire Station",
            firehouse_small_missions: "Fire Station (Small)",
            hospital_missions: "Hospital",
            map_filters: "Map filters list",
            mission_positions: "Points of Interest (POIs)",
            mission_positions_section: "POIs",
            missions_section: "Missions",
            police_copter_station_missions: "Police Aviation",
            police_school_missions: "Police academy",
            police_small_missions: "Police station (Small station)",
            police_special_forces: "Police special forces",
            police_station_missions: "Police station",
            prison_missions: "Prison",
            rapid_deployment_group: "Rapid Setup Group (SEG)",
            rapid_deployment_group_missions: "Rapid Deployment Group",
            rescue_copter_station_missions: "Medical helicopter station",
            riot_police: "Riot police",
            riot_police_missions: "Riot Police",
            staging_area_missions: "Staging area",
            technical_aid_organization: "THW",
            technical_aid_organization_missions: "Technical Aid Organization",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "My buildings",
            user_missions: "My missions",
            water_watch: "Water rescue",
            water_watch_missions: "Water Rescue"
        },
        message: "Message",
        mission: "Mission",
        missions_filtered_out: "Some missions might be filtered out. Please, check your map filters.",
        no_alliance_chat_impossible: "You are not in an alliance.",
        no_alliance_missions: "There are currently no alliance missions.",
        no_ambulance_missions: "There are no ambulance missions. Ambulance missions can only occur when you have an ambulance and a hospital.",
        no_emergency_missions: "There are no emergency missions available. An emergency mission can occur after you made your first station.",
        no_radio_messages: "You didn't receive any radio messages.",
        radio_messages: "Radio",
        restore_map: "Restore Map",
        server_warning: "Server maintenance at 18:00 EDT. 6h downtime expected.",
        show_informations: "Green = The missions are shown in the list. Red = The missions aren't shown.",
        sicherheitswache: "Planned Appearances",
        transport: "Transport",
        unattended: "Unattended"
    },
    fms: {
        going: "Responding",
        not_ready: "Out of Service",
        on_destination: "At the transport destination",
        on_place: "On Scene",
        patient_transported: "Transporting Patient",
        prisoner_transported: "Transporting Prisoner",
        ready_home: "Available at Station",
        ready_traveling: "Clear and Available",
        talking_wish: "Transport Request",
        waiting_for_vehicle: "Awaiting vehicle to tow"
    },
    intervention_order: {
        back: "Back",
        battalion_chief_unit: "",
        category: "Category",
        colour: "Color",
        column: "Column",
        column_number: "Column number",
        column_number_hint: "If a column number is given, the Alarm and Response entry will be displayed in the corresponding column on the alert page.",
        create_intervention_order: "Create new Alarm and Response Regulation",
        "delete": "Delete",
        delete_all: "Delete Alarm and Response Regulations completely",
        delete_all_confirm: "Are you sure you want to delete the whole alarm and response regulation? Existing exported entries are no longer available!",
        description: "Name",
        edit: "Edit",
        "export": {
            "export": "Export",
            "import": "Import",
            import_done: "The selected entries have been imported and written to your Alarm and Response plan .",
            saved: "Alarm and Response Regulations Exports",
            saved_text: "Your Alarm and Response Regulation has been prepared for export. Via the link another player can import the Alarm and Response Regulation. If you change your Alarm and Response Regualtion in the meantime, this change will automatically be applied in the export."
        },
        hotkey_hint: "Choose a hotkey for this vehicle selection. Press at your window mission: ALT + your hotkey (or at Firefox: ALT + SHIFT + your hotkey or at mac os: ctrl + alt + your hotkey) to choose your vehicle selection.",
        intervention_order: "Edit Alarm and Response Regulations",
        name: "Name",
        no_intervention_created: "You haven't created any Alarm and Response Regulation yet.",
        options: "Options",
        reset: "Reset the previous selection in the alarm window.",
        reset_hint: "If you have selected the vehicle in the dispatch window, you can use this button to reset it.",
        save: "Save",
        station: "Station",
        station_hint: "When a building is selected, only vehicles of the corresponding building will be selected.",
        successfully_created: "Alarm and Response Regulation successfully created.",
        successfully_deleted: "Alarm and Response Regulation deleted",
        successfully_updated: "Alarm and Response Regulations successfully updated.",
        vehicles: {
            ab_atemschutz_only: "SCBA-Module",
            ab_einsatzleitung_only: "Command-Module",
            ab_gefahrgut_only: "HazMat-Module",
            ab_oel_only: "Oil spill-Module",
            ab_ruest: "Tech/Rescue-Module",
            ab_ruest_rw: "",
            abl2wasser_only: "Hose-Supply-Module",
            air_tanker: "Air tanker",
            ambulance: "ALS ambulance",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Traffic Car",
            arff: "ARFF (Airport Fire Truck)",
            at_c: "",
            at_m: "",
            at_o: "",
            battalion_chief_unit: "Battalion Chief unit",
            bike_police: "DB-Bike",
            boot: "Light boats (General)",
            brush_truck: "Wildland fire engine",
            brush_truck_1: "Type 3 engine",
            brush_truck_2: "Type 5 engine",
            brush_truck_3: "Type 7 engine",
            brush_truck_4: "Type 4 engine",
            brush_truck_5: "Type 6 engine",
            brush_vehicle: "Wildland fire vehicle",
            commerce_police: "Commerce Police Car",
            coresponder: "",
            crew_carrier: "Crew Carrier",
            dekon_p: "",
            division_chief_unit: "Mobile Command Vehicle",
            dlk_or_tm50: "",
            dozer_trailer: "Dozer Trailer",
            elw1_or_elw2: "Battalion Chief Unit, Mobile Command Vehicle or Mobile Command-Module",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            elw_police: "Police MCV",
            emergency_ambulance: "Emergency ambulance or Helicopter",
            fbi_bomb_tech: "FBI Bomb Technician Vehicle",
            fbi_drone: "FBI Surveillance Drone",
            fbi_investigation_unit: "FBI Investigation Wagon",
            fbi_mobile_command: "FBI Mobile Command Center",
            fbi_unit: "FBI Unit",
            fire_aviation: "Fire aviation",
            fire_truck: "Firetrucks",
            fireboat: "Large Fireboat",
            fly_car: "Fly-Car",
            fly_car_any: "",
            fukw: "",
            fustw_or_police_motorcycle: "Patrol car or Police Motorcycle",
            fwk: "",
            gefkw: "DB-AV",
            gkw: "Utility Truck",
            grtw: "Mass Casualty Unit",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "HazMat",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Water Retention",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Hose Vehicle",
            heavy_air_tanker: "Heavy air tanker",
            helicopter_bucket: "Helicopter bucket",
            hems: "HEMS",
            hint: {
                water_amount: ""
            },
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "",
            joint_response_unit: "",
            k9: "K-9 Unit",
            kdow_lna: "",
            kdow_orgl: "EMS Chief",
            kdow_orgl_any: "",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Fire Trucks",
            long_distance_ambulance: "BLS ambulance",
            mask_service_unit: "Mobile Air Unit",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Light Multi-Purpose Boat",
            naw: "",
            naw_or_critical_transport: "NAW or critical transport",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulance",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Patrol car",
            police_car_3: "NH-O",
            police_horse: "Mounted Police",
            police_motorcycle: "Police Motorcycle",
            polizeihubschrauber: "Police helicopter",
            rescue_dogs: "",
            rescue_dogs_seg: "",
            rescue_dogs_thw: "",
            rescue_vehicle: "Heavy rescue vehicle",
            rescue_vehicle_only: "Heavy Rescue",
            rescueboat: "Large Rescue Boat",
            rettungstreppe: "",
            rth_only: "Helicopter",
            schlauchwagen: "Water Tanker",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            sheriff_unit: "Sheriff Unit",
            spokesman: "",
            swat: "SWAT",
            swat_armored_vehicle: "SWAT Armoured Vehicle",
            swat_suv: "SWAT SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dive Team",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tanker Truck",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Platform trucks",
            ulf: "",
            wasserwerfer: "",
            water_amount: "Gallons of water",
            water_amount_tlf: "",
            water_drop_helicopter: "Water drop helicopter"
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'Click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!",
                        select_position: "Move the blue marker where you want to build your first station!"
                    },
                    pick_location: "First pick a location to start! Type the name of the location you want to start in into the search bar or find it on the map yourself! What about your hometown?",
                    welcome: "Hello, welcome to MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                },
                mobile: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'First we will pick a location to start and build your first building! <br /> <br /> To do that click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!"
                    },
                    welcome: "Hello, welcome to MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    },
                    mobile: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    },
                    mobile: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                },
                mobile: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                }
            },
            tips: {
                browser: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                },
                mobile: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                }
            }
        },
        commons: {
            collect: "Collect",
            "continue": "No",
            end: "End",
            next: "Next",
            prev: "Prev",
            skip: "Yes",
            skip_hint: "Do you really want to cancel the tutorial? It can't be accessed at any later time. You will not be eligible for the tutorial completion reward."
        },
        rewards: {
            log: "Reward for finishing the tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins to help you get started! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins to help you get started! </br> Your Police MissionChief-team"
                    }
                },
                tips: {
                    browser: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    }
                }
            }
        }
    }
}, I18n.translations.en_GB = {
    common: {
        add: "Add",
        back: "Back",
        cancel: "Cancel",
        change_saved: "Changes saved",
        coins_spend: "Do you really want to spend these coins?",
        congratulations: "Congratulations!",
        content: "Content",
        copy: "Copy",
        credits: "Credits",
        "delete": "Delete",
        details: "Details",
        edit: "Edit",
        error: "Error",
        is_offline: "%{user} is offline.",
        is_offline_long: "Long time: %{user} is offline",
        is_offline_with_duration: "%{user} is offline: %{duration}",
        is_online: "%{user} is online.",
        loading: "Loading...",
        name: "Name",
        none: "None",
        of: "of",
        off: "Off",
        on: "On",
        save: "Save",
        search: "Search",
        show: "Show",
        user_not_found: "User not found",
        wrong_key: "Wrong key"
    },
    javascript: {
        alarm: "Dispatch",
        arrival: "Arrival",
        backalarm: "Cancel",
        coins: "Coins",
        credits: "Credits",
        days: "days",
        few_seconds: "in few seconds",
        finish_in: "Finish in:",
        hours: "H",
        location_not_found: "Not found",
        messages: "Messages",
        minutes: "min.",
        missed_vehicle: "It lacks:",
        mission_start_in: "Starts in:",
        "new": "New",
        not_found_map: "The vehicle hasn't been found on the map",
        now: "Now",
        patient: "Patient",
        patient_untouched: "Untreated patients",
        poi_delete: "Are you sure you want to delete the POI: %{caption}?",
        reload: "Reload",
        sale: "Sale",
        sale_ended: "Sale ended",
        secounds: "sec.",
        sicherheitswache_error: 'The security guard "%{caption}" was not successful, because not all the criteria were met.',
        sicherheitswache_success: 'The security guard "%{caption}" has been successfully carried out. Receive %{credits} Credits.',
        start_in: "Start in: ",
        start_username: "Starter:",
        time_left: "Time left:",
        to_building: "View Building",
        to_mission: "View Mission",
        understand: "Acknowledge",
        user_not_found: "The player was not found.",
        vehicles_not_visible: "Vehicles not visible. "
    },
    map: {
        alliance: "Alliance",
        alliance_chat: "Chat",
        alliance_chat_banned: "You are currently banned from the alliance chat.",
        alliance_chat_banned_admin: "Banned by:",
        alliance_chat_banned_timeleft: "Time remaining:",
        alliance_chat_radio_off: "Alliance Radio: Off",
        alliance_chat_radio_on: "Alliance Radio: On",
        alliance_event: "Event",
        alliance_missions: "Alliance Missions",
        alliance_missions_event: "Event",
        ambulance: "Ambulance",
        attended: "Attended",
        cancel_alliance_event: "Cancel alliance event",
        cancel_alliance_event_confirm: "Do you really want to cancel the alliance event?",
        challenges: "",
        chat_history: "Chat History",
        congratulations: "Congratulations! You can now be promoted.",
        create_alliance_event: "Start alliance event",
        create_alliance_operation: "Create a large scale alliance mission",
        emergency: "Emergency",
        finishing: "Finishing",
        join_alliance_infos: "If you are in an alliance, other players can freely give you missions.",
        map: "Map",
        map_filters: {
            all_buildings: "Buildings",
            all_missions: "Missons",
            alliance_buildings: "Alliance Buildings",
            alliance_members: "Members",
            alliance_missions: "Shared by Alliance",
            ambulance_station_missions: "Ambulance Station",
            ambulance_station_small_missions: "Ambulance station (Small station)",
            building_complex: "Building Complex",
            buildings_section: "Stations",
            clinic_missions: "Clinic",
            dispatch_center_missions: "Dispatch Center",
            fire_school_missions: "Fire Academy",
            firehouse_missions: "Fire Station",
            firehouse_small_missions: "Fire Station (Small)",
            hospital_missions: "Hospital",
            map_filters: "Points of Interest (POIs)",
            mission_positions: "Points of Interest (POIs)",
            mission_positions_section: "POIs",
            missions_section: "Missions",
            police_copter_station_missions: "Police Aviation",
            police_school_missions: "Police training centre",
            police_small_missions: "Police Station (Small station)",
            police_special_forces: "Police special forces",
            police_station_missions: "Police Station",
            prison_missions: "Prison",
            rapid_deployment_group: "Rapid Setup Group (SEG)",
            rescue_copter_station_missions: "Medical Helicopter Station",
            riot_police: "Riot Police",
            riot_police_missions: "Riot Police",
            staging_area_missions: "Staging Area",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "My buildings",
            user_missions: "My missions",
            water_watch: "Water Rescue",
            water_watch_missions: "Water Rescue"
        },
        message: "Message",
        mission: "Mission",
        missions_filtered_out: "Some missions might be filtered out. Please, check your map filters.",
        no_alliance_chat_impossible: "You are not in an alliance.",
        no_alliance_missions: "There are currently no alliance missions.",
        no_ambulance_missions: "There are no ambulance missions. Ambulance missions can only occur when you have an ambulance and a hospital.",
        no_emergency_missions: "There are no emergency missions available. An emergency mission can occur after you made your first station.",
        no_radio_messages: "You didn't receive any radio messages.",
        radio_messages: "Radio",
        restore_map: "Restore Map",
        server_warning: "Server maintenance at 11 pm. 6h downtime expected.",
        show_informations: "Green = The missions are shown in the list. Red = The missions aren't shown.",
        sicherheitswache: "Planned Appearances",
        transport: "Transport",
        unattended: "Unattended"
    },
    fms: {
        going: "Responding",
        not_ready: "Out of Service",
        on_destination: "At the transport destination",
        on_place: "On Scene",
        patient_transported: "Transporting Patient",
        prisoner_transported: "Transporting Prisoner",
        ready_home: "Available at Station",
        ready_traveling: "Clear and Available",
        talking_wish: "Transport Request",
        waiting_for_vehicle: "Awaiting vehicle to tow"
    },
    intervention_order: {
        back: "Back",
        category: "Category",
        colour: "Color",
        column: "Column",
        column_number: "Column number",
        column_number_hint: "If a column number is given, the Alarm and Response entry will be displayed in the corresponding column on the alert page.",
        create_intervention_order: "Create new Alarm and Response Regulation",
        "delete": "Delete",
        delete_all: "Delete Alarm and Response Regulations completely",
        delete_all_confirm: "Are you sure you want to delete the whole alarm and response regulation? Existing exported entries are no longer available!",
        description: "Name",
        edit: "Edit",
        "export": {
            "export": "Export",
            "import": "Import",
            import_done: "The selected entries have been imported and written to your Alarm and Response plan .",
            saved: "Alarm and Response Regulations Exports",
            saved_text: "Your Alarm and Response Regulation has been prepared for export. Via the link another player can import the Alarm and Response Regulation. If you change your Alarm and Response Regualtion in the meantime, this change will automatically be applied in the export."
        },
        hotkey_hint: "Choose a hotkey for this vehicle selection. Press at your window mission: ALT + your hotkey (or at Firefox: ALT + SHIFT + your hotkey or at mac os: ctrl + alt + your hotkey) to choose your vehicle selection.",
        intervention_order: "Edit Alarm and Response Regulations",
        name: "Name",
        no_intervention_created: "You haven't created any Alarm and Response Regulation yet.",
        options: "Options",
        reset: "Reset the previous selection in the alarm window.",
        reset_hint: "If you have selected the vehicle in the dispatch window, you can use this button to reset it.",
        save: "Save",
        station: "Station",
        station_hint: "When a building is selected, only vehicles of the corresponding building will be selected.",
        successfully_created: "Alarm and Response Regulation successfully created.",
        successfully_deleted: "Alarm and Response Regulation deleted",
        successfully_updated: "Alarm and Response Regulations successfully updated.",
        vehicles: {
            ab_atemschutz_only: "BASU-Module",
            ab_einsatzleitung_only: "Command-Module",
            ab_gefahrgut_only: "HazMat-Module",
            ab_oel_only: "Oil spill-Module",
            ab_ruest: "Tech/Rescue-Module",
            ab_ruest_rw: "",
            abl2wasser_only: "Hose-Supply-Module",
            ambulance: "Ambulance",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Traffic Car",
            arff: "ARFF (Airport Fire Truck)",
            battalion_chief_unit: "Fire Officer",
            boot: "Boats (General)",
            coresponder: "Co-Responder Vehicle",
            crew_carrier: "Crew Carrier",
            dekon_p: "",
            division_chief_unit: "ICCU or Ambulance Control Unit",
            dlk_or_tm50: "",
            elw1_or_elw2: "Fire Officer or ICCU",
            elw2_or_ab_elw: "Incident Command and Control Unit",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Emergency ambulance or Helicopter",
            fire_truck: "Fire engines",
            fireboat: "Large Fireboat",
            fly_car: "Rapid Response Vehicle / General Practitioner",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Utility Truck",
            grtw: "Mass Casualty Unit",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "HazMat Unit or CBRN Vehicle",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Water Retention",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Hose Vehicle",
            hems: "HEMS",
            hlf_only: "Rescue Pump",
            hlf_or_rw_and_lf: "Rescue Pump or Rescue Support Unit and Fire engine",
            hondengeleider: "",
            joint_response_unit: "Joint Response Unit",
            k9: "Dog Support Unit (DSU)",
            kdow_lna: "",
            kdow_orgl: "Operational Team Leader",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Fire Trucks",
            long_distance_ambulance: "BLS ambulance",
            mask_service_unit: "Breathing Apparatus Support Unit",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Multi-Purpose Boat",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulance",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Police car",
            polizeihubschrauber: "Police helicopter",
            rescue_vehicle: "Rescue Support Unit or Rescue Pump",
            rescue_vehicle_only: "Rescue Support Unit",
            rescueboat: "Large Rescue Boat",
            rettungstreppe: "",
            rth_only: "HEMS",
            schlauchwagen: "Water Carrier",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Armed Response Vehicle",
            swat_armored_vehicle: "Armed Response Vehicle (ARV)",
            swat_suv: "Armed Response Vehicle (ARV)",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dive Team",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tanker Truck",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Aerial Appliance Truck",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'Click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!",
                        select_position: "Move the blue marker where you want to build your first station!"
                    },
                    pick_location: "First pick a location to start! Type the name of the location you want to start in into the search bar or find it on the map yourself! What about your hometown?",
                    welcome: "Hello, welcome to MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                },
                mobile: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'First we will pick a location to start and build your first building! <br /> <br /> To do that click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!"
                    },
                    welcome: "Hello, welcome to MissionChief!  I will teach you some lessons to help you start off your emergency services career well!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    },
                    mobile: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    },
                    mobile: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                },
                mobile: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                }
            },
            tips: {
                browser: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                },
                mobile: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                }
            }
        },
        commons: {
            collect: "Collect",
            "continue": "No",
            end: "End",
            next: "Next",
            prev: "Prev",
            skip: "Yes",
            skip_hint: "Do you really want to cancel the tutorial? It can't be accessed at any later time. You will not be eligible for the tutorial completion reward."
        },
        rewards: {
            log: "Reward for finishing the tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins. to help you get started! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins. to help you get started! </br> Your Police MissionChief-team"
                    }
                },
                tips: {
                    browser: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    }
                }
            }
        }
    }
}, I18n.translations.nl_NL = {
    common: {
        add: "Toevoegen",
        back: "Terug",
        cancel: "Cancel",
        change_saved: "Veranderingen opgeslagen",
        coins_spend: "Weet je zeker dat je Coins uitgeeft? ",
        congratulations: "Gefeliciteerd! ",
        content: "Inhoud",
        copy: "kopiëren",
        credits: "Credits",
        "delete": "Verwijderen",
        details: "Details",
        edit: "Bewerken",
        error: "Error",
        is_offline: "%{user} is offline.",
        is_offline_long: "%{user} is al een lange tijd offline.",
        is_offline_with_duration: "%{user} is offline: %{duration}",
        is_online: "%{user} is online.",
        loading: "Laden...",
        name: "Naam",
        none: "Geen",
        of: "van",
        off: "Uit",
        on: "Aan",
        save: "Opslaan",
        search: "Zoeken",
        show: "Bekijken",
        user_not_found: "Gebruiker niet gevonden",
        wrong_key: "Verkeerde key"
    },
    javascript: {
        alarm: "Alarm",
        arrival: "Aankomst",
        backalarm: "Retour post",
        coins: "Coins",
        credits: "Credits",
        days: "dagen",
        few_seconds: "Nog enkele seconden",
        finish_in: "Duurt nog:",
        hours: "uur",
        location_not_found: "Uw locatie is niet gevonden.",
        messages: "Berichten",
        minutes: "minuten",
        missed_vehicle: "Niet beschikbaar:",
        mission_start_in: "Begint in:",
        "new": "Nieuw",
        not_found_map: "Het voertuig is niet gevonden op de kaart",
        now: "Nu",
        patient: "Patiënten",
        patient_untouched: "onbehandelde patiënten",
        poi_delete: 'Weet je zeker dat je dit Point of Interest: "%{caption}" wilt verwijderen?',
        reload: "Refresh",
        sale: "Sale",
        sale_ended: "Uitverkoop voorbij",
        secounds: "seconden",
        sicherheitswache_error: 'Het evenement "%{caption}" werd niet succesvol doorlopen. Er werd niet aan alle vereisten voldaan. ',
        sicherheitswache_success: 'Het evenement "%{caption}" werd succesvol doorlopen. Je hebt %{credits} Credits gekregen.',
        start_in: "Uitrukken in:",
        start_username: "Gestart door:",
        time_left: "Tijd over:",
        to_building: "Naar post",
        to_mission: "Naar incident",
        understand: "Begrepen",
        user_not_found: "De speler is niet gevonden.",
        vehicles_not_visible: "Voertuig verborgen.",
        water_approaching: "Aanrijdend: %{amount} L.",
        water_missing: "Nog nodig: %{amount} L.",
        water_on_site: "Ter plaatse: %{amount} L.",
        water_selected: "Geselecteerd: %{amount} L."
    },
    map: {
        alliance: "Team",
        alliance_chat: "Teamchat",
        alliance_chat_banned: "Je bent uit de Teamchat verbannen.",
        alliance_chat_banned_admin: "Verbannen voor:",
        alliance_chat_banned_timeleft: "Resterende tijd:",
        alliance_chat_radio_off: "Teammeldingen: Uit",
        alliance_chat_radio_on: "Teammeldingen: Aan",
        alliance_event: "Event",
        alliance_missions: "Grote inzet",
        alliance_missions_event: "Event",
        ambulance: "Besteld vervoer",
        attended: "Uitgevoerd",
        cancel_alliance_event: "Alliantie-evenement annuleren",
        cancel_alliance_event_confirm: "Wil je het alliantie-evenement echt annuleren?",
        challenges: "",
        chat_history: "Chat geschiedenis",
        congratulations: "Gefeliciteerd! Je mag je nieuwe rang ophalen.",
        create_alliance_event: "Team-Event starten",
        create_alliance_operation: "Grote inzet aanmaken",
        emergency: "Spoed",
        finishing: "Wordt afgerond",
        join_alliance_infos: "Wanneer je in een team zit kunnen andere spelers een incident vrijgeven.",
        map: "Kaart",
        map_filters: {
            all_buildings: "Gebouwen",
            all_missions: "Incidenten",
            alliance_buildings: "Teamgebouwen",
            alliance_members: "Teamleden",
            alliance_missions: "Gedeeld door alliantie",
            ambulance_station_missions: "Ambulance, standplaats",
            ambulance_station_small_missions: "Ambulance, VWS-post",
            building_complex: "Gebouwencomplex",
            buildings_section: "Posten",
            clinic_missions: "Clinic",
            dispatch_center_missions: "Meldkamer",
            fire_school_missions: "Brandweer, Academie",
            firehouse_missions: "Brandweer, Kazerne",
            firehouse_small_missions: "Brandweerkazerne (klein)",
            hospital_missions: "Spoedeisende hulp",
            map_filters: "Belangrijke plaatsen (POI's)",
            mission_positions: "Belangrijke plaatsen (POI's)",
            mission_positions_section: "POI's",
            missions_section: "Incidenten",
            police_copter_station_missions: "Politiehelikopter standplaats",
            police_school_missions: "Politie, Academie",
            police_small_missions: "Politie, Steunpunt",
            police_special_forces: "Police special forces",
            police_station_missions: "Politie, Opkomstbureau",
            prison_missions: "Politie, Cellencomplex voor teams",
            rapid_deployment_group: "Nooddiensten",
            rescue_copter_station_missions: "Ambulance, Standplaats MMT",
            riot_police: "Politie, Hoofdbureau",
            riot_police_missions: "Politie, Hoofdbureau",
            staging_area_missions: "Uitgangsstelling (UGS)",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "",
            user_buildings: "Mijn gebouwen",
            user_missions: "Mijn inzetten",
            water_watch: "Waterongevallen",
            water_watch_missions: "Waterongevallen"
        },
        message: "Bericht",
        mission: "Incidenten",
        missions_filtered_out: "Sommige missies worden mogelijk uitgefilterd. Controleer alstublieft uw kaartfilters.",
        no_alliance_chat_impossible: "Je zit nog niet in een team. De chat is pas beschikbaar als je in een team zit. ",
        no_alliance_missions: "Er zijn geen team inzetten beschikbaar",
        no_ambulance_missions: "Er kan nog geen besteld vervoer plaatsvinden zonder een ziekenhuis en een zorgambulance.",
        no_emergency_missions: "Er hebben zich nog geen incidenten plaatsgevonden. Incidenten kunnen vanaf je eerste post plaatsvinden.",
        no_radio_messages: "Je hebt nog geen statusmeldingen ontvangen.",
        radio_messages: "Status",
        restore_map: "Kaart terugzetten",
        server_warning: "Serveronderhoud om 00.00 uur. We verwachten 6 uur offline te zijn.",
        show_informations: "Groen = Inzet wordt in de lijst weergegeven. Rood = Inzet wordt niet weergegeven.",
        sicherheitswache: "Geplande inzetten",
        transport: "Transport",
        unattended: "Niet uitgevoerd"
    },
    fms: {
        going: "Uitgerukt",
        not_ready: "Niet beschikbaar",
        on_destination: "Aanvraag spraakcontact",
        on_place: "Ter plaatse",
        patient_transported: "Vertrokken met patiënt",
        prisoner_transported: "Transport met arrestant",
        ready_home: "Op post",
        ready_traveling: "Beschikbaar",
        talking_wish: "Aanvraag spraakcontact",
        waiting_for_vehicle: "Wachten op trekkend voertuig."
    },
    intervention_order: {
        back: "Terug",
        category: "Categorie",
        colour: "Kleur",
        column: "Kolom",
        column_number: "Kolomnummer",
        column_number_hint: "Wanneer je een kolomnummer invult wordt het deze Alarm en Uitrukregel in de bijbehorende kolom in de alarmeringsscherm geplaatst.",
        create_intervention_order: "Nieuwe Alarm en Uitrukregel aanmaken",
        "delete": "Verwijderen",
        delete_all: "Inzetvoorstellen compleet verwijderen",
        delete_all_confirm: "Weet je zeker dat je de inzetvoorstellen wilt verwijderen? Ook de geëxporteerde variant wordt niet meer beschikbaar.",
        description: "Beschrijving",
        edit: "Bewerken",
        "export": {
            "export": "Exporteren",
            "import": "Importeren",
            import_done: "De gekozen input wordt geïmporteerd en jouw eigen A&U worden overschreven.",
            saved: "A&U-Geëxporteerd ",
            saved_text: "Jouw A&U worden voor export voorbereid. Met de link kunnen andere spelers de A&U importeren. Wanneer je tussentijds je eigen A&U regels veranderd, zullen deze veranderingen automatisch in de export worden meegenomen."
        },
        hotkey_hint: "Kies een letter voor deze inzet. In het alarmeringsscherm kun je dan met ALT + Letter naar keuze snel een keuze maken. (In Firefox: ALT + SHIFT + Letter naar keuze, Op Mac OS: CTRL + ALT + Letter)",
        intervention_order: "Inzetvoorstellen aanpassen",
        name: "Naam",
        no_intervention_created: "Je hebt nog geen inzetvoorstellen aangemaakt.",
        options: "Opties",
        reset: "Voorgaande keuze in alarmeringsscherm terugzetten.",
        reset_hint: "Wanneer je bij je voertuigkeuze de verkeerde voertuigen geselecteerd hebt, kun je met deze knop de gehele selectie verwijderen en opnieuw beginnen.",
        save: "Opslaan",
        station: "Post",
        station_hint: "Wanneer je een post selecteert worden alleen voertuigen van deze post geselecteerd. ",
        successfully_created: "Alarm en Uitrukregel succesvol opgeslagen.",
        successfully_deleted: "Alarm en Uitrukregel verwijderd.",
        successfully_updated: "Inzetvoorstellen succesvol opgeslagen.",
        vehicles: {
            ab_atemschutz_only: "Adembeschermingshaakarmbak",
            ab_einsatzleitung_only: "",
            ab_gefahrgut_only: "",
            ab_oel_only: "Haakarmbak Milieu",
            ab_ruest: "Haakarmbak Hulpverlening",
            ab_ruest_rw: "Hulpverleningsvoertuig of HVH",
            abl2wasser_only: "Watertransportsysteem-haakarmbak",
            ambulance: "Ambulance",
            ambulance_or_rapid_responder: "Ambulance of Rapid Responder",
            arff: "Crashtender",
            at_c: "AT-Commandant",
            at_m: "AT-Materiaalwagen",
            at_o: "AT-Operator",
            battalion_chief_unit: "Officier van Dienst Brandweer",
            bike_police: "DB-Bike",
            boot: "WOA of BA-RB",
            dekon_p: "",
            division_chief_unit: "Hoofdofficier van Dienst - Brandweer",
            dlk_or_tm50: "",
            elw1_or_elw2: "",
            elw2_or_ab_elw: "",
            elw3: "Commandovoertuig of haakarmbak",
            elw_airport: "Airport Fire Officer / On Scene Commander",
            emergency_ambulance: "MMT-Auto of Lifeliner",
            fire_truck: "Tankautospuit",
            fireboat: "",
            fly_car: "Rapid Responder",
            fly_car_any: "OVDG-RR of Rapid Responder",
            fukw: "Hondenbrigade",
            fustw_or_police_motorcycle: "Politie Noodhulp of Dienstmotor Noodhulp",
            fwk: "",
            gefkw: "DB-AV",
            gkw: "",
            grtw: "",
            grtw0: "",
            grtw1: "",
            grukw: "ME Flexbus",
            gw_atemschutz_only: "Adembeschermingsvoertuig",
            gw_gefahrgut: "Adviseur Gevaarlijke Stoffen",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Hoogte reddingsteam (HRT)",
            gw_messtechnik: "Dienstbus Verkenningseenheid Brandweer",
            gw_oel_only: "Milieu wagen",
            gw_san: "",
            gw_taucher: "Waterongevallenvoertuig",
            gw_wasserrettung: "Strandvoertuig (DAT-RB of KHV)",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Alleen Slangenwagen / Watertankwagen",
            hems: "",
            hint: {
                water_amount: "In te voeren in Liters. Voorbeeld: Als je hier 4500 invoert zullen er voertuigen geselecteerd worden tot de gekozen waarde van 4500L is bereikt."
            },
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "Hondengeleider",
            k9: "",
            kdow_lna: "",
            kdow_orgl: "Officier van Dienst Geneeskunde",
            kdow_orgl_any: "OVD-G of OVDG-RR",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "ME Commandovoertuig",
            lf_only: "",
            long_distance_ambulance: "Zorgambulance",
            mask_service_unit: "Adembeschermingsvoertuig of haakarmbak",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Dienstauto / Dienstbus brandweer",
            mzb: "",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "MMT-Auto",
            oil_unit: "Milieu wagen of haakarmbak milieu",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "Officier van Dienst - Politie",
            police_car: "Politie Noodhulp",
            police_car_3: "NH-O",
            police_motorcycle: "Dienstmotor Noodhulp",
            polizeihubschrauber: "Politiehelikopter",
            rescue_vehicle: "HV of TS-HV",
            rescue_vehicle_only: "Hulpverleningsvoertuig",
            rescueboat: "",
            rettungstreppe: "",
            rth_only: "Lifeliner",
            schlauchwagen: "Slangenwagen / Watertankwagen of Watertransportsysteem-haakarmbak",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            spokesman: "Voorlichters",
            swat: "",
            swat_armored_vehicle: "",
            swat_suv: "",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "",
            thw_mzkw: "",
            thw_tauchkraftwagen: "",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Redvoertuig",
            ulf: "",
            wasserwerfer: "",
            water_amount: "Water (in Liters):",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Geef je nieuwe gebouw een naam. Maak het herkenbaar en opschaalbaar. Bijvoorbeeld 'Brandweerkazerne nr. 0001'. Als je klaar bent, klik dan op 'Volgende'.",
                        build_with_credits: "Bouw nu je gebouw met credits.",
                        new_building: "Klik op 'Nieuw gebouw maken'.",
                        select_building: "Kies nu eerst het type gebouw waar je mee wil beginnen. We raden je aan om te beginnen met de brandweer, zo maak je de beste start!",
                        select_position: "Zet de blauwe markering neer waar je je eerste gebouw wil bouwen."
                    },
                    pick_location: "Kies eerst een locatie om te beginnen. Typ de naam van de locatie waar je wil beginnen in de zoekbalk of zoek zelf op de kaart. Je kunt bijvoorbeeld je woonplaats kiezen.",
                    welcome: "Hallo, welkom bij Meldkamerspel!  Ik zal je het een en ander leren om je te helpen je carrière bij de hulpdiensten goed te beginnen."
                },
                mobile: {
                    build_building: {
                        add_name: "Geef je nieuwe gebouw een naam. Maak het herkenbaar en opschaalbaar. Bijvoorbeeld 'Brandweerkazerne nr. 0001'. Als je klaar bent, klik dan op 'Volgende'.",
                        build_with_credits: "Bouw nu je gebouw met credits.",
                        new_building: "Eerst kiezen we een locatie om te beginnen en bouwen we je eerste gebouw. <br /> <br /> Om dat te doen, klik je op 'Nieuw gebouw maken'.",
                        select_building: "Kies nu eerst het type gebouw waar je mee wil beginnen. We raden je aan om te beginnen met de brandweer, zo maak je de beste start!"
                    },
                    welcome: "Hallo, welkom bij Meldkamerspel!  Ik zal je het een en ander leren om je te helpen je carrière bij de hulpdiensten goed te beginnen."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Dit is het Alarmeringsmenu. Hiervandaan stuur je je eenheden naar de melding.",
                        dispatch_menu_buttons: "Dit zijn de twee Alarmeringsknoppen. De eerste: 'Alarmeren' stuurt de geselecteerde eenheden naar de melding. De tweede knop doet hetzelfde als de eerste, maar schakelt daarna door naar de volgende missie. Klik nu op de eerste knop.",
                        dispatch_menu_mission_general: "Hier zie je algemene informatie over de melding: de naam, het adres, het icoontje van de missie. Het icoontje van een mannetje vervangt het sterretje voor missies waaraan je al deelneemt.",
                        dispatch_menu_mission_progress: "Hier zie je hoeveel vooruitgang er is geboekt met deze melding; hoeveel medewerkers ter plaatse zijn en de resterende tijd die nog nodig is om de melding af te handelen.",
                        dispatch_menu_mission_specific: "Hier zie je meer informatie over de melding; welke eenheden onderweg en welke al ter plaatse zijn.",
                        dispatch_menu_vehicle_list: "Dit is een lijst met beschikbare voertuigen. Hier selecteer je de voertuigen. Selecteer nu je voertuig door erop te klikken."
                    },
                    mobile: {
                        dispatch_menu: "Dit is het Alarmeringsmenu. Hiervandaan stuur je je eenheden naar de melding.",
                        dispatch_menu_buttons: "Dit zijn de twee Alarmeringsknoppen. De eerste: 'Alarmeren' stuurt de geselecteerde eenheden naar de melding. De tweede knop doet hetzelfde als de eerste, maar schakelt daarna door naar de volgende missie. Klik nu op de eerste knop.",
                        dispatch_menu_mission_general: "Hier zie je algemene informatie over de melding: de naam, het adres, het icoontje van de missie. Het icoontje van een mannetje vervangt het sterretje voor missies waaraan je al deelneemt.",
                        dispatch_menu_mission_progress: "Hier zie je hoeveel vooruitgang er is geboekt met deze melding; hoeveel medewerkers ter plaatse zijn en de resterende tijd die nog nodig is om de melding af te handelen.",
                        dispatch_menu_mission_specific: "Hier zie je meer informatie over de melding; welke eenheden onderweg en welke al ter plaatse zijn.",
                        dispatch_menu_vehicle_list: "Dit is een lijst met beschikbare voertuigen. Hier selecteer je de voertuigen. Selecteer nu je voertuig door erop te klikken."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Nu willen we leren hoe we met incidenten om moeten gaan. Open het Alarmeringsmenu door op de 'Alarm'-knop te drukken.",
                        first_mission: "Geweldig, je hebt je eerste gebouw gebouwd! En kijk, de eerste meldingen komen al binnen!"
                    },
                    mobile: {
                        dispatch_button: "Nu willen we leren hoe we met incidenten om moeten gaan. Open het Alarmeringsmenu door op de 'Alarm'-knop te drukken.",
                        first_mission: "Geweldig, je hebt je eerste gebouw gebouwd! En kijk, de eerste meldingen komen al binnen!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Goed zo, je bent op weg om een geweldige meldkamercentralist te worden! Hier heb je %{coins} Coins om je verder op weg te helpen. </br> Het team van Meldkamerspel"
                },
                mobile: {
                    general: "Goed zo, je bent op weg om een geweldige meldkamercentralist te worden! Hier heb je %{coins} Coins om je verder op weg te helpen. </br> Het team van Meldkamerspel"
                }
            },
            tips: {
                browser: {
                    contact: "Als je vragen hebt, kun je de veelgestelde vragen over het spel bekijken of een bezoekje brengen aan de forums of onze Facebook-pagina. Op het Blog vind je nog extra handleidingen en video's met uitleg over de verschillende functies in het spel.",
                    general: "Als volgende stap raden we je aan om een meldkamer(gratis!) te bouwen en dan zo snel mogelijk nieuwe gebouwen te bouwen, aangezien het maximumaantal missies gelijk is aan het type station waarvan je er het meeste hebt (politie, brandweer, ambulance) plus 1. Bijvoorbeeld: 5 brandweerkazernes en 3 ambulanceposten = 6 missies.",
                    join_alliance: "Ook kun je je aansluiten bij een team. Dat kan je vooral in het begin erg vooruit helpen.",
                    summary: "Dit zijn de basisprincipes van Meldkamerspel. Meldigen afhandelen, Credits verdienen, meer gebouwen en eenheden kopen, enzovoorts. Veel speelplezier! </br> Het team van Meldkamerspel"
                },
                mobile: {
                    contact: "Als je vragen hebt, kun je de veelgestelde vragen over het spel bekijken of een bezoekje brengen aan de forums of onze Facebook-pagina. Op het Blog vind je nog extra handleidingen en video's met uitleg over de verschillende functies in het spel.",
                    general: "Als volgende stap raden we je aan om een meldkamer(gratis!) te bouwen en dan zo snel mogelijk nieuwe gebouwen te bouwen, aangezien het maximumaantal missies gelijk is aan het type station waarvan je er het meeste hebt (politie, brandweer, ambulance) plus 1. Bijvoorbeeld: 5 brandweerkazernes en 3 ambulanceposten = 6 missies.",
                    join_alliance: "Ook kun je je aansluiten bij een team. Dat kan je vooral in het begin erg vooruit helpen.",
                    summary: "Dit zijn de basisprincipes van Meldkamerspel. Meldigen afhandelen, Credits verdienen, meer gebouwen en eenheden kopen, enzovoorts. Veel speelplezier! </br> Het team van Meldkamerspel"
                }
            }
        },
        commons: {
            collect: "Ophalen",
            "continue": "Nee",
            end: "Beëindigen",
            next: "Volgende",
            prev: "Vorige",
            skip: "Ja",
            skip_hint: "Wil je de tutorial echt stoppen? Je kunt hem later niet opnieuw openen. Je komt dan niet meer in aanmerking voor beloningen voor het voltooien van de tutorial."
        },
        rewards: {
            log: "Beloning voor het voltooien van de tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Geef je nieuwe gebouw een naam. Maak het herkenbaar en opschaalbaar. Bijvoorbeeld 'Politie nr. 0001'. Als je klaar bent, klik dan op 'Volgende'.",
                            select_building: "Kies nu eerst het type gebouw waar je mee wil beginnen. We raden je aan om te beginnen met de politie, zo maak je de beste start!"
                        },
                        welcome: "Hallo, welkom bij Meldkamerspel Politie! Ik zal je het een en ander leren om je te helpen je carrière bij de hulpdiensten goed te beginnen."
                    },
                    mobile: {
                        build_building: {
                            add_name: "Geef je nieuwe gebouw een naam. Maak het herkenbaar en opschaalbaar. Bijvoorbeeld 'Politie nr. 0001'. Als je klaar bent, klik dan op 'Volgende'.",
                            select_building: "Kies nu eerst het type gebouw waar je mee wil beginnen. We raden je aan om te beginnen met de politie, zo maak je de beste start!"
                        },
                        welcome: "Hallo, welkom bij Meldkamerspel Politie! Ik zal je het een en ander leren om je te helpen je carrière bij de hulpdiensten goed te beginnen."
                    }
                },
                rewards: {
                    browser: {
                        general: "Goed zo, je bent op weg om een geweldige meldkamercentralist te worden! Hier heb je %{coins} Coins om je verder op weg te helpen. </br> Het team van Meldkamerspel Politie"
                    },
                    mobile: {
                        general: "Goed zo, je bent op weg om een geweldige meldkamercentralist te worden! Hier heb je %{coins} Coins om je verder op weg te helpen. </br> Het team van Meldkamerspel Politie"
                    }
                },
                tips: {
                    browser: {
                        summary: "Dit zijn de basisprincipes van Meldkamerspel Politie. Meldigen afhandelen, Credits verdienen, meer gebouwen en eenheden kopen, enzovoorts. Veel speelplezier! </br> Het team van Meldkamerspel Politie"
                    },
                    mobile: {
                        summary: "Dit zijn de basisprincipes van Meldkamerspel Politie. Meldigen afhandelen, Credits verdienen, meer gebouwen en eenheden kopen, enzovoorts. Veel speelplezier! </br> Het team van Meldkamerspel Politie"
                    }
                }
            }
        }
    }
}, I18n.translations.es_ES = {
    common: {
        add: "Añadir",
        back: "Atrás",
        cancel: "Cancelar",
        change_saved: "Cambios guardados",
        coins_spend: "¿Seguro que quieres gastar estas monedas?",
        congratulations: "¡Enhorabuena!",
        content: "Contenido",
        copy: "Copiar",
        credits: "Créditos",
        "delete": "Eliminar",
        details: "Detalles",
        edit: "Editar",
        error: "Error",
        is_offline: "%{user} no está conectado.",
        is_offline_long: "%{user} no se ha conectado desde hace mucho tiempo",
        is_offline_with_duration: "%{user} no está conectado: %{duration}",
        is_online: "%{user} está conectado.",
        loading: "Cargando...",
        name: "Nombre",
        none: "Nada",
        of: "de",
        off: "No",
        on: "Sí",
        save: "Guardar",
        search: "Buscar",
        show: "Mostrar",
        user_not_found: "Usuario no encontrado",
        wrong_key: "Tecla equivocada"
    },
    javascript: {
        alarm: "Enviar",
        arrival: "Llegada",
        backalarm: "Cancelar",
        coins: "Monedas",
        credits: "Créditos",
        days: "días",
        few_seconds: "en pocos segundos",
        finish_in: "Termina en:",
        hours: "H",
        location_not_found: "No encontrado",
        messages: "Mensajes",
        minutes: "min.",
        missed_vehicle: "Falta:",
        mission_start_in: "Comienza en:",
        "new": "Nuevo",
        not_found_map: "No se ha encontrado el vehículo en el mapa",
        now: "Ahora",
        patient: "Paciente",
        patient_untouched: "Pacientes no tratados",
        poi_delete: "¿Seguro que quieres eliminar el PI %{caption}?",
        reload: "Recargar",
        sale: "Rebajas",
        sale_ended: "Oferta finalizada",
        secounds: "seg.",
        sicherheitswache_error: "El guardia de seguridad %{caption} no ha completado su misión, ya que no se han cumplido todos los criterios.",
        sicherheitswache_success: "El guardia de seguridad %{caption} ha completado su misión. Recibes %{credits} créditos.",
        start_in: "Comienza en: ",
        start_username: "Usuario:",
        time_left: "Tiempo restante:",
        to_building: "Ver edificio",
        to_mission: "Ver misión",
        understand: "Recibido",
        user_not_found: "No se ha encontrado al jugador.",
        vehicles_not_visible: "Los vehículos no están visibles. "
    },
    map: {
        alliance: "Alianza",
        alliance_chat: "Chat",
        alliance_chat_banned: "Tienes prohibido entrar al chat de la alianza.",
        alliance_chat_banned_admin: "Prohibición emitida por:",
        alliance_chat_banned_timeleft: "Tiempo restante:",
        alliance_chat_radio_off: "Radio de la alianza: No",
        alliance_chat_radio_on: "Radio de la alianza: Sí",
        alliance_event: "Evento",
        alliance_missions: "Misiones de alianza",
        alliance_missions_event: "Evento",
        ambulance: "Ambulancia",
        attended: "Respondido",
        cancel_alliance_event: "Cancelar evento de alianza",
        cancel_alliance_event_confirm: "¿Seguro que quieres cancelar el evento de alianza?",
        challenges: "",
        chat_history: "Historial de chat",
        congratulations: "¡Enhorabuena! Puedes ascender.",
        create_alliance_event: "Comenzar evento de alianza",
        create_alliance_operation: "Crea una misión de alianza a gran escala",
        emergency: "Emergencia",
        finishing: "Completando",
        join_alliance_infos: "Si estás en una alianza, otros jugadores podrán ofrecerte misiones.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Edificios",
            all_missions: "Misiones",
            alliance_buildings: "Edificios de la alianza",
            alliance_members: "Miembros",
            alliance_missions: "Compartido por la alianza",
            ambulance_station_missions: "Parque de ambulancias",
            ambulance_station_small_missions: "Parque de ambulancias (pequeño)",
            building_complex: "Complejo de edificios",
            buildings_section: "Instalaciones",
            clinic_missions: "Clínica",
            dispatch_center_missions: "Centralita",
            fire_school_missions: "Academia de bomberos",
            firehouse_missions: "Parque de bomberos",
            firehouse_small_missions: "Parque de bomberos (pequeño)",
            hospital_missions: "Hospital",
            map_filters: "Lista de filtros de mapa",
            mission_positions: "Puntos de interés (PI)",
            mission_positions_section: "PI",
            missions_section: "Misiones",
            police_copter_station_missions: "Helipuerto Policial",
            police_school_missions: "Academia de Policía",
            police_small_missions: "Comisaría de policía (pequeño)",
            police_special_forces: "Fuerzas especiales de la policía",
            police_station_missions: "Comisaría de policía",
            prison_missions: "Prisión",
            rapid_deployment_group: "Grupo de preparación rápida (GPR)",
            rescue_copter_station_missions: "Helipuerto médico",
            riot_police: "Policía antidisturbios",
            riot_police_missions: "Policía antidisturbios",
            staging_area_missions: "Zona de preparación",
            technical_aid_organization: "SAT",
            technical_aid_organization_school: "Academia SAT",
            user_buildings: "Mis edificios",
            user_missions: "Mis misiones",
            water_watch: "Rescate acuático",
            water_watch_missions: "Rescate acuático"
        },
        message: "Mensaje",
        mission: "Misión",
        missions_filtered_out: "Algunas misiones pueden ser filtradas. Por favor, revise los filtros de su mapa.",
        no_alliance_chat_impossible: "No estás en una alianza.",
        no_alliance_missions: "No hay misiones de alianza.",
        no_ambulance_missions: "No hay transportes para pacientes. Estarán disponibles en cuanto poseas un vehículo SVB y un hospital.",
        no_emergency_missions: "No hay misiones de emergencia disponibles. Solo habrá misiones de emergencia después de que construyas tu primera instalación.",
        no_radio_messages: "No has recibido mensajes de radio.",
        radio_messages: "Radio",
        restore_map: "Restaurar mapa",
        server_warning: "Mantenimiento del servidor a las 00:00. Se espera un tiempo de inactividad de 6 horas.",
        show_informations: "Verde: las misiones se mostrarán en la lista. Rojo: las misiones no se mostrarán.",
        sicherheitswache: "Misones planificadas",
        transport: "Transporte",
        unattended: "Sin respuesta"
    },
    fms: {
        going: "Respondiendo",
        not_ready: "Fuera de servicio",
        on_destination: "En el destino del transporte",
        on_place: "Presente",
        patient_transported: "Transportando paciente",
        prisoner_transported: "Transportando preso",
        ready_home: "Disponible en la instalación",
        ready_traveling: "Listo y disponible",
        talking_wish: "Petición de transporte",
        waiting_for_vehicle: "Esperando a remolque"
    },
    intervention_order: {
        back: "Atrás",
        category: "Categoría",
        colour: "Color",
        column: "Columna",
        column_number: "N.º de columna",
        column_number_hint: "Si hay un número de columna, la entrada en las normas de alerta y respuesta se mostrará en la columna correspondiente de la página de la alerta.",
        create_intervention_order: "Crear nueva norma de alerta y respuesta",
        "delete": "Eliminar",
        delete_all: "Eliminar todas las normas de alerta y respuesta",
        delete_all_confirm: "¿Seguro que quieres eliminar todas las normas de alerta y respuesta? ¡Las entradas exportadas existentes ya no están disponibles!",
        description: "Nombre",
        edit: "Editar",
        "export": {
            "export": "Exportar",
            "import": "Importar",
            import_done: "Las entradas seleccionadas se han importado y añadido a tu plan de alerta y respuesta.",
            saved: "Exportar las normas de alerta y respuesta",
            saved_text: "Las normas de alerta y respuesta están preparadas para ser exportadas. Mediante el enlace, otro jugador podrá importarlas. Mientras tanto, si cambias alguna norma, el cambio se aplicará automáticamente a lo exportado."
        },
        hotkey_hint: "Elije una tecla para esta selección de vehículos. En la ventana de la misión, pulsa ALT + tu tecla (ALT + SHIFT + tu tecla en Firefox o CTRL + ALT + tu tecla en MacOS) para seleccionarla.",
        intervention_order: "Editar normas de alerta y respuesta",
        name: "Nombre",
        no_intervention_created: "Todavía no has creado ninguna norma de alerta y respuesta.",
        options: "Opciones",
        reset: "Restablece la selección anterior en la ventana de alertas.",
        reset_hint: "Si has seleccionado el vehículo en la ventana de respuesta, puedes usar este botón para restablecer.",
        save: "Guardar",
        station: "Instalación",
        station_hint: "Si hay un edificio seleccionado, solo se seleccionarán los vehículos de ese edificio.",
        successfully_created: "Norma de alerta y respuesta creada correctamente.",
        successfully_deleted: "Norma de alerta y respuesta eliminada",
        successfully_updated: "Norma de alerta y respuesta actualizada correctamente.",
        vehicles: {
            ab_atemschutz_only: "Módulo ERA",
            ab_einsatzleitung_only: "Módulo de mando",
            ab_gefahrgut_only: "Módulo Hazmat",
            ab_oel_only: "Módulo de vertido de crudo",
            ab_ruest: "Módulo tecnológico de rescate",
            ab_ruest_rw: "",
            abl2wasser_only: "Módulo de mangueras",
            ambulance: "UVI móvil",
            ambulance_or_rapid_responder: "",
            arff: "CBA (Camión de bomberos de aeropuerto)",
            battalion_chief_unit: "Unidad de Mando y Comunicaciones",
            boot: "Botes (general)",
            dekon_p: "",
            division_chief_unit: "Unidad de mando",
            dlk_or_tm50: "",
            elw1_or_elw2: "Unidad de Mando y Comunicaciones, unidad de mando o módulo de mando móvil ",
            elw2_or_ab_elw: "Bomba de Rescate o Unidad de Apoyo de Rescate y Camión de Bomberos",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulancia o Helicóptero",
            fire_truck: "Camiones de bomberos",
            fireboat: "Barco de bomberos grande",
            fly_car: "VIR",
            fly_car_any: "VIR / Médico de cabecera",
            fukw: "",
            fustw_or_police_motorcycle: "Coche patrulla o Moto de Policía",
            fwk: "",
            gefkw: "",
            gkw: "Camión de usos múltiples",
            grtw: "Unidad para múltiples víctimas",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Hazmat",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Camión de rescate en altura",
            gw_messtechnik: "Camión de medición",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Retención de agua",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Vehículo con manguera",
            hems: "HEMS",
            hlf_only: "Vehículo de rescate",
            hlf_or_rw_and_lf: "Vehículo de rescate o vehículo de rescate pesado y camión de bomberos",
            hondengeleider: "",
            k9: "Unidad Canina",
            kdow_lna: "",
            kdow_orgl: "Unidad logística de AMV",
            kdow_orgl_any: "Unidad logística de AMV",
            ktw_b: "",
            ktw_or_rtw: "SVB o SVA",
            lebefkw: "Vehículo de mando ligero (leBefKw)",
            lf_only: "Camiones de bomberos",
            long_distance_ambulance: "Ambulancia SVB",
            mask_service_unit: "Unidad aérea",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Camión de transporte",
            mzb: "Barco multiusos",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulancia",
            oil_unit: "Camión para fuegos de aceite",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Coche patrulla",
            police_motorcycle: "Moto de Policía",
            polizeihubschrauber: "Helicóptero de Policía",
            rescue_vehicle: "Furgones de Útiles Varios",
            rescue_vehicle_only: "Furgón de Útiles Varios",
            rescueboat: "Barco de rescate grande",
            rettungstreppe: "",
            rth_only: "HEMS",
            schlauchwagen: "Camión cisterna",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Fuerzas especiales (GEO)",
            swat_armored_vehicle: "Unidad Antidisturbios",
            swat_suv: "Unidad GEO",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Camión de transporte técnico",
            thw_mzkw: "Vehículo multiusos",
            thw_tauchkraftwagen: "Equipo de buceo",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Camión cisterna",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Camión AE",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "¡El segundo paso es bautizarla! Dale un nombre reconocible y escalable, Como «Parque de bomberos #0001». Cuando acabes, haz clic en Sig.",
                        build_with_credits: "Ahora, construye tu edificio con créditos.",
                        new_building: "Haz clic en «Nuevo edificio».",
                        select_building: "Lo primero es elegir el tipo de edificio con el que quieres comenzar. ¡Te recomendamos que escojas un parque de bomberos! En cualquier caso, lo mejor es comenzar con una instalación pequeña.",
                        select_position: "Mueve el marcador azul al lugar donde quieres construir tu primera instalación."
                    },
                    pick_location: "Para comenzar, elige una ubicación. Puedes escribir su nombre en la barra de búsqueda o mover el mapa hasta llegar a ella. ¿Qué te parece si vamos a tu hogar?",
                    welcome: "¡Hola! Te damos la bienvenida a Centro de Mando.  ¡Te voy a enseñar algunos conceptos básicos para que puedas comenzar tu carrera como operador con buen pie!"
                },
                mobile: {
                    build_building: {
                        add_name: "¡El segundo paso es bautizarla! Dale un nombre reconocible y escalable, Como «Parque de bomberos #0001». Cuando acabes, haz clic en Sig.",
                        build_with_credits: "Ahora, construye tu edificio con créditos.",
                        new_building: "Comenzaremos eligiendo una ubicación para tu primer edificio. <br /> <br /> Haz clic en «Nuevo edificio».",
                        select_building: "Lo primero es elegir el tipo de edificio con el que quieres comenzar. ¡Te recomendamos que escojas un parque de bomberos! En cualquier caso, lo mejor es comenzar con una instalación pequeña."
                    },
                    welcome: "¡Hola! Te damos la bienvenida a Centro de Mando.  ¡Te voy a enseñar algunos conceptos básicos para que puedas comenzar tu carrera como operador con buen pie!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Desde este menú Puedes enviar a tus unidades a misiones.",
                        dispatch_menu_buttons: "Hay dos botones para enviar el vehículo: El primero, «Enviar», dirige a las unidades seleccionadas a la misión. El segundo también hace esto, pero después pasa a la siguiente misión. Por ahora, haz clic en el primer botón.",
                        dispatch_menu_mission_general: "Aquí puedes ver información general de la misión, como su nombre, dirección e icono. En las misiones en las que ya estés participando aparecerá un pequeño símbolo de una persona en lugar de la estrella.",
                        dispatch_menu_mission_progress: "Aquí puedes ver el progreso de la misión, así como el personal en el lugar del incidente y el tiempo restante.",
                        dispatch_menu_mission_specific: "Aquí puedes ver más información sobre la misión, qué unidades están respondiendo a la emergencia y cuáles han llegado ya allí.",
                        dispatch_menu_vehicle_list: "Esta es la lista de vehículos que tienes disponibles. Aquí puedes seleccionarlos. Elige el vehículo que quieras enviar y haz clic sobre él."
                    },
                    mobile: {
                        dispatch_menu: "Desde este menú Puedes enviar a tus unidades a misiones.",
                        dispatch_menu_buttons: "Hay dos botones para enviar el vehículo: El primero, «Enviar», dirige a las unidades seleccionadas a la misión. El segundo también hace esto, pero después pasa a la siguiente misión. Por ahora, haz clic en el primer botón.",
                        dispatch_menu_mission_general: "Aquí puedes ver información general de la misión, como su nombre, dirección e icono. En las misiones en las que ya estés participando aparecerá un pequeño símbolo de una persona en lugar de la estrella.",
                        dispatch_menu_mission_progress: "Aquí puedes ver el progreso de la misión, así como el personal en el lugar del incidente y el tiempo restante.",
                        dispatch_menu_mission_specific: "Aquí puedes ver más información sobre la misión, qué unidades están respondiendo a la emergencia y cuáles han llegado ya allí.",
                        dispatch_menu_vehicle_list: "Esta es la lista de vehículos que tienes disponibles. Aquí puedes seleccionarlos. Elige el vehículo que quieras enviar y haz clic sobre él."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Ahora, aprendamos cómo lidiar con incidentes. Haz clic en un botón «enviar» para abrir el menú.",
                        first_mission: "¡Genial! Tu primer edificio ya está construido. ¿Ves? Ya estás recibiendo avisos de emergencias."
                    },
                    mobile: {
                        dispatch_button: "Ahora, aprendamos cómo lidiar con incidentes. Haz clic en un botón «enviar» para abrir el menú.",
                        first_mission: "¡Genial! Tu primer edificio ya está construido. ¿Ves? Ya estás recibiendo avisos de emergencias."
                    }
                }
            },
            rewards: {
                browser: {
                    general: "¡Genial! Sigue así y te convertirás en un gran operador. ¡Aquí tienes %{coins} monedas para ayudarte a arrancar! </br> El equipo de Centro de Mando"
                },
                mobile: {
                    general: "¡Genial! Sigue así y te convertirás en un gran operador. ¡Aquí tienes %{coins} monedas para ayudarte a arrancar! </br> El equipo de Centro de Mando"
                }
            },
            tips: {
                browser: {
                    contact: "Si tienes alguna pregunta, puedes consultar el FAQ y visitar el foro del juego y nuestra página de Facebook.",
                    general: "Te recomendamos que tu siguiente paso sea construir una centralita y después, en cuanto sea posible, nuevas instalaciones, ya que el número máximo de misiones es igual al número máximo de instalaciones del mismo tipo (comisarías, parques de bomberos o de ambulancias...) más 1. Por ejemplo: 5 parques de bomberos y 3 de ambulancias permiten tener 6 misiones disponibles.",
                    join_alliance: "Además, unirse a una alianza es de gran ayuda, especialmente al principio.",
                    summary: "¡Ya conoces lo fundamental de Centro de Mando! Completar misiones, ganar créditos, comprar más unidades y vuelta a empezar. ¡Diviértete! </br> El equipo de Centro de Mando"
                },
                mobile: {
                    contact: "Si tienes alguna pregunta, puedes consultar el FAQ y visitar el foro del juego y nuestra página de Facebook.",
                    general: "Te recomendamos que tu siguiente paso sea construir una centralita y después, en cuanto sea posible, nuevas instalaciones, ya que el número máximo de misiones es igual al número máximo de instalaciones del mismo tipo (comisarías, parques de bomberos o de ambulancias...) más 1. Por ejemplo: 5 parques de bomberos y 3 de ambulancias permiten tener 6 misiones disponibles.",
                    join_alliance: "Además, unirse a una alianza es de gran ayuda, especialmente al principio.",
                    summary: "¡Ya conoces lo fundamental de Centro de Mando! Completar misiones, ganar créditos, comprar más unidades y vuelta a empezar. ¡Diviértete! </br> El equipo de Centro de Mando"
                }
            }
        },
        commons: {
            collect: "Recoger",
            "continue": "No",
            end: "Fin",
            next: "Sig.",
            prev: "Ant.",
            skip: "Sí",
            skip_hint: "¿Seguro que quieres saltarte el tutorial? Después, no podrás acceder a él.No podrás recibir la recompensa por completar el tutorial."
        },
        rewards: {
            log: "Recompensa por completar el tutorial."
        }
    }
}, I18n.translations.en_AU = {
    common: {
        add: "Add",
        back: "Back",
        cancel: "Cancel",
        change_saved: "Changes saved",
        coins_spend: "Do you really want to spend these coins?",
        congratulations: "Congratulations!",
        content: "Content",
        copy: "copy",
        credits: "Credits",
        "delete": "Delete",
        details: "Details",
        edit: "Edit",
        error: "Error",
        is_offline: "%{user} is offline.",
        is_offline_long: "Long time: %{user} is offline",
        is_offline_with_duration: "%{user} is offline: %{duration}",
        is_online: "%{user} is online.",
        loading: "Loading...",
        name: "Name",
        none: "None",
        of: "of",
        off: "Off",
        on: "On",
        save: "Save",
        search: "Search",
        show: "Show",
        user_not_found: "User not found",
        wrong_key: "Wrong key"
    },
    javascript: {
        alarm: "Dispatch",
        arrival: "Arrival",
        backalarm: "Cancel",
        coins: "Coins",
        credits: "Credits",
        days: "days",
        few_seconds: "in few seconds",
        finish_in: "Finish in:",
        hours: "H",
        location_not_found: "Not found",
        messages: "Messages",
        minutes: "min.",
        missed_vehicle: "It lacks:",
        mission_start_in: "Starts in:",
        "new": "New",
        not_found_map: "The vehicle hasn't been found on the map",
        now: "Now",
        patient: "Patient",
        patient_untouched: "Untreated patients",
        poi_delete: "Are you sure you want to delete the POI: %{caption}?",
        reload: "Reload",
        sale: "Sale",
        sale_ended: "Sale ended",
        secounds: "sec.",
        sicherheitswache_error: 'The security guard "%{caption}" was not successful, because not all the criteria were met.',
        sicherheitswache_success: 'The security guard "%{caption}" has been successfully carried out. Receive %{credits} Credits.',
        start_in: "Start in: ",
        start_username: "Starter:",
        time_left: "Time left:",
        to_building: "View Building",
        to_mission: "View Mission",
        understand: "Acknowledge",
        user_not_found: "The player was not found.",
        vehicles_not_visible: "Vehicles not visible. "
    },
    map: {
        alliance: "Alliance",
        alliance_chat: "Chat",
        alliance_chat_banned: "You are currently banned from the alliance chat.",
        alliance_chat_banned_admin: "Banned by:",
        alliance_chat_banned_timeleft: "Time remaining:",
        alliance_chat_radio_off: "Alliance Radio: Off",
        alliance_chat_radio_on: "Alliance Radio: On",
        alliance_event: "Event",
        alliance_missions: "Alliance Missions",
        alliance_missions_event: "Event",
        ambulance: "Ambulance",
        attended: "Attended",
        cancel_alliance_event: "Cancel alliance event",
        cancel_alliance_event_confirm: "Do you really want to cancel the alliance event?",
        challenges: "",
        chat_history: "Chat History",
        congratulations: "Congratulations! You can now be promoted.",
        create_alliance_event: "Start alliance event",
        create_alliance_operation: "Create a large scale alliance mission",
        emergency: "Emergency",
        finishing: "Finishing",
        join_alliance_infos: "If you are in an alliance, other players can freely give you missions.",
        map: "Map",
        map_filters: {
            all_buildings: "Buildings",
            all_missions: "Missons",
            alliance_buildings: "Alliance Buildings",
            alliance_members: "Members",
            alliance_missions: "Shared by Alliance",
            ambulance_station_missions: "Ambulance Station",
            ambulance_station_small_missions: "Ambulance station (Small station)",
            building_complex: "Building Complex",
            buildings_section: "Stations",
            clinic_missions: "Clinic",
            dispatch_center_missions: "Dispatch Center",
            fire_school_missions: "Fire Academy",
            firehouse_missions: "Fire Station",
            firehouse_small_missions: "Fire Station (Small)",
            hospital_missions: "Hospital",
            map_filters: "Map filters list",
            mission_positions: "Points of Interest (POIs)",
            mission_positions_section: "POIs",
            missions_section: "Missions",
            police_copter_station_missions: "Police Air Wing",
            police_school_missions: "Police Academy",
            police_small_missions: "Police Station (Small station)",
            police_special_forces: "Police special forces",
            police_station_missions: "Police Station",
            prison_missions: "Police Lockup",
            rapid_deployment_group: "Rapid Setup Group (SEG)",
            rescue_copter_station_missions: "Air Ambulance Station",
            riot_police: "Riot Police",
            riot_police_missions: "Riot Police",
            staging_area_missions: "Staging Area",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "My buildings",
            user_missions: "My missions",
            water_watch: "Water Rescue",
            water_watch_missions: "Water Rescue"
        },
        message: "Message",
        mission: "Mission",
        missions_filtered_out: "Some missions might be filtered out. Please, check your map filters.",
        no_alliance_chat_impossible: "You are not in an alliance.",
        no_alliance_missions: "There are currently no alliance missions.",
        no_ambulance_missions: "There are no ambulance missions. Ambulance missions can only occur when you have an ambulance and a hospital.",
        no_emergency_missions: "There are no emergency missions available. An emergency mission can occur after you made your first station.",
        no_radio_messages: "You didn't receive any radio messages.",
        radio_messages: "Radio",
        restore_map: "Restore Map",
        server_warning: "Server maintenance at 08:00 AEST. 6h downtime expected.",
        show_informations: "Green = The missions are shown in the list. Red = The missions aren't shown.",
        sicherheitswache: "Planned Appearances",
        transport: "Transport",
        unattended: "Unattended"
    },
    fms: {
        going: "Responding",
        not_ready: "Out of Service",
        on_destination: "At the transport destination",
        on_place: "On Scene",
        patient_transported: "Transporting Patient",
        prisoner_transported: "Transporting Prisoner",
        ready_home: "Available at Station",
        ready_traveling: "Clear and Available",
        talking_wish: "Transport Request",
        waiting_for_vehicle: "Awaiting vehicle to tow"
    },
    intervention_order: {
        back: "Back",
        category: "Category",
        colour: "Color",
        column: "Column",
        column_number: "Column number",
        column_number_hint: "If a column number is given, the Alarm and Response entry will be displayed in the corresponding column on the alert page.",
        create_intervention_order: "Create new Alarm and Response Regulation",
        "delete": "Delete",
        delete_all: "Delete Alarm and Response Regulations completely",
        delete_all_confirm: "Are you sure you want to delete the whole alarm and response regulation? Existing exported entries are no longer available!",
        description: "Name",
        edit: "Edit",
        "export": {
            "export": "Export",
            "import": "Import",
            import_done: "The selected entries have been imported and written to your Alarm and Response plan .",
            saved: "Alarm and Response Regulations Exports",
            saved_text: "Your Alarm and Response Regulation has been prepared for export. Via the link another player can import the Alarm and Response Regulation. If you change your Alarm and Response Regualtion in the meantime, this change will automatically be applied in the export."
        },
        hotkey_hint: "Choose a hotkey for this vehicle selection. Press at your window mission: ALT + your hotkey (or at Firefox: ALT + SHIFT + your hotkey or at mac os: ctrl + alt + your hotkey) to choose your vehicle selection.",
        intervention_order: "Edit Alarm and Response Regulations",
        name: "Name",
        no_intervention_created: "You haven't created any Alarm and Response Regulation yet.",
        options: "Options",
        reset: "Reset the previous selection in the alarm window.",
        reset_hint: "If you have selected the vehicle in the dispatch window, you can use this button to reset it.",
        save: "Save",
        station: "Station",
        station_hint: "When a building is selected, only vehicles of the corresponding building will be selected.",
        successfully_created: "Alarm and Response Regulation successfully created.",
        successfully_deleted: "Alarm and Response Regulation deleted",
        successfully_updated: "Alarm and Response Regulations successfully updated.",
        vehicles: {
            ab_atemschutz_only: "SCBA-Module",
            ab_einsatzleitung_only: "Command-Module",
            ab_gefahrgut_only: "HazMat-Module",
            ab_oel_only: "Oil spill-Module",
            ab_ruest: "Tech/Rescue-Module",
            ab_ruest_rw: "",
            abl2wasser_only: "Hose-Supply-Module",
            ambulance: "Ambulance",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Traffic Car",
            arff: "ARFF Tender",
            battalion_chief_unit: "Support Vehicle",
            boot: "Boats (General)",
            crew_carrier: "Crew Carrier",
            dekon_p: "",
            division_chief_unit: "Mobile Command Vehicle",
            dlk_or_tm50: "",
            elw1_or_elw2: "Support Vehicle or Mobile Command Vehicle",
            elw2_or_ab_elw: "Rescue Pump or Rescue Support Unit and Fire engine",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulance or Air Ambulance",
            fire_truck: "Pumper or Light Tanker or Tanker",
            fireboat: "Fire Boat",
            fly_car: "MICA",
            fly_car_any: "ICP / ICS / EMS Rescue",
            fukw: "",
            fustw_or_police_motorcycle: "Police car or Police Motorcycle",
            fwk: "",
            gefkw: "",
            gkw: "Utility Truck",
            grtw: "Mass Casualty Unit",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "HAZMAT Unit",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "SES Vehicle",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Hose Vehicle",
            hems: "Air Ambulance",
            hlf_only: "Rescue Pumper",
            hlf_or_rw_and_lf: "Rescue Pumper or Major Rescue Vehicle and Fire Engine",
            hondengeleider: "",
            k9: "K-9 Unit",
            kdow_lna: "",
            kdow_orgl: "Paramedic Supervisor",
            kdow_orgl_any: "Required Paramedic Supervisor",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Fire Trucks",
            long_distance_ambulance: "BLS ambulance",
            mask_service_unit: "BASU",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Rescue Boat",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulance",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Patrol Car",
            police_horse: "Mounted Police",
            police_motorcycle: "Police Motorcycle",
            polizeihubschrauber: "Police helicopter",
            rescue_vehicle: "Rescue",
            rescue_vehicle_only: "Rescue",
            rescueboat: "Marine Rescue Boat",
            rettungstreppe: "",
            rth_only: "Air Ambulance",
            schlauchwagen: "Bulk Water Tanker",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "TOG",
            swat_armored_vehicle: "TOG Armoured Vehicle",
            swat_suv: "TOG SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dive Team",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tanker Truck",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Turntable Ladders",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'Click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!",
                        select_position: "Move the blue marker where you want to build your first station!"
                    },
                    pick_location: "First pick a location to start! Type the name of the location you want to start in into the search bar or find it on the map yourself! What about your hometown?",
                    welcome: "Hello, welcome to MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                },
                mobile: {
                    build_building: {
                        add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Fire station #0001". When you are done, please click "Next"!',
                        build_with_credits: "Now build your building with credits!",
                        new_building: 'First we will pick a location to start and build your first building! <br /> <br /> To do that click on "New building"!',
                        select_building: "First choose the type of building you want to start with, we highly suggest you to start with fire services! In any case starting with a small station is advised!"
                    },
                    welcome: "Hello, welcome to MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    },
                    mobile: {
                        dispatch_menu: "This is the dispatch menu. From here you send your units to missions!",
                        dispatch_menu_buttons: 'These are your two dispatch buttons! The first one: "Dispatch" sends the selected units to the mission. The second one does the same as the first one but goes to the next mission. Click the first button for now.',
                        dispatch_menu_mission_general: "Here you can see the general mission information, that means the name, address, icon of the mission. The little man-icon appears and replaces a small star, on missions which you already participated in.",
                        dispatch_menu_mission_progress: "Here you can see how much progress has been made to deal with this mission as well as the number of staff on site and the time left to deal with the mission!",
                        dispatch_menu_mission_specific: "Here you can see more information about the mission, which units are responding to the call and which are already at the site",
                        dispatch_menu_vehicle_list: "This is the list of your available vehicles. You select the vehicles here. Now select your vehicle by clicking on it!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    },
                    mobile: {
                        dispatch_button: 'Now we want to learn how to deal with incidents. Open the dispatch menu by clicking on a "dispatch"-button!',
                        first_mission: "Great, you've built your first building! See, the first missions were reported to you!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                },
                mobile: {
                    general: "Great, you are on your way to becoming an awesome Missionchief! Here are %{coins} Coins. to help you get started! </br> Your MissionChief-team"
                }
            },
            tips: {
                browser: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                },
                mobile: {
                    contact: "If you have questions you can consult the in game FAQ or visit the game forums or our facebook page!",
                    general: "As a next step we would recommend you to build a dispatch center and then as soon as possible new stations, since the max number of missions equals the highest number of any of stations of a different type (police, fire, ambulance) plus 1; e.g. 5 fire and 3 ambulance stations = 6 missions.",
                    join_alliance: "Also, joining an alliance would help you greatly, especially in the beginning, so that's recommended, too.",
                    summary: "These are the basics of MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your MissionChief-team"
                }
            }
        },
        commons: {
            collect: "Collect",
            "continue": "No",
            end: "End",
            next: "Next",
            prev: "Prev",
            skip: "Yes",
            skip_hint: "Do you really want to cancel the tutorial? It can't be accessed at any later time. You will not be eligible for the tutorial completion reward."
        },
        rewards: {
            log: "Reward for finishing the tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Second give your new station a name! Make it recognisable and scalable! E.g. "Police station #0001". When you are done, please click "Next"!',
                            select_building: "First choose the type of building you want to start with, we highly suggest you to start with a police station! In any case starting with a small station is advised!"
                        },
                        welcome: "Hello, welcome to Police MissionChief! I will teach you some lessons to help you start off your emergency services career well!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins. to help you get started! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        general: "Great, you are on your way to becoming an awesome Police MissionChief! Here are %{coins} Coins. to help you get started! </br> Your Police MissionChief-team"
                    }
                },
                tips: {
                    browser: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    },
                    mobile: {
                        summary: "These are the basics of Police MissionChief! Accomplish missions, get credits, buy more units, repeat. Have fun playing! </br> Your Police MissionChief-team"
                    }
                }
            }
        }
    }
}, I18n.translations.sv_SE = {
    common: {
        add: "Lägg till",
        back: "Tillbaka",
        cancel: "Avbryt",
        change_saved: "Ändringar sparade",
        coins_spend: "Vill du verkligen spendera dina mynt?",
        congratulations: "Grattis!",
        content: "Innehåll",
        credits: "Krediter",
        "delete": "Ta bort",
        details: "Detaljer",
        edit: "Redigera",
        error: "Fel",
        is_offline: "%{user} är offline.",
        is_offline_long: "Länge: %{user} är offline",
        is_offline_with_duration: "%{user} är offline: %{duration}",
        is_online: "%{user} är online.",
        loading: "Laddar …",
        name: "Namn",
        none: "Ingen",
        of: "av",
        off: "Av",
        on: "På",
        save: "Spara",
        search: "Sök",
        show: "Visa",
        user_not_found: "Användaren kunde inte hittas",
        wrong_key: "Fel kod"
    },
    javascript: {
        alarm: "Larmcentral",
        arrival: "Ankomst",
        backalarm: "Avbryt",
        coins: "Mynt",
        credits: "Krediter",
        days: "dagar",
        few_seconds: "om några sekunder",
        finish_in: "Avsluta om:",
        hours: "tim",
        location_not_found: "Kunde inte hittas",
        messages: "Meddelanden",
        minutes: "min",
        missed_vehicle: "Det saknar:",
        mission_start_in: "Börjar om:",
        "new": "Ny",
        not_found_map: "Fordonet kunde inte hittas på kartan",
        now: "Nu",
        patient: "Patient",
        patient_untouched: "Obehandlade patienter",
        poi_delete: "Vill du verkligen ta bort intressepunkten %{caption}?",
        reload: "Ladda om",
        sale: "Sale",
        sale_ended: "Rean är slut",
        secounds: "sek",
        sicherheitswache_error: "Vakten %{caption} lyckades inte eftersom kriterierna inte uppfyllts.",
        sicherheitswache_success: "Vakten %{caption} har lyckats. Få %{credits} krediter.",
        start_in: "Åker om: ",
        start_username: "Startad av:",
        time_left: "Tid kvar:",
        to_building: "Visa byggnad",
        to_mission: "Visa uppdrag",
        understand: "Acceptera",
        user_not_found: "Spelaren kunde inte hittas.",
        vehicles_not_visible: "Fordon syns inte. ",
        water_approaching: "Påväg: %{amount} liter",
        water_missing: "Saknas: %{amount} liter",
        water_on_site: "På plats: %{amount} liter",
        water_selected: "Valt: %{amount} liter"
    },
    map: {
        alliance: "Allians",
        alliance_chat: "Chatt",
        alliance_chat_banned: "Du är bannlyst från allianschatten.",
        alliance_chat_banned_admin: "Bannad av:",
        alliance_chat_banned_timeleft: "Tid kvar:",
        alliance_chat_radio_off: "Alliansradio: Av",
        alliance_chat_radio_on: "Alliansradio: På",
        alliance_event: "Evenemang",
        alliance_missions: "Alliansuppdrag",
        alliance_missions_event: "Evenemang",
        ambulance: "Ambulans",
        attended: "Besvarade",
        cancel_alliance_event: "Avbryt alliansevenemanget",
        cancel_alliance_event_confirm: "Vill du verkligen avbryta alliansevenemanget?",
        chat_history: "Chatthistorik",
        congratulations: "Grattis! Nu kan du befordras.",
        create_alliance_event: "Starta evenemang",
        create_alliance_operation: "Skapa ett storskaligt uppdrag",
        emergency: "Akut",
        finishing: "I slutfas",
        join_alliance_infos: "Om du är med i en allians kan andra spelare ge dig uppdrag.",
        map: "Karta",
        map_filters: {
            all_buildings: "Byggnader",
            all_missions: "Uppdrag",
            alliance_buildings: "Alliansbyggnader",
            alliance_members: "Medlemmar",
            alliance_missions: "Delade av alliansen",
            ambulance_station_missions: "Ambulansstation",
            ambulance_station_small_missions: "Ambulansstation (liten)",
            building_complex: "Byggnadskomplex",
            buildings_section: "Stationer",
            clinic_missions: "Klinik",
            dispatch_center_missions: "Larmcentral",
            fire_school_missions: "Räddningsskola",
            firehouse_missions: "Brandstation",
            firehouse_small_missions: "Brandstation (liten)",
            hospital_missions: "Sjukhus",
            map_filters: "Intressepunkter",
            mission_positions: "Intressepunkter",
            mission_positions_section: "Intressepunkter",
            missions_section: "Uppdrag",
            police_copter_station_missions: "Polisflyg",
            police_school_missions: "Polisskola",
            police_small_missions: "Polisstation (liten)",
            police_special_forces: "Insatsstyrka",
            police_station_missions: "Polisstation",
            prison_missions: "Fängelse",
            rapid_deployment_group: "Snabb installationsgrupp (SEG)",
            rescue_copter_station_missions: "Ambulanshelikopterstation",
            riot_police: "Kravallpolis",
            riot_police_missions: "Kravallpolis",
            staging_area_missions: "Uppsamlingsområde",
            technical_aid_organization: "MSB",
            technical_aid_organization_school: "Träningscentrum",
            user_buildings: "Mina byggnader",
            user_missions: "Mina uppdrag",
            water_watch: "Vattenräddning",
            water_watch_missions: "Vattenräddning"
        },
        message: "Meddelande",
        mission: "Uppdrag",
        missions_filtered_out: "Vissa uppdrag kan filtreras bort. Kontrollera dina kartfilter.",
        no_alliance_chat_impossible: "Du är inte med i en allians.",
        no_alliance_missions: "Det finns inga alliansuppdrag just nu.",
        no_ambulance_missions: "Det finns ingen patienttransport. Patienttransporter kan ske först när du skaffat en lättvårdsambulans eller ett sjukhus.",
        no_emergency_missions: "Det finns inga akutuppdrag just nu. Ett akutuppdrag kan inträffa efter att du gjort din första station.",
        no_radio_messages: "Du har inga radiomeddelanden.",
        radio_messages: "Radio",
        restore_map: "Återställ karta",
        server_warning: "Vid midnatt sker serverunderhåll. Arbetet räknas pågå i cirka 6 timmar.",
        show_informations: "Grönt = Uppdragen visas i listan. Rött = Uppdragen visas inte.",
        sicherheitswache: "Planerade uppdrag",
        transport: "Transport",
        unattended: "Obesvarade"
    },
    fms: {
        going: "På uppdrag",
        not_ready: "Inte i tjänst",
        on_destination: "På transportmålet",
        on_place: "På platsen",
        patient_transported: "Transporterar patient",
        prisoner_transported: "Transporterar fånge",
        ready_home: "Tillgänglig på stationen",
        ready_traveling: "Tillgänglig",
        talking_wish: "Transportbegäran",
        waiting_for_vehicle: "Inväntar fordon att bärga"
    },
    intervention_order: {
        back: "Tillbaka",
        category: "Kategori",
        colour: "Färg",
        column: "Kolumn",
        column_number: "Kolumnnummer",
        column_number_hint: "Om du anger ett kolumnnummer kommer utryckningsinformationen visas i den kolumnen på larmsidan.",
        create_intervention_order: "Skapa ett nytt utryckningsförfarande",
        "delete": "Ta bort",
        delete_all: "Ta bort utryckningsförfarande",
        delete_all_confirm: "Vill du verkligen ta bort hela utryckningsförfarandet? Befintliga exporterade inlägg försvinner också!",
        description: "Namn",
        edit: "Redigera",
        "export": {
            "export": "Exportera",
            "import": "Importera",
            import_done: "De valda inläggen har importerats och skrivits in i ditt utryckningsförfarande.",
            saved: "Exporterade utryckningsförfaranden",
            saved_text: "Ditt utryckningsförfarande har förberetts för exportering. Med länken kan en annan spelare importera utryckningsförfarandet. Om du ändrar utryckningsförfarandet kommer exporten också att ändras."
        },
        hotkey_hint: "Välj en snabbtangent för det här fordonsvalet. Tryck i uppdragsfönstret: Alt + snabbtangenten (eller i Firefox: Alt + Skift + snabbtangenten, eller i Mac OS: Cmd + Alt + snabbtangenten) för att välja fordon.",
        intervention_order: "Ändra utryckningsförfarande",
        name: "Namn",
        no_intervention_created: "Du har inte skapat något utryckningsförfarande än.",
        options: "Alternativ",
        reset: "Återställ förra valet i larmfönstret.",
        reset_hint: "Om du har valt fordonet i utsändningsfönstret kan du använda den här knappen för att återställa det.",
        save: "Spara",
        station: "Station",
        station_hint: "När du valt en byggnad kommer bara fordon som motsvarar byggnaden att väljas.",
        successfully_created: "Utryckningsförfarandet har skapats.",
        successfully_deleted: "Utryckningsförfarandet har tagits bort",
        successfully_updated: "Utryckningsförfarandet har uppdaterats.",
        vehicles: {
            ab_atemschutz_only: "Andningsskydd-modul",
            ab_einsatzleitung_only: "Kommando-modul",
            ab_gefahrgut_only: "Farligt gods-modul",
            ab_oel_only: "Oljeläcka-modul",
            ab_ruest: "Teknik/räddning-modul",
            abl2wasser_only: "Slang-modul",
            ambulance: "Ambulans",
            arff: "Flygplansbrandbil",
            battalion_chief_unit: "Brandbefäl",
            boot: "Båtar (allmänt)",
            brush_truck: "Skogsbrandsfordon",
            brush_truck_1: "Terrängbil",
            brush_truck_2: "Bandvagn",
            brush_truck_3: "ATV",
            coresponder: "FIP",
            division_chief_unit: "Räddningsledning",
            elw1_or_elw2: "Brandbefäl eller Ledningsfordon",
            elw2_or_ab_elw: "Räddningspump eller stödenhet och brandbil",
            emergency_ambulance: "Ambulans eller Helikopter",
            fire_aviation: "Brandflygsenhet",
            fire_truck: "Släckbilar",
            fireboat: "Stor brandbåt",
            fly_car: "Akutläkarbil",
            fly_car_any: "Jourläkare / Akutläkarbil / FIP / IVPA / MC-Ambulans",
            fustw_or_police_motorcycle: "Radiobil eller Polismotorcykel",
            gkw: "Jeep",
            grtw: "Ambulansbuss",
            gw_gefahrgut: "Kemskyddsenhet",
            gw_hoehenrettung: "Repräddning",
            gw_messtechnik: "Mätteknik",
            gw_taucher: "Dykbil",
            gw_wasserrettung: "Vattenräddning",
            gwl2wasser_only: "Slangfordon",
            hems: "Ambulanshelikopter",
            hlf_only: "Räddningsbil",
            hlf_or_rw_and_lf: "Räddningsbil eller tyngre räddningsbil och brandbil",
            k9: "Hundenhet",
            kdow_orgl: "Ledningsfordon",
            kdow_orgl_any: "Ledningsfordon, ambulans",
            ktw_or_rtw: "Lättvårdsambulans eller Ambulans",
            lebefkw: "Lätt kommandofordon",
            lf_only: "Släckbilar",
            long_distance_ambulance: "Lättvårdsambulans",
            mask_service_unit: "Mobil luftenhet",
            mtw: "MTW",
            mzb: "Flerfunktionsbåt",
            nef_only: "Ambulans",
            oil_unit: "Oljeenhet",
            police_car: "Radiobil",
            police_horse: "Polishästar",
            police_motorcycle: "Polismotorcykel",
            polizeihubschrauber: "Polishelikopter",
            rescue_vehicle: "Lastväxlare",
            rescue_vehicle_only: "Lastväxlare",
            rescueboat: "Stor räddningsbåt",
            rth_only: "Ambulanshelikopter",
            schlauchwagen: "Tankbil",
            swat: "Insatsfordon",
            swat_armored_vehicle: "Bepansrat insatsfordon",
            swat_suv: "Insatsfordon",
            thw_mtw: "Grupptransportsbil",
            thw_mzkw: "Minibuss",
            thw_tauchkraftwagen: "Dykgrupp",
            tlf_only: "Tankbil",
            turntable_ladder: "Stegbilar",
            water_amount: "Liter av vatten"
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Efter det får du ge stationen ett namn. Gör det lätt att känna igen, och försök att hitta på något du kan bygga vidare på. Exempelvis "Brandstation nr 0001". Klicka på Nästa när du är klar.',
                        build_with_credits: "Nu får du bygga byggnaden för krediter!",
                        new_building: "Klicka på Ny byggnad.",
                        select_building: "Du får välja vad för sorts byggnad du vill börja med. Vi rekommenderar att börja med en brandstation! Oavsett vad du väljer är det bäst att börja med en liten station.",
                        select_position: "Flytta den blå markören till platsen där du vill bygga din första central."
                    },
                    pick_location: "Börja med att välja en plats! Skriv in namnet på platsen där du vill börja i sökfältet, eller leta upp den på kartan. Kanske din hemstad?",
                    welcome: "Hej och välkommen till Larmcentralen-spelet!  Jag ska lära dig några saker så du får en flygande start på nödutryckningskarriären."
                },
                mobile: {
                    build_building: {
                        add_name: 'Efter det får du ge stationen ett namn. Gör det lätt att känna igen, och försök att hitta på något du kan bygga vidare på. Exempelvis "Brandstation nr 0001". Klicka på Nästa när du är klar.',
                        build_with_credits: "Nu får du bygga byggnaden för krediter!",
                        new_building: "Först väljer vi en plats där du kan bygga din första byggnad. <br /><br />För att göra det klickar du på Ny byggnad.",
                        select_building: "Du får välja vad för sorts byggnad du vill börja med. Vi rekommenderar att börja med en brandstation! Oavsett vad du väljer är det bäst att börja med en liten station."
                    },
                    welcome: "Hej och välkommen till Larmcentralen-spelet!  Jag ska lära dig några saker så du får en flygande start på nödutryckningskarriären."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Det här är larmcentralsmenyn. Härifrån kan du skicka ut fordon på uppdrag!",
                        dispatch_menu_buttons: "De här två knapparna sätter igång uppdraget. Den första, Skicka ut, skickar ut de valda fordonen till uppdraget. Den andra gör samma sak, men går sedan vidare till nästa uppdrag. Du kan trycka på den första.",
                        dispatch_menu_mission_general: "Här ser du allmän information om uppdraget: namn, adress och uppdragsikon. Ikonen med den lilla mannen dyker upp och ersätter stjärnan i uppdrag du redan deltagit i.",
                        dispatch_menu_mission_progress: "Här kan du se dina framsteg i uppdraget, hur mycket personal du har på plats och hur lång tid som återstår!",
                        dispatch_menu_mission_specific: "Här ser du mer information om uppdraget, vilka fordon som besvarar anropet och vilka som redan befinner sig på platsen.",
                        dispatch_menu_vehicle_list: "I den här listan ser du dina tillgängliga fordon. Det är härifrån du väljer dina fordon. Klicka på ett för att välja det!"
                    },
                    mobile: {
                        dispatch_menu: "Det här är larmcentralsmenyn. Härifrån kan du skicka ut fordon på uppdrag!",
                        dispatch_menu_buttons: "De här två knapparna sätter igång uppdraget. Den första, Skicka ut, skickar ut de valda fordonen till uppdraget. Den andra gör samma sak, men går sedan vidare till nästa uppdrag. Du kan trycka på den första.",
                        dispatch_menu_mission_general: "Här ser du allmän information om uppdraget: namn, adress och uppdragsikon. Ikonen med den lilla mannen dyker upp och ersätter stjärnan i uppdrag du redan deltagit i.",
                        dispatch_menu_mission_progress: "Här kan du se dina framsteg i uppdraget, hur mycket personal du har på plats och hur lång tid som återstår!",
                        dispatch_menu_mission_specific: "Här ser du mer information om uppdraget, vilka fordon som besvarar anropet och vilka som redan befinner sig på platsen.",
                        dispatch_menu_vehicle_list: "I den här listan ser du dina tillgängliga fordon. Det är härifrån du väljer dina fordon. Klicka på ett för att välja det!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Nu ska vi lära oss hur man tar hand om rapporter. Öppna larmcentralsmenyn genom att trycka på Larmcentral.",
                        first_mission: "Toppen, du har byggt din första byggnad! Titta, du har fått in dina första uppdrag!"
                    },
                    mobile: {
                        dispatch_button: "Nu ska vi lära oss hur man tar hand om rapporter. Öppna larmcentralsmenyn genom att trycka på Larmcentral.",
                        first_mission: "Toppen, du har byggt din första byggnad! Titta, du har fått in dina första uppdrag!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Toppen, du börjar få full koll på hur man sköter en larmcentral! Här får du %{coins} mynt att komma igång med! </br>Teamet på Larmcentralen-spelet"
                },
                mobile: {
                    general: "Toppen, du börjar få full koll på hur man sköter en larmcentral! Här får du %{coins} mynt att komma igång med! </br>Teamet på Larmcentralen-spelet"
                }
            },
            tips: {
                browser: {
                    contact: "Om du har frågor kan du vända dig till avsnittet Frågor och svar i spelet, spelets forum eller vår Facebook-sida!",
                    general: "Efter det här rekommenderar jag att du bygger en larmcentral följt av nya stationer, för det maximala antalet uppdrag är lika med det högsta antalet stationer av samma typ (polis-, brand- eller ambulansstation) plus 1. Om du har 5 brandstationer och 3 ambulansstationer innebär det alltså att du kan ha 6 uppdrag.",
                    join_alliance: "Det kan även ge stora fördelar att gå med i en allians, särskilt tidigt i spelet, så det rekommenderas också.",
                    summary: "Det här är grunderna i Larmcentralen-spelet! Klara uppdrag, tjäna krediter, köp fler fordon, upprepa. Ha så kul! </br>Teamet på Larmcentralen-spelet"
                },
                mobile: {
                    contact: "Om du har frågor kan du vända dig till avsnittet Frågor och svar i spelet, spelets forum eller vår Facebook-sida!",
                    general: "Efter det här rekommenderar jag att du bygger en larmcentral följt av nya stationer, för det maximala antalet uppdrag är lika med det högsta antalet stationer av samma typ (polis-, brand- eller ambulansstation) plus 1. Om du har 5 brandstationer och 3 ambulansstationer innebär det alltså att du kan ha 6 uppdrag.",
                    join_alliance: "Det kan även ge stora fördelar att gå med i en allians, särskilt tidigt i spelet, så det rekommenderas också.",
                    summary: "Det här är grunderna i Larmcentralen-spelet! Klara uppdrag, tjäna krediter, köp fler fordon, upprepa. Ha så kul! </br>Teamet på Larmcentralen-spelet"
                }
            }
        },
        commons: {
            collect: "Hämta",
            "continue": "Nej",
            end: "Avsluta",
            next: "Nästa",
            prev: "Föregående",
            skip: "Ja",
            skip_hint: "Vill du verkligen avbryta handledningen? Du kommer inte åt den senare. I så fall får du ingen belöning för att ha klarat av handledningen."
        },
        rewards: {
            log: "Belöning för att ha klarat handledningen."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Efter det får du ge stationen ett namn. Gör det lätt att känna igen, och försök att hitta på något du kan bygga vidare på. Exempelvis "Polisstation nr 0001". Klicka på Nästa när du är klar.',
                            select_building: "Du får välja vad för sorts byggnad du vill börja med. Vi rekommenderar att börja med en polisstation! Oavsett vad du väljer är det bäst att börja med en liten station."
                        },
                        welcome: "Hej och välkommen till Larmcentralen-spelet Polis! Jag ska lära dig några saker så du får en flygande start på nödutryckningskarriären."
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Efter det får du ge stationen ett namn. Gör det lätt att känna igen, och försök att hitta på något du kan bygga vidare på. Exempelvis "Polisstation nr 0001". Klicka på Nästa när du är klar.',
                            select_building: "Du får välja vad för sorts byggnad du vill börja med. Vi rekommenderar att börja med en polisstation! Oavsett vad du väljer är det bäst att börja med en liten station."
                        },
                        welcome: "Hej och välkommen till Larmcentralen-spelet Polis! Jag ska lära dig några saker så du får en flygande start på nödutryckningskarriären."
                    }
                },
                rewards: {
                    browser: {
                        general: "Toppen, du börjar få full koll på hur man sköter en larmcentral! Här får du %{coins} mynt att komma igång med! </br>Teamet på Larmcentralen-spelet Polis"
                    },
                    mobile: {
                        general: "Toppen, du börjar få full koll på hur man sköter en larmcentral! Här får du %{coins} mynt att komma igång med! </br>Teamet på Larmcentralen-spelet Polis"
                    }
                },
                tips: {
                    browser: {
                        summary: "Det här är grunderna i Larmcentralen-spelet Polis! Klara uppdrag, tjäna krediter, köp fler fordon, upprepa. Ha så kul! </br>Teamet på Larmcentralen-spelet Polis"
                    },
                    mobile: {
                        summary: "Det här är grunderna i Larmcentralen-spelet Polis! Klara uppdrag, tjäna krediter, köp fler fordon, upprepa. Ha så kul! </br>Teamet på Larmcentralen-spelet Polis"
                    }
                }
            }
        }
    }
}, I18n.translations.pl_PL = {
    common: {
        add: "Dodaj",
        back: "Wstecz",
        cancel: "Anuluj",
        change_saved: "Zapisano zmiany",
        coins_spend: "Czy na pewno chcesz wydać monety?",
        congratulations: "Gratulacje!",
        content: "Zawartość",
        credits: "Kredyty",
        "delete": "Usuń",
        details: "Szczegóły",
        edit: "Edytuj",
        error: "Błąd",
        is_offline: "%{user} jest offline.",
        is_offline_long: "Od dawna: %{user} jest offline",
        is_offline_with_duration: "%{user} jest offline: %{duration}",
        is_online: "%{user} jest online.",
        loading: "Wczytywanie…",
        name: "Nazwa",
        none: "Brak",
        of: "z",
        off: "Wył.",
        on: "Wł.",
        save: "Zapisz",
        search: "Wyszukaj",
        show: "Pokaż",
        user_not_found: "Nie znaleziono użytkownika",
        wrong_key: "Nieprawidłowy klawisz"
    },
    javascript: {
        alarm: "Wyślij",
        arrival: "Przybycie",
        backalarm: "Anuluj",
        coins: "Monety",
        credits: "Kredyty",
        days: "dni",
        few_seconds: "za kilka sekund",
        finish_in: "Koniec za:",
        hours: "Godz.",
        location_not_found: "Nie znaleziono",
        messages: "Wiadomości",
        minutes: "min",
        missed_vehicle: "Brakuje:",
        mission_start_in: "Początek za:",
        "new": "Nowy",
        not_found_map: "Nie znaleziono pojazdu na mapie",
        now: "Teraz",
        patient: "Pacjent",
        patient_untouched: "Pacjenci bez opieki",
        poi_delete: "Czy na pewno chcesz usunąć UM: %{caption}?",
        reload: "Odśwież",
        sale: "Wyprzedaż",
        sale_ended: "Promocja zakończona",
        secounds: "s",
        sicherheitswache_error: "Zabezpieczenie „%{caption}” nie było skuteczne, ponieważ nie spełniono wszystkich kryteriów.",
        sicherheitswache_success: "Zabezpieczenie „%{caption}” zadziałało. Otrzymaj %{credits} kredytów(-y).",
        start_in: "Początek za: ",
        start_username: "Inicjator:",
        time_left: "Pozostało czasu:",
        to_building: "Pokaż budynek",
        to_mission: "Pokaż misję",
        understand: "Potwierdź",
        user_not_found: "Nie znaleziono gracza.",
        vehicles_not_visible: "Pojazdy nie są widoczne. ",
        water_approaching: "W drodze: %{amount} l.",
        water_missing: "Potrzebna: %{amount} l.",
        water_on_site: "Na miejscu: %{amount} l.",
        water_selected: "Wybrany: %{amount} l."
    },
    map: {
        alliance: "Sojusz",
        alliance_chat: "Czat",
        alliance_chat_banned: "Obecnie jest na ciebie nałożona blokada czatu sojuszu.",
        alliance_chat_banned_admin: "Zablokowano przez:",
        alliance_chat_banned_timeleft: "Pozostały czas:",
        alliance_chat_radio_off: "Radio sojuszu: Wył.",
        alliance_chat_radio_on: "Radio sojuszu: Wł.",
        alliance_event: "Wydarzenie",
        alliance_missions: "Misje sojuszu",
        alliance_missions_event: "Wydarzenie",
        ambulance: "Ambulans",
        attended: "Podjęte",
        cancel_alliance_event: "Anuluj wydarzenie sojuszu",
        cancel_alliance_event_confirm: "Czy na pewno chcesz anulować wydarzenie sojuszu?",
        challenges: "",
        chat_history: "Historia czatu",
        congratulations: "Gratulacje! Możesz teraz otrzymać awans.",
        create_alliance_event: "Rozpocznij wydarzenie sojuszu",
        create_alliance_operation: "Utwórz misję sojuszu na dużą skalę",
        emergency: "Sytuacja wyjątkowa",
        finishing: "Realizowane",
        join_alliance_infos: "Jeśli należysz do sojuszu, inni gracze mogą ci wyznaczać misje bez ograniczeń.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Budynki",
            all_missions: "Misje",
            alliance_buildings: "Budynki sojuszu",
            alliance_members: "Członkowie",
            alliance_missions: "Dzielone przez sojusz",
            ambulance_station_missions: "Stacja Pogotowia Ratunkowego",
            ambulance_station_small_missions: "Podstacja Pogotowia Ratunkowego",
            building_complex: "Kompleks budynków",
            buildings_section: "Posterunki",
            clinic_missions: "Klinika",
            dispatch_center_missions: "Centrum Powiadamiania Ratunkowego",
            fire_school_missions: "Szkoła Pożarnicza",
            firehouse_missions: "Jednostka Ratowniczo-Gaśnicza",
            firehouse_small_missions: "Remiza",
            hospital_missions: "Szpital",
            map_filters: "Użyteczne Miejsca (UM)",
            mission_positions: "Użyteczne Miejsca (UM)",
            mission_positions_section: "UM",
            missions_section: "Misje",
            police_copter_station_missions: "Lotnictwo policyjne",
            police_school_missions: "Szkoła Policyjna",
            police_small_missions: "Posterunek Policji",
            police_special_forces: "Jednostki specjalne policji",
            police_station_missions: "Komenda Policji",
            prison_missions: "Zakład Karny",
            rapid_deployment_group: "Grupa szybkiego montażu (SEG)",
            rescue_copter_station_missions: "Baza HEMS",
            riot_police: "Oddziały Prewencji",
            riot_police_missions: "Oddziały prewencji",
            staging_area_missions: "Miejsce koncentracji Sił i Środków",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Moje budynki",
            user_missions: "Moje misje",
            water_watch: "Ratownictwo wodne",
            water_watch_missions: "Ratownictwo wodne"
        },
        message: "Wiadomość",
        mission: "Misja",
        missions_filtered_out: "Niektóre misje mogą zostać odfiltrowane. Proszę sprawdzić filtry map.",
        no_alliance_chat_impossible: "Nie należysz do sojuszu.",
        no_alliance_missions: "W tej chwili nie ma misji sojuszu.",
        no_ambulance_missions: "Brak misji dla ambulansów. Misje dla ambulansów pojawiają się tylko, gdy masz ambulans i szpital.",
        no_emergency_missions: "Brak misji z sytuacją wyjątkową. Misja z sytuacją wyjątkową może się pojawić, gdy wybudujesz pierwszy posterunek.",
        no_radio_messages: "Nie otrzymano wiadomości drogą radiową.",
        radio_messages: "Radio",
        restore_map: "Przywróć mapę",
        server_warning: "Przewidujemy przerwę techniczną o północy. Przewidywany czas w okolicach 6 godzin.",
        show_informations: "Zielony = misje są pokazywane. Czerwony = misje nie są pokazywane.",
        sicherheitswache: "Planowane misje",
        transport: "Transport",
        unattended: "Niepodjęte"
    },
    fms: {
        going: "Reagowanie",
        not_ready: "Nieczynny",
        on_destination: "W miejscu docelowym transportu",
        on_place: "Na miejscu",
        patient_transported: "Transportuje pacjenta",
        prisoner_transported: "Transportuje więźnia",
        ready_home: "Dostępne na posterunku",
        ready_traveling: "Dostępne",
        talking_wish: "Żądanie transportu",
        waiting_for_vehicle: "Czeka na pojazd do holowania"
    },
    intervention_order: {
        back: "Wstecz",
        battalion_chief_unit: "Samochód Oficera Operacyjnego lub SLRr",
        category: "Kategoria",
        colour: "Kolor",
        column: "Kolumna",
        column_number: "Numer kolumny",
        column_number_hint: "Jeśli podano numer kolumny, zasada reagowania będzie wyświetlana w analogicznej kolumnie na stronie wezwania.",
        create_intervention_order: "Utwórz nową zasadę reagowania",
        "delete": "Usuń",
        delete_all: "Usuń wszystkie zasady reagowania",
        delete_all_confirm: "Czy na pewno chcesz usunąć całą zasadę reagowania? Istniejące wyeksportowane wersje przestały być dostępne!",
        description: "Nazwa",
        edit: "Edytuj",
        "export": {
            "export": "Eksportuj",
            "import": "Importuj",
            import_done: "Wybrane wpisy zostały zaimportowane i wprowadzone do twojej zasady reagowania.",
            saved: "Wyeksportowane zasady reagowania",
            saved_text: "Zasada reagowania została przygotowana do eksportu. Za pomocą tego linku możesz zaimportować zasadę reagowania. Jeśli w międzyczasie zmienisz zasadę reagowania, zostanie ona automatycznie uwzględniona w eksporcie."
        },
        hotkey_hint: "Wybierz skrót dla tego zestawu pojazdów. Naciśnij w oknie misji: ALT + skrót (lub w przeglądarce Firefox: ALT + SHIFT + skrót lub w systemie macOS: Ctrl + Alt + skrót), aby wybrać zestaw pojazdów.",
        intervention_order: "Edytuj zasady reagowania",
        name: "Nazwa",
        no_intervention_created: "Nie utworzono żadnych zasad reagowania.",
        options: "Opcje",
        reset: "Wyczyść poprzedni wybór w oknie wezwania.",
        reset_hint: "Jeśli w oknie wezwania został wybrany pojazd, możesz użyć tego przycisku, aby zresetować wybór.",
        save: "Zapisz",
        station: "Posterunek",
        station_hint: "Po wybraniu budynku zajęte zostaną tylko pojazdy, które są do niego przypisane.",
        successfully_created: "Utworzono zasadę reagowania.",
        successfully_deleted: "Usunięto zasadę reagowania",
        successfully_updated: "Zaktualizowano zasadę reagowania.",
        vehicles: {
            ab_atemschutz_only: "Moduł aparatu oddechowego",
            ab_einsatzleitung_only: "Moduł dowodzenia",
            ab_gefahrgut_only: "Moduł Rchem",
            ab_oel_only: "Moduł do sprzątania oleju",
            ab_ruest: "Moduł ratownictwa technicznego",
            ab_ruest_rw: "",
            abl2wasser_only: "Moduł wężowy",
            ambulance: "Ambulans P lub S",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Radiowóz WRD",
            arff: "SP LSP (samochód pożarniczy lotniskowej straży pożarnej)",
            battalion_chief_unit: "SLOp lub SLRr",
            boot: "Łodzie (ogólne)",
            dekon_p: "",
            division_chief_unit: "Samochód dowodzenia i łączności",
            dlk_or_tm50: "",
            elw1_or_elw2: "SLOp lub Samochód dowodzenia i łączności",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulans lub śmigłowiec LPR",
            fire_truck: "Samochody pożarnicze",
            fireboat: "Duża łódź strażacka",
            fly_car: "Samochód szefa brygady",
            fukw: "",
            fustw_or_police_motorcycle: "Radiowóz OPI lub Motocykl Policyjny",
            fwk: "Dźwig SP",
            gefkw: "",
            gkw: "Samochód kwatermistrzowski",
            grtw: "Jednostka do zdarzeń masowych",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Ratownictwo chemiczne",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "SRWys",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Samochód SLRw",
            gw_wasserrettung: "Ratownictwo wodne",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Samochód wężowy",
            hems: "Śmigłowiec LPR",
            hlf_only: "GBARt",
            hlf_or_rw_and_lf: "GBARt lub samochód ratownictwa technicznego oraz samochód gaśniczy",
            hondengeleider: "",
            k9: "Jednostka z psami",
            kdow_lna: "",
            kdow_orgl: "Szef służb ratownictwa medycznego",
            ktw_b: "",
            ktw_or_rtw: "Ambulans P, S lub T",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Samochody pożarnicze",
            long_distance_ambulance: "Ambulans T",
            mask_service_unit: "SPGaz",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Łódź wielozadaniowa",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulans",
            oil_unit: "Jednostka do sprzątania oleju",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Radiowóz OPI",
            police_motorcycle: "Motocykl Policyjny",
            polizeihubschrauber: "Helikopter Policyjny",
            rescue_vehicle: "Samochód Ratownictwa Technicznego",
            rescue_vehicle_only: "Samochód Ratownictwa Technicznego",
            rescueboat: "Duża łódź ratownicza",
            rettungstreppe: "",
            rth_only: "Śmigłowiec",
            schlauchwagen: "Cysterna z wodą",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SPKP",
            swat_armored_vehicle: "Opanerzony Pojazd SPKP",
            swat_suv: "SUV SPKP",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Zespół nurków",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Samochód dla ratownictwa wodno-nurkowego",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "SH lub SD",
            ulf: "",
            wasserwerfer: "",
            water_amount: "Litry wody",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Teraz musisz nazwać swój posterunek! Nazwa musi być rozpoznawalna i skalowalna! Np.: „Posterunek straży pożarnej #0001”. Gdy skończysz, kliknij opcję Dalej!",
                        build_with_credits: "Teraz wznieś budynek za kredyty!",
                        new_building: "Kliknij opcję Nowy budynek!",
                        select_building: "Wybierz rodzaj budynku, od którego chcesz zacząć, sugerujemy wybór straży pożarnej! W każdym wypadku najlepiej zacząć od małego posterunku!",
                        select_position: "Przesuń błękitny znacznik w miejsce, w którym chcesz zbudować pierwszy posterunek!"
                    },
                    pick_location: "Najpierw wybierz miejsce początkowe! W pasku wyszukiwania wpisz nazwę miejsca, w którym masz ochotę rozpocząć grę, bądź zlokalizuj je na mapie osobiście! Może chcesz wybrać swoje rodzinne miasto?",
                    welcome: "Witaj w grze Operator ratunkowy!  Pomożemy Ci dobrze rozpocząć karierę w służbach ratowniczych!"
                },
                mobile: {
                    build_building: {
                        add_name: "Teraz musisz nazwać swój posterunek! Nazwa musi być rozpoznawalna i skalowalna! Np.: „Posterunek straży pożarnej #0001”. Gdy skończysz, kliknij opcję Dalej!",
                        build_with_credits: "Teraz wznieś budynek za kredyty!",
                        new_building: "Najpierw wybierz miejsce początkowe i wznieś swój pierwszy budynek! <br /> <br /> W tym celu wybierz opcję Nowy budynek!",
                        select_building: "Wybierz rodzaj budynku, od którego chcesz zacząć, sugerujemy wybór straży pożarnej! W każdym wypadku najlepiej zacząć od małego posterunku!"
                    },
                    welcome: "Witaj w grze Operator ratunkowy!  Pomożemy Ci dobrze rozpocząć karierę w służbach ratowniczych!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "To menu wezwania. Możesz tu wysyłać swoje jednostki na misje!",
                        dispatch_menu_buttons: "To dwa przyciski wysyłania na wezwanie. Pierwszy: Opcja Wyślij posyła wybrane jednostki na misję. Drugi przycisk wydaje to samo polecenie i przenosi do następnej misji. Na razie kliknij pierwszy przycisk.",
                        dispatch_menu_mission_general: "Tutaj znajdują się ogólne informacje o misji, czyli nazwa, adres i ikona misji. Jeśli na misję została wysłana jednostka, gwiazdkę zastępuje ikona przestawiająca postać.",
                        dispatch_menu_mission_progress: "Tutaj można sprawdzić postępy w wykonywaniu misji oraz liczbę personelu na miejscu i czas pozostały do wykonania misji!",
                        dispatch_menu_mission_specific: "Tutaj znajdują się szczegółowe informacje o misji, w tym jednostki, które ją wykonują i te, które są już na miejscu.",
                        dispatch_menu_vehicle_list: "To lista dostępnych pojazdów. Tutaj wybierasz pojazdy. Wybierz pojazd, klikając go!"
                    },
                    mobile: {
                        dispatch_menu: "To menu wezwania. Możesz tu wysyłać swoje jednostki na misje!",
                        dispatch_menu_buttons: "To dwa przyciski wysyłania na wezwanie. Pierwszy: Opcja Wyślij posyła wybrane jednostki na misję. Drugi przycisk wydaje to samo polecenie i przenosi do następnej misji. Na razie kliknij pierwszy przycisk.",
                        dispatch_menu_mission_general: "Tutaj znajdują się ogólne informacje o misji, czyli nazwa, adres i ikona misji. Jeśli na misję została wysłana jednostka, gwiazdkę zastępuje ikona przestawiająca postać.",
                        dispatch_menu_mission_progress: "Tutaj można sprawdzić postępy w wykonywaniu misji oraz liczbę personelu na miejscu i czas pozostały do wykonania misji!",
                        dispatch_menu_mission_specific: "Tutaj znajdują się szczegółowe informacje o misji, w tym jednostki, które ją wykonują i te, które są już na miejscu.",
                        dispatch_menu_vehicle_list: "To lista dostępnych pojazdów. Tutaj wybierasz pojazdy. Wybierz pojazd, klikając go!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Teraz nauczymy się, jak reagować na wydarzenia. Otwórz menu wezwań, klikając przycisk Wyślij!",
                        first_mission: "Świetnie, masz już pierwszy budynek! Przyszły zgłoszenia pierwszych misji!"
                    },
                    mobile: {
                        dispatch_button: "Teraz nauczymy się, jak reagować na wydarzenia. Otwórz menu wezwań, klikając przycisk Wyślij!",
                        first_mission: "Świetnie, masz już pierwszy budynek! Przyszły zgłoszenia pierwszych misji!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Doskonale, wkrótce osiągniesz mistrzostwo w grze Operator ratunkowy! Oto %{coins} Monet, które pomogą Ci na początek! </br> Zespół gry Operator ratunkowy"
                },
                mobile: {
                    general: "Doskonale, wkrótce osiągniesz mistrzostwo w grze Operator ratunkowy! Oto %{coins} Monet, które pomogą Ci na początek! </br> Zespół gry Operator ratunkowy"
                }
            },
            tips: {
                browser: {
                    contact: "W przypadku niejasności warto odwiedzić dział często zadawanych pytań, forum gry lub naszą stronę na Facebooku!",
                    general: "Następnymi zalecanymi krokami są budowa centrum powiadamiania ratunkowego oraz jak najszybsze wzniesienie nowych posterunków, ponieważ maksymalna liczba misji jest równa najwyższej liczbie posterunków jednego typu (policji, straży pożarnej, pogotowia ratunkowego) plus 1, np. przy 5 posterunkach straży pożarnej i 3 pogotowia ratunkowego dostępnych jest 6 misji.",
                    join_alliance: "Bardzo pomocne jest również dołączenie do sojuszu, zwłaszcza na początku gry, dlatego zalecamy również ten krok.",
                    summary: "Oto podstawy gry Operator ratunkowy! Wykonuj misje, zdobywaj kredyty, kupuj kolejne jednostki, powtarzaj proces. Miłej gry! </br> Zespół gry Operator ratunkowy"
                },
                mobile: {
                    contact: "W przypadku niejasności warto odwiedzić dział często zadawanych pytań, forum gry lub naszą stronę na Facebooku!",
                    general: "Następnymi zalecanymi krokami są budowa centrum powiadamiania ratunkowego oraz jak najszybsze wzniesienie nowych posterunków, ponieważ maksymalna liczba misji jest równa najwyższej liczbie posterunków jednego typu (policji, straży pożarnej, pogotowia ratunkowego) plus 1, np. przy 5 posterunkach straży pożarnej i 3 pogotowia ratunkowego dostępnych jest 6 misji.",
                    join_alliance: "Bardzo pomocne jest również dołączenie do sojuszu, zwłaszcza na początku gry, dlatego zalecamy również ten krok.",
                    summary: "Oto podstawy gry Operator ratunkowy! Wykonuj misje, zdobywaj kredyty, kupuj kolejne jednostki, powtarzaj proces. Miłej gry! </br> Zespół gry Operator ratunkowy"
                }
            }
        },
        commons: {
            collect: "Odbierz",
            "continue": "Nie",
            end: "Zakończ",
            next: "Dalej",
            prev: "Wstecz",
            skip: "Tak",
            skip_hint: "Czy na pewno chcesz pominąć samouczek? Pamiętaj, że nie będzie on później dostępny. W ten sposób tracisz szansę na uzyskanie nagrody za ukończenie samouczka."
        },
        rewards: {
            log: "Nagroda za ukończenie samouczka."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Teraz musisz nazwać swój posterunek! Nazwa musi być rozpoznawalna i skalowalna! Np.: „Posterunek Policja #0001”. Gdy skończysz, kliknij opcję Dalej!",
                            select_building: "Wybierz rodzaj budynku, od którego chcesz zacząć, sugerujemy wybór posterunek policja! W każdym wypadku najlepiej zacząć od małego posterunku!"
                        },
                        welcome: "Witaj w grze Operator ratunkowy Policja! Pomożemy Ci dobrze rozpocząć karierę w służbach ratowniczych!"
                    },
                    mobile: {
                        build_building: {
                            add_name: "Teraz musisz nazwać swój posterunek! Nazwa musi być rozpoznawalna i skalowalna! Np.: „Posterunek Policja #0001”. Gdy skończysz, kliknij opcję Dalej!",
                            select_building: "Wybierz rodzaj budynku, od którego chcesz zacząć, sugerujemy wybór posterunek policja! W każdym wypadku najlepiej zacząć od małego posterunku!"
                        },
                        welcome: "Witaj w grze Operator ratunkowy Policja! Pomożemy Ci dobrze rozpocząć karierę w służbach ratowniczych!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Doskonale, wkrótce osiągniesz mistrzostwo w grze Operator ratunkowy Policja! Oto %{coins} Monet, które pomogą Ci na początek! </br> Zespół gry Operator ratunkowy Policja"
                    },
                    mobile: {
                        general: "Doskonale, wkrótce osiągniesz mistrzostwo w grze Operator ratunkowy Policja! Oto %{coins} Monet, które pomogą Ci na początek! </br> Zespół gry Operator ratunkowy Policja"
                    }
                },
                tips: {
                    browser: {
                        summary: "Oto podstawy gry Operator ratunkowy Policja! Wykonuj misje, zdobywaj kredyty, kupuj kolejne jednostki, powtarzaj proces. Miłej gry! </br> Zespół gry Operator ratunkowy Policja"
                    },
                    mobile: {
                        summary: "Oto podstawy gry Operator ratunkowy Policja! Wykonuj misje, zdobywaj kredyty, kupuj kolejne jednostki, powtarzaj proces. Miłej gry! </br> Zespół gry Operator ratunkowy Policja"
                    }
                }
            }
        }
    }
}, I18n.translations.it_IT = {
    common: {
        add: "Aggiungi",
        back: "Indietro",
        cancel: "Annulla",
        change_saved: "Modifiche salvate",
        coins_spend: "Vuoi davvero spendere queste monete?",
        congratulations: "Congratulazioni!",
        content: "Contenuto",
        credits: "Crediti",
        "delete": "Elimina",
        details: "Dettagli",
        edit: "Modifica",
        error: "Errore",
        is_offline: "%{user} non è in linea.",
        is_offline_long: "Ora estesa: %{user} è offline",
        is_offline_with_duration: "%{user} non è in linea: %{duration}",
        is_online: "%{user} è online.",
        loading: "Caricamento...",
        name: "Nome",
        none: "Nessuno",
        of: "di",
        off: "Off",
        on: "On",
        save: "Salva",
        search: "Cerca",
        show: "Mostra",
        user_not_found: "Impossibile trovare l'utente",
        wrong_key: "Codice errato"
    },
    javascript: {
        alarm: "Assegna",
        arrival: "Arrivo",
        backalarm: "Annulla",
        coins: "Monete",
        credits: "Crediti",
        days: "giorni",
        few_seconds: "in pochi secondi",
        finish_in: "Finisce tra:",
        hours: "H",
        location_not_found: "Non trovato",
        messages: "Messaggi",
        minutes: "min.",
        missed_vehicle: "Manca:",
        mission_start_in: "Inizia tra:",
        "new": "Nuovo",
        not_found_map: "Il veicolo non è stato trovato sulla mappa",
        now: "Adesso",
        patient: "Paziente",
        patient_untouched: "Pazienti non trattati",
        poi_delete: "Vuoi davvero eliminare il PDI: %{caption}?",
        reload: "Ricarica",
        sale: "Sale",
        sale_ended: "Vendita terminata",
        secounds: "sec.",
        sicherheitswache_error: 'La guardia di sicurezza "%{caption}" non è stata completata, perché non tutti i criteri sono stati soddisfatti.',
        sicherheitswache_success: 'La guardia di sicurezza "%{caption}" è stata completata. Ricevi %{credits} crediti.',
        start_in: "Inizia tra: ",
        start_username: "Avviatore:",
        time_left: "Tempo rimanente:",
        to_building: "Visualizza edificio",
        to_mission: "Visualizza missione",
        understand: "Conferma",
        user_not_found: "Il giocatore non è stato trovato.",
        vehicles_not_visible: "Veicoli non visibili. "
    },
    map: {
        alliance: "Alleanza",
        alliance_chat: "Chat",
        alliance_chat_banned: "Al momento sei escluso dalla chat dell'alleanza.",
        alliance_chat_banned_admin: "Escluso da:",
        alliance_chat_banned_timeleft: "Tempo rimanente:",
        alliance_chat_radio_off: "Radio alleanza: Off",
        alliance_chat_radio_on: "Radio alleanza: On",
        alliance_event: "Evento",
        alliance_missions: "Missioni dell'alleanza",
        alliance_missions_event: "Evento",
        ambulance: "Ambulanza",
        attended: "Completate",
        cancel_alliance_event: "Annulla evento dell'alleanza",
        cancel_alliance_event_confirm: "Vuoi davvero annullare l'evento dell'alleanza?",
        challenges: "",
        chat_history: "Cronologia chat",
        congratulations: "Congratulazioni! Adesso puoi ricevere una promozione.",
        create_alliance_event: "Inizia evento dell'alleanza",
        create_alliance_operation: "Crea una missione dell'alleanza su larga scala",
        emergency: "Emergenza",
        finishing: "In corso",
        join_alliance_infos: "Se fai parte di un'alleanza, altri giocatori possono assegnarti liberamente delle missioni.",
        map: "Mappa",
        map_filters: {
            all_buildings: "Edifici",
            all_missions: "Missioni",
            alliance_buildings: "Edifici dell'alleanza",
            alliance_members: "Membri",
            alliance_missions: "Condivisa dall'alleanza",
            ambulance_station_missions: "Stazione ambulanze",
            ambulance_station_small_missions: "Stazione ambulanze (stazione piccola)",
            building_complex: "Complesso di edifici",
            buildings_section: "Stazioni",
            clinic_missions: "Clinica",
            dispatch_center_missions: "Centrale operativa",
            fire_school_missions: "Scuola dei vigili del fuoco",
            firehouse_missions: "Caserma dei vigili del fuoco",
            firehouse_small_missions: "Caserma dei vigili del fuoco (piccola)",
            hospital_missions: "Ospedale",
            map_filters: "Punti di interesse (PDI)",
            mission_positions: "Punti di interesse (PDI)",
            mission_positions_section: "PDI",
            missions_section: "Missioni",
            police_copter_station_missions: "Reparto volo polizia",
            police_school_missions: "Scuola di polizia",
            police_small_missions: "Stazione di polizia (stazione piccola)",
            police_special_forces: "Forze di polizia speciali",
            police_station_missions: "Stazione di polizia",
            prison_missions: "Cella di commissariato",
            rapid_deployment_group: "Gruppo di installazione rapida (SEG)",
            rescue_copter_station_missions: "Stazione elisoccorso sanitario",
            riot_police: "Squadra antisommossa",
            riot_police_missions: "Squadra antisommossa",
            staging_area_missions: "Base temporanea",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "I miei edifici",
            user_missions: "Le mie missioni",
            water_watch: "Soccorso acquatico",
            water_watch_missions: "Soccorso acquatico"
        },
        message: "Messaggio",
        mission: "Missione",
        missions_filtered_out: "Alcune missioni potrebbero essere filtrate. Per favore, controlla i filtri della tua mappa.",
        no_alliance_chat_impossible: "Non fai parte di alcuna alleanza.",
        no_alliance_missions: "Al momento non ci sono missioni dell'alleanza.",
        no_ambulance_missions: "Nessuna missione delle ambulanze. Le missioni delle ambulanze possono verificarsi solo quando si dispone di un'ambulanza e di un ospedale.",
        no_emergency_missions: "Non ci sono missioni di emergenza disponibili. Una missione di emergenza può verificarsi dopo aver creato la prima stazione.",
        no_radio_messages: "Nessun messaggio radio ricevuto.",
        radio_messages: "Radio",
        restore_map: "Ripristina mappa",
        server_warning: "Manutenzione del server alle 00:00. Tempo di inattività previsto di 6 ore.",
        show_informations: "Verde = Le missioni vengono mostrate nell'elenco. Rosso = Le missioni non vengono mostrate.",
        sicherheitswache: "Missioni pianificate",
        transport: "Trasporto",
        unattended: "Da compiere"
    },
    fms: {
        going: "In risposta",
        not_ready: "Fuori servizio",
        on_destination: "Alla destinazione del trasporto",
        on_place: "Sulla scena",
        patient_transported: "Trasporto paziente",
        prisoner_transported: "Trasporto detenuto",
        ready_home: "Disponibile alla stazione",
        ready_traveling: "Pronto e disponibile",
        talking_wish: "Richiesta trasporto",
        waiting_for_vehicle: "In attesa del veicolo da trainare"
    },
    intervention_order: {
        back: "Indietro",
        category: "Categoria",
        colour: "Colore",
        column: "Colonna",
        column_number: "Numero di colonna",
        column_number_hint: "Se viene fornito un numero di colonna, la voce Allarme e risposta verrà visualizzata nella colonna corrispondente nella pagina di avviso.",
        create_intervention_order: "Crea nuova regola di allarme e risposta",
        "delete": "Elimina",
        delete_all: "Elimina completamente le regole di allarme e risposta",
        delete_all_confirm: "Vuoi davvero eliminare tutte le regole di allarme e risposta? Le voci esportate esistenti non sono più disponibili!",
        description: "Nome",
        edit: "Modifica",
        "export": {
            "export": "Esporta",
            "import": "Importa",
            import_done: "Le voci selezionate sono state importate e scritte nel piano di allarme e risposta.",
            saved: "Esportazioni regole di allarme e risposta",
            saved_text: "La regola di allarme e risposta è pronta per l'esportazione. Tramite il link un altro giocatore può importare la regola di allarme e risposta. Se nel frattempo modifichi una regola di allarme e risposta, tale modifica verrà automaticamente applicata nell'esportazione."
        },
        hotkey_hint: "Scegli un tasto di scelta rapida per questa selezione di veicoli. Premi durante la missione su Windows: ALT + tasto di scelta rapida (o su Firefox: ALT + SHIFT + tasto di scelta rapida oppure su Mac OS: ctrl + alt + tasto di scelta rapida) per scegliere la tua selezione di veicoli.",
        intervention_order: "Modifica le regole di allarme e risposta",
        name: "Nome",
        no_intervention_created: "Non hai ancora creato alcuna regola di allarme e risposta.",
        options: "Opzioni",
        reset: "Ripristina la selezione precedente nella finestra degli allarmi.",
        reset_hint: "Se hai selezionato il veicolo nella finestra di assegnazione, puoi utilizzare questo pulsante per ripristinarlo.",
        save: "Salva",
        station: "Stazione",
        station_hint: "Quando selezioni un edificio, verranno selezionati solo i veicoli dell'edificio corrispondente.",
        successfully_created: "Creazione della regola di allarme e risposta riuscita.",
        successfully_deleted: "Regola di allarme e risposta eliminata",
        successfully_updated: "Aggiornamento delle regole di allarme e risposta completato.",
        vehicles: {
            ab_atemschutz_only: "Modulo - SCBA",
            ab_einsatzleitung_only: "Modulo - Comando",
            ab_gefahrgut_only: "Modulo - N.B.C.R.",
            ab_oel_only: "Modulo - Perdita di olio",
            ab_ruest: "Modulo - Soccorso/Tecniche",
            ab_ruest_rw: "",
            abl2wasser_only: "Modulo - Alimentazione tubi",
            ambulance: "Ambulanza BLSD",
            ambulance_or_rapid_responder: "",
            arff: "ARFF (mezzo antincendio aeroportuale)",
            battalion_chief_unit: "Funzionario",
            boot: "Barca",
            commerce_police: "Volante Finanza",
            crew_carrier: "AF/BUS",
            dekon_p: "",
            division_chief_unit: "Veicoli comando mobile",
            dlk_or_tm50: "",
            elw1_or_elw2: "Modulo - Funzionario, Veicoli comando mobile o Comando mobile ",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Automedica (VLV)",
            fbi_bomb_tech: "Furgone artificieri",
            fire_truck: "Autopompe",
            fireboat: "Barca antincendio grande",
            fly_car: "Fly-Car",
            fukw: "",
            fustw_or_police_motorcycle: "Volante oppure Moto della Polizia",
            fwk: "AG",
            gefkw: "",
            gkw: "Furgone generico",
            grtw: "Unità antistrage",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "N.B.C.R.",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Camion Tecnico NSSA",
            gw_wasserrettung: "Ritenzione delle acque",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Autocarro per tubazioni",
            hems: "Elisoccorso HEMS",
            hlf_only: "Autopompa",
            hlf_or_rw_and_lf: "Autopompa oppure Polisoccorso e Autobotte",
            hondengeleider: "",
            k9: "Unità cinofila antidroga",
            kdow_lna: "",
            kdow_orgl: "DTS",
            ktw_b: "",
            ktw_or_rtw: "Ambulanza ordinaria o BLSD",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Mezzi antincendio",
            long_distance_ambulance: "Ambulanza ordinaria o BLSD",
            mask_service_unit: "Carro aria",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Trasporto truppa MTW",
            mzb: "Barca",
            naw: "Ambulanza MSA",
            naw_or_rtw_and_nef: "MSA o VLV",
            naw_or_rtw_and_nef_or_rth: "MSA o VLV o Elisoccorso",
            nef_only: "Automedica (VLV)",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Auto di pattuglia",
            police_motorcycle: "Moto della Polizia",
            polizeihubschrauber: "Elicottero della polizia",
            rescue_vehicle: "Polisoccorso",
            rescue_vehicle_only: "CA / POLI",
            rescueboat: "Barca di salvataggio grande",
            rettungstreppe: "",
            rth_only: "Elisoccorso",
            schlauchwagen: "Autobotte",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Unità speciali",
            swat_armored_vehicle: "Veicolo Antisommossa",
            swat_suv: "UOPI Suv",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Team sommozzatori",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Veicolo trasporto sommozzatori",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Autoscala",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Ora assegna un nome alla tua nuova stazione. Scegli un nome di facile identificazione e numerabile. Per esempio: "Caserma dei vigili del fuoco 0001". Quando hai finito, fai clic su "Avanti".',
                        build_with_credits: "Ora costruisci il tuo edificio utilizzando i crediti.",
                        new_building: 'Fai clic su "Nuovo edificio".',
                        select_building: "Per prima cosa scegli il tipo di edificio con cui vuoi cominciare; ti consiglio vivamente di iniziare con i vigili del fuoco. In ogni caso, sarebbe meglio iniziare con una stazione di piccole dimensioni.",
                        select_position: "Sposta il segnalino blu dove desideri costruire la tua prima stazione."
                    },
                    pick_location: "Per prima cosa, scegli una posizione. Digita nella barra di ricerca il nome del luogo da cui vuoi iniziare oppure trovalo sulla mappa. Che ne dici della tua città natale?",
                    welcome: "Ciao, ti do il benvenuto in Operatore 112!  Ti insegnerò un po' di cose per aiutarti a partire alla grande con la tua carriera nei servizi di emergenza."
                },
                mobile: {
                    build_building: {
                        add_name: 'Ora assegna un nome alla tua nuova stazione. Scegli un nome di facile identificazione e numerabile. Per esempio: "Caserma dei vigili del fuoco 0001". Quando hai finito, fai clic su "Avanti".',
                        build_with_credits: "Ora costruisci il tuo edificio utilizzando i crediti.",
                        new_building: 'Per prima cosa, scegliamo una posizione dove costruiremo il primo edificio. <br /> <br /> Per fare questo, fai clic su "Nuovo edificio".',
                        select_building: "Per prima cosa scegli il tipo di edificio con cui vuoi cominciare; ti consiglio vivamente di iniziare con i vigili del fuoco. In ogni caso, sarebbe meglio iniziare con una stazione di piccole dimensioni."
                    },
                    welcome: "Ciao, ti do il benvenuto in Operatore 112!  Ti insegnerò un po' di cose per aiutarti a partire alla grande con la tua carriera nei servizi di emergenza."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Questo è il menu di assegnazione. Da qui potrai inviare le tue unità in missione.",
                        dispatch_menu_buttons: 'Questi sono i due pulsanti per l\'assegnazione. Il primo pulsante: "Assegna" invia in missione le unità selezionate. Il secondo fa la stessa cosa del primo pulsante ma passa alla missione successiva. Per adesso, fai clic sul primo pulsante.',
                        dispatch_menu_mission_general: "Qui puoi visualizzare le informazioni generali della missione, ovvero nome, indirizzo, icona della missione. Nelle missioni a cui hai già preso parte, l'icona a forma di piccola stella viene sostituita da un'icona a forma di omino.",
                        dispatch_menu_mission_progress: "Qui puoi vedere i progressi già fatti in una missione, il numero di persone operative sul posto e il tempo rimasto per occuparti della missione.",
                        dispatch_menu_mission_specific: "Qui trovi maggiori informazioni sulla missione, sulle unità che rispondono alla chiamata e su quelle che si trovano già sul posto.",
                        dispatch_menu_vehicle_list: "Questa è la lista dei mezzi a tua disposizione. Qui puoi selezionare i veicoli. Seleziona un veicolo facendo clic su di esso."
                    },
                    mobile: {
                        dispatch_menu: "Questo è il menu di assegnazione. Da qui potrai inviare le tue unità in missione.",
                        dispatch_menu_buttons: 'Questi sono i due pulsanti per l\'assegnazione. Il primo pulsante: "Assegna" invia in missione le unità selezionate. Il secondo fa la stessa cosa del primo pulsante ma passa alla missione successiva. Per adesso, fai clic sul primo pulsante.',
                        dispatch_menu_mission_general: "Qui puoi visualizzare le informazioni generali della missione, ovvero nome, indirizzo, icona della missione. Nelle missioni a cui hai già preso parte, l'icona a forma di piccola stella viene sostituita da un'icona a forma di omino.",
                        dispatch_menu_mission_progress: "Qui puoi vedere i progressi già fatti in una missione, il numero di persone operative sul posto e il tempo rimasto per occuparti della missione.",
                        dispatch_menu_mission_specific: "Qui trovi maggiori informazioni sulla missione, sulle unità che rispondono alla chiamata e su quelle che si trovano già sul posto.",
                        dispatch_menu_vehicle_list: "Questa è la lista dei mezzi a tua disposizione. Qui puoi selezionare i veicoli. Seleziona un veicolo facendo clic su di esso."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Ora dovremo imparare a gestire gli incidenti. Apri il menu di assegnazione facendo clic sul pulsante "Assegna".',
                        first_mission: "Fantastico, hai costruito il tuo primo edificio! Vedi, ti sono state segnalate le prime missioni."
                    },
                    mobile: {
                        dispatch_button: 'Ora dovremo imparare a gestire gli incidenti. Apri il menu di assegnazione facendo clic sul pulsante "Assegna".',
                        first_mission: "Fantastico, hai costruito il tuo primo edificio! Vedi, ti sono state segnalate le prime missioni."
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Fantastico, stai per diventare un eccezionale Capomissione! Ecco %{coins} monete per aiutarti a partire! </br> Il team di Operatore 112"
                },
                mobile: {
                    general: "Fantastico, stai per diventare un eccezionale Capomissione! Ecco %{coins} monete per aiutarti a partire! </br> Il team di Operatore 112"
                }
            },
            tips: {
                browser: {
                    contact: "Se hai domande puoi consultare le FAQ del gioco oppure visitarne i forum o la nostra pagina di Facebook.",
                    general: "Come passo successivo ti consiglio di costruire una centrale operativa e poi, appena possibile, delle nuove stazioni. Il numero massimo di missioni è uguale al numero più alto di una delle stazioni di tipo diverso (polizia, vigili del fuoco, ambulanza) più 1; per esempio: 5 stazioni dei vigili del fuoco e 3 di ambulanze = 6 missioni.",
                    join_alliance: "Inoltre, ti consiglio di unirti a un'alleanza perché, soprattutto all'inizio, questo potrebbe esserti di grande aiuto.",
                    summary: "Queste sono le nozioni di base di Operatore 112. Completa missioni, ottieni crediti, acquista altre unità e ricomincia. Divertiti a giocare! </br> Il team di Operatore 112"
                },
                mobile: {
                    contact: "Se hai domande puoi consultare le FAQ del gioco oppure visitarne i forum o la nostra pagina di Facebook.",
                    general: "Come passo successivo ti consiglio di costruire una centrale operativa e poi, appena possibile, delle nuove stazioni. Il numero massimo di missioni è uguale al numero più alto di una delle stazioni di tipo diverso (polizia, vigili del fuoco, ambulanza) più 1; per esempio: 5 stazioni dei vigili del fuoco e 3 di ambulanze = 6 missioni.",
                    join_alliance: "Inoltre, ti consiglio di unirti a un'alleanza perché, soprattutto all'inizio, questo potrebbe esserti di grande aiuto.",
                    summary: "Queste sono le nozioni di base di Operatore 112. Completa missioni, ottieni crediti, acquista altre unità e ricomincia. Divertiti a giocare! </br> Il team di Operatore 112"
                }
            }
        },
        commons: {
            collect: "Raccogli",
            "continue": "false",
            end: "Fine",
            next: "Succ",
            prev: "Prec",
            skip: "Sì",
            skip_hint: "Vuoi davvero saltare il tutorial? Non sarà più accessibile in seguito. Non potrai qualificarti per il premio di completamento tutorial."
        },
        rewards: {
            log: "Ricompensa per aver completato il tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Ora assegna un nome alla tua nuova stazione. Scegli un nome di facile identificazione e numerabile. Per esempio: "Stazione di polizia 0001". Quando hai finito, fai clic su "Avanti".',
                            select_building: "Per prima cosa scegli il tipo di edificio con cui vuoi cominciare; ti consiglio vivamente di iniziare con la polizia. In ogni caso, sarebbe meglio iniziare con una stazione di piccole dimensioni."
                        },
                        welcome: "Ciao, ti do il benvenuto in Operatore 112 Polizia!  Ti insegnerò un po' di cose per aiutarti a partire alla grande con la tua carriera nei servizi di emergenza."
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Ora assegna un nome alla tua nuova stazione. Scegli un nome di facile identificazione e numerabile. Per esempio: "Stazione di polizia 0001". Quando hai finito, fai clic su "Avanti".',
                            select_building: "Per prima cosa scegli il tipo di edificio con cui vuoi cominciare; ti consiglio vivamente di iniziare con la polizia. In ogni caso, sarebbe meglio iniziare con una stazione di piccole dimensioni."
                        },
                        welcome: "Ciao, ti do il benvenuto in Operatore 112 Polizia!  Ti insegnerò un po' di cose per aiutarti a partire alla grande con la tua carriera nei servizi di emergenza."
                    }
                },
                rewards: {
                    browser: {
                        general: "Fantastico, stai per diventare un eccezionale Capomissione! Ecco %{coins} monete per aiutarti a partire! </br> Il team di Operatore 112 Polizia"
                    },
                    mobile: {
                        general: "Fantastico, stai per diventare un eccezionale Capomissione! Ecco %{coins} monete per aiutarti a partire! </br> Il team di Operatore 112 Polizia"
                    }
                },
                tips: {
                    browser: {
                        summary: "Queste sono le nozioni di base di Operatore 112 Polizia. Completa missioni, ottieni crediti, acquista altre unità e ricomincia. Divertiti a giocare! </br> Il team di Operatore 112 Polizia"
                    },
                    mobile: {
                        summary: "Queste sono le nozioni di base di Operatore 112 Polizia. Completa missioni, ottieni crediti, acquista altre unità e ricomincia. Divertiti a giocare! </br> Il team di Operatore 112 Polizia"
                    }
                }
            }
        }
    }
}, I18n.translations.fr_FR = {
    common: {
        add: "Ajouter",
        back: "Retour",
        cancel: "Annuler",
        change_saved: "Modifications enregistrées",
        coins_spend: "Voulez-vous vraiment dépenser ces pièces ?",
        congratulations: "Félicitations !",
        content: "Contenu",
        copy: "Copier",
        credits: "Crédits",
        "delete": "Supprimer",
        details: "Détails",
        edit: "Modifier",
        error: "Erreur",
        is_offline: "%{user} est hors ligne.",
        is_offline_long: "Période prolongée : %{user} est hors ligne",
        is_offline_with_duration: "%{user} est hors ligne: %{duration}",
        is_online: "%{user} est en ligne.",
        loading: "Chargement...",
        name: "Nom",
        none: "Aucun",
        of: "de",
        off: "OFF",
        on: "ON",
        save: "Enregistrer",
        search: "Rechercher",
        show: "Afficher",
        user_not_found: "Utilisateur introuvable",
        wrong_key: "Clé invalide"
    },
    javascript: {
        alarm: "Déployer",
        arrival: "Arrivée",
        backalarm: "Annuler",
        coins: "Pièces",
        credits: "Crédits",
        days: "jours",
        few_seconds: "dans quelques secondes",
        finish_in: "Terminer dans :",
        hours: "h",
        location_not_found: "Introuvable",
        messages: "Messages",
        minutes: "min",
        missed_vehicle: "Il manque :",
        mission_start_in: "Commence dans :",
        "new": "Neuf",
        not_found_map: "Impossible de trouver le véhicule sur la carte",
        now: "Maintenant",
        patient: "Patient",
        patient_untouched: "Patients non traités",
        poi_delete: "Voulez-vous vraiment supprimer ce point d’intérêt : %{caption} ?",
        reload: "Recharger",
        sale: "Soldes",
        sale_ended: "Fin de l’offre spéciale",
        secounds: "sec.",
        sicherheitswache_error: "Le garde de sécurité « %{caption} » a échoué dans sa mission, car il ne répondait pas à tous les critères.",
        sicherheitswache_success: "Le garde de sécurité « %{caption} » a rempli son objectif. Recevoir %{credits} crédits.",
        start_in: "Commencer dans : ",
        start_username: "Initiateur :",
        time_left: "Temps restant:",
        to_building: "Afficher le bâtiment",
        to_mission: "Afficher la mission",
        understand: "Bien reçu",
        user_not_found: "Impossible de trouver le joueur.",
        vehicles_not_visible: "Les véhicules ne sont pas visibles. "
    },
    map: {
        alliance: "Alliance",
        alliance_chat: "Salon",
        alliance_chat_banned: "Il vous est actuellement interdit de discuter dans le salon de l’alliance.",
        alliance_chat_banned_admin: "Interdiction émise par :",
        alliance_chat_banned_timeleft: "Temps restant :",
        alliance_chat_radio_off: "Radio de l’alliance : OFF",
        alliance_chat_radio_on: "Radio de l’alliance : ON",
        alliance_event: "Évènement",
        alliance_missions: "Missions d’alliance",
        alliance_missions_event: "Évènement",
        ambulance: "Ambulance",
        attended: "Assignée",
        cancel_alliance_event: "Annuler l’évènement d’alliance",
        cancel_alliance_event_confirm: "Voulez-vous vraiment annuler l’évènement d’alliance ?",
        challenges: "",
        chat_history: "Historique du salon",
        congratulations: "Félicitations ! Vous avez désormais accès à une promotion.",
        create_alliance_event: "Lancer l’évènement d’alliance",
        create_alliance_operation: "Créer une mission d’alliance majeure",
        emergency: "Urgence",
        finishing: "Presque achevée",
        join_alliance_infos: "Si vous appartenez à une alliance, les autres joueurs peuvent vous confier des missions.",
        map: "Carte",
        map_filters: {
            all_buildings: "Bâtiments",
            all_missions: "Missions",
            alliance_buildings: "Bâtiments d’alliance",
            alliance_members: "Membres",
            alliance_missions: "Partagées par l’alliance",
            ambulance_station_missions: "Poste Ambulancier",
            ambulance_station_small_missions: "Poste Ambulancier (petit)",
            building_complex: "Complexe",
            buildings_section: "Postes",
            clinic_missions: "Clinic",
            dispatch_center_missions: "Centre de Traitement des Appels",
            fire_school_missions: "Centre de Formation Départemental",
            firehouse_missions: "Centre de secours",
            firehouse_small_missions: "Centre de Première Intervention",
            hospital_missions: "Centre Hospitalier",
            map_filters: "Points d'intérêt (PI)",
            mission_positions: "Points d'intérêt (PI)",
            mission_positions_section: "PI",
            missions_section: "Missions",
            police_copter_station_missions: "Forces aériennes de la Gendarmerie nationale",
            police_school_missions: "Ecole de police",
            police_small_missions: "Police Municipale",
            police_special_forces: "Police special forces",
            police_station_missions: "Gendarmerie",
            prison_missions: "Prison",
            rapid_deployment_group: "Groupe à configuration rapide (GCR)",
            rescue_copter_station_missions: "Groupement d'hélicoptères de la Sécurité Civile",
            riot_police: "Brigade anti-émeutes",
            riot_police_missions: "Brigade anti-émeutes",
            staging_area_missions: "Centre de Regroupement des Moyens",
            technical_aid_organization: "Protection civile",
            technical_aid_organization_school: "École de protection civile",
            user_buildings: "Mes bâtiments",
            user_missions: "Mes missions",
            water_watch: "Secours nautique",
            water_watch_missions: "Secours nautique"
        },
        message: "Message",
        mission: "Mission",
        missions_filtered_out: "Certaines missions peuvent être filtrées. Veuillez vérifier les filtres de votre carte.",
        no_alliance_chat_impossible: "Vous n’appartenez à aucune alliance.",
        no_alliance_missions: "Aucune mission d’alliance à afficher.",
        no_ambulance_missions: "Il n'y a pas de transport de patient en attente. Les transports seront disponibles dès que vous aurez trois ambulances de transport ou de secours et un hôpital.",
        no_emergency_missions: "Aucune mission d’urgence à afficher. Vous pouvez recevoir des missions d’urgence dès lors que vous avez construit votre premier poste.",
        no_radio_messages: "Vous n’avez reçu aucun message radio.",
        radio_messages: "Radio",
        restore_map: "Restaurer la carte",
        server_warning: "Maintenance des serveurs à 00h00. Ceux-ci seront indisponibles durant une durée approximative de 6h00.",
        show_informations: "Vert = les missions s’affichent dans la liste. Rouge = les missions ne s’affichent pas.",
        sicherheitswache: "Missions prévues",
        transport: "Transport",
        unattended: "Non assignée"
    },
    fms: {
        going: "En intervention",
        not_ready: "Hors service",
        on_destination: "À la destination de transport",
        on_place: "Sur les lieux",
        patient_transported: "Transporte le patient",
        prisoner_transported: "Transporte le prisonnier",
        ready_home: "Disponible au poste",
        ready_traveling: "Prêt et opérationnel",
        talking_wish: "Demande de transport",
        waiting_for_vehicle: "En attente du véhicule à remorquer"
    },
    intervention_order: {
        back: "Retour",
        category: "Catégorie",
        colour: "Couleur",
        column: "Colonne",
        column_number: "Numéro de colonne",
        column_number_hint: "Si un numéro de colonne est indiqué, l’entrée de la Régulation d’alertes et d’interventions s’affichera dans la colonne correspondante sur la page d’alertes.",
        create_intervention_order: "Créer une nouvelle Régulation d’alertes et d’interventions",
        "delete": "Supprimer",
        delete_all: "Supprimer les Régulations d’alertes et d’interventions",
        delete_all_confirm: "Voulez-vous vraiment supprimer toute Régulation d’alertes et d’interventions ? Les entrées existantes exportées ne sont plus disponibles !",
        description: "Nom",
        edit: "Modifier",
        "export": {
            "export": "Exporter",
            "import": "Importer",
            import_done: "Les entrées sélectionnées ont été importées et incorporées à votre Régulation d’alertes et d’interventions.",
            saved: "Exportations des Régulations d’alertes et d’interventions",
            saved_text: "Votre Régulation d’alertes et d’interventions est prête à l’exportation. Grâce à ce lien, un autre joueur peut importer cette Régulation d’alertes et d’interventions. Si d’ici là vous modifiez votre Régulation d’alertes et d’interventions, ce changement sera automatiquement appliqué à l’exportation."
        },
        hotkey_hint: "Choisissez un raccourci pour cette sélection de véhicules. Dans votre fenêtre de mission, appuyez sur : ALT + votre raccourci (ou sur Firefox : ALT + Shift + votre raccourci, ou sur Mac OS : CTRL + ALT + votre raccourci) pour choisir votre sélection de véhicules.",
        intervention_order: "Modifier les Régulations d’alertes et d’interventions",
        name: "Nom",
        no_intervention_created: "Vous n’avez créé aucune Régulation d’alertes et d’interventions à l’heure actuelle.",
        options: "Options",
        reset: "Réinitialisez la sélection précédente dans la fenêtre d’alertes.",
        reset_hint: "Si vous avez sélectionné le véhicule dans la fenêtre de déploiement, vous pouvez utiliser ce bouton pour la réinitialiser.",
        save: "Enregistrer",
        station: "Poste",
        station_hint: "Quand un bâtiment est sélectionné, seuls les véhicules dépendant de celui-ci le sont également.",
        successfully_created: "Régulation d’alertes et d’interventions créée.",
        successfully_deleted: "Régulation d’alertes et d’interventions supprimée",
        successfully_updated: "Régulations d’alertes et d’interventions mises à jour.",
        vehicles: {
            ab_atemschutz_only: "Module ARI",
            ab_einsatzleitung_only: "Module de commandement",
            ab_gefahrgut_only: "Module risques chimiques",
            ab_oel_only: "Module marée noire",
            ab_ruest: "Module tech/sauvetage",
            ab_ruest_rw: "",
            abl2wasser_only: "Module approv. lance à eau",
            ambulance: "ASSU / VSAV / AR",
            ambulance_or_rapid_responder: "",
            arff: "VIA (fourgon d’incendie d’aéroport)",
            battalion_chief_unit: "Chef de groupe",
            boot: "Bateaux (généraux)",
            brush_truck: "CCF",
            brush_truck_1: "CCFS",
            brush_truck_2: "CCFM",
            brush_truck_3: "CCFL",
            dekon_p: "",
            division_chief_unit: "Véhicule poste de commandement",
            dlk_or_tm50: "",
            elw1_or_elw2: "Chef de Groupe ou PC",
            elw2_or_ab_elw: "Pompe de secours ou unité de secours en renfort et véhicule d'incendie",
            elw3: "VLHR",
            elw_airport: "",
            emergency_ambulance: "Ambulance d’urgence ou hélicoptère",
            fire_truck: "Fourgons d’incendie",
            fireboat: "Grand bateau d’incendie",
            fly_car: "VRM",
            fly_car_any: "VL SSSM / VLM",
            fukw: "",
            fustw_or_police_motorcycle: "Véhicule de patrouille ou Unité motocycliste",
            fwk: "",
            gefkw: "",
            gkw: "Véhicule Tout Usage",
            grtw: "Unité accidents majeurs",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Véhicules risques chimiques",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "VGRIMP",
            gw_messtechnik: "GW-M",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "VPL",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Véhicule à lance",
            hems: "Services d’urgence",
            hlf_only: "Véhicule de secours",
            hlf_or_rw_and_lf: "Véhicule de secours ou véhicule de secours lourd et véhicule d'incendie",
            hondengeleider: "",
            k9: "Brigade canine",
            kdow_lna: "",
            kdow_orgl: "PC DSM",
            ktw_b: "",
            ktw_or_rtw: "Ambulance de secours ou Ambulance de transport",
            lebefkw: "Camionnette de police",
            lf_only: "Fourgons d’incendie",
            long_distance_ambulance: "Ambulance Type A",
            mask_service_unit: "Véhicule d'Assistance Respiratoire",
            mek_mtf: "",
            mek_zf: "",
            mtw: "VSAV",
            mzb: "BLS",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulance",
            oil_unit: "Camion d’assainissement",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Voiture de patrouille",
            police_motorcycle: "Unité motocycliste",
            polizeihubschrauber: "Hélicoptère de police",
            rescue_vehicle: "Véhicule de secours routier",
            rescue_vehicle_only: "Secours routier",
            rescueboat: "Grand bateau de sauvetage",
            rettungstreppe: "",
            rth_only: "Hélicoptère",
            schlauchwagen: "Camion-citerne ou CCFS",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SWAT",
            swat_armored_vehicle: "Véhicule renforcé du SWAT",
            swat_suv: "SUV du SWAT",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Fourgon de la protection civile",
            thw_mzkw: "Camion de la protection civile",
            thw_tauchkraftwagen: "Équipe de plongée",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Camion-citerne",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Moyen Elévateur Aérien",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Ensuite, donnez un nom à votre poste ! Il faut qu'il soit identifiable et évolutif. Par exemple : « Caserne de pompiers n°1 ». Cliquez sur « Suiv. » lorsque vous avez terminé !",
                        build_with_credits: "Construisez maintenant votre bâtiment à l'aide de crédits !",
                        new_building: "Cliquez sur « Nouveau bâtiment » !",
                        select_building: "Choisissez d'abord le type de bâtiment avec lequel vous voulez débuter. Nous vous recommandons de démarrer avec une caserne de pompiers. Dans tous les cas, nous vous conseillons un petit poste !",
                        select_position: "Déplacez le marqueur bleu où vous voulez construire votre premier poste !"
                    },
                    pick_location: "Tout d'abord, choisissez un endroit où démarrer. Indiquez le nom du lieu depuis lequel vous voulez commencer dans la barre de recherche ou directement sur la carte. Que diriez-vous de la ville où vous résidez ?",
                    welcome: "Bonjour, et bienvenue sur Opérateur 112 !  Je vais vous aider à bien démarrer votre carrière dans les services d'urgence !"
                },
                mobile: {
                    build_building: {
                        add_name: "Ensuite, donnez un nom à votre poste ! Il faut qu'il soit identifiable et évolutif. Par exemple : « Caserne de pompiers n°1 ». Cliquez sur « Suiv. » lorsque vous avez terminé !",
                        build_with_credits: "Construisez maintenant votre bâtiment à l'aide de crédits !",
                        new_building: "Nous allons d'abord choisir un emplacement pour commencer et construire votre premier bâtiment ! <br /> <br /> Pour cela, cliquez sur « Nouveau bâtiment ».",
                        select_building: "Choisissez d'abord le type de bâtiment avec lequel vous voulez débuter. Nous vous recommandons de démarrer avec une caserne de pompiers. Dans tous les cas, nous vous conseillons un petit poste !"
                    },
                    welcome: "Bonjour, et bienvenue sur Opérateur 112 !  Je vais vous aider à bien démarrer votre carrière dans les services d'urgence !"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Voici le menu de déploiement. Vous pouvez d'ici envoyer vos unités en mission !",
                        dispatch_menu_buttons: "Ce sont vos deux boutons de déploiement ! Le premier « Déployer » envoie les unités sélectionnées pour la mission. Le second fait la même chose que le premier, mais pour la mission suivante. Pour l'instant, cliquez sur le premier bouton.",
                        dispatch_menu_mission_general: "Ici sont affichées les informations générales de mission, c'est-à-dire le nom, l'adresse et l'icône de la mission. La petite icône en forme de silhouette apparaît et remplace l'étoile pour les missions auxquelles vous participez déjà.",
                        dispatch_menu_mission_progress: "Vous pouvez voir ici votre progression sur cette mission, le personnel sur site ainsi que le temps restant pour accomplir la mission !",
                        dispatch_menu_mission_specific: "Vous pouvez consulter ici plus d'informations sur la mission, voir quelles unités répondent à l'appel, et quelles sont celles qui sont déjà sur site.",
                        dispatch_menu_vehicle_list: "Voici la liste de vos véhicules disponibles. Vous pouvez sélectionner les véhicules d'ici. Sélectionnez votre véhicule en cliquant dessus !"
                    },
                    mobile: {
                        dispatch_menu: "Voici le menu de déploiement. Vous pouvez d'ici envoyer vos unités en mission !",
                        dispatch_menu_buttons: "Ce sont vos deux boutons de déploiement ! Le premier « Déployer » envoie les unités sélectionnées pour la mission. Le second fait la même chose que le premier, mais pour la mission suivante. Pour l'instant, cliquez sur le premier bouton.",
                        dispatch_menu_mission_general: "Ici sont affichées les informations générales de mission, c'est-à-dire le nom, l'adresse et l'icône de la mission. La petite icône en forme de silhouette apparaît et remplace l'étoile pour les missions auxquelles vous participez déjà.",
                        dispatch_menu_mission_progress: "Vous pouvez voir ici votre progression sur cette mission, le personnel sur site ainsi que le temps restant pour accomplir la mission !",
                        dispatch_menu_mission_specific: "Vous pouvez consulter ici plus d'informations sur la mission, voir quelles unités répondent à l'appel, et quelles sont celles qui sont déjà sur site.",
                        dispatch_menu_vehicle_list: "Voici la liste de vos véhicules disponibles. Vous pouvez sélectionner les véhicules d'ici. Sélectionnez votre véhicule en cliquant dessus !"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Il vous faut maintenant apprendre à gérer les incidents. Ouvrez le menu de déploiement en cliquant sur le bouton « Déployer » !",
                        first_mission: "Parfait, vous avez construit votre premier bâtiment ! Regardez, on commence déjà à vous signaler des missions !"
                    },
                    mobile: {
                        dispatch_button: "Il vous faut maintenant apprendre à gérer les incidents. Ouvrez le menu de déploiement en cliquant sur le bouton « Déployer » !",
                        first_mission: "Parfait, vous avez construit votre premier bâtiment ! Regardez, on commence déjà à vous signaler des missions !"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Parfait, vous êtes bien parti pour devenir un Opérateur 112 de talent ! Voici %{coins} pièces pour vous aider à démarrer ! </br> L'équipe d'Opérateur 112"
                },
                mobile: {
                    general: "Parfait, vous êtes bien parti pour devenir un Opérateur 112 de talent ! Voici %{coins} pièces pour vous aider à démarrer ! </br> L'équipe d'Opérateur 112"
                }
            },
            tips: {
                browser: {
                    contact: "Si vous avez des questions, vous pouvez consulter la FAQ du jeu, visiter les forums du jeu ou notre page Facebook !",
                    general: "Nous vous recommandons pour l'étape suivante de construire un centre de secours et, dès que possible, de nouveaux postes puisque le nombre de missions maximum équivaut au plus grand nombre de postes d'un genre (police, pompiers, ambulance) plus 1. Par exemple, 5 casernes de pompiers et 3 postes ambulanciers = 6 missions.",
                    join_alliance: "De plus, nous vous recommandons de rejoindre une alliance, ce qui peut grandement vous aider, surtout au début.",
                    summary: "Voici les bases d'Opérateur 112 ! Accomplissez des missions, recevez des crédits, achetez plus d'unités, recommencez. Amusez-vous bien ! </br> L'équipe d'Opérateur 112"
                },
                mobile: {
                    contact: "Si vous avez des questions, vous pouvez consulter la FAQ du jeu, visiter les forums du jeu ou notre page Facebook !",
                    general: "Nous vous recommandons pour l'étape suivante de construire un centre de secours et, dès que possible, de nouveaux postes puisque le nombre de missions maximum équivaut au plus grand nombre de postes d'un genre (police, pompiers, ambulance) plus 1. Par exemple, 5 casernes de pompiers et 3 postes ambulanciers = 6 missions.",
                    join_alliance: "De plus, nous vous recommandons de rejoindre une alliance, ce qui peut grandement vous aider, surtout au début.",
                    summary: "Voici les bases d'Opérateur 112 ! Accomplissez des missions, recevez des crédits, achetez plus d'unités, recommencez. Amusez-vous bien ! </br> L'équipe d'Opérateur 112"
                }
            }
        },
        commons: {
            collect: "Récupérer",
            "continue": "Non",
            end: "Fin",
            next: "Suiv.",
            prev: "Préc.",
            skip: "Oui",
            skip_hint: "Veux-tu vraiment passer le didacticiel ? Tu ne pourras pas y accéder par la suite. Tu renonceras ainsi à la récompense offerte pour avoir terminé le didacticiel."
        },
        rewards: {
            log: "Récompense pour avoir terminé le didacticiel."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Ensuite, donnez un nom à votre poste ! Il faut qu'il soit identifiable et évolutif. Par exemple : « Police Muncipale n°1 ». Cliquez sur « Suiv. » lorsque vous avez terminé !",
                            select_building: "Choisissez d'abord le type de bâtiment avec lequel vous voulez débuter. Nous vous recommandons de démarrer avec une police muncipale. Dans tous les cas, nous vous conseillons un petit poste !"
                        },
                        welcome: "Bonjour, et bienvenue sur Opérateur 112 Police !  Je vais vous aider à bien démarrer votre carrière dans les services d'urgence !"
                    },
                    mobile: {
                        build_building: {
                            add_name: "Ensuite, donnez un nom à votre poste ! Il faut qu'il soit identifiable et évolutif. Par exemple : « Police Muncipale n°1 ». Cliquez sur « Suiv. » lorsque vous avez terminé !",
                            select_building: "Choisissez d'abord le type de bâtiment avec lequel vous voulez débuter. Nous vous recommandons de démarrer avec une police muncipale. Dans tous les cas, nous vous conseillons un petit poste !"
                        },
                        welcome: "Bonjour, et bienvenue sur Opérateur 112 Police !  Je vais vous aider à bien démarrer votre carrière dans les services d'urgence !"
                    }
                },
                rewards: {
                    mobile: {
                        general: "Parfait, vous êtes bien parti pour devenir un Opérateur 112 Police de talent ! Voici %{coins} pièces pour vous aider à démarrer ! </br> L'équipe d'Opérateur 112 Police"
                    }
                },
                tips: {
                    browser: {
                        summary: "Voici les bases d'Opérateur 112 Police ! Accomplissez des missions, recevez des crédits, achetez plus d'unités, recommencez. Amusez-vous bien ! </br> L'équipe d'Opérateur 112 Police"
                    },
                    mobile: {
                        summary: "Voici les bases d'Opérateur 112 Police ! Accomplissez des missions, recevez des crédits, achetez plus d'unités, recommencez. Amusez-vous bien ! </br> L'équipe d'Opérateur 112 Police"
                    }
                }
            }
        }
    }
}, I18n.translations.ru_RU = {
    common: {
        add: "Добавить",
        back: "Назад",
        cancel: "Отменить",
        change_saved: "Изменения сохранены",
        coins_spend: "Вы действительно хотите потратить эти монеты?",
        congratulations: "Поздравляем!",
        content: "Содержимое",
        copy: "Скопировать",
        credits: "Кредиты",
        "delete": "Удалить",
        details: "Подробности",
        edit: "Редактировать",
        error: "Ошибка",
        is_offline: "%{user} не в сети.",
        is_offline_long: "Давно: %{user} не в сети",
        is_offline_with_duration: "%{user} не в сети: %{duration}",
        is_online: "%{user} в сети.",
        loading: "Загружается...",
        name: "Название",
        none: "Ни один",
        of: "из",
        off: "Выкл",
        on: "Вкл",
        save: "Сохранить",
        search: "Искать",
        show: "Показать",
        user_not_found: "Пользователь не найден",
        wrong_key: "Неверная клавиша"
    },
    javascript: {
        alarm: "Отправить",
        arrival: "Прибытие",
        backalarm: "Отменить",
        coins: "Монеты",
        credits: "Кредиты",
        days: "дн.",
        few_seconds: "через несколько секунд",
        finish_in: "Закончить через:",
        hours: "Ч",
        location_not_found: "Не найдено",
        messages: "Сообщения",
        minutes: "мин.",
        missed_vehicle: "Не хватает:",
        mission_start_in: "Начинается через:",
        "new": "Новый",
        not_found_map: "Машина не обнаружена на карте",
        now: "Сейчас",
        patient: "Пациент",
        patient_untouched: "Не получившие помощи пациенты",
        poi_delete: "Вы уверены, что хотите удалить эту важную точку: %{caption}?",
        reload: "Загрузить повторно",
        sale: "Распродажа",
        sale_ended: "Акция завершена",
        secounds: "сек.",
        sicherheitswache_error: "Cотрудник охраны «%{caption}» не добился успеха, потому что не все критерии удовлетворены.",
        sicherheitswache_success: "Cотрудник охраны «%{caption}» успешно выведен. Получите кредиты (%{credits}).",
        start_in: "Начать через: ",
        start_username: "Начинает:",
        time_left: "Осталось:",
        to_building: "Смотреть здание",
        to_mission: "Смотреть задание",
        understand: "Подтвердить",
        user_not_found: "Игрок не найден.",
        vehicles_not_visible: "Машины не видны. "
    },
    map: {
        alliance: "Альянс",
        alliance_chat: "Чат",
        alliance_chat_banned: "В настоящее время вы лишены доступа к чату альянса.",
        alliance_chat_banned_admin: "Заблокировал:",
        alliance_chat_banned_timeleft: "Осталось времени:",
        alliance_chat_radio_off: "Радио альянса: Выкл",
        alliance_chat_radio_on: "Радио альянса: Вкл",
        alliance_event: "Событие",
        alliance_missions: "Задания альянса",
        alliance_missions_event: "Событие",
        ambulance: "Скорая помощь",
        attended: "Посещённые",
        cancel_alliance_event: "Отменить событие альянса",
        cancel_alliance_event_confirm: "Вы уверены что хотите отменить событие альянса?",
        challenges: "",
        chat_history: "История чата",
        congratulations: "Поздравляем! Теперь вы можете получить повышение.",
        create_alliance_event: "Начать событие альянса",
        create_alliance_operation: "Создайте крупномасштабное задание альянса",
        emergency: "Чрезвычайная ситуация",
        finishing: "Завершаются",
        join_alliance_infos: "Если вы состоите в альянсе, другие игроки могут свободно давать вам задания.",
        map: "Карта",
        map_filters: {
            all_buildings: "Здания",
            all_missions: "Задания",
            alliance_buildings: "Здания альянса",
            alliance_members: "Участники",
            alliance_missions: "Совместно с альянсом",
            ambulance_station_missions: "Станция скорой помощи",
            ambulance_station_small_missions: "Станция скорой помощи (малая)",
            building_complex: "Комплекс Зданий",
            buildings_section: "Станции",
            clinic_missions: "Клиника",
            dispatch_center_missions: "Диспетчерский пункт",
            fire_school_missions: "Академия пожарной службы",
            firehouse_missions: "Пожарная станция",
            firehouse_small_missions: "Пожарная станция (малая)",
            hospital_missions: "Больница",
            map_filters: "Важные точки",
            mission_positions: "Важные точки",
            mission_positions_section: "Важные точки",
            missions_section: "Задания",
            police_copter_station_missions: "Полицейская авиация",
            police_school_missions: "Академия полиции",
            police_small_missions: "Полицейский участок (малый)",
            police_special_forces: "Полицейские отряды спец. назначения",
            police_station_missions: "Полицейский участок",
            prison_missions: "Тюрьма",
            rapid_deployment_group: "Группа быстрого развёртывания",
            rescue_copter_station_missions: "Станция вертолётов скорой помощи",
            riot_police: "Спецназ полиции",
            riot_police_missions: "Спецназ полиции",
            staging_area_missions: "Пункт сбора",
            technical_aid_organization: "МЧС",
            technical_aid_organization_school: "Высшая школа МЧС",
            user_buildings: "Мои здания",
            user_missions: "Мои задания",
            water_watch: "ОСВОД",
            water_watch_missions: "ОСВОД"
        },
        message: "Сообщение",
        mission: "Задание",
        missions_filtered_out: "Некоторые миссии могут быть отфильтрованы. Пожалуйста, проверьте фильтры вашей карты.",
        no_alliance_chat_impossible: "Вы не состоите в альянсе.",
        no_alliance_missions: "В настоящее время заданий альянса нет.",
        no_ambulance_missions: "Нет возможности перевозки пациентов. Перевозка станет возможной, когдапоявятся автомобиль скорой помощи и больница.",
        no_emergency_missions: "Нет доступных заданий ЧС. Задание ЧС может появиться только тогда, когда вы построите свою первую станцию.",
        no_radio_messages: "Вы не получали сообщений по радио.",
        radio_messages: "Радио",
        restore_map: "Восстановить карту",
        server_warning: "Server maintenance at 1 am. 6h downtime expected.",
        show_informations: "Зелёный = задания отображаются в списке. Красный = задания не отображаются.",
        sicherheitswache: "Запланированные задания",
        transport: "Транспорт",
        unattended: "Непосещенные"
    },
    fms: {
        going: "Выезжает",
        not_ready: "Не работает",
        on_destination: "В пункте назначения перевозки",
        on_place: "На месте",
        patient_transported: "Перевозит пациента",
        prisoner_transported: "Перевозит заключённого",
        ready_home: "Доступно на станции",
        ready_traveling: "Не имеет заданий и доступно",
        talking_wish: "Заявка на перевозку",
        waiting_for_vehicle: "Ожидает машину для буксировки"
    },
    intervention_order: {
        back: "Назад",
        category: "Категория",
        colour: "Цвет",
        column: "Столбец",
        column_number: "Номер столбца",
        column_number_hint: "Если задан номер столбца, в соответствующей колонке на странице тревоги будет отображаться запись ИИР.",
        create_intervention_order: "Создать новое правило ИИР",
        "delete": "Удалить",
        delete_all: "Полностью удалить правила ИИР",
        delete_all_confirm: "Вы уверены, что хотите удалить правило ИИР целиком? Существующие экспортированные записи более недоступны!",
        description: "Название",
        edit: "Редактировать",
        "export": {
            "export": "Экспортировать",
            "import": "Импортировать",
            import_done: "Выбранные записи импортированы и добавлены в ваш план ИИР.",
            saved: "Экспорт правил ИИР",
            saved_text: "Правило ИИР подготовлено к экспорту. Другой игрок сможет импортировать правило ИИР, воспользовавшись этой ссылкой. Если в этом время вы измените своё правило ИИР, изменения будут автоматически применены к экспортируемому правилу."
        },
        hotkey_hint: "Выберите горячую клавишу для выделения этой машины. Нажмите в окне задания: ALT + горячая клавиша (или в Firefox: ALT + SHIFT + горячая клавиша, или в mac os: ctrl + alt + горячая клавиша), чтобы выделить выбранную машину.",
        intervention_order: "Редактировать правила ИИР",
        name: "Название",
        no_intervention_created: "Вы пока не создали правил ИИР.",
        options: "Параметры",
        reset: "Сбросьте предыдущее выделение в окне тревоги.",
        reset_hint: "Если в окне отправки вы выделили машину, эту кнопку можно использовать для сброса.",
        save: "Сохранить",
        station: "Станция",
        station_hint: "При выборе здания, будут выделены только машины соответствующего здания.",
        successfully_created: "Правило ИИР успешно создано.",
        successfully_deleted: "Правило ИИР удалено",
        successfully_updated: "Правила ИИР успешно обновлены.",
        vehicles: {
            ab_atemschutz_only: "Модуль дыхательных аппаратов",
            ab_einsatzleitung_only: "Модуль управления",
            ab_gefahrgut_only: "Модуль обезвреживания",
            ab_oel_only: "Модуль разлива нефти",
            ab_ruest: "Технологический модуль/модуль спасения",
            ab_ruest_rw: "",
            abl2wasser_only: "Модуль подачи шланга",
            ambulance: "Реанимобиль",
            ambulance_or_rapid_responder: "",
            arff: "АПСР (пожарная машина аэропорта)",
            battalion_chief_unit: "Подразделение командира батальона",
            boot: "Суда (общее)",
            dekon_p: "",
            division_chief_unit: "Мобильный командный пункт",
            dlk_or_tm50: "",
            elw1_or_elw2: "Подразделение командира батальона, мобильный командный пункт или мобильный модуль управления ",
            elw2_or_ab_elw: "Насос или вспомогательное спасательное подразделение",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Машина скорой помощи ИЛИ вертолет",
            fire_truck: "Пожарные машины",
            fireboat: "Большой пожарный катер",
            fly_car: "Медицинский автомобиль",
            fly_car_any: "Медицинский автомобиль / Терапевт",
            fukw: "",
            fustw_or_police_motorcycle: "Полицейская машина или Полицейский мотоцикл",
            fwk: "",
            gefkw: "",
            gkw: "Грузовой автомобиль",
            grtw: "Подразделение по работе с большим числом пострадавших",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Обезвреживание",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Автомобиль с лестницей",
            gw_messtechnik: "Метрологический автомобиль",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Автомобиль водолазов",
            gw_wasserrettung: "Автомобиль спасения на воде",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Машина с брандспойнтом",
            hems: "Вертолёт неотложной медицинской помощи",
            hlf_only: "ПСА",
            hlf_or_rw_and_lf: "Спасатели или тяжёлые спасатели и пожарный автомобиль",
            hondengeleider: "",
            k9: "Подразделение кинологов",
            kdow_lna: "",
            kdow_orgl: "Глава скорой",
            ktw_b: "",
            ktw_or_rtw: "Скорые и реанимобили",
            lebefkw: "Облегченный командный пункт",
            lf_only: "Пожарные машины",
            long_distance_ambulance: "Реанимобиль",
            mask_service_unit: "Мобильное воздушное подразделение",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Транспортёр",
            mzb: "Спасательная лодка",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Скорая помощь",
            oil_unit: "Маслоудалитель",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Патрульный автомобиль",
            police_motorcycle: "Полицейский мотоцикл",
            polizeihubschrauber: "Полицейский вертолёт",
            rescue_vehicle: "Машина для спасательных работ в тяжёлых условиях",
            rescue_vehicle_only: "Подразделение спасателей в тяжёлых условиях",
            rescueboat: "Большое спасательное судно",
            rettungstreppe: "",
            rth_only: "Медицинский вертолёт",
            schlauchwagen: "Цистерна с водой",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Спецназ",
            swat_armored_vehicle: "Бронемобиль спецназа",
            swat_suv: "Внедорожник спецназа",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Автомобиль технической службы (АТС - МЧС)",
            thw_mzkw: "Грузовик с бортом подъемником (ГрБП)",
            thw_tauchkraftwagen: "Команда водолазов",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Машина водолазов",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Платформы",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Теперь назовите свою новую станцию! Выберите узнаваемое и не очень длинное название! Например, «Пожарная станция №0001». Когда закончите, нажмите «Далее»!",
                        build_with_credits: "Теперь постройте здание за кредиты!",
                        new_building: "Щёлкните кнопку «Новое здание»!",
                        select_building: "Сперва выберите тип здания. Предлагаем начать с пожарной части! Так или иначе, но рекомендуем начать с небольшой станции!",
                        select_position: "Переместите синюю метку туда, где хотите построить свою первую станцию!"
                    },
                    pick_location: "Первым делом давайте выберем место, откуда вы начнете свой путь! Введите название места в поисковую строку или самостоятельно найдите его на карте! Как насчет вашего родного города?",
                    welcome: "Добро пожаловать в «Диспетчер 112»!  Я преподам вам несколько уроков, которые помогут начать карьеру спасателя!"
                },
                mobile: {
                    build_building: {
                        add_name: "Теперь назовите свою новую станцию! Выберите узнаваемое и не очень длинное название! Например, «Пожарная станция №0001». Когда закончите, нажмите «Далее»!",
                        build_with_credits: "Теперь постройте здание за кредиты!",
                        new_building: "Сперва давайте выберем место, откуда вы начнете свой путь, и построим там ваше первое здание! <br /> <br /> Для этого щёлкните кнопку «Новое здание»!",
                        select_building: "Сперва выберите тип здания. Предлагаем начать с пожарной части! Так или иначе, но рекомендуем начать с небольшой станции!"
                    },
                    welcome: "Добро пожаловать в «Диспетчер 112»!  Я преподам вам несколько уроков, которые помогут начать карьеру спасателя!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Это меню отправки. С его помощью вы можете отправлять подразделения на задания!",
                        dispatch_menu_buttons: "Это две кнопки отправки. Первая кнопка, «Отправить», отправляет выбранные подразделения на задание. Вторая делает то же самое, но с переходом к следующему заданию. Щёлкните первую кнопку.",
                        dispatch_menu_mission_general: "Здесь приведена общая информация о задании: название, адрес и значок. Задания, которые вы уже выполняете, отмечены значком человечка, а не звездочкой.",
                        dispatch_menu_mission_progress: "Здесь можно узнать прогресс выполнения задания, количество сотрудников на месте инцидента и время до завершения задания.",
                        dispatch_menu_mission_specific: "Здесь представлена подробная информация о задании, а также об отправленных на вызов и уже находящихся на месте подразделениях.",
                        dispatch_menu_vehicle_list: "Это список доступных машин. Здесь можно выбрать машины. Выберите машину, щёлкнув её!"
                    },
                    mobile: {
                        dispatch_menu: "Это меню отправки. С его помощью вы можете отправлять подразделения на задания!",
                        dispatch_menu_buttons: "Это две кнопки отправки. Первая кнопка, «Отправить», отправляет выбранные подразделения на задание. Вторая делает то же самое, но с переходом к следующему заданию. Щёлкните первую кнопку.",
                        dispatch_menu_mission_general: "Здесь приведена общая информация о задании: название, адрес и значок. Задания, которые вы уже выполняете, отмечены значком человечка, а не звездочкой.",
                        dispatch_menu_mission_progress: "Здесь можно узнать прогресс выполнения задания, количество сотрудников на месте инцидента и время до завершения задания.",
                        dispatch_menu_mission_specific: "Здесь представлена подробная информация о задании, а также об отправленных на вызов и уже находящихся на месте подразделениях.",
                        dispatch_menu_vehicle_list: "Это список доступных машин. Здесь можно выбрать машины. Выберите машину, щёлкнув её!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Теперь давайте научимся разбираться с происшествиями. Откройте меню отправки, щёлкнув по кнопке «Отправить»!",
                        first_mission: "Отлично, вы построили своё первое здание! Смотрите, уже поступили первые задания для вас!"
                    },
                    mobile: {
                        dispatch_button: "Теперь давайте научимся разбираться с происшествиями. Откройте меню отправки, щёлкнув по кнопке «Отправить»!",
                        first_mission: "Отлично, вы построили своё первое здание! Смотрите, уже поступили первые задания для вас!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Отлично, скоро вы станете настоящим мастером «Диспетчер 112»! Держите монеты для начала: %{coins}! </br> Команда «Диспетчер 112»"
                },
                mobile: {
                    general: "Отлично, скоро вы станете настоящим мастером «Диспетчер 112»! Держите монеты для начала: %{coins}! </br> Команда «Диспетчер 112»"
                }
            },
            tips: {
                browser: {
                    contact: "Если у вас остались вопросы, ознакомьтесь с ЧАВО или загляните на форумы игры или на нашу страничку Facebook!",
                    general: "Следующим шагом рекомендуем возвести диспетчерский пункт, а затем начать строительство новых станций, поскольку максимальное количество заданий на одно больше количества станций самого распространенного типа (полиция, пожарные, скорая помощь). Например, при пяти пожарных станциях и трёх станциях скорой помощи вам будет доступно шесть заданий.",
                    join_alliance: "Мы также рекомендуем вступить в альянс, так как это может здорово вам помочь, особенно по началу.",
                    summary: "Теперь вы знаете основы игры в «Диспетчер 112»! Выполняйте задания, получайте кредиты и покупайте новые подразделения. Весёлой игры! </br> Команда «Диспетчер 112»"
                },
                mobile: {
                    contact: "Если у вас остались вопросы, ознакомьтесь с ЧАВО или загляните на форумы игры или на нашу страничку Facebook!",
                    general: "Следующим шагом рекомендуем возвести диспетчерский пункт, а затем начать строительство новых станций, поскольку максимальное количество заданий на одно больше количества станций самого распространенного типа (полиция, пожарные, скорая помощь). Например, при пяти пожарных станциях и трёх станциях скорой помощи вам будет доступно шесть заданий.",
                    join_alliance: "Мы также рекомендуем вступить в альянс, так как это может здорово вам помочь, особенно по началу.",
                    summary: "Теперь вы знаете основы игры в «Диспетчер 112»! Выполняйте задания, получайте кредиты и покупайте новые подразделения. Весёлой игры! </br> Команда «Диспетчер 112»"
                }
            }
        },
        commons: {
            collect: "Получить",
            "continue": "Нет",
            end: "Конец",
            next: "Далее",
            prev: "Назад",
            skip: "Да",
            skip_hint: "Вы уверены, что хотите пропустить обучение? Вы больше не сможете к нему вернуться. Вы не сможете получить награду за завершение обучения."
        },
        rewards: {
            log: "Награда за завершение обучения."
        }
    }
}, I18n.translations.da_DK = {
    common: {
        add: "Tilføj",
        back: "Tilbage",
        cancel: "Annullér",
        change_saved: "Ændringer gemt",
        coins_spend: "Er du sikker på, at du vil bruge disse mønter?",
        congratulations: "Tillykke!",
        content: "Indhold",
        credits: "Kreditter",
        "delete": "Slet",
        details: "Detaljer",
        edit: "Redigér",
        error: "Fejl",
        is_offline: "%{user} er offline.",
        is_offline_long: "Lang tid: %{user} er offline",
        is_offline_with_duration: "%{user} er offline: %{duration}",
        is_online: "%{user} er online.",
        loading: "Indlæser ...",
        name: "Navn",
        none: "Ingen",
        of: "af",
        off: "Fra",
        on: "Til",
        save: "Gem",
        search: "Søg",
        show: "Vis",
        user_not_found: "Bruger ikke fundet",
        wrong_key: "Forkert nøgle"
    },
    javascript: {
        alarm: "Send ud",
        arrival: "Ankomst",
        backalarm: "Annullér",
        coins: "Mønter",
        credits: "Kreditter",
        days: "dage",
        few_seconds: "om få sekunder",
        finish_in: "Færdig om:",
        hours: "T",
        location_not_found: "Ikke fundet",
        messages: "Meddelelser",
        minutes: "min.",
        missed_vehicle: "Mangler:",
        mission_start_in: "Begynder om:",
        "new": "Ny",
        not_found_map: "Køretøjet blev ikke fundet på kortet",
        now: "Nu",
        patient: "Patient",
        patient_untouched: "Ubehandlede patienter",
        poi_delete: "Er du sikker på, at du vil slette interessepunktet: %{caption}?",
        reload: "Genindlæs",
        sale: "Sale",
        sale_ended: "Udsalg forbi ",
        secounds: "sek.",
        sicherheitswache_error: 'Sikkerhedsvagten "%{caption}" lykkedes ikke, da ikke alle kriterier blev opfyldt.',
        sicherheitswache_success: 'Sikkerhedsvagten "%{caption}" er blevet gennemført. Modtag %{credits} kreditter.',
        start_in: "Begynder om: ",
        start_username: "Begynder:",
        time_left: "Tid tilbage:",
        to_building: "Se bygning",
        to_mission: "Se mission",
        understand: "Forstået",
        user_not_found: "Spilleren blev ikke fundet",
        vehicles_not_visible: "Køretøjer ikke synlige. "
    },
    map: {
        alliance: "Alliance",
        alliance_chat: "Chat",
        alliance_chat_banned: "Du er bortvist fra alliance-chatten.",
        alliance_chat_banned_admin: "Bortvist af:",
        alliance_chat_banned_timeleft: "Tid tilbage:",
        alliance_chat_radio_off: "Allianceradio Fra",
        alliance_chat_radio_on: "Allianceradio Til",
        alliance_event: "Begivenhed",
        alliance_missions: "Alliancemissioner",
        alliance_missions_event: "Begivenhed",
        ambulance: "Ambulance",
        attended: "Iværksatte",
        cancel_alliance_event: "Annullér alliancebegivenhed",
        cancel_alliance_event_confirm: "Er du sikker på, at du vil annullere alliancebegivenheden?",
        challenges: "",
        chat_history: "Chat-historik",
        congratulations: "Tillykke! Du kan nu blive forfremmet.",
        create_alliance_event: "Påbegynd alliancebegivenhed",
        create_alliance_operation: "Opret en stor alliancemission",
        emergency: "Krisesituation",
        finishing: "Næsten afsluttede",
        join_alliance_infos: "Hvis du er i en alliance, kan andre spillere give dig missioner.",
        map: "Kort",
        map_filters: {
            all_buildings: "Bygninger",
            all_missions: "Missioner",
            alliance_buildings: "Alliancebygninger",
            alliance_members: "Medlemmer",
            alliance_missions: "Delt af alliance",
            ambulance_station_missions: "Ambulancestation",
            ambulance_station_small_missions: "Ambulancestation (lille station)",
            building_complex: "Bygningskompleks",
            buildings_section: "Stationer",
            clinic_missions: "Klinik",
            dispatch_center_missions: "Alarmcentral",
            fire_school_missions: "Brandakademi",
            firehouse_missions: "Brandstation",
            firehouse_small_missions: "Brandstation (lille station)",
            hospital_missions: "Hospital",
            map_filters: "Liste over kortfiltre",
            mission_positions: "Interessepunkter (POI)",
            mission_positions_section: "POI",
            missions_section: "Missioner",
            police_copter_station_missions: "Politihelikopterstation",
            police_school_missions: "Politiskole",
            police_small_missions: "Politistation (lille station)",
            police_special_forces: "Politiets specialstyrke",
            police_station_missions: "Politistation",
            prison_missions: "Statsfængsel",
            rapid_deployment_group: "Akut indsatsgruppe (AIG)",
            rescue_copter_station_missions: "Rednings Helikopter Station",
            riot_police: "Uropoliti",
            riot_police_missions: "Uropoliti",
            staging_area_missions: "Opstillingsområde",
            technical_aid_organization: "Beredskabskorps",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Mine bygninger",
            user_missions: "Mine missioner",
            water_watch: "Vandredning",
            water_watch_missions: "Vandredning"
        },
        message: "Meddelelse",
        mission: "Mission",
        missions_filtered_out: "Nogle missioner kan blive filtreret ud. Tjek venligst dine kortfilter.",
        no_alliance_chat_impossible: "Du er ikke i en alliance.",
        no_alliance_missions: "Der er ingen alliancemissioner lige nu",
        no_ambulance_missions: "Der er ingen ambulancemissioner. Der er kun ambulancemissioner, når du har en ambulance og et hospital.",
        no_emergency_missions: "Der er ingen tilgængelige krisemissioner. Der kan opstå krisemissioner, når du har oprettet din første station.",
        no_radio_messages: "Du har ikke modtaget radiomeddelelser.",
        radio_messages: "Radio",
        restore_map: "Gendan kort",
        server_warning: "Servervedligeholdelse kl. 00.00. 6 t. nedlukning forventet.",
        show_informations: "Grøn = Missionerne vises på listen. Rød = Missionerne vises ikke.",
        sicherheitswache: "Planlagte indsatser",
        transport: "Transport",
        unattended: "Ikke iværksatte"
    },
    fms: {
        going: "Rykker ud",
        not_ready: "Ude af drift",
        on_destination: "Ved transportdestinationen",
        on_place: "På ulykkestedet",
        patient_transported: "Transporterer patient",
        prisoner_transported: "Transporterer fange",
        ready_home: "Tilgængelig ved station",
        ready_traveling: "Fri og ledig",
        talking_wish: "Transportanmodning",
        waiting_for_vehicle: "Venter på bugseringskøretøj"
    },
    intervention_order: {
        back: "Tilbage",
        category: "Kategori",
        colour: "Farve",
        column: "Søjle",
        column_number: "Søjletal",
        column_number_hint: "Hvis et søjletal er angivet, vises alarm og beredskab i den tilsvarende søjle på varslingssiden.",
        create_intervention_order: "Opret ny alarm- og beredskabsregulering",
        "delete": "Slet",
        delete_all: "Slet alarm- og beredskabsregulering helt",
        delete_all_confirm: "Er du sikker på, at du vil slette hele alarm- og beredskabsreguleringen? Tidligere eksporterede indlæg er ikke tilgængelige!",
        description: "Navn",
        edit: "Redigér",
        "export": {
            "export": "Eksportér",
            "import": "Importér",
            import_done: "De valgte indlæg er blevet importeret og skrevet på din alarm- og beredskabsplan.",
            saved: "Alarm- og beredskabsreguleringer – eksport",
            saved_text: "Dine alarm- og beredskabsreguleringer er klar til eksport. Med linket kan en anden spiller importere alarm- og beredskabsreguleringerne. Hvis du i mellemtiden ændrer dine alarm- og beredskabsreguleringer, bliver denne ændring automatisk brugt i eksporten."
        },
        hotkey_hint: "Vælg en genvejstast for dette køretøjsvalg. Tryk følgende i dit missionsvindue: ALT + din genvejstast (eller med Firefox: ALT + SHIFT + din genvejstast eller på Mac OS: CTRL + ALT + din genvejstast) for at vælge køretøj(er).",
        intervention_order: "Redigér alarm- og beredskabsreguleringer",
        name: "Navn",
        no_intervention_created: "Du har ikke redigeret alarm- og beredskabsreguleringer endnu.",
        options: "Indstillinger",
        reset: "Nulstil forrige valg i alarmvinduet.",
        reset_hint: "Hvis du har valgt et køretøj i udsendelsesvinduet, kan du bruge denne knap til at nulstille.",
        save: "Gem",
        station: "Station",
        station_hint: "Når du har valgt en bygning, bliver kun køretøjer fra bygningen valgt.",
        successfully_created: "Alarm- og beredskabsregulering oprettet.",
        successfully_deleted: "Alarm- og beredskabsregulering slettet",
        successfully_updated: "Alarm- og beredskabsregulering opdateret.",
        vehicles: {
            ab_atemschutz_only: "Røgdykkermodul",
            ab_einsatzleitung_only: "Kommandomodul",
            ab_gefahrgut_only: "Gift- og kemikaliemodul",
            ab_oel_only: "Olieudslipmodul",
            ab_ruest: "Teknologi-/redningsmodul",
            ab_ruest_rw: "",
            abl2wasser_only: "Brandslangemodul",
            ambulance: "ALS-ambulance",
            ambulance_or_rapid_responder: "",
            arff: "ARFF (lufthavnsbrandbil)",
            battalion_chief_unit: "Indsatsleder Brand",
            boot: "Både (generelt)",
            dekon_p: "",
            division_chief_unit: "Mobilkommando-køretøj",
            dlk_or_tm50: "",
            elw1_or_elw2: "Indsatsleder Brand eller Ledelses- og kommunikationsmodul",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            elw_police: "Indsatsleder Politi",
            emergency_ambulance: "Ambulance eller Rednings Helikopter",
            fire_truck: "Brandbiler",
            fireboat: "Stor brandbåd",
            fly_car: "Akutlæge",
            fukw: "",
            fustw_or_police_motorcycle: "Patruljevogn eller Politimotorcykel",
            fwk: "",
            gefkw: "",
            gkw: "Servicebil",
            grtw: "Mobil Behandlingsplads",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Gift og kemikalie-enhed",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Dykkerbil",
            gw_wasserrettung: "Kystlivredderbil",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Brandslangekøretøj",
            hems: "Rednings Helikopter",
            hlf_only: "Specialsprøjte",
            hlf_or_rw_and_lf: "Specialsprøjte eller Tung Redningsvogn og Autosprøjte",
            hondengeleider: "",
            k9: "Hundepatrulje",
            kdow_lna: "",
            kdow_orgl: "Indsatsleder Akutlæge",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Brandbiler",
            long_distance_ambulance: "Regionsambulance",
            mask_service_unit: "Højtrykskompressor",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Mandskabstransport",
            mzb: "Bådtrailer",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulance",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Patruljebil",
            police_motorcycle: "Politimotorcykel",
            polizeihubschrauber: "Politihelikopter",
            rescue_vehicle: "Redningsvogn",
            rescue_vehicle_only: "Tung redning",
            rescueboat: "Stor redningsbåd",
            rettungstreppe: "",
            rth_only: "Rednings Helikopter",
            schlauchwagen: "Vandtankvogn",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "AKS",
            swat_armored_vehicle: "AKS Pansret mandskabsvogn",
            swat_suv: "AKS Patruljevogn",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dykkerhold",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tankvogn",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Stigevogne",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Dernæst skal du navngive din station! Gør den genkendelig og skalerbar! F.eks. "Brandstation #0001". Når du er færdig, så tryk "Næste"!',
                        build_with_credits: "Byg derefter din bygning med kreditter!",
                        new_building: 'Klik på "Ny bygning"!',
                        select_building: "Vælg først den type bygning, du vil starte med. Vi anbefaler, at du starter med brandtjeneste! I hvert fald anbefales det, at man starter med en lille station!",
                        select_position: "Flyt den blå markør til der, hvor du gerne vil bygge din første station!"
                    },
                    pick_location: "Vælg først et sted at starte! Indtast navnet på stedet, hvor du gerne vil starte, på søgebjælken, eller find det selv på kortet! Hvad med din hjemby?",
                    welcome: "Hej, velkommen til Alarmcentral-spil!  Jeg vil give dig lidt vejledning, så du kan få en ordentlig start på din redningstjeneste-karierre!"
                },
                mobile: {
                    build_building: {
                        add_name: 'Dernæst skal du navngive din station! Gør den genkendelig og skalerbar! F.eks. "Brandstation #0001". Når du er færdig, så tryk "Næste"!',
                        build_with_credits: "Byg derefter din bygning med kreditter!",
                        new_building: 'Først vælger vi et sted at begynde at bygge din første bygning! <br /> <br /> For at gøre det, skal du klikke på "Ny bygning"!',
                        select_building: "Vælg først den type bygning, du vil starte med. Vi anbefaler, at du starter med brandtjeneste! I hvert fald anbefales det, at man starter med en lille station!"
                    },
                    welcome: "Hej, velkommen til Alarmcentral-spil!  Jeg vil give dig lidt vejledning, så du kan få en ordentlig start på din redningstjeneste-karierre!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Dette er udsend-menuen. Herfra sender du dine enheder på missioner!",
                        dispatch_menu_buttons: 'Disse er dine to "udsend"-knapper! Den første: "Udsend" sender de valgte enheder på missionen. Den anden gør det samme som den første, men gælder for den næste mission. Klik på den første nu.',
                        dispatch_menu_mission_general: "Her kan du se generel information om missionen, så som missionens navn, adresse og ikon. Ikonet med den lille mand dukker op og erstatter en lille stjerne, når det er missioner, du allerede har deltaget i.",
                        dispatch_menu_mission_progress: "Her kan du se, hvor mange fremskridt, der er sket med at håndtere missionen, antallet af personale på stedet, samt den tid, der resterer til at håndtere missionen!",
                        dispatch_menu_mission_specific: "Her kan du se mere information om missionen. Hvilke enheder, der reagerer på opkaldet, og hvilke, der allerede er nået frem",
                        dispatch_menu_vehicle_list: "Dette er en liste over tilgængelige køretøjer. Du vælger køretøjerne her. Vælg nu dine køretøjer ved at klikke på den!"
                    },
                    mobile: {
                        dispatch_menu: "Dette er udsend-menuen. Herfra sender du dine enheder på missioner!",
                        dispatch_menu_buttons: 'Disse er dine to "udsend"-knapper! Den første: "Udsend" sender de valgte enheder på missionen. Den anden gør det samme som den første, men gælder for den næste mission. Klik på den første nu.',
                        dispatch_menu_mission_general: "Her kan du se generel information om missionen, så som missionens navn, adresse og ikon. Ikonet med den lille mand dukker op og erstatter en lille stjerne, når det er missioner, du allerede har deltaget i.",
                        dispatch_menu_mission_progress: "Her kan du se, hvor mange fremskridt, der er sket med at håndtere missionen, antallet af personale på stedet, samt den tid, der resterer til at håndtere missionen!",
                        dispatch_menu_mission_specific: "Her kan du se mere information om missionen. Hvilke enheder, der reagerer på opkaldet, og hvilke, der allerede er nået frem",
                        dispatch_menu_vehicle_list: "Dette er en liste over tilgængelige køretøjer. Du vælger køretøjerne her. Vælg nu dine køretøjer ved at klikke på den!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Nu skal vi lære, hvordan vi tager os af hændelser. Åbn udsendelsesmenuen ved at klikke på "udsend"-knappen!',
                        first_mission: "Glimrende, du har bygget din første bygning. Se, de første missioner blev indberettet til dig!"
                    },
                    mobile: {
                        dispatch_button: 'Nu skal vi lære, hvordan vi tager os af hændelser. Åbn udsendelsesmenuen ved at klikke på "udsend"-knappen!',
                        first_mission: "Glimrende, du har bygget din første bygning. Se, de første missioner blev indberettet til dig!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Glimrende - du er på vej til at blive alletiders til Alarmcentral-spil! Her er %{coins} mønter til at få dig i gang! </br> Dit Alarmcentral-spil-hold"
                },
                mobile: {
                    general: "Glimrende - du er på vej til at blive alletiders til Alarmcentral-spil! Her er %{coins} mønter til at få dig i gang! </br> Dit Alarmcentralspil-hold"
                }
            },
            tips: {
                browser: {
                    contact: "Hvis du har spørgsmål, kan du tjekke Spørgsmål og svar i spillet eller besøge spilforummer på vores Facebook-side!",
                    general: "Som et næste skridt vil vi anbefale, at du bygger en alarmcentral, og dernæst - så snart som muligt - nye stationer, da det maksimale antal missioner er lig med det højeste antal af enhver slags station (politi-, brand-, og ambulance-) plus 1; f.eks. 5 brand- og 3 ambulancestationer = 6 missioner.",
                    join_alliance: "Det ville også hjælpe dig enormt, især i starten, så det anbefales også.",
                    summary: "Dette er den grundlæggende viden i Alarmcentral-spil! Fuldfør missioner, få kreditter, køb flere enheder, gentag. God fornøjelse! </br> Dit Alarmcentral-spil-hold"
                },
                mobile: {
                    contact: "Hvis du har spørgsmål, kan du tjekke Spørgsmål og svar i spillet eller besøge spilforummer på vores Facebook-side!",
                    general: "Som et næste skridt vil vi anbefale, at du bygger en alarmcentral, og dernæst - så snart som muligt - nye stationer, da det maksimale antal missioner er lig med det højeste antal af enhver slags station (politi-, brand-, og ambulance-) plus 1; f.eks. 5 brand- og 3 ambulancestationer = 6 missioner.",
                    join_alliance: "Det ville også hjælpe dig enormt, især i starten, så det anbefales også.",
                    summary: "Dette er den grundlæggende viden i Alarmcentral-spil! Fuldfør missioner, få kreditter, køb flere enheder, gentag. God fornøjelse! </br> Dit Alarmcentral-spil-hold"
                }
            }
        },
        commons: {
            collect: "Hent",
            "continue": "Nej",
            end: "Afslut",
            next: "Næste",
            prev: "Forrige",
            skip: "Ja",
            skip_hint: "Vil du virkelig afbryde introduktionen? Du kan ikke vende tilbage til den senere. Du kvalificerer dig ikke til belønningen for at gennemføre introduktionen."
        },
        rewards: {
            log: "Belønning for at afslutte gennemgangen."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'Dernæst skal du navngive din station! Gør den genkendelig og skalerbar! F.eks. "Politistation #0001". Når du er færdig, så tryk "Næste"!',
                            select_building: "Vælg først den type bygning, du vil starte med. Vi anbefaler, at du starter med politistation! I hvert fald anbefales det, at man starter med en lille station!"
                        },
                        welcome: "Hej, velkommen til Politi Alarmcentral-spil!  Jeg vil give dig lidt vejledning, så du kan få en ordentlig start på din redningstjeneste-karierre!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'Dernæst skal du navngive din station! Gør den genkendelig og skalerbar! F.eks. "Politistation #0001". Når du er færdig, så tryk "Næste"!',
                            select_building: "Vælg først den type bygning, du vil starte med. Vi anbefaler, at du starter med politistation! I hvert fald anbefales det, at man starter med en lille station!"
                        },
                        welcome: "Hej, velkommen til Politi Alarmcentral-spil!  Jeg vil give dig lidt vejledning, så du kan få en ordentlig start på din redningstjeneste-karierre!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Glimrende - du er på vej til at blive alletiders til Politi Alarmcentral-spil! Her er %{coins} mønter til at få dig i gang! </br> Dit Politi Alarmcentral-spil-hold"
                    },
                    mobile: {
                        general: "Glimrende - du er på vej til at blive alletiders til Politi Alarmcentral-spil! Her er %{coins} mønter til at få dig i gang! </br> Dit Politi Alarmcentral-spil-hold"
                    }
                },
                tips: {
                    browser: {
                        summary: "Dette er den grundlæggende viden i Politi Alarmcentral-spil! Fuldfør missioner, få kreditter, køb flere enheder, gentag. God fornøjelse! </br> Dit Politi Alarmcentral-spil-hold"
                    },
                    mobile: {
                        summary: "Dette er den grundlæggende viden i Politi Alarmcentral-spil! Fuldfør missioner, få kreditter, køb flere enheder, gentag. God fornøjelse! </br> Dit Politi Alarmcentral-spil-hold"
                    }
                }
            }
        }
    }
}, I18n.translations.nb_NO = {
    common: {
        add: "Legg til",
        back: "Tilbake",
        cancel: "Avbryt",
        change_saved: "Endringer lagret",
        coins_spend: "Er du sikker på at du vil bruke disse myntene?",
        congratulations: "Gratulerer!",
        content: "Innhold",
        credits: "Kreditter",
        "delete": "Slett",
        details: "Info",
        edit: "Rediger",
        error: "Feil",
        is_offline: "%{user} er offline.",
        is_offline_long: "Lenge: %{user} er offline",
        is_offline_with_duration: "%{user} er offline: %{duration}",
        is_online: "%{user} er online.",
        loading: "Laster inn …",
        name: "Navn",
        none: "Ingen",
        of: "av",
        off: "Av",
        on: "På",
        save: "Lagre",
        search: "Søk",
        show: "Vis",
        user_not_found: "Brukeren ble ikke funnet",
        wrong_key: "Feil nøkkel"
    },
    javascript: {
        alarm: "Send ut",
        arrival: "Ankomst",
        backalarm: "Avbryt",
        coins: "Mynter",
        credits: "Kreditter",
        days: "dager",
        few_seconds: "om få sekunder",
        finish_in: "Fullfør om:",
        hours: "T",
        location_not_found: "Ikke funnet",
        messages: "Meldinger",
        minutes: "min.",
        missed_vehicle: "Mangler:",
        mission_start_in: "Starter om:",
        "new": "Ny",
        not_found_map: "Fremkomstmiddelet ble ikke funnet på kartet",
        now: "Nå",
        patient: "Pasient",
        patient_untouched: "Ubehandlede pasienter",
        poi_delete: "Er du sikker på at du vil slette interessepunktet %{caption}?",
        reload: "Last inn på nytt",
        sale: "Salg",
        sale_ended: "Salg avsluttet",
        secounds: "sek.",
        sicherheitswache_error: "Sikkerhetsvakten %{caption} lyktes ikke, for ikke alle kriteriene ble innfridd.",
        sicherheitswache_success: "Sikkerhetsvakten %{caption} lyktes. Få %{credits} kreditter.",
        start_in: "Starter om: ",
        start_username: "Starter:",
        time_left: "Gjenstående tid:",
        to_building: "Vis bygning",
        to_mission: "Vis oppdrag",
        understand: "Bekreft",
        user_not_found: "Spilleren ble ikke funnet.",
        vehicles_not_visible: "Fremkomstmidler er ikke synlige. "
    },
    map: {
        alliance: "Allianse",
        alliance_chat: "Chat",
        alliance_chat_banned: "Du er utestengt fra alliansechatten.",
        alliance_chat_banned_admin: "Utestengt av:",
        alliance_chat_banned_timeleft: "Gjenværende tid:",
        alliance_chat_radio_off: "Allianseradio: Av",
        alliance_chat_radio_on: "Allianseradio: På",
        alliance_event: "Hendelse",
        alliance_missions: "Allianseoppdrag",
        alliance_missions_event: "Hendelse",
        ambulance: "Ambulanse",
        attended: "Håndterer",
        cancel_alliance_event: "Kansellere alliansehendelse",
        cancel_alliance_event_confirm: "Er du sikker på at du vil kansellere alliansehendelsen?",
        challenges: "",
        chat_history: "Chatlogg",
        congratulations: "Gratulerer! Du kan nå forfremmes.",
        create_alliance_event: "Start alliansehendelse",
        create_alliance_operation: "Lag et allianseoppdrag i stor skala",
        emergency: "Nødssituasjon",
        finishing: "Fullfører",
        join_alliance_infos: "Hvis du er i en allianse, kan andre spillere gi deg oppdrag.",
        map: "Kart",
        map_filters: {
            all_buildings: "Bygninger",
            all_missions: "Oppdrag",
            alliance_buildings: "Alliansebygninger",
            alliance_members: "Medlemmer",
            alliance_missions: "Delt av allianse",
            ambulance_station_missions: "Ambulansestasjon",
            ambulance_station_small_missions: "Ambulansestasjon (liten)",
            building_complex: "Bygningskompleks",
            buildings_section: "Stasjoner",
            clinic_missions: "Legevakt",
            dispatch_center_missions: "Nødetatssenter",
            fire_school_missions: "Brannskole",
            firehouse_missions: "Brannstasjon",
            firehouse_small_missions: "Brannstasjon (liten)",
            hospital_missions: "Sykehus",
            map_filters: "Kartfilterliste",
            mission_positions: "Interessepunkt",
            mission_positions_section: "Interessepunkt",
            missions_section: "Oppdrag",
            police_copter_station_missions: "Politiheliport",
            police_school_missions: "Politiskole",
            police_small_missions: "Politistasjon (liten)",
            police_special_forces: "Politiets spesialstyrker",
            police_station_missions: "Politistasjon",
            prison_missions: "Fengsel",
            rapid_deployment_group: "Rask oppsettsgruppe (SEG)",
            rescue_copter_station_missions: "Luftambulansestasjon",
            riot_police: "Opprørspoliti",
            riot_police_missions: "Opprørspoliti",
            staging_area_missions: "Oppstillingsplass",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Mine bygninger",
            user_missions: "Mine oppdrag",
            water_watch: "Vannredning",
            water_watch_missions: "Vannredning"
        },
        message: "Melding",
        mission: "Oppdrag",
        missions_filtered_out: "Noen oppdrag kan bli filtrert ut. Vennligst sjekk kartfiltrene dine.",
        no_alliance_chat_impossible: "Du er ikke i en allianse.",
        no_alliance_missions: "Du har for øyeblikket ingen allianseoppdrag.",
        no_ambulance_missions: "Det er ingen pasientoverflytninger bestilt. Overflytninger kan forekomme når du har en Syketransport og et sykehus.",
        no_emergency_missions: "Du har ingen nødoppdrag. Du kan få nødoppdrag etter at du bygger din første stasjon.",
        no_radio_messages: "Du har ikke fått noen radiomeldinger.",
        radio_messages: "Radio",
        restore_map: "Gjenopprett kart",
        server_warning: "Servervedlikehold i natt klokken 00:00. Det vil vare i 6 timer.",
        show_informations: "Grønn = oppdragene vises på listen. Rød = oppdragene vises ikke.",
        sicherheitswache: "Planlagte visninger",
        transport: "Transport",
        unattended: "Ikke håndtert"
    },
    fms: {
        going: "Rykker ut",
        not_ready: "Ikke klar",
        on_destination: "Framme ved destinasjonen",
        on_place: "På åstedet",
        patient_transported: "Transporterer pasient",
        prisoner_transported: "Transporterer innsatt",
        ready_home: "Tilgjengelig på stasjon",
        ready_traveling: "Klar og tilgjengelig",
        talking_wish: "Transportforespørsel",
        waiting_for_vehicle: "Venter på at bil taues"
    },
    intervention_order: {
        back: "Tilbake",
        category: "Kategori",
        colour: "Farge",
        column: "Kolonne",
        column_number: "Kolonnenummer",
        column_number_hint: "Hvis et kolonnenummer oppgis, vil Alarm og respons-oppføringen vises i den tilsvarende kolonnen på varselsiden.",
        create_intervention_order: "Opprett ny Alarm og respons-regulering",
        "delete": "Slett",
        delete_all: "Slett Alarm og respons-regulering",
        delete_all_confirm: "Er du sikker på at du vil slette hele Alarm og respons-regulering? Eksisterende eksporterte oppføringer er ikke lenger tilgjengelige!",
        description: "Navn",
        edit: "Rediger",
        "export": {
            "export": "Eksporter",
            "import": "Importer",
            import_done: "De valgte oppføringene ble importer og skrevet over til Alarm og respons-planen.",
            saved: "Eksport av Alarm og respons-reguleringer",
            saved_text: "Alarm og respons-reguleringen er klargjort for eksport. Via koblingen kan andre spillere importere Alarm og respons-reguleringen. Hvis du i mellomtiden endrer Alarm og respons-reguleringen, reflekteres endringene i automatisk i eksporten."
        },
        hotkey_hint: "Velg en snarvei for dette fremkomstmiddelvalget. Oppgi i oppdragsvinduet: ALT + snarveien (eller i Firefox: ALT + SHIFT + snarveien, eller på mac os: ctrl + alt + snarveien) for å velge fremkomstmiddelvalget.",
        intervention_order: "Rediger Alarm og respons-reguleringer",
        name: "Navn",
        no_intervention_created: "Du har ikke opprettet noen Alarm og respons-regulering ennå.",
        options: "Alternativer",
        reset: "Tilbakestill forrige valg i alarmvinduet.",
        reset_hint: "Hvis du har valgt fremkomstmiddelet i utrykningsvinduet, kan du bruke denne knappen til å tilbakestille det.",
        save: "Spar",
        station: "Stasjon",
        station_hint: "Når en bygning er valgt, kan bare fremkomstmidler av tilsvarende bygning velges.",
        successfully_created: "Alarm og respons-regulering ble opprettet.",
        successfully_deleted: "Alarm og respons-regulering ble slettet.",
        successfully_updated: "Alarm og respons-regulering ble oppdatert.",
        vehicles: {
            ab_atemschutz_only: "SCBA-modul",
            ab_einsatzleitung_only: "Kommandomodul",
            ab_gefahrgut_only: "HazMat-modul",
            ab_oel_only: "Oljeutslipp-modul",
            ab_ruest: "Tek/rednings-modul",
            ab_ruest_rw: "",
            abl2wasser_only: "Slangeforsyning-modul",
            ambulance: "Ambulanse",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Utrykningspolitibil",
            arff: "Flyplassbrannbil",
            battalion_chief_unit: "Innsatsleder brann",
            boot: "Båter (generelt)",
            coresponder: "First responder bil",
            dekon_p: "",
            division_chief_unit: "Innsatsstøttebil",
            dlk_or_tm50: "",
            elw1_or_elw2: "Innsatsleder brann eller innsatsstøttebil",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulanse eller luftambulanse",
            fire_truck: "Brannbil",
            fireboat: "Brannbåt",
            fly_car: "Legebil",
            fly_car_any: "Legebil / Akuttbil / First responder bil / Akutthjelper / Ambulansemotorsykkel",
            fukw: "",
            fustw_or_police_motorcycle: "Patruljebil eller Politimotorsykkel",
            fwk: "",
            gefkw: "",
            gkw: "Lett lastebil",
            grtw: "Masseskade-enhet",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "Røykdykkerbil",
            gw_gefahrgut: "CBRNe-enhet",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Stigebil",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Dykkerbil",
            gw_wasserrettung: "Dykkerbil",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Tankbil",
            hems: "Luftambulanse",
            hlf_only: "Redningsbil",
            hlf_or_rw_and_lf: "Redningsbil eller Tungredningsbil og Brannbil",
            hondengeleider: "",
            k9: "Hundepatrulje",
            kdow_lna: "",
            kdow_orgl: "Innsatsleder Helse",
            kdow_orgl_any: "Innsatslederbil helse",
            ktw_b: "",
            ktw_or_rtw: "Syketransport eller Ambulanse",
            lebefkw: "Innsatsleder politi",
            lf_only: "Brannbil",
            long_distance_ambulance: "Syketransport",
            mask_service_unit: "Røykdykkerbil",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Lett redningsbåt",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Anestesilege",
            oil_unit: "IUA enhet",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Patruljebil",
            police_motorcycle: "Politimotorsykkel",
            polizeihubschrauber: "Politihelikopter",
            rescue_vehicle: "Tungredningsbil",
            rescue_vehicle_only: "Tungredningsbil",
            rescueboat: "Ambulansebåt",
            rettungstreppe: "",
            rth_only: "Luftambulanse",
            schlauchwagen: "Tankbil",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Politi med våpentrening",
            swat_armored_vehicle: "Pansret kjøretøy",
            swat_suv: "Delta kjøretøy",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dykkerbil",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tankbil",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Stigebil",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Så gir du stasjonen et navn. Gjør det gjenkjennelig og skalerbart! F.eks. «Brannstasjon nr. 0001». Når du er ferdig, klikker du på «Neste»!",
                        build_with_credits: "Bygg bygningen din med kreditter!",
                        new_building: "Klikk på «Ny bygning»!",
                        select_building: "Velg først bygningstypen du vil begynne med, vi anbefaler deg å begynne med brannvesenet! Det er også lurt å begynne med en liten stasjon.",
                        select_position: "Flytt den blå markøren dit du vil bygge den første stasjonen din!"
                    },
                    pick_location: "Velg først et sted å begynne! Skriv inn navnet der du vil begynne, eller finn det selv på kartet! Hva med hjembyen din?",
                    welcome: "Hei og velkommen til Nødsentralspillet!  Jeg skal lære deg hvordan du får en pangstart i nødetatenes verden!"
                },
                mobile: {
                    build_building: {
                        add_name: "Så gir du stasjonen et navn. Gjør det gjenkjennelig og skalerbart! F.eks. «Brannstasjon nr. 0001». Når du er ferdig, klikker du på «Neste»!",
                        build_with_credits: "Bygg bygningen din med kreditter!",
                        new_building: "Først velger vi et sted å begynne og bygge vår første bygning. <br /> <br />For å gjøre det klikker du på «Ny bygning»!",
                        select_building: "Velg først bygningstypen du vil begynne med, vi anbefaler deg å begynne med brannvesenet! Det er også lurt å begynne med en liten stasjon."
                    },
                    welcome: "Hei og velkommen til Nødsentralspillet!  Jeg skal lære deg hvordan du får en pangstart i nødetatenes verden!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Dette er nødedatsmenyen. Her i fra kan du sende enhetene dine ut på oppdrag!",
                        dispatch_menu_buttons: "Dette er dine to nødetatsknapper. Den første: «Nødetat» sender de valgte enhetene ut på oppdraget. Den andre gjør det samme som den første, men går ut på neste oppdrag. Klikk på den første knappen.",
                        dispatch_menu_mission_general: "Her kan du se generell oppdragsinfo, altså navnet, adressen og oppdragsikonet. Ikonet av den lille mannen dukker opp og erstatter en liten stjerne på oppdrag du allerede deltar på.",
                        dispatch_menu_mission_progress: "Her kan du se hvor mye framdrift som er gjort på oppdraget, samt antallet personell på stedet og hvor mye tid du har igjen.",
                        dispatch_menu_mission_specific: "Her kan du se info om oppdraget, hvilke enheter som svarer på nødanropet og hvem som allerede er på stedet.",
                        dispatch_menu_vehicle_list: "Dette er listen over dine tilgjengelige fremkomstmidler. Velg fremkomstmidler her. Velg fremkomstmiddelet ved å klikke på det."
                    },
                    mobile: {
                        dispatch_menu: "Dette er nødedatsmenyen. Her i fra kan du sende enhetene dine ut på oppdrag!",
                        dispatch_menu_buttons: "Dette er dine to nødetatsknapper. Den første: «Nødetat» sender de valgte enhetene ut på oppdraget. Den andre gjør det samme som den første, men går ut på neste oppdrag. Klikk på den første knappen.",
                        dispatch_menu_mission_general: "Her kan du se generell oppdragsinfo, altså navnet, adressen og oppdragsikonet. Ikonet av den lille mannen dukker opp og erstatter en liten stjerne på oppdrag du allerede deltar på.",
                        dispatch_menu_mission_progress: "Her kan du se hvor mye framdrift som er gjort på oppdraget, samt antallet personell på stedet og hvor mye tid du har igjen.",
                        dispatch_menu_mission_specific: "Her kan du se info om oppdraget, hvilke enheter som svarer på nødanropet og hvem som allerede er på stedet.",
                        dispatch_menu_vehicle_list: "Dette er listen over dine tilgjengelige fremkomstmidler. Velg fremkomstmidler her. Velg fremkomstmiddelet ved å klikke på det."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Nå skal vi lære å håndtere ulykker. Åpne nødetatsmenyen ved å klikke på en nødetatsknapp.",
                        first_mission: "Flott, du har bygget din første bygning! Se, de første oppdragene ble meldt inn til deg!"
                    },
                    mobile: {
                        dispatch_button: "Nå skal vi lære å håndtere ulykker. Åpne nødetatsmenyen ved å klikke på en nødetatsknapp.",
                        first_mission: "Flott, du har bygget din første bygning! Se, de første oppdragene ble meldt inn til deg!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Flott, nå er du på vei til å bli en god nødsentralleder! Her får du %{coins} mynter for å komme i gang! </br> Nødsentralspillet-teamet"
                },
                mobile: {
                    general: "Flott, nå er du på vei til å bli en god nødsentralleder! Her får du %{coins} mynter for å komme i gang! </br> Nødsentralspillet-teamet"
                }
            },
            tips: {
                browser: {
                    contact: "Hvis du har spørsmål, kan du sjekke med spillets Vanlige spørsmål eller gå til spillforumet eller Facebook-siden vår.",
                    general: "I neste trinn anbefaler vi deg å bygge et nødetatssenter og så snart som mulig nye stasjoner, siden maks antall oppdrag er lik det høyeste antallet stasjoner av en stasjonstype (politi, brann, ambulanse) pluss 1. F.eks. 5 brannstasjoner og 3 ambulansestasjoner = 6 oppdrag.",
                    join_alliance: "Det er også nyttig å bli med i allianser, spesielt i begynnelsen, så det anbefales også.",
                    summary: "Dette er det grunnleggende i Nødsentralspillet! Utfør oppdrag, få kreditter, kjøp flere enheter og gjenta. Kos deg med spillingen! </br> Nødsentralspillet-teamet"
                },
                mobile: {
                    contact: "Hvis du har spørsmål, kan du sjekke med spillets Vanlige spørsmål eller gå til spillforumet eller Facebook-siden vår.",
                    general: "I neste trinn anbefaler vi deg å bygge et nødetatssenter og så snart som mulig nye stasjoner, siden maks antall oppdrag er lik det høyeste antallet stasjoner av en stasjonstype (politi, brann, ambulanse) pluss 1. F.eks. 5 brannstasjoner og 3 ambulansestasjoner = 6 oppdrag.",
                    join_alliance: "Det er også nyttig å bli med i allianser, spesielt i begynnelsen, så det anbefales også.",
                    summary: "Dette er det grunnleggende i Nødsentralspillet! Utfør oppdrag, få kreditter, kjøp flere enheter og gjenta. Kos deg med spillingen! </br> Nødsentralspillet-teamet"
                }
            }
        },
        commons: {
            collect: "Hent",
            "continue": "Nei",
            end: "Slutt",
            next: "Neste",
            prev: "Forrige",
            skip: "Ja",
            skip_hint: "Vil du avslutte veiledningen? Den vil ikke være tilgjengelig senere. Du vil ikke få belønningen for fullført veiledning."
        },
        rewards: {
            log: "Belønning for å fullføre veiledningen."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Så gir du stasjonen et navn. Gjør det gjenkjennelig og skalerbart! F.eks. «Politistasjon nr. 0001». Når du er ferdig, klikker du på «Neste»!",
                            select_building: "Velg først bygningstypen du vil begynne med, vi anbefaler deg å begynne med politistasjon! Det er også lurt å begynne med en liten stasjon."
                        },
                        welcome: "Hei og velkommen til Nødsentralspillet Politiet! Jeg skal lære deg hvordan du får en pangstart i nødetatenes verden!"
                    },
                    mobile: {
                        build_building: {
                            add_name: "Så gir du stasjonen et navn. Gjør det gjenkjennelig og skalerbart! F.eks. «Politistasjon nr. 0001». Når du er ferdig, klikker du på «Neste»!",
                            select_building: "Velg først bygningstypen du vil begynne med, vi anbefaler deg å begynne med politistasjon! Det er også lurt å begynne med en liten stasjon."
                        },
                        welcome: "Hei og velkommen til Nødsentralspillet Politiet! Jeg skal lære deg hvordan du får en pangstart i nødetatenes verden!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Flott, nå er du på vei til å bli en god nødsentralleder! Her får du %{coins} mynter for å komme i gang! </br> Nødsentralspillet-teamet"
                    },
                    mobile: {
                        general: "Flott, nå er du på vei til å bli en god nødsentralleder! Her får du %{coins} mynter for å komme i gang! </br> Nødsentralspillet-teamet"
                    }
                },
                tips: {
                    browser: {
                        summary: "Dette er det grunnleggende i Nødsentralspillet Politiet! Utfør oppdrag, få kreditter, kjøp flere enheter og gjenta. Kos deg med spillingen! </br> Nødsentralspillet-teamet"
                    },
                    mobile: {
                        summary: "Dette er det grunnleggende i Nødsentralspillet Politiet! Utfør oppdrag, få kreditter, kjøp flere enheter og gjenta. Kos deg med spillingen! </br> Nødsentralspillet-teamet"
                    }
                }
            }
        }
    }
}, I18n.translations.cs_CZ = {
    common: {
        add: "Přidat",
        back: "Zpět",
        cancel: "Zrušit",
        change_saved: "Změny uloženy",
        coins_spend: "Opravdu chcete mince utratit?",
        congratulations: "Blahopřejeme!",
        content: "Obsah",
        credits: "Kredity",
        "delete": "Odstranit",
        details: "Podrobnosti",
        edit: "Upravit",
        error: "Chyba",
        is_offline: "%{user} je offline.",
        is_offline_long: "%{user} je už dlouho offline",
        is_offline_with_duration: "%{user} je offline: %{duration}",
        is_online: "%{user} je online.",
        loading: "Načítání…",
        name: "Název",
        none: "Nic",
        of: "z",
        off: "Vyp.",
        on: "Zap.",
        save: "Uložit",
        search: "Hledat",
        show: "Zobrazit",
        user_not_found: "Uživatel nenalezen",
        wrong_key: "Nesprávná klávesa"
    },
    javascript: {
        alarm: "Výjezd",
        arrival: "Příjezd",
        backalarm: "Zrušit",
        coins: "Mince",
        credits: "Kredity",
        days: "d",
        few_seconds: "za pár sekund",
        finish_in: "Konec za:",
        hours: "h",
        location_not_found: "Nenalezeno",
        messages: "Zprávy",
        minutes: "min",
        missed_vehicle: "Chybí:",
        mission_start_in: "Začne za:",
        "new": "Nový",
        not_found_map: "Vozidlo nebylo nalezeno nikde na mapě",
        now: "Teď",
        patient: "Pacient",
        patient_untouched: "Neošetření pacienti",
        poi_delete: "Opravdu chcete odstranit bod zájmu: %{caption}?",
        reload: "Obnovit",
        sale: "Prodej",
        sale_ended: "Prodej ukončen",
        secounds: "s",
        sicherheitswache_error: "Hlídka %{caption} nebyla úspěšná, protože nebyla splněna všechna kritéria.",
        sicherheitswache_success: "Hlídka %{caption} byla úspěšná. Získáte %{credits} kreditů.",
        start_in: "Začátek za: ",
        start_username: "Zahájil uživatel:",
        time_left: "Zbývající čas:",
        to_building: "Zobrazit budovu",
        to_mission: "Zobrazit misi",
        understand: "OK",
        user_not_found: "Hráč nebyl nalezen.",
        vehicles_not_visible: "Vozidla nejsou vidět. "
    },
    map: {
        alliance: "Aliance",
        alliance_chat: "Chat",
        alliance_chat_banned: "Z aliančního chatu jste aktuálně vypovězeni.",
        alliance_chat_banned_admin: "Ban od hráče:",
        alliance_chat_banned_timeleft: "Zbývající čas:",
        alliance_chat_radio_off: "Alianční vysílačka: Vyp.",
        alliance_chat_radio_on: "Alianční vysílačka: Zap.",
        alliance_event: "Akce",
        alliance_missions: "Alianční mise",
        alliance_missions_event: "Akce",
        ambulance: "Sanitka",
        attended: "Řešené",
        cancel_alliance_event: "Zrušit alianční akci",
        cancel_alliance_event_confirm: "Opravdu chcete alianční akci zrušit?",
        challenges: "Výzvy",
        chat_history: "Historie chatu",
        congratulations: "Blahopřejeme! Nyní můžete povýšit.",
        create_alliance_event: "Zahájit alianční akci",
        create_alliance_operation: "Vytvořit velkou alianční misi",
        emergency: "Stav nouze",
        finishing: "Dokončované",
        join_alliance_infos: "V alianci vám ostatní hráči můžou dávat mise.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Budovy",
            all_missions: "Mise",
            alliance_buildings: "Alianční budovy",
            alliance_members: "Členové",
            alliance_missions: "Sdíleno aliancí",
            ambulance_station_missions: "Výjezdové stanoviště ZZS",
            ambulance_station_small_missions: "Výjezdové stanoviště ZZS (malá)",
            building_complex: "Komplex budov",
            buildings_section: "Stanice",
            clinic_missions: "Klinika",
            dispatch_center_missions: "Operační středisko",
            fire_school_missions: "Školní a výcvikové zařízení HZS",
            firehouse_missions: "Požární stanice",
            firehouse_small_missions: "Požární stanice (malá)",
            hospital_missions: "Nemocnice",
            map_filters: "Seznam filtrů mapy",
            mission_positions: "Body zájmu (BZ)",
            mission_positions_section: "BZ",
            missions_section: "Mise",
            police_copter_station_missions: "Základna Letecké služby PČR",
            police_school_missions: "Policejní Akademie",
            police_small_missions: "Obvodní oddělení Policie (malé)",
            police_special_forces: "Speciální policejní jednotky",
            police_station_missions: "Obvodní oddělení Policie",
            prison_missions: "Policejní cela",
            rapid_deployment_group: "Krizový tým",
            rescue_copter_station_missions: "Základna Letecké záchranné služby",
            riot_police: "Pořádková jednotka",
            riot_police_missions: "Pořádková jednotka",
            staging_area_missions: "Přípravná oblast",
            technical_aid_organization: "Technická pomoc",
            technical_aid_organization_school: "Škola technické pomoci",
            user_buildings: "Moje budovy",
            user_missions: "Moje mise",
            water_watch: "Vodní záchranná služba",
            water_watch_missions: "Vodní záchranná služba"
        },
        message: "Zpráva",
        mission: "Mise",
        missions_filtered_out: "Některé mise mohou být odfiltrovány. Zkontrolujte prosím své mapové filtry.",
        no_alliance_chat_impossible: "Nejste v žádné alianci.",
        no_alliance_missions: "K dispozici nejsou žádné alianční mise.",
        no_ambulance_missions: "Mise záchranné služby nejsou k dispozici. Objeví se, až když budete mít záchrannou službu a nemocnici.",
        no_emergency_missions: "Nouzové mise nejsou k dispozici. Objeví se, až postavíte první stanici.",
        no_radio_messages: "Na vysílačku vám nepřišly žádné zprávy.",
        radio_messages: "Vysílačka",
        restore_map: "Obnovit mapu",
        server_warning: "Údržba serveru v 00:00. Předpokládáme 6hodinové odstavení.",
        show_informations: "Zelená = Mise budou zobrazeny v seznamu. Červená = Mise nebudou zobrazeny.",
        sicherheitswache: "Plánované mise",
        transport: "Převoz",
        unattended: "Neřešené"
    },
    fms: {
        going: "Na cestě",
        not_ready: "Mimo provoz",
        on_destination: "Na místě",
        on_place: "Na místě",
        patient_transported: "Převoz pacienta",
        prisoner_transported: "Převoz vězně",
        ready_home: "K dispozici",
        ready_traveling: "K dispozici (na cestě)",
        talking_wish: "Žádost o převoz",
        waiting_for_vehicle: "Čekání na odtah"
    },
    intervention_order: {
        back: "Zpět",
        category: "Kategorie",
        colour: "Barva",
        column: "Sloupec",
        column_number: "Číslo sloupce",
        column_number_hint: "Když zadáte číslo sloupce, pravidlo nouzového výjezdu se zobrazí v příslušném sloupci na stránce nouzové situace.",
        create_intervention_order: "Vytvořit nové pravidlo nouzového výjezdu",
        "delete": "Odstranit",
        delete_all: "Odstranit všechna pravidla nouzových výjezdů",
        delete_all_confirm: "Opravdu chcete odstranit všechna pravidla? Exportované položky už nejsou k dispozici!",
        description: "Název",
        edit: "Upravit",
        "export": {
            "export": "Exportovat",
            "import": "Importovat",
            import_done: "Vybrané položky byly importovány a zaneseny do plánu nouzových výjezdů.",
            saved: "Export pravidel nouzových výjezdů",
            saved_text: "Pravidlo nouzového výjezdu je připravené k exportu. Ostatní hráči mohou pravidlo importovat pomocí odkazu. Pokud mezitím pravidlo změníte, změna se automaticky promítne i do exportu."
        },
        hotkey_hint: "Přiřaďte tomuto výběru klávesu. V okně s misí stiskněte: ALT + klávesa (nebo ve Firefoxu: ALT + SHIFT + klávesa, nebo na Mac OS: CTRL + ALT + klávesa), a tím proveďte přednastavený výběr vozidel.",
        intervention_order: "Upravit pravidla nouzových výjezdů",
        name: "Název",
        no_intervention_created: "Zatím jste nevytvořili žádné pravidlo nouzového výjezdu.",
        options: "Možnosti",
        reset: "Vymazat předchozí výběr v okně nouzové situace.",
        reset_hint: "Pokud jste už v dispečerském okně vybrali vozidlo, můžete pomocí tohoto tlačítka výběr zrušit.",
        save: "Uložit",
        station: "Stanice",
        station_hint: "Když je vybrána některá budova, označí se pouze její vozidla.",
        successfully_created: "Pravidlo nouzového výjezdu bylo úspěšně vytvořeno.",
        successfully_deleted: "Pravidlo nouzového výjezdu odstraněno",
        successfully_updated: "Pravidlo nouzového výjezdu bylo úspěšně aktualizováno.",
        vehicles: {
            ab_atemschutz_only: "Modul s dýchacími přístroji",
            ab_einsatzleitung_only: "Velitelský modul",
            ab_gefahrgut_only: "Modul pro práci s nebezpečnými látkami",
            ab_oel_only: "Modul pro likvidaci uniklé ropy",
            ab_ruest: "Technicko-záchranářský modul",
            ab_ruest_rw: "",
            abl2wasser_only: "Modul s hadicemi",
            ambulance: "Sanitka RZP",
            ambulance_or_rapid_responder: "",
            any_traffic_car: "Vozidlo vyšetřovatelů DN",
            arff: "Letištní speciál",
            battalion_chief_unit: "Velitelský automobil",
            boot: "Přívěs se člunem",
            dekon_p: "",
            division_chief_unit: "MOS",
            dlk_or_tm50: "",
            elw1_or_elw2: "VEA nebo MOS",
            elw2_or_ab_elw: "MOS nebo řízení provozu",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Sanitka nebo vrtulník",
            fbi_bomb_tech: "Vozidlo pyrotechnika PČR",
            fire_truck: "Hasičské vozy",
            fireboat: "Velká hasičská loď",
            fly_car: "Lékařské vozidlo RV",
            fly_car_any: "Samochód Lekarza  / SRMed / Motoambulans",
            fukw: "",
            fustw_or_police_motorcycle: "Policejní automobil nebo Policejní motocykl",
            fwk: "",
            gefkw: "",
            gkw: "Užitkový vůz",
            grtw: "Jednotka pro hromadná neštěstí",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Nebezpečné látky",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Výšková jednotka",
            gw_messtechnik: "Detekční jednotka",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "Potápěčský automobil",
            gw_wasserrettung: "SUV VZS ČČK nebo Dodávka VZS ČČK",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Vozidlo s hadicí",
            hems: "LZS",
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "",
            k9: "Vozidlo Kynologů PČR",
            kdow_lna: "",
            kdow_orgl: "IP",
            kdow_orgl_any: "IP",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Lehčí velitelské vozidlo",
            lf_only: "Hasičské vozy",
            long_distance_ambulance: "Sanitka DZS",
            mask_service_unit: "Protiplynový automobil",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Transportní týmový vůz",
            mzb: "Přívěs se člunem",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Sanitka",
            oil_unit: "Ropná jednotka",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Hlídkový vůz",
            police_motorcycle: "Policejní motocykl",
            polizeihubschrauber: "Policejní vrtulník",
            rescue_vehicle: "Technický automobil",
            rescue_vehicle_only: "Těžká záchranářská jednotka",
            rescueboat: "Velká záchranářská loď",
            rettungstreppe: "",
            rth_only: "Vrtulník LZS",
            schlauchwagen: "Kombinovaný hasící automobil",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "URNA",
            swat_armored_vehicle: "Obrněné vozidlo URNA",
            swat_suv: "URNA SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Transportní vůz techniků",
            thw_mzkw: "Víceúčelové vozidlo",
            thw_tauchkraftwagen: "Potápěčský tým",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Vůz s cisternou",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "AZ nebo AP",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Dál svou novou stanici pojmenujte. Název by měl být rozpoznatelný a škálovatelný. Např. „Hasičská stanice 1“. Až bude hotovo, klikněte na možnost „Další“.",
                        build_with_credits: "Teď si budovu postavte za kredity.",
                        new_building: "Klikněte na možnost „Nová budova“.",
                        select_building: "Nejdřív si vyberte typ budovy, se kterou chcete začít. Doporučujeme začít s hasičskou stanicí. V každém případě doporučujeme začínat s malou stanicí.",
                        select_position: "Přesuňte modrý ukazatel na místo, kde chcete postavit svou první stanici."
                    },
                    pick_location: "Nejdřív si vyberte místo, kde chcete začít. Do vyhledávacího panelu napište název místa, ve kterém chcete začít, případně místo najděte na mapě. Co takhle město, ve kterém bydlíte?",
                    welcome: "Zdravíme! Vítejte ve hře Operační středisko!  V několika lekcích vás naučím, jak správně odstartovat kariéru v záchranných službách."
                },
                mobile: {
                    build_building: {
                        add_name: "Dál svou novou stanici pojmenujte. Název by měl být rozpoznatelný a škálovatelný. Např. „Hasičská stanice 1“. Až bude hotovo, klikněte na možnost „Další“.",
                        build_with_credits: "Teď si budovu postavte za kredity.",
                        new_building: "Nejdřív vybereme počáteční místo a postavíme první budovu. <br /> <br /> Proveďte to kliknutím na možnost „Nová budova“.",
                        select_building: "Nejdřív si vyberte typ budovy, se kterou chcete začít. Doporučujeme začít s hasičskou stanicí. V každém případě doporučujeme začínat s malou stanicí."
                    },
                    welcome: "Zdravíme! Vítejte ve hře Operační středisko!  V několika lekcích vás naučím, jak správně odstartovat kariéru v záchranných službách."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Toto je nabídka výjezdů. Odtud na mise posíláte jednotky.",
                        dispatch_menu_buttons: "Toto jsou dvě výjezdní tlačítka. První: „Výjezd“ vyšle vybrané jednotky na misi. Druhé dělá to samé jako první, ale přesune vás také na další misi. Prozatím klikněte na první tlačítko.",
                        dispatch_menu_mission_general: "Dozvíte se zde obecné informace o misi, čili název, adresu a ikonu mise. U misí, které jste už začali řešit, se objeví ikonka člověka, která nahradí hvězdičku.",
                        dispatch_menu_mission_progress: "Dozvíte se zde, kolik pokroku se na misi udělalo, a také počet záchranářů na místě. Uveden je také čas zbývající do splnění mise.",
                        dispatch_menu_mission_specific: "Tady se dozvíte další podrobnosti o misi, které jednotky vyjedou a které už jsou na místě.",
                        dispatch_menu_vehicle_list: "Toto je seznam vašich dostupných vozidel. Vozidla vybíráte zde. Teď vyberte vozidlo tak, že na něj kliknete."
                    },
                    mobile: {
                        dispatch_menu: "Toto je nabídka výjezdů. Odtud na mise posíláte jednotky.",
                        dispatch_menu_buttons: "Toto jsou dvě výjezdní tlačítka. První: „Výjezd“ vyšle vybrané jednotky na misi. Druhé dělá to samé jako první, ale přesune vás také na další misi. Prozatím klikněte na první tlačítko.",
                        dispatch_menu_mission_general: "Dozvíte se zde obecné informace o misi, čili název, adresu a ikonu mise. U misí, které jste už začali řešit, se objeví ikonka člověka, která nahradí hvězdičku.",
                        dispatch_menu_mission_progress: "Dozvíte se zde, kolik pokroku se na misi udělalo, a také počet záchranářů na místě. Uveden je také čas zbývající do splnění mise.",
                        dispatch_menu_mission_specific: "Tady se dozvíte další podrobnosti o misi, které jednotky vyjedou a které už jsou na místě.",
                        dispatch_menu_vehicle_list: "Toto je seznam vašich dostupných vozidel. Vozidla vybíráte zde. Teď vyberte vozidlo tak, že na něj kliknete."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Teď se naučíme, jak se vypořádat s nehodami. Kliknutím na tlačítko „Výjezd“ otevřete nabídku výjezdů.",
                        first_mission: "Výborně! Postavili jste svou vůbec první budovu! Podívejte, už se vám hlásí první mise."
                    },
                    mobile: {
                        dispatch_button: "Teď se naučíme, jak se vypořádat s nehodami. Kliknutím na tlačítko „Výjezd“ otevřete nabídku výjezdů.",
                        first_mission: "Výborně! Postavili jste svou vůbec první budovu! Podívejte, už se vám hlásí první mise."
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Výborně! Jste na té nejlepší cestě stát se úžasným vedoucím operačního střediska. Zde máte %{coins} mincí na začátek. </br> Váš tým hry Operační středisko"
                },
                mobile: {
                    general: "Výborně! Jste na té nejlepší cestě stát se úžasným vedoucím operačního střediska. Zde máte %{coins} mincí na začátek. </br> Váš tým hry Operační středisko"
                }
            },
            tips: {
                browser: {
                    contact: "Pokud máte nějaké dotazy, můžete se podívat do častých dotazů o hře, případně navštivte naše herní fórum nebo stránku na Facebooku.",
                    general: "V dalším kroku bychom vám doporučili postavit dispečink a poté co nejrychleji další stanice, jelikož maximální počet misí se rovná maximálnímu počtu stanic různého typu (policie, hasiči, záchranka) plus 1. Tedy např. 5 hasičských stanic a 3 stanice záchranky = 6 misí.",
                    join_alliance: "Přidat se k alianci by vám rovněž mohlo velice pomoct, hlavně na začátku. Takže to také doporučujeme.",
                    summary: "Toto jsou základy hry Operační středisko! Plňte mise, získávejte kredity, nakupujte další jednotky. Postup opakujte. Příjemnou zábavu při hraní! </br> Váš tým hry Operační středisko"
                },
                mobile: {
                    contact: "Pokud máte nějaké dotazy, můžete se podívat do častých dotazů o hře, případně navštivte naše herní fórum nebo stránku na Facebooku.",
                    general: "V dalším kroku bychom vám doporučili postavit dispečink a poté co nejrychleji další stanice, jelikož maximální počet misí se rovná maximálnímu počtu stanic různého typu (policie, hasiči, záchranka) plus 1. Tedy např. 5 hasičských stanic a 3 stanice záchranky = 6 misí.",
                    join_alliance: "Přidat se k alianci by vám rovněž mohlo velice pomoct, hlavně na začátku. Takže to také doporučujeme.",
                    summary: "Toto jsou základy hry Operační středisko! Plňte mise, získávejte kredity, nakupujte další jednotky. Postup opakujte. Příjemnou zábavu při hraní! </br> Váš tým hry Operační středisko"
                }
            }
        },
        commons: {
            collect: "Sebrat",
            "continue": "Ne",
            end: "Konec",
            next: "Další",
            prev: "Předchozí",
            skip: "Ano",
            skip_hint: "Opravdu chcete výuku zrušit? Později už se k ní nedostanete. Nedostanete odměnu za dokončení výuky."
        },
        rewards: {
            log: "Odměna za dokončení výuky."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Dál svou novou stanici pojmenujte. Název by měl být rozpoznatelný a škálovatelný. Např. „Obvodní oddělení Policie 001“. Až bude hotovo, klikněte na možnost „Další“.",
                            select_building: "Nejdřív si vyberte typ budovy, se kterou chcete začít. Doporučujeme začít s policejní stanicí. V každém případě doporučujeme začínat s malou stanicí."
                        },
                        welcome: "Zdravíme! Vítejte ve hře Operační středisko Policie! V několika lekcích vás naučím, jak správně odstartovat kariéru v záchranných službách."
                    },
                    mobile: {
                        build_building: {
                            add_name: "Dál svou novou stanici pojmenujte. Název by měl být rozpoznatelný a škálovatelný. Např. „Obvodní oddělení Policie 001“. Až bude hotovo, klikněte na možnost „Další“.",
                            select_building: "Nejdřív si vyberte typ budovy, se kterou chcete začít. Doporučujeme začít s policejní stanicí. V každém případě doporučujeme začínat s malou stanicí."
                        },
                        welcome: "Zdravíme! Vítejte ve hře Operační středisko Policie! V několika lekcích vás naučím, jak správně odstartovat kariéru v záchranných službách."
                    }
                },
                rewards: {
                    browser: {
                        general: "Výborně! Jste na té nejlepší cestě stát se úžasným vedoucím operačního střediska policie. Zde máte %{coins} mincí na začátek. </br> Váš tým hry Operační středisko Policie"
                    },
                    mobile: {
                        general: "Výborně! Jste na té nejlepší cestě stát se úžasným vedoucím operačního střediska policie. Zde máte %{coins} mincí na začátek. </br> Váš tým hry Operační středisko Policie"
                    }
                },
                tips: {
                    browser: {
                        summary: "Toto jsou základy hry Operační středisko Policie! Plňte mise, získávejte kredity, nakupujte další jednotky. Postup opakujte. Příjemnou zábavu při hraní! </br> Váš tým hry Operační středisko Policie"
                    },
                    mobile: {
                        summary: "Toto jsou základy hry Operační středisko Policie! Plňte mise, získávejte kredity, nakupujte další jednotky. Postup opakujte. Příjemnou zábavu při hraní! </br> Váš tým hry Operační středisko Policie"
                    }
                }
            }
        }
    }
}, I18n.translations.tr_TR = {
    common: {
        add: "Ekle",
        back: "Geri",
        cancel: "İptal et",
        change_saved: "Değişiklikler kaydedildi",
        coins_spend: "Gerçekten bu altınları harcamak istiyor musun?",
        congratulations: "Tebrikler!",
        content: "İçerik",
        credits: "Krediler",
        "delete": "Sil",
        details: "Ayrıntılar",
        edit: "Düzenle",
        error: "Hata",
        is_offline: "%{user} çevrim dışı.",
        is_offline_long: "Uzun süre: %{user} çevrim dışı",
        is_offline_with_duration: "%{user} çevrim dışı: %{duration}",
        is_online: "%{user} çevrim içi.",
        loading: "Yükleniyor...",
        name: "Ad",
        none: "Yok",
        of: "/",
        off: "Kapalı",
        on: "Açık",
        save: "Kaydet",
        search: "Ara",
        show: "Göster",
        user_not_found: "Kullanıcı bulunmadı",
        wrong_key: "Yanlış tuş"
    },
    javascript: {
        alarm: "Sevk Et",
        arrival: "Varış",
        backalarm: "İptal et",
        coins: "Altın",
        credits: "Krediler",
        days: "gün",
        few_seconds: "birkaç saniyede",
        finish_in: "Bitir:",
        hours: "S",
        location_not_found: "Bulunmadı",
        messages: "Mesajlar",
        minutes: "dk.",
        missed_vehicle: "Eksik:",
        mission_start_in: "Başlıyor:",
        "new": "Yeni",
        not_found_map: "Araç haritada bulunamadı",
        now: "Şimdi",
        patient: "Hasta",
        patient_untouched: "Tedavi edilmeyen hastalar",
        poi_delete: "%{caption} İlgili Alanını silmek istediğinden emin misin?",
        reload: "Yeniden yükle",
        sale: "Satış",
        sale_ended: "İndirim sona erdi.",
        secounds: "sn.",
        sicherheitswache_error: 'Tüm kriterler sağlanmadığı için güvenlik koruması "%{caption}" başarılı olamadı.',
        sicherheitswache_success: 'Güvenlik koruması "%{caption}" başarıyla gerçekleştirildi. %{credits} Kredi al.',
        start_in: "Başlıyor: ",
        start_username: "Başlatan:",
        time_left: "Kalan süre:",
        to_building: "Yapıyı Görüntüle",
        to_mission: "Görevi Görüntüle",
        understand: "Onayla",
        user_not_found: "Oyuncu bulunamadı.",
        vehicles_not_visible: "Araçlar görünmüyor. "
    },
    map: {
        alliance: "Birlik",
        alliance_chat: "Sohbet",
        alliance_chat_banned: "Şu anda birlik sohbetinde yasaklısın.",
        alliance_chat_banned_admin: "Yasaklayan:",
        alliance_chat_banned_timeleft: "Kalan süre:",
        alliance_chat_radio_off: "Birlik Radyosu: Kapalı",
        alliance_chat_radio_on: "Birlik Radyosu: Açık",
        alliance_event: "Etkinlik",
        alliance_missions: "Birlik Görevleri",
        alliance_missions_event: "Etkinlik",
        ambulance: "Ambulans",
        attended: "Attended",
        cancel_alliance_event: "Cancel alliance event",
        cancel_alliance_event_confirm: "Do you really want to cancel the alliance event?",
        challenges: "",
        chat_history: "Sohbet Geçmişi",
        congratulations: "Tebrikler! Artık terfi alabilirsin.",
        create_alliance_event: "Birlik etkinliği başlat",
        create_alliance_operation: "Büyük ölçekli bir birlik görevi oluştur",
        emergency: "Acil Durum",
        finishing: "Finishing",
        join_alliance_infos: "Bir birlikteysen diğer oyuncular sana istedikleri gibi görevler verebilirler.",
        map: "Harita",
        map_filters: {
            all_buildings: "Yapılar",
            all_missions: "Görevler",
            alliance_buildings: "Birlik Yapıları",
            alliance_members: "Üyeler",
            alliance_missions: "Birlik Paylaşımları",
            ambulance_station_missions: "Ambulans İstasyonu",
            ambulance_station_small_missions: "Ambulans istasyonu (Küçük istasyon)",
            building_complex: "Building Complex",
            buildings_section: "İstasyonlar",
            clinic_missions: "Klinik",
            dispatch_center_missions: "Sevk Merkezi",
            fire_school_missions: "İtfaiye Akademisi",
            firehouse_missions: "İtfaiye İstasyonu",
            firehouse_small_missions: "İtfaiye İstasyonu (Küçük)",
            hospital_missions: "Hastane",
            map_filters: "Harita filtreleri listesi",
            mission_positions: "İlgi Alanları (POI'ler)",
            mission_positions_section: "POI'ler",
            missions_section: "Görevler",
            police_copter_station_missions: "Polis helikopter heliportu",
            police_school_missions: "Polis akademisi",
            police_small_missions: "Polis Karakolu (Küçük karakol)",
            police_special_forces: "Polis özel harekat",
            police_station_missions: "Polis Karakolu",
            prison_missions: "Hapishane",
            rapid_deployment_group: "Hızlı Kurulum Grubu (SEG)",
            rescue_copter_station_missions: "Tıbbi Helikopter İstasyonu",
            riot_police: "Çevik Kuvvet",
            riot_police_missions: "Çevik Kuvvet",
            staging_area_missions: "Toplanma Alanı",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Yapılarım",
            user_missions: "Görevlerim",
            water_watch: "Su Kurtarma",
            water_watch_missions: "Su Kurtarma"
        },
        message: "Mesaj",
        mission: "Görev",
        missions_filtered_out: "Bazı görevler filtrelenebilir. Lütfen harita filtrelerinizi kontrol edin.",
        no_alliance_chat_impossible: "Bir birlikte değilsin.",
        no_alliance_missions: "Şu anda hiçbir birlik görevi yok.",
        no_ambulance_missions: "Hiçbir ambulans görevi yok. Ambulans görevlerini sadece bir ambulansa ve bir hastaneye sahip olduğunda yapabilirsin.",
        no_emergency_missions: "Şu anda hiçbir acil durum görevi yok. İlk istasyonunu yaptıktan sonra bir acil durum görevi alabilirsin.",
        no_radio_messages: "Hiçbir radyo mesajı almadın.",
        radio_messages: "Radyo",
        restore_map: "Haritayı Geri Yükle",
        server_warning: "Server maintenance at 18:00 UTC. 6h downtime expected.",
        show_informations: "Yeşil = Görevler liste içinde gösterilir. Kırmızı = Görevler gösterilmez.",
        sicherheitswache: "Planlanan Gösterimler",
        transport: "Nakil",
        unattended: "Unattended"
    },
    fms: {
        going: "Müdahale ediyor",
        not_ready: "Hizmet Dışı",
        on_destination: "Nakil varış noktasında",
        on_place: "Olay Yerinde",
        patient_transported: "Hasta Nakil Ediliyor",
        prisoner_transported: "Mahkum Nakil Ediliyor",
        ready_home: "İstasyonda Hazır",
        ready_traveling: "Boşta ve Kullanılabilir",
        talking_wish: "Nakil Talebi",
        waiting_for_vehicle: "Araç tarafından çekilmeyi bekliyor"
    },
    intervention_order: {
        back: "Geri",
        category: "Kategori",
        colour: "Renk",
        column: "Sütun",
        column_number: "Sütun sayısı",
        column_number_hint: "Bir sütun sayısı verildiyse Alarm ve Müdahale girdisi, alarm sayfasındaki ilgili sütunda görüntülenecektir.",
        create_intervention_order: "Yeni Alarm ve Müdahale Düzenlemesi oluştur",
        "delete": "Sil",
        delete_all: "Alarm ve Müdahale Düzenlemelerini tamamen sil",
        delete_all_confirm: "Tüm alarm ve müdahale düzenlemesini silmek istediğinden emin misin? Daha önceden dışa aktarılmış girdiler artık kullanılamaz!",
        description: "Ad",
        edit: "Düzenle",
        "export": {
            "export": "Dışa aktar",
            "import": "İçe aktar",
            import_done: "Seçili girdiler içe aktarıldı ve Alarm ve Müdahale planına kaydedildi.",
            saved: "Alarm ve Müdahale Düzenlemelerinin Dışa Aktarımları",
            saved_text: "Alarm ve Müdahale Düzenlemesi dışa aktarım için hazırlandı. Bu bağlantı ile başka bir oyuncu Alarm ve Müdahale Düzenlemesini içe aktarabilir. Bu esnada Alarm ve Müdahale Düzenlemesini değiştirirsen bu değişiklik dışa aktarımda otomatik olarak uygulanacak."
        },
        hotkey_hint: "Bu araç seçimi için bir kısayol tuşu seç. Pencerendeki göreve bas: ALT + kısayol tuşun (veya Firefox'ta: ALT + SHIFT + kısayol tuşun veya Mac işletim sisteminde: ctrl + alt + kısayol tuşun) ile araç seçimini yap.",
        intervention_order: "Alarm ve Müdahale Düzenlemelerini düzenle",
        name: "Ad",
        no_intervention_created: "Henüz hiçbir Alarm ve Müdahale Düzenlemesi oluşturmadın.",
        options: "Seçenekler",
        reset: "Önceki seçimi alarm penceresinde sıfırla.",
        reset_hint: "Aracı sevk penceresinde seçtiysen onu sıfırlamak için bu tuşu kullanabilirsin.",
        save: "Kaydet",
        station: "İstasyon",
        station_hint: "Bir yapı seçildiğinde sadece ilgili yapıya ait araçlar seçilecektir.",
        successfully_created: "Alarm ve Müdahale Düzenlemesi başarıyla oluşturuldu.",
        successfully_deleted: "Alarm ve Müdahale Düzenlemesi silindi",
        successfully_updated: "Alarm ve Müdahale Düzenlemesi başarıyla güncellendi.",
        vehicles: {
            ab_atemschutz_only: "SCBA Modülü",
            ab_einsatzleitung_only: "Komuta Modülü",
            ab_gefahrgut_only: "Tehlikeli Madde Modülü",
            ab_oel_only: "Yağ Sızıntısı Modülü",
            ab_ruest: "Teknik/Kurtarma Modülü",
            ab_ruest_rw: "",
            abl2wasser_only: "Hortumla Besleme Modülü",
            ambulance: "ALS ambulansı",
            ambulance_or_rapid_responder: "",
            arff: "ARFF (Havalimanı İtfaiye Aracı)",
            battalion_chief_unit: "Tabur Amiri birimi",
            boot: "Botlar (Genel)",
            dekon_p: "",
            division_chief_unit: "Mobil Komuta Aracı",
            dlk_or_tm50: "",
            elw1_or_elw2: "Tabur Amiri Birimi, Mobil Komuta Aracı veya Mobil Komuta Modülü ",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Acil durum ambulansı veya Helikopteri",
            fire_truck: "İtfaiye Araçları",
            fireboat: "Büyük İtfaiye Botları",
            fly_car: "Uçan Araba",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Hizmet Kamyonu",
            grtw: "Mobil Hastane Aracı",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Tehlikeli Madde",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Su Toplama",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Hortumlu Araç",
            hems: "Hızır Acil Helikopteri",
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "",
            k9: "Polis K-9 Aracı",
            kdow_lna: "",
            kdow_orgl: "Hızır Acil Amiri",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "İtfaiye Araçları",
            long_distance_ambulance: "BLS ambulansı",
            mask_service_unit: "Mobil Hava Birimi",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Çok Amaçlı Bot",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulans",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Devriye arabası",
            polizeihubschrauber: "Polis helikopteri",
            rescue_vehicle: "Büyük kurtarma aracı",
            rescue_vehicle_only: "Büyük Kurtarma",
            rescueboat: "Büyük Kurtarma Botu",
            rettungstreppe: "",
            rth_only: "Helikopter",
            schlauchwagen: "Su Tankeri",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "PÖH",
            swat_armored_vehicle: "PÖH Zırhlı Aracı",
            swat_suv: "PÖH SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Dalış Ekibi",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Tanker",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Platformlu kamyonlar",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'İkinci adımda yeni istasyonuna bir isim ver! Farkedilebilir ve ölçeklenebilir olsun! Ör. "İtfaiye istasyonu no. 0001". İşin bittiğinde lütfen "İleri" ögesine tıkla!',
                        build_with_credits: "Şimdi binanı kredilerinle inşa et!",
                        new_building: '"Yeni bina" ögesine tıkla!',
                        select_building: "Öncelikle başlamak istediğin bina tipini seç, itfaiye ile başlamanı şiddetle tavsiye ederiz! Her durumda küçük bir istasyonla başlaman daha iyi olur!",
                        select_position: "Mavi işaretçiyi ilk istasyonunu inşa etmek istediğin yere taşı!"
                    },
                    pick_location: "Başlamak için önce bir konum seç! Başlamak istediğin konumun adını arama çubuğuna yaz veya haritada kendin bul! Memleketine ne dersin?",
                    welcome: "Merhaba, 112 Merkez'e hoş geldin!  Acil servis kariyerine güzel bir başlangıç yapmana yardımcı olacak bazı tüyolar vereceğim sana!"
                },
                mobile: {
                    build_building: {
                        add_name: 'İkinci adımda yeni istasyonuna bir isim ver! Farkedilebilir ve ölçeklenebilir olsun! Ör. "İtfaiye istasyonu no. 0001". İşin bittiğinde lütfen "İleri" ögesine tıkla!',
                        build_with_credits: "Şimdi binanı kredilerinle inşa et!",
                        new_building: 'Başlamak için önce bir konum seçecek ve ilk binanı inşa edeceğiz! <br /> <br /> Bunun için "Yeni bina" ögesine tıkla!',
                        select_building: "Öncelikle başlamak istediğin bina tipini seç, itfaiye ile başlamanı şiddetle tavsiye ederiz! Her durumda küçük bir istasyonla başlaman daha iyi olur!"
                    },
                    welcome: "Merhaba, 112 Merkez'e hoş geldin!  Acil servis kariyerine güzel bir başlangıç yapmana yardımcı olacak bazı tüyolar vereceğim sana!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Bu sevk etme menüsüdür. Buradan birliklerini görevlere gönderirsin!",
                        dispatch_menu_buttons: 'Bunlar ise senin için iki sevk düğmesi! İlki: "Sevk et" seçilen birimleri göreve gönderir. İkincisi birinciyle aynı şeyi yapar, ancak bir sonraki göreve gider. Şimdilik ilk düğmeye tıkla.',
                        dispatch_menu_mission_general: "Burada görevin adı, adresi ve simgesi gibi genel görev bilgilerini görebilirsin. Daha önce katıldığın görevlerde, küçük yıldızın yerini küçük adam simgesi alır.",
                        dispatch_menu_mission_progress: "Burada bu görevle başa çıkmak için ne kadar ilerleme kaydedildiğini, ayrıca sahadaki personel sayısını ve görevin üstesinden gelmek için kalan süreyi görebilirsin!",
                        dispatch_menu_mission_specific: "Burada, hangi birimlerin çağrıya yanıt verdiği ve hangilerinin çoktan sahada olduğu gibi görev hakkında daha fazla bilgi görebilirsin.",
                        dispatch_menu_vehicle_list: "Bu, mevcut araçlarının listesidir. Burada araçları seçersin. Şimdi üzerine tıklayarak aracını seç!"
                    },
                    mobile: {
                        dispatch_menu: "Bu sevk etme menüsüdür. Buradan birliklerini görevlere gönderirsin!",
                        dispatch_menu_buttons: 'Bunlar ise senin için iki sevk düğmesi! İlki: "Sevk et" seçilen birimleri göreve gönderir. İkincisi birinciyle aynı şeyi yapar, ancak bir sonraki göreve gider. Şimdilik ilk düğmeye tıkla.',
                        dispatch_menu_mission_general: "Burada görevin adı, adresi ve simgesi gibi genel görev bilgilerini görebilirsin. Daha önce katıldığın görevlerde, küçük yıldızın yerini küçük adam simgesi alır.",
                        dispatch_menu_mission_progress: "Burada bu görevle başa çıkmak için ne kadar ilerleme kaydedildiğini, ayrıca sahadaki personel sayısını ve görevin üstesinden gelmek için kalan süreyi görebilirsin!",
                        dispatch_menu_mission_specific: "Burada, hangi birimlerin çağrıya yanıt verdiği ve hangilerinin çoktan sahada olduğu gibi görev hakkında daha fazla bilgi görebilirsin.",
                        dispatch_menu_vehicle_list: "Bu, mevcut araçlarının listesidir. Burada araçları seçersin. Şimdi üzerine tıklayarak aracını seç!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Şimdi olaylarla nasıl başa çıkacağımızı öğrenelim. Bir "sevk et" düğmesine tıklayarak sevk etme menüsünü aç!',
                        first_mission: "Harika, ilk binanı inşa ettin! Bak, ilk görevler geldi bile!"
                    },
                    mobile: {
                        dispatch_button: 'Şimdi olaylarla nasıl başa çıkacağımızı öğrenelim. Bir "sevk et" düğmesine tıklayarak sevk etme menüsünü aç!',
                        first_mission: "Harika, ilk binanı inşa ettin! Bak, ilk görevler geldi bile!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Harika, mükemmel bir 112 Merkezi olma yolundasın! İşte sana başlamana yardımcı olmak için %{coins} Altın! </br> 112 Merkez ekibin"
                },
                mobile: {
                    general: "Harika, mükemmel bir 112 Merkezi olma yolundasın! İşte sana başlamana yardımcı olmak için %{coins} Altın! </br> 112 Merkez ekibin"
                }
            },
            tips: {
                browser: {
                    contact: "Soruların varsa oyun içi SSS bölümüne başvurabilir veya oyun forumlarını veya facebook sayfamızı ziyaret edebilirsin!",
                    general: "Bir sonraki adım olarak, bir sevk merkezi ve sonra mümkün olan en kısa sürede yeni istasyonlar inşa etmeni öneririz, çünkü maksimum görev sayısı farklı tipteki istasyonlardan (polis, itfaiye, ambulans) en fazla olanın 1 fazlasına eşittir; ör. 5 itfaiye ve 3 ambulans istasyonu = 6 görev demektir.",
                    join_alliance: "Ayrıca, bir ittifaka katılmak özellikle başlangıçta sana çok yardımcı olacaktır, bu yüzden bunu da tavsiye ederiz.",
                    summary: "İşte bunlar 112 Merkez'in temel özellikleri! Görevleri yerine getir, kredi al, daha fazla birim satın al ve bunları tekrarla. Oyunda iyi eğlenceler! </br> 112 Merkez ekibin"
                },
                mobile: {
                    contact: "Soruların varsa oyun içi SSS bölümüne başvurabilir veya oyun forumlarını veya facebook sayfamızı ziyaret edebilirsin!",
                    general: "Bir sonraki adım olarak, bir sevk merkezi ve sonra mümkün olan en kısa sürede yeni istasyonlar inşa etmeni öneririz, çünkü maksimum görev sayısı farklı tipteki istasyonlardan (polis, itfaiye, ambulans) en fazla olanın 1 fazlasına eşittir; ör. 5 itfaiye ve 3 ambulans istasyonu = 6 görev demektir.",
                    join_alliance: "Ayrıca, bir ittifaka katılmak özellikle başlangıçta sana çok yardımcı olacaktır, bu yüzden bunu da tavsiye ederiz.",
                    summary: "İşte bunlar 112 Merkez'in temel özellikleri! Görevleri yerine getir, kredi al, daha fazla birim satın al ve bunları tekrarla. Oyunda iyi eğlenceler! </br> 112 Merkez ekibin"
                }
            }
        },
        commons: {
            collect: "Topla",
            "continue": "Hayır",
            end: "Bitir",
            next: "Sonraki",
            prev: "Önceki",
            skip: "Evet",
            skip_hint: "Eğitimi gerçekten iptal etmek istiyor musun? Daha sonra erişmek mümkün olmayacak. Eğitim tamamlama ödülü alamayacaksın."
        },
        rewards: {
            log: "Eğitimi tamamlama ödülü."
        }
    }
}, I18n.translations.pt_PT = {
    common: {
        add: "Adicionar",
        back: "Voltar",
        cancel: "Cancelar",
        change_saved: "Alterações salvas",
        coins_spend: "Deseja mesmo gastar estas moedas?",
        congratulations: "Parabéns!",
        content: "Conteúdo",
        credits: "Créditos",
        "delete": "Apagar",
        details: "Detalhes",
        edit: "Editar",
        error: "Erro",
        is_offline: "%{user} está offline.",
        is_offline_long: "Tempo: %{user} está offline",
        is_offline_with_duration: "%{user} está offline: %{duration}",
        is_online: "%{user} está online.",
        loading: "Carregando...",
        name: "Nome",
        none: "Nenhum",
        of: "de",
        off: "Desligado",
        on: "Ligado",
        save: "Salvar",
        search: "Procurar",
        show: "Exibir",
        user_not_found: "Usuário não encontrado",
        wrong_key: "Chave errada"
    },
    javascript: {
        alarm: "Despachar",
        arrival: "Chegada",
        backalarm: "Cancelar",
        coins: "Moedas",
        credits: "Créditos",
        days: "dias",
        few_seconds: "em alguns segundos",
        finish_in: "Finaliza em:",
        hours: "H",
        location_not_found: "Não encontrado",
        messages: "Mensagens",
        minutes: "min.",
        missed_vehicle: "Falta:",
        mission_start_in: "Começa em:",
        "new": "Novo",
        not_found_map: "O veículo não foi encontrado no mapa",
        now: "Agora",
        patient: "Paciente",
        patient_untouched: "Pacientes não tratados",
        poi_delete: "Tem certeza de que quer apagar o PDI: %{caption}?",
        reload: "Recarregar",
        secounds: "seg.",
        sicherheitswache_error: 'A guarda de segurança "%{caption}" não teve êxito porque nem todos os critérios foram atendidos.',
        sicherheitswache_success: 'A guarda de segurança "%{caption}" foi realizada com sucesso. Receber %{credits} créditos.',
        start_in: "Começar em: ",
        start_username: "Iniciante:",
        time_left: "Tempo restante:",
        to_building: "Ver edifício",
        to_mission: "Ver missão",
        understand: "Reconhecer",
        user_not_found: "O jogador não foi encontrado.",
        vehicles_not_visible: "Veículos não visíveis. "
    },
    map: {
        alliance: "Aliança",
        alliance_chat: "Chat",
        alliance_chat_banned: "Você está banido do chat da aliança no momento.",
        alliance_chat_banned_admin: "Banido por:",
        alliance_chat_banned_timeleft: "Tempo restante:",
        alliance_chat_radio_off: "Rádio da aliança: Desligado",
        alliance_chat_radio_on: "Rádio da aliança: Ligado",
        alliance_event: "Evento",
        alliance_missions: "Missões da aliança",
        alliance_missions_event: "Evento",
        ambulance: "Ambulância",
        attended: "Respondidas",
        cancel_alliance_event: "Cancelar evento de aliança",
        cancel_alliance_event_confirm: "Realmente desejas cancelar o evento de aliança?",
        challenges: "",
        chat_history: "Histórico do chat",
        congratulations: "Parabéns! Agora você pode ser promovido.",
        create_alliance_event: "Iniciar evento de aliança",
        create_alliance_operation: "Criar missão de aliança em grande escala",
        emergency: "Emergência",
        finishing: "Em decurso",
        join_alliance_infos: "Se estiver numa aliança, outros jogadores podem compartilhar missões consigo.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Edifícios",
            all_missions: "Missões",
            alliance_buildings: "Edifícios da aliança",
            alliance_members: "Membros",
            alliance_missions: "Partilhado pela aliança",
            ambulance_station_missions: "Estação de Ambulâncias",
            ambulance_station_small_missions: "Estação de Ambulâncias (Pequena)",
            building_complex: "Conjunto de Edifícios",
            buildings_section: "Estações",
            clinic_missions: "Centro de Saúde",
            dispatch_center_missions: "Centro de Comando",
            fire_school_missions: "Escola de Formação de Bombeiros",
            firehouse_missions: "Corpo de Bombeiros",
            firehouse_small_missions: "Corpo de Bombeiros (Pequeno)",
            hospital_missions: "Hospital",
            map_filters: "Lista de filtros do mapa",
            mission_positions: "Pontos de interesse (PDI)",
            mission_positions_section: "PDI",
            missions_section: "Missões",
            police_copter_station_missions: "Aviação policial",
            police_school_missions: "Escola Prática de Polícia",
            police_small_missions: "Esquadra de Polícia (Pequena)",
            police_special_forces: "Unidade Especial de Polícia",
            police_station_missions: "Esquadra de Polícia",
            prison_missions: "Prisão",
            rapid_deployment_group: "Grupo de Instalação Rápida (SEG)",
            rescue_copter_station_missions: "Centro de Meios Aéreos",
            riot_police: "Tropa de choque",
            riot_police_missions: "Tropa de choque",
            staging_area_missions: "Zona de Concentração e Reserva",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Os meus edifícios",
            user_missions: "As minhas missões",
            water_watch: "Resgate aquático",
            water_watch_missions: "Resgate aquático"
        },
        message: "Mensagem",
        mission: "Missão",
        missions_filtered_out: "Algumas missões podem ser filtradas. Por favor, verifique seus filtros de mapa.",
        no_alliance_chat_impossible: "Não está em nenhuma aliança.",
        no_alliance_missions: "De momento não existem missões de aliança.",
        no_ambulance_missions: "Não há missões de ambulância. Você só pode participar de missões de ambulância quando tiver uma ambulância e um hospital.",
        no_emergency_missions: "Não há missões de emergência disponíveis. Poderá participar em missões de emergência depois de construir o seu primeiro corpo de bombeiros.",
        no_radio_messages: "Não existem mensagens via rádio",
        radio_messages: "Rádio",
        restore_map: "Restaurar mapa",
        server_warning: "Manutenção do servidor às 23h. 6h tempo de inatividade esperadas.",
        show_informations: "Verde = As missões são exibidas na lista. Vermelho = As missões não são exibidas.",
        sicherheitswache: "Missões planejadas",
        transport: "Transporte",
        unattended: "Não respondidas"
    },
    fms: {
        going: "Em trânsito",
        not_ready: "Fora de serviço",
        on_destination: "No destino do transporte",
        on_place: "No local",
        patient_transported: "A transportar paciente",
        prisoner_transported: "A transportar detido.",
        ready_home: "Disponível na estação",
        ready_traveling: "Livre e disponível",
        talking_wish: "Pedido de Transporte",
        waiting_for_vehicle: "Aguardando veículo para rebocar"
    },
    intervention_order: {
        back: "Voltar",
        category: "Categoria",
        colour: "Cor",
        column: "Coluna",
        column_number: "Número de coluna",
        column_number_hint: "Se um número de coluna for selecionado, a entrada de Alarme e Resposta será exibida na coluna correspondente na página de alerta.",
        create_intervention_order: "Criar novo Regulamento de Alarme e Resposta",
        "delete": "Apagar",
        delete_all: "Apagar Regulamentos de Alarme e Resposta completamente",
        delete_all_confirm: "Tem certeza de que quer apagar totalmente o regulamento de alarme e resposta? As entradas exportadas existentes não estão mais disponíveis!",
        description: "Nome",
        edit: "Editar",
        "export": {
            "export": "Exportar",
            "import": "Importar",
            import_done: "As entradas selecionadas foram importadas e escritas no seu plano de Alarme e Resposta.",
            saved: "Exportações de Regulamentos de Alarme e Resposta",
            saved_text: "Seu Regulamento de Alarme e Resposta foi preparado para exportação. Por meio do link, outro jogador pode importar o Regulamento de Alarme e Resposta. Se você alterar seu Regulamento de Alarme e Resposta neste intervalo, essa alteração será automaticamente aplicada à exportação."
        },
        hotkey_hint: "Escolha uma tecla de atalho para selecionar este veículo. Carregue na janela de missão: ALT + a sua tecla de atalho (ou no Firefox: ALT + SHIFT + a sua tecla de atalho, ou no mac os: ctrl + alt + a sua tecla de atalho) para escolher a seleção do seu veículo.",
        intervention_order: "Editar Regulamentos de Alarme e Resposta",
        name: "Nome",
        no_intervention_created: "Você ainda não criou um Regulamento de Alarme e Resposta.",
        options: "Opções",
        reset: "Redefina a seleção anterior na janela de alarme.",
        reset_hint: "Se selecionou o veículo na janela de despacho, pode usar este botão para redefinir.",
        save: "Salvar",
        station: "Estação",
        station_hint: "Quando um edifício é selecionado, apenas veículos do edifício selecionado serão selecionados.",
        successfully_created: "Regulamento de Alarme e Resposta criado com êxito.",
        successfully_deleted: "Regulamento de Alarme e Resposta apagado",
        successfully_updated: "Regulamento de Alarme e Resposta atualizado com êxito.",
        vehicles: {
            ab_atemschutz_only: "Módulo SCBA",
            ab_gefahrgut_only: "Módulo de PP",
            ab_oel_only: "Módulo de derramamento de óleo",
            ab_ruest: "Módulo de resgate técnico",
            ab_ruest_rw: "",
            abl2wasser_only: "Módulo de fornecimento de mangueiras",
            ambulance: "ABSC",
            ambulance_or_rapid_responder: "",
            arff: "Veículo de Combate Especial",
            battalion_chief_unit: "VCOT",
            boot: "Barcos (geral)",
            dekon_p: "",
            division_chief_unit: "VCOC",
            dlk_or_tm50: "",
            elw1_or_elw2: "VCOT / VCOC",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "ABSC / Heli INEM",
            fbi_bomb_tech: "UEP/UI - CIEXSS",
            fire_truck: "VFCI / VLCI / VUCI / VP",
            fireboat: "Barco de combate a incêndio grande",
            fly_car: "Fly-Car",
            fly_car_any: "VMER / Mota INEM",
            fukw: "",
            fustw_or_police_motorcycle: "CP / EPRI",
            fwk: "VSAE",
            gefkw: "",
            gkw: "Veículo de Logística",
            grtw: "VIC",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "VPMA",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Retenção de água",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "VTTU",
            hems: "Heli INEM",
            hlf_only: "VUCI",
            hlf_or_rw_and_lf: "VUCI ou VSAT e VFCI / VLCI",
            hondengeleider: "",
            k9: "Unidade canina",
            kdow_lna: "",
            kdow_orgl: "Chefe de SEM",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "VFCI / VLCI",
            long_distance_ambulance: "Ambulância de SBV",
            mask_service_unit: "UAAR",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Barco multiuso",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulância",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "CP",
            police_motorcycle: "EPRI",
            polizeihubschrauber: "Helicóptero de polícia",
            rescue_vehicle: "VSAT / VUCI",
            rescue_vehicle_only: "VSAT",
            rescueboat: "Barco de resgate grande",
            rettungstreppe: "",
            rth_only: "Heli INEM",
            schlauchwagen: "VTTU",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SWAT",
            swat_armored_vehicle: "Veículo blindado da SWAT",
            swat_suv: "SUV da SWAT",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Equipe de mergulho",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Veículo Tanque de Grande Capacidade",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "VE / VP",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'A seguir, dá um nome à tua nova estação! Escolhe algo que seja reconhecível e expansível! Por ex. «Bombeiros #0001". Quando terminares, clica em «Seguinte»!',
                        build_with_credits: "Agora, constrói o teu edifício com créditos!",
                        new_building: "Clica em «Novo Edifício»!",
                        select_building: "Primeiro, escolhe o tipo de edifício com que desejas começar. Recomendamos vivamente que comeces pelos bombeiros! De qualquer forma, recomendamos que comeces com uma pequena estação!",
                        select_position: "Move o marcador azul para onde desejas construir a tua primeira estação!"
                    },
                    pick_location: "Primeiro, escolhe um local para começar! Introduz o nome da localização onde desejas começar na barra de pesquisa ou encontra-a no mapa por ti mesmo! Que tal a tua cidade natal?",
                    welcome: "Olá, bem vindo ao Jogo Operador 112!  Vou dar-te algumas instruções para te ajudar a começares bem a tua carreira nos serviços de emergência!"
                },
                mobile: {
                    build_building: {
                        add_name: 'A seguir, dá um nome à tua nova estação! Escolhe algo que seja reconhecível e expansível! Por ex. «Bombeiros #0001". Quando terminares, clica em «Seguinte»!',
                        build_with_credits: "Agora, constrói o teu edifício com créditos!",
                        new_building: "Primeiro, vamos escolher um local para começares e construires o teu primeiro edifício! <br /> <br /> Para fazê-lo, clica em «Novo edifício»!",
                        select_building: "Primeiro, escolhe o tipo de edifício com que desejas começar. Recomendamos vivamente que comeces pelos bombeiros! De qualquer forma, recomendamos que comeces com uma pequena estação!"
                    },
                    welcome: "Olá, bem vindo ao Jogo Operador 112!  Vou dar-te algumas instruções para te ajudar a começares bem a tua carreira nos serviços de emergência!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Este é o menu de operação. A partir daqui envias as tuas unidades em missões!",
                        dispatch_menu_buttons: "Estes são os teus dois botões de operação! O primeiro: «Enviar» envia as unidades selecionadas para a missão. O segundo botão faz a mesma coisa que o primeiro, mas passa para a missão seguinte. Por agora, clica no primeiro botão.",
                        dispatch_menu_mission_general: "Aqui podes ver as informações gerais da missão, ou seja, o nome, a morada e o ícone da missão. O pequeno ícone do boneco aparece e substitui uma pequena estrela nas missões em que já participaste.",
                        dispatch_menu_mission_progress: "Aqui podes ver quanto progresso já foi feito para lidar com esta missão, assim como o número de elementos no local e o tempo restante para cumprir a missão!",
                        dispatch_menu_mission_specific: "Aqui podes ver mais informação sobre a missão, que unidades estão a responder à chamada e quais as já se encontram no local.",
                        dispatch_menu_vehicle_list: "Esta é a lista dos teus veículos disponíveis. Selecionas dentre estes veículos. Agora, clica e seleciona o teu veículo!"
                    },
                    mobile: {
                        dispatch_menu: "Este é o menu de operação. A partir daqui envias as tuas unidades em missões!",
                        dispatch_menu_buttons: "Estes são os teus dois botões de operação! O primeiro: «Enviar» envia as unidades selecionadas para a missão. O segundo botão faz a mesma coisa que o primeiro, mas passa para a missão seguinte. Por agora, clica no primeiro botão.",
                        dispatch_menu_mission_general: "Aqui podes ver as informações gerais da missão, ou seja, o nome, a morada e o ícone da missão. O pequeno ícone do boneco aparece e substitui uma pequena estrela nas missões em que já participaste.",
                        dispatch_menu_mission_progress: "Aqui podes ver quanto progresso já foi feito para lidar com esta missão, assim como o número de elementos no local e o tempo restante para cumprir a missão!",
                        dispatch_menu_mission_specific: "Aqui podes ver mais informação sobre a missão, que unidades estão a responder à chamada e quais as já se encontram no local.",
                        dispatch_menu_vehicle_list: "Esta é a lista dos teus veículos disponíveis. Selecionas dentre estes veículos. Agora, clica e seleciona o teu veículo!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Agora iremos aprender como lidar com incidentes. Abre o menu do operador clicando num botão «operação»!",
                        first_mission: "Fantástico, construíste o teu primeiro edifício! Vês, comunicaram-te as primeiras missões!"
                    },
                    mobile: {
                        dispatch_button: "Agora iremos aprender como lidar com incidentes. Abre o menu do operador clicando num botão «operação»!",
                        first_mission: "Fantástico, construíste o teu primeiro edifício! Vês, comunicaram-te as primeiras missões!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Muito bem, estás a caminho de te tornares um fantástico Operador 112! Aqui tens %{coins} Moedas para um apoio inicial! </br> A tua Equipa do Jogo Operador 112"
                },
                mobile: {
                    general: "Muito bem, estás a caminho de te tornares um fantástico Operador 112! Aqui tens %{coins} Moedas para um apoio inicial! </br> A tua Equipa do Jogo Operador 112"
                }
            },
            tips: {
                browser: {
                    contact: "Se tiveres questões, podes consultar as Perguntas Frequentes do jogo ou visitar os fóruns do jogo ou a nossa página do Facebook!",
                    general: "Para o próximo passo, recomendamos que construas um centro de operações e a seguir, assim que possível, novas estações, já que o número máximo de missões corresponde ao maior número de quaisquer estações de um tipo diferente (polícia, bombeiros, ambulâncias) mais 1; por exemplo, 5 bombeiros e 3 estações de ambulâncias = 6 missões.",
                    join_alliance: "Adicionalmente, seria muito vantajoso para ti entrares numa aliança, especialmente no início, por isso também recomendamos que o faças.",
                    summary: "Isto é o básico do Jogo Operador 112! Completa missões, ganha créditos, compra mais unidades, faz tudo outra vez. Diverte-te a jogar! </br> A tua Equipa do Jogo Operador 112"
                },
                mobile: {
                    contact: "Se tiveres questões, podes consultar as Perguntas Frequentes do jogo ou visitar os fóruns do jogo ou a nossa página do Facebook!",
                    general: "Para o próximo passo, recomendamos que construas um centro de operações e a seguir, assim que possível, novas estações, já que o número máximo de missões corresponde ao maior número de quaisquer estações de um tipo diferente (polícia, bombeiros, ambulâncias) mais 1; por exemplo, 5 bombeiros e 3 estações de ambulâncias = 6 missões.",
                    join_alliance: "Adicionalmente, seria muito vantajoso para ti entrares numa aliança, especialmente no início, por isso também recomendamos que o faças.",
                    summary: "Isto é o básico do Jogo Operador 112! Completa missões, ganha créditos, compra mais unidades, faz tudo outra vez. Diverte-te a jogar! </br> A tua Equipa do Jogo Operador 112"
                }
            }
        },
        commons: {
            collect: "Recolher",
            "continue": "Não",
            end: "Fim",
            next: "Seguinte",
            prev: "Anterior",
            skip: "Sim",
            skip_hint: "Realmente desejas cancelar o tutorial? Não será possível acedê-lo mais tarde. Não serás elegível para a recompensa de finalização do tutorial."
        },
        rewards: {
            log: "Recompensa por completar o tutorial."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: 'A seguir, dá um nome à tua nova estação! Escolhe algo que seja reconhecível e expansível! Por ex. «Esquadra de Polícia #0001". Quando terminares, clica em «Seguinte»!',
                            select_building: "Primeiro, escolhe o tipo de edifício com que desejas começar. Recomendamos vivamente que comeces pela polícia! De qualquer forma, recomendamos que comeces com uma pequena estação!"
                        },
                        welcome: "Olá, bem vindo ao Jogo Operador 112 Polícia!  Vou dar-te algumas instruções para te ajudar a começares bem a tua carreira nos serviços de emergência!"
                    },
                    mobile: {
                        build_building: {
                            add_name: 'A seguir, dá um nome à tua nova estação! Escolhe algo que seja reconhecível e expansível! Por ex. «Esquadra de Polícia #0001". Quando terminares, clica em «Seguinte»!'
                        },
                        welcome: "Olá, bem vindo ao Jogo Operador 112 Polícia!  Vou dar-te algumas instruções para te ajudar a começares bem a tua carreira nos serviços de emergência!"
                    }
                },
                rewards: {
                    browser: {
                        general: "Muito bem, estás a caminho de te tornares um fantástico Operador 112 Polícia! Aqui tens %{coins} Moedas para um apoio inicial! </br> A tua Equipa do Jogo Operador 112 - Polícia"
                    },
                    mobile: {
                        general: "Muito bem, estás a caminho de te tornares um fantástico Operador 112 Polícia! Aqui tens %{coins} Moedas para um apoio inicial! </br> A tua Equipa do Jogo Operador 112 - Polícia"
                    }
                },
                tips: {
                    browser: {
                        summary: "Isto é o básico do Jogo Operador 112 - Polícia! Completa missões, ganha créditos, compra mais unidades, faz tudo outra vez. Diverte-te a jogar! </br> A tua Equipa do Jogo Operador 112 - Polícia"
                    },
                    mobile: {
                        summary: "Isto é o básico do Jogo Operador 112 - Polícia! Completa missões, ganha créditos, compra mais unidades, faz tudo outra vez. Diverte-te a jogar! </br> A tua Equipa do Jogo Operador 112 - Polícia"
                    }
                }
            }
        }
    }
}, I18n.translations.pt_BR = {
    common: {
        add: "Adicionar",
        back: "Voltar",
        cancel: "Cancelar",
        change_saved: "Alterações salvas",
        coins_spend: "Deseja mesmo gastar estas moedas?",
        congratulations: "Parabéns!",
        content: "Conteúdo",
        credits: "Créditos",
        "delete": "Apagar",
        details: "Detalhes",
        edit: "Editar",
        error: "Erro",
        is_offline: "%{user} está offline.",
        is_offline_long: "Tempo: %{user} está offline",
        is_offline_with_duration: "%{user} está offline: %{duration}",
        is_online: "%{user} está online.",
        loading: "Carregando...",
        name: "Nome",
        none: "Nenhum",
        of: "de",
        off: "Desligado",
        on: "Ligado",
        save: "Salvar",
        search: "Buscar",
        show: "Exibir",
        user_not_found: "Usuário não encontrado",
        wrong_key: "Chave errada"
    },
    javascript: {
        alarm: "Despachar",
        arrival: "Chegada",
        backalarm: "Cancelar",
        coins: "Moedas",
        credits: "Créditos",
        days: "dias",
        few_seconds: "em alguns segundos",
        finish_in: "Finaliza em:",
        hours: "H",
        location_not_found: "Não encontrado",
        messages: "Mensagens",
        minutes: "min.",
        missed_vehicle: "Falta:",
        mission_start_in: "Começa em:",
        "new": "Novo",
        not_found_map: "O veículo não foi encontrado no mapa",
        now: "Agora",
        patient: "Paciente",
        patient_untouched: "Pacientes não tratados",
        poi_delete: "Tem certeza de que quer apagar o PDI: %{caption}?",
        reload: "Recarregar",
        sale: "Promoções",
        sale_ended: "Fin de l’offre spéciale",
        secounds: "seg.",
        sicherheitswache_error: 'A guarda de segurança "%{caption}" não teve êxito porque nem todos os critérios foram atendidos.',
        sicherheitswache_success: 'A guarda de segurança "%{caption}" foi realizada com sucesso. Receber %{credits} créditos.',
        start_in: "Começar em: ",
        start_username: "Iniciante:",
        time_left: "Tempo restante:",
        to_building: "Ver edifício",
        to_mission: "Ver missão",
        understand: "Reconhecer",
        user_not_found: "O jogador não foi encontrado.",
        vehicles_not_visible: "Veículos não visíveis. "
    },
    map: {
        alliance: "Aliança",
        alliance_chat: "Chat",
        alliance_chat_banned: "Você está banido do chat da aliança no momento.",
        alliance_chat_banned_admin: "Banido por:",
        alliance_chat_banned_timeleft: "Tempo restante:",
        alliance_chat_radio_off: "Rádio da aliança: Desligado",
        alliance_chat_radio_on: "Rádio da aliança: Ligado",
        alliance_event: "Evento",
        alliance_missions: "Missões da aliança",
        alliance_missions_event: "Evento",
        ambulance: "Ambulância",
        attended: "Respondidas",
        cancel_alliance_event: "Cancelar evento de aliança",
        cancel_alliance_event_confirm: "Realmente desejas cancelar o evento de aliança?",
        challenges: "",
        chat_history: "Histórico do chat",
        congratulations: "Parabéns! Agora você pode ser promovido.",
        create_alliance_event: "Iniciar evento de aliança",
        create_alliance_operation: "Crie uma missão de aliança de larga escala",
        emergency: "Emergência",
        finishing: "Em decurso",
        join_alliance_infos: "Se você estiver em uma aliança, outros jogadores podem lhe dar missões livremente.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Edifícios",
            all_missions: "Missões",
            alliance_buildings: "Edifícios da aliança",
            alliance_members: "Membros",
            alliance_missions: "Partilhado pela aliança",
            ambulance_station_missions: "Bases do SAMU",
            ambulance_station_small_missions: "Bases do SAMU (pequena)",
            building_complex: "Conjunto de Edifícios",
            buildings_section: "Estações",
            clinic_missions: "Clínica",
            dispatch_center_missions: "Central de Despacho",
            fire_school_missions: "Academia de bombeiros militar",
            firehouse_missions: "Unidade de bombeiros militar",
            firehouse_small_missions: "Unidade de bombeiros militar (pequena)",
            hospital_missions: "Hospital",
            map_filters: "Lista de filtros do mapa",
            mission_positions: "Pontos de interesse (PDI)",
            mission_positions_section: "PDI",
            missions_section: "Missões",
            police_copter_station_missions: "Aviação policial",
            police_school_missions: "Academia de polícia militar",
            police_small_missions: "Delegacias de polícia militar (pequena)",
            police_special_forces: "Unidade Especial de Polícia",
            police_station_missions: "Delegacias de polícia militar",
            prison_missions: "Presídio",
            rapid_deployment_group: "Grupo de Instalação Rápida (SEG)",
            rescue_copter_station_missions: "Estação de Helicópteros de Resgate",
            riot_police: "Tropa de choque",
            riot_police_missions: "Tropa de choque",
            staging_area_missions: "Área de concentração",
            technical_aid_organization: "THW",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Os meus edifícios",
            user_missions: "As minhas missões",
            water_watch: "Resgate aquático",
            water_watch_missions: "Resgate aquático"
        },
        message: "Mensagem",
        mission: "Missão",
        missions_filtered_out: "Algumas missões podem ser filtradas. Por favor, verifique seus filtros de mapa.",
        no_alliance_chat_impossible: "Você não está em uma aliança.",
        no_alliance_missions: "Não há missões de aliança no momento.",
        no_ambulance_missions: "Não há missões de ambulância. Você só pode participar de missões de ambulância quando tiver uma ambulância e um hospital.",
        no_emergency_missions: "Não há missões de emergência disponíveis. Você pode participar de uma missão de emergência depois que construir o seu primeiro corpo de bombeiros.",
        no_radio_messages: "Você não recebeu mensagens de rádio.",
        radio_messages: "Rádio",
        restore_map: "Restaurar mapa",
        server_warning: "Manutenção do servidor às 7h da tarde. 6h de tempo de inatividade esperado.",
        show_informations: "Verde = As missões são exibidas na lista. Vermelho = As missões não são exibidas.",
        sicherheitswache: "Missões planejadas",
        transport: "Transporte",
        unattended: "Não respondidas"
    },
    fms: {
        going: "Respondendo",
        not_ready: "Fora de serviço",
        on_destination: "No destino do transporte",
        on_place: "No local",
        patient_transported: "Transportando paciente",
        prisoner_transported: "Transportando detento",
        ready_home: "Disponível na estação",
        ready_traveling: "Livre e disponível",
        talking_wish: "Solicitação de transporte",
        waiting_for_vehicle: "Aguardando veículo para rebocar"
    },
    intervention_order: {
        back: "Voltar",
        category: "Categoria",
        colour: "Cor",
        column: "Coluna",
        column_number: "Número de coluna",
        column_number_hint: "Se um número de coluna for informado, a entrada de Alarme e Resposta será exibida na coluna correspondente na página de alerta.",
        create_intervention_order: "Criar novo Regulamento de Alarme e Resposta",
        "delete": "Apagar",
        delete_all: "Apagar Regulamentos de Alarme e Resposta completamente",
        delete_all_confirm: "Tem certeza de que quer apagar totalmente o regulamento de alarme e resposta? As entradas exportadas existentes não estão mais disponíveis!",
        description: "Nome",
        edit: "Editar",
        "export": {
            "export": "Exportar",
            "import": "Importar",
            import_done: "As entradas selecionadas foram importadas e escritas no seu plano de Alarme e Resposta.",
            saved: "Exportações de Regulamentos de Alarme e Resposta",
            saved_text: "Seu Regulamento de Alarme e Resposta foi preparado para exportação. Por meio do link, outro jogador pode importar o Regulamento de Alarme e Resposta. Se você alterar seu Regulamento de Alarme e Resposta neste intervalo, essa alteração será automaticamente aplicada à exportação."
        },
        hotkey_hint: "Escolha uma tecla de atalho para selecionar este veículo. Pressione na sua janela de missão: ALT + sua tecla de atalho (ou no Firefox: ALT + SHIFT + sua tecla de atalho, ou no mac os: ctrl + alt + sua tecla de atalho) para escolher a seleção do seu veículo.",
        intervention_order: "Editar Regulamentos de Alarme e Resposta",
        name: "Nome",
        no_intervention_created: "Você ainda não criou um Regulamento de Alarme e Resposta.",
        options: "Opções",
        reset: "Redefina a seleção anterior na janela de alarme.",
        reset_hint: "Se você selecionou o veículo na janela de despacho, pode usar este botão para redefinir.",
        save: "Salvar",
        station: "Estação",
        station_hint: "Quando um edifício é selecionado, somente veículos do edifício correspondente serão selecionados.",
        successfully_created: "Regulamento de Alarme e Resposta criado com êxito.",
        successfully_deleted: "Regulamento de Alarme e Resposta apagado",
        successfully_updated: "Regulamento de Alarme e Resposta atualizado com êxito.",
        vehicles: {
            ab_atemschutz_only: "Módulo SCBA",
            ab_einsatzleitung_only: "Módulo de comando",
            ab_gefahrgut_only: "Módulo de PP",
            ab_oel_only: "Módulo de derramamento de óleo",
            ab_ruest: "Módulo de resgate técnico",
            ab_ruest_rw: "",
            abl2wasser_only: "Módulo de fornecimento de mangueiras",
            ambulance: "Ambulância de SAV",
            ambulance_or_rapid_responder: "",
            arff: "Defesa Civil (caminhão de bombeiro para aeroportos)",
            battalion_chief_unit: "Viatura de batalhão",
            boot: "Barcos (geral)",
            dekon_p: "",
            division_chief_unit: "Viatura de comando móvel",
            dlk_or_tm50: "",
            elw1_or_elw2: "Viatura de batalhão, viatura de comando móvel ou módulo de comando móvel ",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulância de emergência ou helicóptero de resgate",
            fire_truck: "Caminhões de bombeiro",
            fireboat: "Barco de combate a incêndio grande",
            fly_car: "VIR",
            fly_car_any: "VIR ou Médico de Clinica Geral",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Caminhão utilitário",
            grtw: "Unidade para incidentes com múltiplas vítimas",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Produtos Perigosos",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Retenção de água",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Veículo com mangueira",
            hems: "HEMS",
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "",
            k9: "Unidade de Ações com Cães",
            kdow_lna: "",
            kdow_orgl: "Chefe de SEM",
            ktw_b: "",
            ktw_or_rtw: "USB ou SAMU",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Caminhões de bombeiro",
            long_distance_ambulance: "Ambulância de SBV",
            mask_service_unit: "Unidade aérea móvel",
            mek_mtf: "",
            mek_zf: "",
            mtw: "MTW",
            mzb: "Barco multiuso",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulância",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Carro de patrulha",
            polizeihubschrauber: "Helicóptero de polícia",
            rescue_vehicle: "Veículo de resgate pesado",
            rescue_vehicle_only: "Resgate pesado",
            rescueboat: "Barco de resgate grande",
            rettungstreppe: "",
            rth_only: "Helicóptero de Resgate",
            schlauchwagen: "Caminhão pipa",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Treinamento do Comando de Operações Especiais",
            swat_armored_vehicle: "Veículo blindado da SWAT",
            swat_suv: "SUV da SWAT",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Equipe de mergulho",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Caminhão tanque",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Caminhão plataforma",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Depois, dê um nome para a sua estação! Escolha um nome simples e fácil de ser lembrado! Por exemplo: “Estação de incêndios 0001". Quando tiver terminado, clique em “Próximo”!',
                        build_with_credits: "Agora, construa o seu edifício com créditos!",
                        new_building: "Clique em “Novo edifício”!",
                        select_building: "Primeiro, escolha o tipo de edifício com o qual você quer começar. Sugerimos que você comece com atendimentos a incêndios! De qualquer forma, é bom que você comece com uma estação pequena!",
                        select_position: "Mova o marcador azul para onde você quer construir a sua primeira estação!"
                    },
                    pick_location: "Primeiro, escolha um lugar para começar! Digite na barra de pesquisa o nome do local em que você quer começar ou encontre-o no mapa! Que tal a sua cidade?",
                    welcome: "Olá! Boas-vindas a Operador 193!  Eu vou lhe ensinar algumas coisas para que você comece bem a sua carreira nos serviços de emergência!"
                },
                mobile: {
                    build_building: {
                        add_name: 'Depois, dê um nome para a sua estação! Escolha um nome simples e fácil de ser lembrado! Por exemplo: “Estação de incêndios 0001". Quando tiver terminado, clique em “Próximo”!',
                        build_with_credits: "Agora, construa o seu edifício com créditos!",
                        new_building: 'Primeiro, vamos escolher um lugar para começar e construir o seu primeiro edifício! <br /> <br /> Para fazer isso, clique em “Novo edifício"!',
                        select_building: "Primeiro, escolha o tipo de edifício com o qual você quer começar. Sugerimos que você comece com atendimentos a incêndios! De qualquer forma, é bom que você comece com uma estação pequena!"
                    },
                    welcome: "Olá! Boas-vindas a Operador 193!  Eu vou lhe ensinar algumas coisas para que você comece bem a sua carreira nos serviços de emergência!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Este é o menu de atendimento. É a partir daqui que você envia as suas unidades para as missões!",
                        dispatch_menu_buttons: "Estes são os seus dois botões de atendimento! O primeiro: “Atender” envia as unidades selecionadas para a missão. O segundo faz a mesma coisa que o primeiro, mas leva à missão seguinte. Por enquanto, clique no primeiro botão.",
                        dispatch_menu_mission_general: "Aqui você acessa as informações gerais da missão: o nome, o endereço e o ícone da missão. Nas missões das quais você já participou, o ícone do homenzinho aparece e substitui a estrelinha.",
                        dispatch_menu_mission_progress: "Aqui você pode ver o progresso da missão, o número de atendentes no local e o tempo que resta para o encerramento da missão!",
                        dispatch_menu_mission_specific: "Aqui você pode ter mais informações sobre a missão, quais unidades estão atendendo ao chamado e quais já estão no local.",
                        dispatch_menu_vehicle_list: "Esta é a sua lista de veículos disponíveis. Você seleciona os veículos aqui. Agora, selecione o seu veículo clicando nele!"
                    },
                    mobile: {
                        dispatch_menu: "Este é o menu de atendimento. É a partir daqui que você envia as suas unidades para as missões!",
                        dispatch_menu_buttons: "Estes são os seus dois botões de atendimento! O primeiro: “Atender” envia as unidades selecionadas para a missão. O segundo faz a mesma coisa que o primeiro, mas leva à missão seguinte. Por enquanto, clique no primeiro botão.",
                        dispatch_menu_mission_general: "Aqui você acessa as informações gerais da missão: o nome, o endereço e o ícone da missão. Nas missões das quais você já participou, o ícone do homenzinho aparece e substitui a estrelinha.",
                        dispatch_menu_mission_progress: "Aqui você pode ver o progresso da missão, o número de atendentes no local e o tempo que resta para o encerramento da missão!",
                        dispatch_menu_mission_specific: "Aqui você pode ter mais informações sobre a missão, quais unidades estão atendendo ao chamado e quais já estão no local.",
                        dispatch_menu_vehicle_list: "Esta é a sua lista de veículos disponíveis. Você seleciona os veículos aqui. Agora, selecione o seu veículo clicando nele!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Agora, queremos que você aprenda a lidar com incidentes. Abra o menu de atendimento clicando no botão “Atender”!",
                        first_mission: "Ótimo! Você construiu o seu primeiro edifício! Veja só, as primeiras missões já foram passadas a você!"
                    },
                    mobile: {
                        dispatch_button: "Agora, queremos que você aprenda a lidar com incidentes. Abra o menu de atendimento clicando no botão “Atender”!",
                        first_mission: "Ótimo! Você construiu o seu primeiro edifício! Veja só, as primeiras missões já foram passadas a você!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Ótimo! Em breve você vai se tornar um grande chefe de atendimento em Operador 193! Aí vão %{coins} moedas para ajudar você no começo! </br> Equipe do Operador 193"
                },
                mobile: {
                    general: "Ótimo! Em breve você vai se tornar um grande chefe de atendimento em Operador 193! Aí vão %{coins} moedas para ajudar você no começo! </br> Equipe do Operador 193"
                }
            },
            tips: {
                browser: {
                    contact: "Em caso de dúvidas, consulte a seção “Perguntas Frequentes” no jogo, visite os fóruns de discussão ou acesse a nossa página no Facebook!",
                    general: "Como o próximo passo, recomendamos que você construa uma central de atendimentos e depois, o mais rápido possível, novas estações, já que o número máximo de missões será o mesmo do maior número de estações de qualquer tipo (polícia, bombeiros, ambulância) mais 1. Por exemplo: 5 estações de incêndio e 3 de ambulância = 6 missões.",
                    join_alliance: "Além disso, juntar-se a uma aliança pode ser muito benéfico, principalmente no começo. Recomendamos que você também faça isso.",
                    summary: "Este é o básico do Operador 193! Cumpra as missões, ganhe créditos, compre mais unidades, repita os procedimentos. Divirta-se! </br> Equipe do Operador 193"
                },
                mobile: {
                    contact: "Em caso de dúvidas, consulte a seção “Perguntas Frequentes” no jogo, visite os fóruns de discussão ou acesse a nossa página no Facebook!",
                    general: "Como o próximo passo, recomendamos que você construa uma central de atendimentos e depois, o mais rápido possível, novas estações, já que o número máximo de missões será o mesmo do maior número de estações de qualquer tipo (polícia, bombeiros, ambulância) mais 1. Por exemplo: 5 estações de incêndio e 3 de ambulância = 6 missões.",
                    join_alliance: "Além disso, juntar-se a uma aliança pode ser muito benéfico, principalmente no começo. Recomendamos que você também faça isso.",
                    summary: "Este é o básico do Operador 193! Cumpra as missões, ganhe créditos, compre mais unidades, repita os procedimentos. Divirta-se! </br> Equipe do Operador 193"
                }
            }
        },
        commons: {
            collect: "Coletar",
            "continue": "Não",
            end: "Fim",
            next: "Próximo",
            prev: "Anterior",
            skip: "Sim",
            skip_hint: "Realmente desejas cancelar o tutorial? Não será possível acedê-lo mais tarde. Não serás elegível para a recompensa de finalização do tutorial."
        },
        rewards: {
            log: "Recompensa por completar o tutorial."
        }
    }
}, I18n.translations.uk_UA = {
    common: {
        add: "Додати",
        back: "Назад",
        cancel: "Скасувати",
        change_saved: "Зміни збережено",
        coins_spend: "Дійсно бажаєте витратити ці монети?",
        congratulations: "Вітання!",
        content: "Вміст",
        copy: "Копіювати",
        credits: "Кредити",
        "delete": "Видалити",
        details: "Подробиці",
        edit: "Редагувати",
        error: "Помилка",
        is_offline: "%{user} не в мережі.",
        is_offline_long: "Давно: %{user} не в мережі",
        is_offline_with_duration: "%{user} не в мережі: %{duration}",
        is_online: "%{user} в мережі.",
        loading: "Завантаження...",
        name: "Ім'я",
        none: "Жодного",
        of: "з",
        off: "Відкл.",
        on: "Вкл.",
        save: "Зберегти",
        search: "Пошук",
        show: "Показати",
        user_not_found: "Користувача не знайдено.",
        wrong_key: "Невірна клавіша"
    },
    javascript: {
        alarm: "Відправити",
        arrival: "Прибуття",
        backalarm: "Скасувати",
        coins: "Монети",
        credits: "Кредити",
        days: "дн.",
        few_seconds: "через декілька секунд",
        finish_in: "Завершення через:",
        hours: "Г",
        location_not_found: "Не знайдено",
        messages: "Повідомлення",
        minutes: "хв.",
        missed_vehicle: "Не вистачає:",
        mission_start_in: "Початок через:",
        "new": "Новий",
        not_found_map: "Машину не знайдено на карті",
        now: "Зараз",
        patient: "Пацієнт",
        patient_untouched: "Невилікувані пацієнти",
        poi_delete: "Дійсно видалити важливу точку: %{caption}?",
        reload: "Перезавантажити",
        sale: "Розпродаж",
        sale_ended: "Розпродаж завершено",
        secounds: "сек.",
        sicherheitswache_error: 'Співробітник охорони "%{caption}" не виконав завдання, оскільки було задоволено не всі критерії.',
        sicherheitswache_success: 'Співробітника охорони "%{caption}" успішно виведено. Отримайте кредити (%{credits}).',
        start_in: "Початок через: ",
        start_username: "Починає:",
        time_left: "Залишилося часу:",
        to_building: "Перегляд будівлі",
        to_mission: "Перегляд завдання",
        understand: "Визнати",
        user_not_found: "Гравця не знайдено.",
        vehicles_not_visible: "Машину не видно. "
    },
    map: {
        alliance: "Альянс",
        alliance_chat: "Чат",
        alliance_chat_banned: "На даний момент вас заблоковано у чаті альянсу.",
        alliance_chat_banned_admin: "Заблокував:",
        alliance_chat_banned_timeleft: "Залишилося часу:",
        alliance_chat_radio_off: "Радіо альянсу: Відкл.",
        alliance_chat_radio_on: "Радіо альянсу: Вкл.",
        alliance_event: "Подія",
        alliance_missions: "Завдання альянсу",
        alliance_missions_event: "Подія",
        ambulance: "Швидка допомога",
        attended: "Відвідані",
        cancel_alliance_event: "Відмінити подію альянсу",
        cancel_alliance_event_confirm: "Ви впевнені що хочете відмінити подію альянсу?",
        challenges: "",
        chat_history: "Історія чату",
        congratulations: "Вітання! Тепер ви можете отримати підвищення.",
        create_alliance_event: "Розпочати подію альянсу",
        create_alliance_operation: "Створити великомасштабне завдання альянсу",
        emergency: "Надзвичайна ситуація",
        finishing: "Завершуються",
        join_alliance_infos: "Якщо ви перебуваєте в альянсі, інші гравці можуть вільно давати вам завдання.",
        map: "Карта",
        map_filters: {
            all_buildings: "Будівлі",
            all_missions: "Завдання",
            alliance_buildings: "Будівлі альянсу",
            alliance_members: "Учасники",
            alliance_missions: "Спільно використовується альянсом",
            ambulance_station_missions: "Станція швидкої допомоги",
            ambulance_station_small_missions: "Підстанція швидкої допомоги",
            building_complex: "Комплекс Будівель",
            buildings_section: "Станції",
            clinic_missions: "Клініка",
            dispatch_center_missions: "Диспетчерський центр",
            fire_school_missions: "Академія пожежної безпеки",
            firehouse_missions: "Пожежна частина",
            firehouse_small_missions: "Пожежна частина (мала)",
            hospital_missions: "Лікарня",
            map_filters: "Список фільтрів карти",
            mission_positions: "Важливі точки (ВТ)",
            mission_positions_section: "ВТ",
            missions_section: "Завдання",
            police_copter_station_missions: "Поліцейська авіація",
            police_school_missions: "Поліцейська академія",
            police_small_missions: "Відділ поліції",
            police_special_forces: "Спецназ поліції",
            police_station_missions: "Управління поліції",
            prison_missions: "В'язниця",
            rapid_deployment_group: "Група швидкого розгортання",
            rescue_copter_station_missions: "Вертолітна станція швидкої допомоги",
            riot_police: "Підрозділ особливого призначення",
            riot_police_missions: "Спецназ поліції",
            staging_area_missions: "Пункт розподілу",
            technical_aid_organization: "МНС",
            technical_aid_organization_school: "Вища школа МНС",
            user_buildings: "Мої будівлі",
            user_missions: "Мої завдання",
            water_watch: "Водолазно-рятувальна служба",
            water_watch_missions: "Водолазно-рятувальна служба"
        },
        message: "Повідомлення",
        mission: "Завдання",
        missions_filtered_out: "Деякі місії можуть бути відфільтровані. Перевірте свої фільтри на карті.",
        no_alliance_chat_impossible: "Ви не перебуваєте в альянсі.",
        no_alliance_missions: "На даний момент завдання альянсу відсутні.",
        no_ambulance_missions: '"Відсутнє перевезення пацієнтів. Перевезення пацієнтів може здійснюватися за наявності у вас реанімобіля (BLS) чи лікарні."',
        no_emergency_missions: "Немає доступних завдань для екстрених служб. Завдання для екстрених служб може з'явитися тоді, коли ви збудуєте свою першу станцію.",
        no_radio_messages: "Ви не отримували повідомлення по радіо.",
        radio_messages: "Радіо",
        restore_map: "Відновити карту",
        server_warning: "Server maintenance at 18:00 UTC. 6h downtime expected.",
        show_informations: "Зелений = завдання будуть показані у списку. Червоний = завдання не будуть показані.",
        sicherheitswache: "Заплановані завдання",
        transport: "Перевезення",
        unattended: "Невідвідані"
    },
    fms: {
        going: "Виїжджає",
        not_ready: "Не працює",
        on_destination: "В пункті призначення для перевезення",
        on_place: "На місці",
        patient_transported: "Перевезення пацієнта",
        prisoner_transported: "Перевезення в'язня",
        ready_home: "Доступно на станції",
        ready_traveling: "Не має завдань і доступно",
        talking_wish: "Запит на перевезення",
        waiting_for_vehicle: "Очікує машину для буксирування"
    },
    intervention_order: {
        back: "Назад",
        category: "Категорія",
        colour: "Колір",
        column: "Стовпчик",
        column_number: "Номер стовпчика",
        column_number_hint: "Якщо заданий номер стовпчика, у відповідному стовпчику на сторінці тривоги буде відображено запис правила ПІР.",
        create_intervention_order: "Створити нове правило ПІР",
        "delete": "Видалити",
        delete_all: "Повністю видалити правила ПІР",
        delete_all_confirm: "Дійсно повністю видалити правило ПІР? Існуючі експортовані записи більше недоступні!",
        description: "Ім'я",
        edit: "Редагувати",
        "export": {
            "export": "Експорт",
            "import": "Імпорт",
            import_done: "Вибрані записи імпортовано і занесено у ваш план ПІР.",
            saved: "Експорт правил ПІР",
            saved_text: "Ваше правило ПІР підготовлене до експорту. За допомогою посилання, інший гравець зможе експортувати правило ПІР. Якщо протягом цього часу ви зміните своє правило ПІР, зміну буде автоматично застосовано до правила, що експортується."
        },
        hotkey_hint: "Виберіть гарячу клавішу для вибраної машини. Натисніть у вікні завдання: ALT + ваша гаряча клавіша (або у Firefox: ALT + SHIFT + ваша гаряча клавіша або у mac os: ctrl + alt + ваша гаряча клавіша), щоб виділити вибрану машину.",
        intervention_order: "Редагувати правила ПІР",
        name: "Ім'я",
        no_intervention_created: "Ви ще не створили правило ПІР.",
        options: "Опції",
        reset: "Скиньте попереднє виділення у вікні тривоги.",
        reset_hint: "Якщо машину не виділено у вікні відправлення, можна скористатися цією кнопкою для скидання.",
        save: "Зберегти",
        station: "Станція",
        station_hint: "При виборі будівлі, будуть виділені лише машини відповідної будівлі.",
        successfully_created: "Правило ПІР успішно створено.",
        successfully_deleted: "Правило ПІР видалено",
        successfully_updated: "Правила ПІР успішно оновлено.",
        vehicles: {
            ab_atemschutz_only: "Модуль дихальних апаратів",
            ab_einsatzleitung_only: "Модуль управління",
            ab_gefahrgut_only: "Модуль знезараження",
            ab_oel_only: "Модуль ЛАРН",
            ab_ruest: "Технологічний/рятувальний модуль",
            ab_ruest_rw: "",
            abl2wasser_only: "Модуль подачі шлангу",
            ambulance: "Реанімобіль",
            ambulance_or_rapid_responder: "",
            arff: "АРІП (пожежна машина аеропорту)",
            battalion_chief_unit: "Підрозділ командира батальйону",
            boot: "Судна (загальні)",
            dekon_p: "",
            division_chief_unit: "Мобільний командний пункт",
            dlk_or_tm50: "",
            elw1_or_elw2: "Підрозділ командира батальйону, мобільний командний пункт або мобільний модуль управління ",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Машина чи вертоліт швидкої допомоги",
            fire_truck: "Пожежні автомобілі",
            fireboat: "Великий пожежний катер",
            fly_car: "Летючий автомобіль",
            fly_car_any: "Летючий автомобіль / Лікар загальної практики",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Вантажівка",
            grtw: "Підрозділ по роботі з великою кількістю постраждалих",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Знезараження",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Автомобіль з драбиною",
            gw_messtechnik: "Метрологічний автомобіль",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Вологоутримання",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Машина із брандспойнтом",
            hems: "Вертоліт невідкладної медичної допомоги",
            hlf_only: "",
            hlf_or_rw_and_lf: "",
            hondengeleider: "",
            k9: "Підрозділ кінологів",
            kdow_lna: "",
            kdow_orgl: "Керівник швидкої",
            ktw_b: "",
            ktw_or_rtw: "Реанімобіль BLS чи ALS",
            lebefkw: "Легкий командний пункт",
            lf_only: "Пожежні машини",
            long_distance_ambulance: "Реанімобіль",
            mask_service_unit: "Мобільний повітряний підрозділ",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Транспортер",
            mzb: "Багатоцільове судно",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Швидка допомога",
            oil_unit: "Нафтозбирне судно",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Патрульний автомобіль",
            polizeihubschrauber: "Поліцейський вертоліт",
            rescue_vehicle: "Важка рятувальна машина",
            rescue_vehicle_only: "Підрозділ порятунку у важких умовах",
            rescueboat: "Велике рятувальне судно",
            rettungstreppe: "",
            rth_only: "Вертоліт швидкої допомоги",
            schlauchwagen: "Автоцистерна",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Спецназ",
            swat_armored_vehicle: "Броньований автомобіль спецназу",
            swat_suv: "Позашляховик спецназу",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Автомобіль технічної служби",
            thw_mzkw: "Багатоцільова машина",
            thw_tauchkraftwagen: "Команда водолазів",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Автоцистерна",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Пожежні автодрабини",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: 'Далі, дайте своїй новій станції назву! Зробіть її помітною і розширюваною! Наприклад, "Пожежна станція № 0001". Коли будете готові, клацніть "Далі"!',
                        build_with_credits: "Тепер збудуйте свою будівлю за кредити!",
                        new_building: 'Клацніть "Нова будівля"!',
                        select_building: "Спочатку виберіть тип будівлі, з якого хочете розпочати; ми наполегливо рекомендуємо розпочати з пожежної станції! У будь-якому випадку, рекомендується розпочати з малої станції!",
                        select_position: "Перемістіть маркер синього кольору у місце, в якому ви хочете збудувати свою першу станцію!"
                    },
                    pick_location: "Спочатку оберіть місце! Введіть назву місця, з якого хочете розпочати, у рядок пошуку, щоб особисто знайти його на карті! Як щодо вашого рідного міста?",
                    welcome: 'Сердечно вітаємо у грі "Диспетчер 101"!  Я продемонструю вам, яким чином можна дати гарний старт власній кар\'єрі у сфері екстрених служб!'
                },
                mobile: {
                    build_building: {
                        add_name: 'Далі, дайте своїй новій станції назву! Зробіть її помітною і розширюваною! Наприклад, "Пожежна станція № 0001". Коли будете готові, клацніть "Далі"!',
                        build_with_credits: "Тепер збудуйте свою будівлю за кредити!",
                        new_building: 'Спочатку ми виберемо місце і збудуємо вашу першу будівлю! <br /> <br /> Для цього, клацніть "Нова будівля"!',
                        select_building: "Спочатку виберіть тип будівлі, з якого хочете розпочати; ми наполегливо рекомендуємо розпочати з пожежної станції! У будь-якому випадку, рекомендується розпочати з малої станції!"
                    },
                    welcome: 'Сердечно вітаємо у грі "Диспетчер 101"!  Я продемонструю вам, яким чином можна дати гарний старт власній кар\'єрі у сфері екстрених служб!'
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Це меню відправки. Звідси ви відправлятимете свої підрозділи на завдання!",
                        dispatch_menu_buttons: 'Це дві ваші кнопки відправки! Перша: "Відправити" відправляє вибрані підрозділи на завдання. Друга робить те ж саме, що й перша, але переходить до наступного завдання. Поки що, клацніть по першій кнопці.',
                        dispatch_menu_mission_general: "Тут можна отримати загальні відомості про завдання, а саме назву, адресу, значок завдання. У завданнях, в яких ви вже брали участь, з'являється значок з маленькою людиною і замінює маленьку зірочку.",
                        dispatch_menu_mission_progress: "Тут можна побачити, якого прогресу було досягнуто у виконанні завдання, а також кількість персоналу на місці і час, необхідний на виконання завдання!",
                        dispatch_menu_mission_specific: "Тут можна отримати більше відомосте про завдання, про те, які підрозділи відповідають на виклик, а які вже знаходяться на місці.",
                        dispatch_menu_vehicle_list: "Це список ваших доступних машин. Тут можна вибирати машини. Тепер виберіть свою машину, клацнувши по ній!"
                    },
                    mobile: {
                        dispatch_menu: "Це меню відправки. Звідси ви відправлятимете свої підрозділи на завдання!",
                        dispatch_menu_buttons: 'Це дві ваші кнопки відправки! Перша: "Відправити" відправляє вибрані підрозділи на завдання. Друга робить те ж саме, що й перша, але переходить до наступного завдання. Поки що, клацніть по першій кнопці.',
                        dispatch_menu_mission_general: "Тут можна отримати загальні відомості про завдання, а саме назву, адресу, значок завдання. У завданнях, в яких ви вже брали участь, з'являється значок з маленькою людиною і замінює маленьку зірочку.",
                        dispatch_menu_mission_progress: "Тут можна побачити, якого прогресу було досягнуто у виконанні завдання, а також кількість персоналу на місці і час, необхідний на виконання завдання!",
                        dispatch_menu_mission_specific: "Тут можна отримати більше відомосте про завдання, про те, які підрозділи відповідають на виклик, а які вже знаходяться на місці.",
                        dispatch_menu_vehicle_list: "Це список ваших доступних машин. Тут можна вибирати машини. Тепер виберіть свою машину, клацнувши по ній!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: 'Тепер ми хочемо дізнатись, яким чином реагувати на пригоди. Відкрийте меню відправки, клацнувши по кнопці "Відправити"!',
                        first_mission: "Чудово, ви збудували свою першу будівлю! От бачите, ви вже отримали звіти про перші завдання!"
                    },
                    mobile: {
                        dispatch_button: 'Тепер ми хочемо дізнатись, яким чином реагувати на пригоди. Відкрийте меню відправки, клацнувши по кнопці "Відправити"!',
                        first_mission: "Чудово, ви збудували свою першу будівлю! От бачите, ви вже отримали звіти про перші завдання!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: 'Чудово, ви на шляху до того, щоб стати потрясним диспетчером! Ось монети (%{coins}), які допоможуть вам на початку! </br> Ваша команда гри "Диспетчер 101"'
                },
                mobile: {
                    general: 'Чудово, ви на шляху до того, щоб стати потрясним диспетчером! Ось монети (%{coins}), які допоможуть вам на початку! </br> Ваша команда гри "Диспетчер 101"'
                }
            },
            tips: {
                browser: {
                    contact: "У випадку виникнення запитань, ви можете звернутись до відповідей на часті питання по грі або відвідати ігрові форуми чи нашу сторінку у Facebook!",
                    general: "У якості наступного кроку, ми порекомендуємо вам побудувати диспетчерський центр, а потім, якомога швидше, нові станції, оскільки максимальна кількість завдань дорівнює найвищій кількості будь-яких станцій різних типів (поліція, пожежники, швидка) плюс 1; наприклад, 5 пожежних станцій і 3 станції швидкої = 6 завдань.",
                    join_alliance: "Також, вступ у альянс значним чином допоможе вам, особливо на початку, тому це рекомендується також.",
                    summary: 'Це основи гри "Диспетчер 101"! Виконуйте завдання, отримуйте кредити, купляйте більше підрозділів, повторюйте. Веселої вам гри! </br> Ваша команда гри "Диспетчер 101"'
                },
                mobile: {
                    contact: "У випадку виникнення запитань, ви можете звернутись до відповідей на часті питання по грі або відвідати ігрові форуми чи нашу сторінку у Facebook!",
                    general: "У якості наступного кроку, ми порекомендуємо вам побудувати диспетчерський центр, а потім, якомога швидше, нові станції, оскільки максимальна кількість завдань дорівнює найвищій кількості будь-яких станцій різних типів (поліція, пожежники, швидка) плюс 1; наприклад, 5 пожежних станцій і 3 станції швидкої = 6 завдань.",
                    join_alliance: "Також, вступ у альянс значним чином допоможе вам, особливо на початку, тому це рекомендується також.",
                    summary: 'Це основи гри "Диспетчер 101"! Виконуйте завдання, отримуйте кредити, купляйте більше підрозділів, повторюйте. Веселої вам гри! </br> Ваша команда гри "Диспетчер 101"'
                }
            }
        },
        commons: {
            collect: "Взяти",
            "continue": "Ні",
            end: "Кінець",
            next: "Далі",
            prev: "Назад",
            skip: "Так",
            skip_hint: "Дійсно скасувати навчання? Перейти до нього пізніше не буде можливості. Ви не матимете права на нагороду за завершення навчання."
        },
        rewards: {
            log: "Нагорода за завершення навчання."
        }
    }
}, I18n.translations.es_MX = {
    common: {
        add: "Añadir",
        back: "Atrás",
        cancel: "Cancelar",
        change_saved: "Cambios guardados",
        coins_spend: "¿Seguro que quieres gastar estas monedas?",
        congratulations: "¡Enhorabuena!",
        content: "Contenido",
        copy: "Copiar",
        credits: "Créditos",
        "delete": "Eliminar",
        details: "Detalles",
        edit: "Editar",
        error: "Error",
        is_offline: "%{user} no está conectado.",
        is_offline_long: "%{user} no se ha conectado desde hace mucho tiempo",
        is_offline_with_duration: "%{user} no está conectado: %{duration}",
        is_online: "%{user} está conectado.",
        loading: "Cargando...",
        name: "Nombre",
        none: "Nada",
        of: "de",
        off: "No",
        on: "Sí",
        save: "Guardar",
        search: "Buscar",
        show: "Mostrar",
        user_not_found: "Usuario no encontrado",
        wrong_key: "Tecla equivocada"
    },
    javascript: {
        alarm: "Enviar",
        arrival: "Llegada",
        backalarm: "Cancelar",
        coins: "Monedas",
        credits: "Créditos",
        days: "días",
        few_seconds: "en pocos segundos",
        finish_in: "Termina en:",
        hours: "H",
        location_not_found: "No encontrado",
        messages: "Mensajes",
        minutes: "min.",
        missed_vehicle: "Falta:",
        mission_start_in: "Comienza en:",
        "new": "Nuevo",
        not_found_map: "No se ha encontrado el vehículo en el mapa",
        now: "Ahora",
        patient: "Paciente",
        patient_untouched: "Pacientes no tratados",
        poi_delete: "¿Seguro que quieres eliminar el PI %{caption}?",
        reload: "Recargar",
        sale: "Rebajas",
        sale_ended: "Oferta finalizada",
        secounds: "seg.",
        sicherheitswache_error: "El guardia de seguridad %{caption} no ha completado su misión, ya que no se han cumplido todos los criterios.",
        sicherheitswache_success: "El guardia de seguridad %{caption} ha completado su misión. Recibes %{credits} créditos.",
        start_in: "Comienza en: ",
        start_username: "Usuario:",
        time_left: "Tiempo restante:",
        to_building: "Ver edificio",
        to_mission: "Ver misión",
        understand: "Recibido",
        user_not_found: "No se ha encontrado al jugador.",
        vehicles_not_visible: "Los vehículos no están visibles. "
    },
    map: {
        alliance: "Alianza",
        alliance_chat: "Chat",
        alliance_chat_banned: "Tienes prohibido entrar al chat de la alianza.",
        alliance_chat_banned_admin: "Prohibición emitida por:",
        alliance_chat_banned_timeleft: "Tiempo restante:",
        alliance_chat_radio_off: "Radio de la alianza: No",
        alliance_chat_radio_on: "Radio de la alianza: Sí",
        alliance_event: "Evento",
        alliance_missions: "Misiones de alianza",
        alliance_missions_event: "Evento",
        ambulance: "Ambulancia",
        attended: "Respondido",
        cancel_alliance_event: "Cancelar evento de alianza",
        cancel_alliance_event_confirm: "¿Seguro que quieres cancelar el evento de alianza?",
        challenges: "",
        chat_history: "Historial de chat",
        congratulations: "¡Enhorabuena! Puedes ascender.",
        create_alliance_event: "Comenzar evento de alianza",
        create_alliance_operation: "Crea una misión de alianza a gran escala",
        emergency: "Emergencia",
        finishing: "Completando",
        join_alliance_infos: "Si estás en una alianza, otros jugadores podrán ofrecerte misiones.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Edificios",
            all_missions: "Misiones",
            alliance_buildings: "Edificios de la alianza",
            alliance_members: "Miembros",
            alliance_missions: "Compartido por la alianza",
            ambulance_station_missions: "Parque de ambulancias",
            ambulance_station_small_missions: "Parque de ambulancias (pequeño)",
            building_complex: "Complejo de edificios",
            buildings_section: "Instalaciones",
            clinic_missions: "Clínica",
            dispatch_center_missions: "Centralita",
            fire_school_missions: "Academia de bomberos",
            firehouse_missions: "Parque de bomberos",
            firehouse_small_missions: "Parque de bomberos (pequeño)",
            hospital_missions: "Hospital",
            map_filters: "Lista de filtros de mapa",
            mission_positions: "Puntos de interés (PI)",
            mission_positions_section: "PI",
            missions_section: "Misiones",
            police_copter_station_missions: "Helipuerto policial",
            police_school_missions: "Academia de policía",
            police_small_missions: "Comisaría de policía (pequeño)",
            police_special_forces: "Fuerzas especiales de la policía",
            police_station_missions: "Comisaría de policía",
            prison_missions: "Prisión",
            rapid_deployment_group: "Grupo de preparación rápida (GPR)",
            rescue_copter_station_missions: "Helipuerto médico",
            riot_police: "Policía antidisturbios",
            riot_police_missions: "Policía antidisturbios",
            staging_area_missions: "Zona de preparación",
            technical_aid_organization: "SAT",
            technical_aid_organization_school: "Academia SAT",
            user_buildings: "Mis edificios",
            user_missions: "Mis misiones",
            water_watch: "Rescate acuático",
            water_watch_missions: "Rescate acuático"
        },
        message: "Mensaje",
        mission: "Misión",
        missions_filtered_out: "Algunas misiones pueden ser filtradas. Por favor, revise los filtros de su mapa.",
        no_alliance_chat_impossible: "No estás en una alianza.",
        no_alliance_missions: "No hay misiones de alianza.",
        no_ambulance_missions: "No hay misiones de ambulancia. Solo habrá misiones de ambulancia cuando tengas una ambulancia y un hospital.",
        no_emergency_missions: "No hay misiones de emergencia disponibles. Solo habrá misiones de emergencia después de que construyas tu primera instalación.",
        no_radio_messages: "No has recibido mensajes de radio.",
        radio_messages: "Radio",
        restore_map: "Restaurar mapa",
        server_warning: "Mantenimiento del servidor a las 00:00. Se espera un tiempo de inactividad de 6 horas.",
        show_informations: "Verde: las misiones se mostrarán en la lista. Rojo: las misiones no se mostrarán.",
        sicherheitswache: "Misones planificadas",
        transport: "Transporte",
        unattended: "Sin respuesta"
    },
    fms: {
        going: "Respondiendo",
        not_ready: "Fuera de servicio",
        on_destination: "En el destino del transporte",
        on_place: "Presente",
        patient_transported: "Transportando paciente",
        prisoner_transported: "Transportando preso",
        ready_home: "Disponible en la instalación",
        ready_traveling: "Listo y disponible",
        talking_wish: "Petición de transporte",
        waiting_for_vehicle: "Esperando a remolque"
    },
    intervention_order: {
        back: "Atrás",
        category: "Categoría",
        colour: "Color",
        column: "Columna",
        column_number: "N.º de columna",
        column_number_hint: "Si hay un número de columna, la entrada en las normas de alerta y respuesta se mostrará en la columna correspondiente de la página de la alerta.",
        create_intervention_order: "Crear nueva norma de alerta y respuesta",
        "delete": "Eliminar",
        delete_all: "Eliminar todas las normas de alerta y respuesta",
        delete_all_confirm: "¿Seguro que quieres eliminar todas las normas de alerta y respuesta? ¡Las entradas exportadas existentes ya no están disponibles!",
        description: "Nombre",
        edit: "Editar",
        "export": {
            "export": "Exportar",
            "import": "Importar",
            import_done: "Las entradas seleccionadas se han importado y añadido a tu plan de alerta y respuesta.",
            saved: "Exportar las normas de alerta y respuesta",
            saved_text: "Las normas de alerta y respuesta están preparadas para ser exportadas. Mediante el enlace, otro jugador podrá importarlas. Mientras tanto, si cambias alguna norma, el cambio se aplicará automáticamente a lo exportado."
        },
        hotkey_hint: "Elije una tecla para esta selección de vehículos. En la ventana de la misión, pulsa ALT + tu tecla (ALT + SHIFT + tu tecla en Firefox o CTRL + ALT + tu tecla en MacOS) para seleccionarla.",
        intervention_order: "Editar normas de alerta y respuesta",
        name: "Nombre",
        no_intervention_created: "Todavía no has creado ninguna norma de alerta y respuesta.",
        options: "Opciones",
        reset: "Restablece la selección anterior en la ventana de alertas.",
        reset_hint: "Si has seleccionado el vehículo en la ventana de respuesta, puedes usar este botón para restablecer.",
        save: "Guardar",
        station: "Instalación",
        station_hint: "Si hay un edificio seleccionado, solo se seleccionarán los vehículos de ese edificio.",
        successfully_created: "Norma de alerta y respuesta creada correctamente.",
        successfully_deleted: "Norma de alerta y respuesta eliminada",
        successfully_updated: "Norma de alerta y respuesta actualizada correctamente.",
        vehicles: {
            ab_atemschutz_only: "Módulo ERA",
            ab_einsatzleitung_only: "Módulo de mando",
            ab_gefahrgut_only: "Módulo Hazmat",
            ab_oel_only: "Módulo de vertido de crudo",
            ab_ruest: "Módulo tecnológico de rescate",
            ab_ruest_rw: "",
            abl2wasser_only: "Módulo de mangueras",
            ambulance: "UVI móvil",
            ambulance_or_rapid_responder: "",
            arff: "CBA (Camión de bomberos de aeropuerto)",
            battalion_chief_unit: "Unidad de Mando y Comunicaciones",
            boot: "Botes (general)",
            dekon_p: "",
            division_chief_unit: "Unidad de mando",
            dlk_or_tm50: "",
            elw1_or_elw2: "Unidad de Mando y Comunicaciones, unidad de mando o módulo de mando móvil ",
            elw2_or_ab_elw: "Bomba de Rescate o Unidad de Apoyo de Rescate y Camión de Bomberos",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulancia o helicóptero de emergencia",
            fire_truck: "Camiones de bomberos",
            fireboat: "Barco de bomberos grande",
            fly_car: "Coche volador",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Camión de usos múltiples",
            grtw: "Unidad para múltiples víctimas",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Hazmat",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Camión de rescate en altura",
            gw_messtechnik: "Camión de medición",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Retención de agua",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Vehículo con manguera",
            hems: "HSEM",
            hlf_only: "Vehículo de rescate",
            hlf_or_rw_and_lf: "Vehículo de rescate o vehículo de rescate pesado y camión de bomberos",
            hondengeleider: "",
            k9: "Unidad canina",
            kdow_lna: "",
            kdow_orgl: "Jefe de emergencias",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Vehículo de mando ligero (leBefKw)",
            lf_only: "Camiones de bomberos",
            long_distance_ambulance: "Ambulancia SVB",
            mask_service_unit: "Unidad aérea",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Camión de transporte",
            mzb: "Barco multiusos",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulancia",
            oil_unit: "Camión para fuegos de aceite",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Coche patrulla",
            polizeihubschrauber: "Helicóptero de policía",
            rescue_vehicle: "Furgones de Útiles Varios",
            rescue_vehicle_only: "Furgón de Útiles Varios",
            rescueboat: "Barco de rescate grande",
            rettungstreppe: "",
            rth_only: "Helicóptero",
            schlauchwagen: "Camión cisterna",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "Fuerzas especiales (GEO)",
            swat_armored_vehicle: "Vehículo blindado de los GEO",
            swat_suv: "Todoterreno de los GEO",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Camión de transporte técnico",
            thw_mzkw: "Vehículo multiusos",
            thw_tauchkraftwagen: "Equipo de buceo",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Camión cisterna",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Camión AE",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Segundo, ¡ponle un nombre a tu nueva estación! ¡Haz que sea reconocible y aumentable! P. ej., «Estación de bomberos #0001». Cuando termines, ¡haz clic en «Siguiente»!",
                        build_with_credits: "¡Ahora construye tu edificio con créditos!",
                        new_building: "¡Haz clic en «Nuevo edificio»!",
                        select_building: "Primero, elige el tipo de edificio con el que deseas empezar. ¡Te recomendamos que empieces con el servicio de bomberos! En cualquier caso, ¡se recomienda empezar con una estación pequeña!",
                        select_position: "¡Coloca el marcador azul en donde desees construir tu primera estación!"
                    },
                    pick_location: "Primero, ¡elige una ubicación para comenzar! Escribe el nombre de la ubicación donde deseas empezar en la barra de búsqueda ¡o encuéntrala tú mismo en el mapa! ¿Qué hay de tu ciudad?",
                    welcome: "¡Hola! ¡Bienvenido a Centro de Mando MX!  ¡Te daré algunas lecciones para que empieces tu carrera en los servicios de emergencia con el pie derecho!"
                },
                mobile: {
                    build_building: {
                        add_name: "Segundo, ¡ponle un nombre a tu nueva estación! ¡Haz que sea reconocible y aumentable! P. ej., «Estación de bomberos #0001». Cuando termines, ¡haz clic en «Siguiente»!",
                        build_with_credits: "¡Ahora construye tu edificio con créditos!",
                        new_building: "Primero, ¡escogeremos una ubicación para comenzar a construir tu primer edificio! <br /> <br /> Para eso, ¡haz clic en «Nuevo edificio»!",
                        select_building: "Primero, elige el tipo de edificio con el que deseas empezar. ¡Te recomendamos que empieces con el servicio de bomberos! En cualquier caso, ¡se recomienda empezar con una estación pequeña!"
                    },
                    welcome: "¡Hola! ¡Bienvenido a Centro de Mando MX!  ¡Te daré algunas lecciones para que empieces tu carrera en los servicios de emergencia con el pie derecho!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Este es el menú de despachos. ¡Desde aquí puedes enviar a tus unidades a misiones!",
                        dispatch_menu_buttons: "¡Estos son los dos botones de despacho! El primero, «Despachar», envía a las unidades seleccionadas a la misión. El segundo hace lo mismo que el primero, pero va a la siguiente misión. Por ahora, haz clic en el primer botón.",
                        dispatch_menu_mission_general: "Aquí puedes ver la información general de la misión; es decir, el nombre, la dirección y el ícono de la misión. El ícono del hombrecito aparece y reemplaza la estrella pequeña en las misiones donde ya participaste.",
                        dispatch_menu_mission_progress: "Aquí puedes ver el progreso de la misión, además de la cantidad de personal en el sitio ¡y el tiempo restante para cumplir la misión!",
                        dispatch_menu_mission_specific: "Aquí puedes ver más datos sobre la misión, qué unidades están respondiendo al llamado y cuáles ya están en el lugar.",
                        dispatch_menu_vehicle_list: "Esta es la lista de los vehículos disponibles. Selecciona los vehículos aquí. ¡Selecciona un vehículo haciendo clic sobre él!"
                    },
                    mobile: {
                        dispatch_menu: "Este es el menú de despachos. ¡Desde aquí puedes enviar a tus unidades a misiones!",
                        dispatch_menu_buttons: "¡Estos son los dos botones de despacho! El primero, «Despachar», envía a las unidades seleccionadas a la misión. El segundo hace lo mismo que el primero, pero va a la siguiente misión. Por ahora, haz clic en el primer botón.",
                        dispatch_menu_mission_general: "Aquí puedes ver la información general de la misión; es decir, el nombre, la dirección y el ícono de la misión. El ícono del hombrecito aparece y reemplaza la estrella pequeña en las misiones donde ya participaste.",
                        dispatch_menu_mission_progress: "Aquí puedes ver el progreso de la misión, además de la cantidad de personal en el sitio ¡y el tiempo restante para cumplir la misión!",
                        dispatch_menu_mission_specific: "Aquí puedes ver más datos sobre la misión, qué unidades están respondiendo al llamado y cuáles ya están en el lugar.",
                        dispatch_menu_vehicle_list: "Esta es la lista de los vehículos disponibles. Selecciona los vehículos aquí. ¡Selecciona un vehículo haciendo clic sobre él!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Ahora aprenderemos a lidiar con los incidentes. ¡Abre el menú de despachos haciendo clic en el botón «Despachar»!",
                        first_mission: "¡Muy bien! ¡Construiste tu primer edificio! Mira, ¡te reportaron las primeras misiones!"
                    },
                    mobile: {
                        dispatch_button: "Ahora aprenderemos a lidiar con los incidentes. ¡Abre el menú de despachos haciendo clic en el botón «Despachar»!",
                        first_mission: "¡Muy bien! ¡Construiste tu primer edificio! Mira, ¡te reportaron las primeras misiones!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "¡Grandioso! ¡Vas en camino a convertirte en un asombroso Centro de mando MX! ¡Aquí tienes %{coins} monedas para ayudarte a empezar! </br> El equipo de Centro de Mando MX"
                },
                mobile: {
                    general: "¡Grandioso! ¡Vas en camino a convertirte en un asombroso Centro de mando MX! ¡Aquí tienes %{coins} monedas para ayudarte a empezar! </br> El equipo de Centro de Mando MX"
                }
            },
            tips: {
                browser: {
                    contact: "En caso de dudas, consulta las preguntas frecuentes dentro del juego o visita los foros del juego ¡o nuestra página de Facebook!",
                    general: "Como siguiente paso, te recomendamos construir un centro de despachos y, tan pronto sea posible, nuevas estaciones, ya que la cantidad máxima de misiones será igual a la cantidad máxima de estaciones de un determinado tipo (policía, bomberos, ambulancias) más 1; p. ej., 5 de bomberos y 3 de ambulancias = 6 misiones.",
                    join_alliance: "Asimismo, unirte a una alianza te será de gran ayuda, sobre todo, al inicio, por lo que también te lo recomendamos.",
                    summary: "¡Estas son las bases de Centro de Mando MX! Completa misiones, obtén créditos, compra más unidades, repite. ¡Diviértete jugando! </br> El equipo de Centro de Mando MX"
                },
                mobile: {
                    contact: "En caso de dudas, consulta las preguntas frecuentes dentro del juego o visita los foros del juego ¡o nuestra página de Facebook!",
                    general: "Como siguiente paso, te recomendamos construir un centro de despachos y, tan pronto sea posible, nuevas estaciones, ya que la cantidad máxima de misiones será igual a la cantidad máxima de estaciones de un determinado tipo (policía, bomberos, ambulancias) más 1; p. ej., 5 de bomberos y 3 de ambulancias = 6 misiones.",
                    join_alliance: "Asimismo, unirte a una alianza te será de gran ayuda, sobre todo, al inicio, por lo que también te lo recomendamos.",
                    summary: "¡Estas son las bases de Centro de Mando MX! Completa misiones, obtén créditos, compra más unidades, repite. ¡Diviértete jugando! </br> El equipo de Centro de Mando MX"
                }
            }
        },
        commons: {
            collect: "Recoger",
            "continue": "No",
            end: "Finalizar",
            next: "Siguiente",
            prev: "Anterior",
            skip: "Sí",
            skip_hint: "¿Seguro que quieres saltarte el tutorial? Después, no podrás acceder a él.No podrás recibir la recompensa por completar el tutorial."
        },
        rewards: {
            log: "Recompensa por completar el tutorial."
        }
    }
}, I18n.translations.ja_JP = {
    common: {
        add: "追加",
        back: "戻る",
        cancel: "キャンセル",
        change_saved: "変更内容を保存しました",
        coins_spend: "これらのコインを支払いを実行してもよろしいですか？",
        congratulations: "おめでとうございます！",
        content: "コンテンツ",
        copy: "コピー",
        credits: "クレジット",
        "delete": "削除",
        details: "詳細",
        edit: "編集",
        error: "エラー",
        is_offline: "%{user}はオフラインです。",
        is_offline_long: "長時間：%{user}はオフラインです。",
        is_offline_with_duration: "%{user}はオフラインです: %{duration}",
        is_online: "%{user}はオンラインです。",
        loading: "ロード中…",
        name: "名前",
        none: "なし",
        of: "/",
        off: "オフ",
        on: "オン",
        save: "保存",
        search: "検索",
        show: "表示",
        user_not_found: "ユーザーが見つかりません",
        wrong_key: "誤ったキー"
    },
    javascript: {
        alarm: "指令",
        arrival: "到着",
        backalarm: "キャンセル",
        coins: "コイン",
        credits: "クレジット",
        days: "日",
        few_seconds: "数秒後",
        finish_in: "終了まで：",
        hours: "時間",
        location_not_found: "見つかりません",
        messages: "メッセージ",
        minutes: "分",
        missed_vehicle: "不足：",
        mission_start_in: "開始まで:",
        "new": "新着",
        not_found_map: "車両がマップ上に見つかりませんでした",
        now: "今",
        patient: "患者",
        patient_untouched: "治療を受けていない患者",
        poi_delete: "この到着地点「：%{caption}」を削除しますか？",
        reload: "リロード",
        sale: "セール",
        sale_ended: "セール終了",
        secounds: "秒",
        sicherheitswache_error: "すべての条件を満たさなかったため、セキュリティーガード「%{caption}」が上手くいきませんでした。",
        sicherheitswache_success: "セキュリティーガード「%{caption}」は無事行われました。%{credits}クレジットを受け取ります。",
        start_in: "開始まで： ",
        start_username: "スターター：",
        time_left: "残り時間：",
        to_building: "建物を見る",
        to_mission: "ミッションを見る",
        understand: "承認",
        user_not_found: "プレイヤーが見つかりませんでした。",
        vehicles_not_visible: "車両が見えません。 "
    },
    map: {
        alliance: "アライアンス",
        alliance_chat: "チャット",
        alliance_chat_banned: "アライアンスチャットから現在バンをされています。",
        alliance_chat_banned_admin: "バンを行った人：",
        alliance_chat_banned_timeleft: "残り時間：",
        alliance_chat_radio_off: "アライアンス無線：オフ",
        alliance_chat_radio_on: "アライアンス無線：オン",
        alliance_event: "イベント",
        alliance_missions: "アライアンスミッション",
        alliance_missions_event: "イベント",
        ambulance: "救急車",
        attended: "対応済",
        cancel_alliance_event: "アライアンスイベントのキャンセル",
        cancel_alliance_event_confirm: "本当にアライアンスイベントをキャンセルしますか？ ",
        challenges: "",
        chat_history: "チャット履歴",
        congratulations: "おめでとうございます！昇進することができます。",
        create_alliance_event: "アライアンスイベントを開始",
        create_alliance_operation: "大型アライアンスミッションを作成",
        emergency: "緊急事態",
        finishing: "対応中",
        join_alliance_infos: "アライアンスに所属していれば、他のプレイヤーがあなたへ自由にミッションを割り当てられます。",
        map: "マップ",
        map_filters: {
            all_buildings: "建物",
            all_missions: "ミッション",
            alliance_buildings: "アライアンスの建物",
            alliance_members: "メンバー",
            alliance_missions: "同盟から共有",
            ambulance_station_missions: "救急車ステーション",
            ambulance_station_small_missions: "救急車ステーション（小型ステーション）",
            building_complex: "連結建造物",
            buildings_section: "ステーション",
            clinic_missions: "クリニック",
            dispatch_center_missions: "指令センター",
            fire_school_missions: "消防アカデミー",
            firehouse_missions: "消防局",
            firehouse_small_missions: "消防局（小）",
            hospital_missions: "病院",
            map_filters: "マップフィルターの一覧",
            mission_positions: "到着地点（POI）",
            mission_positions_section: "POI",
            missions_section: "ミッション",
            police_copter_station_missions: "警察航空隊",
            police_school_missions: "警察アカデミー",
            police_small_missions: "警察署（小型ステーション）",
            police_special_forces: "警察特殊部隊",
            police_station_missions: "警察署",
            prison_missions: "刑務所",
            rapid_deployment_group: "高速セットアップグループ（SEG）",
            rescue_copter_station_missions: "医療ヘリコプターステーション",
            riot_police: "対暴徒警察",
            riot_police_missions: "対暴徒警察",
            staging_area_missions: "ステージングエリア",
            technical_aid_organization: "技術支援隊",
            technical_aid_organization_school: "THW連邦学校",
            user_buildings: "自分の建物",
            user_missions: "自分のミッション",
            water_watch: "水難救助",
            water_watch_missions: "水難救助"
        },
        message: "メッセージ",
        mission: "ミッション",
        missions_filtered_out: "一部のミッションは除外される可能性があります。マップフィルターを確認してください。",
        no_alliance_chat_impossible: "アライアンスに所属していません。",
        no_alliance_missions: "現在、アライアンスミッションはありません。",
        no_ambulance_missions: '"患者の搬送はありません。患者の搬送は、一次救命処置と病院を所有すると対応できるようになります。"',
        no_emergency_missions: "参加できる緊急事態ミッションはありません。最初のステーションを作成した後、緊急事態ミッションが発生します。",
        no_radio_messages: "無線メッセージを傍受していません。",
        radio_messages: "無線",
        restore_map: "マップをリストア",
        server_warning: "Server maintenance at 7 am. 6h downtime expected.",
        show_informations: "緑 = ミッションがリスト内に表示されます。赤 = ミッションが表示されません。",
        sicherheitswache: "予定されているミッション",
        transport: "輸送",
        unattended: "未対応"
    },
    fms: {
        going: "応答中",
        not_ready: "故障中",
        on_destination: "輸送目的地",
        on_place: "現場",
        patient_transported: "患者を輸送中",
        prisoner_transported: "囚人を輸送中",
        ready_home: "ステーションで利用可",
        ready_traveling: "ミッションなし、利用可",
        talking_wish: "輸送要請",
        waiting_for_vehicle: "牽引用の車両を待機中"
    },
    intervention_order: {
        back: "戻る",
        category: "カテゴリー",
        colour: "カラー",
        column: "コラム",
        column_number: "コラム番号",
        column_number_hint: "コラム番号が与えられると、警報と応答内容が警報ページ内の対応するコラムに表示されます。",
        create_intervention_order: "新規の警報と応答管理を作成",
        "delete": "削除",
        delete_all: "警報と応答管理を完全に削除",
        delete_all_confirm: "すべての警報と応答管理を削除してもよろしいですか？既存のエクスポートした内容は利用できません！",
        description: "名前",
        edit: "編集",
        "export": {
            "export": "エクスポート",
            "import": "インポート",
            import_done: "選択した内容はインポートされ、警報と応答プランに書かれました。",
            saved: "警報と応答管理をエクスポート",
            saved_text: "警報と応答管理のエクスポート準備ができました。他のプレイヤーはリンクを辿って警報と応答管理がインポートできます。その間警報と応答管理を変更した場合、この変更はエクスポート内に自動的に適用されます。"
        },
        hotkey_hint: "車両セクションのホットキーを選択してください。ミッション画面のボタンを押してください：ALT + 割り当てたホットキー （Firefoxの場合：ALT + SHIFT + 割り当てたホットキー、mac osの場合：ctrl + alt + 割り当てたホットキー）で車両セクションを選択します。",
        intervention_order: "警報と応答管理を編集",
        name: "名前",
        no_intervention_created: "まだ警報と応答管理を作成していません。",
        options: "オプション",
        reset: "警報ウィンドウ内の前回のセクションをリセットします。",
        reset_hint: "指令ウィンドウで車両を選んだ場合、このボタンでリセットできます。",
        save: "保存",
        station: "ステーション",
        station_hint: "建物を選択すると、建物に対応する車両のみが選択されます。",
        successfully_created: "警報と応答管理を無事に作成しました。",
        successfully_deleted: "警報と応答管理を削除",
        successfully_updated: "警報と応答管理が無事にアップデートされました。",
        vehicles: {
            ab_atemschutz_only: "自給式呼吸器モジュール",
            ab_einsatzleitung_only: "指示モジュール",
            ab_gefahrgut_only: "危険物取扱モジュール",
            ab_oel_only: "飛散オイルモジュール",
            ab_ruest: "テック/救助モジュール",
            ab_ruest_rw: "",
            abl2wasser_only: "ホースサプライモジュール",
            ambulance: "ALS救急車",
            ambulance_or_rapid_responder: "",
            arff: "空港用消防車",
            battalion_chief_unit: "消防指令長ユニット",
            boot: "ボート（一般）",
            dekon_p: "",
            division_chief_unit: "移動通信車両",
            dlk_or_tm50: "",
            elw1_or_elw2: "消防司令長車両または指令車",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "緊急救急車またはヘリコプター",
            fire_truck: "消防車",
            fireboat: "火災用大型ボート",
            fly_car: "ドクターカー",
            fly_car_any: "ドクターカー / 家庭医",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "小型トラック",
            grtw: "大型トラックユニット",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "空気充填照明車",
            gw_gefahrgut: "危険物取扱車両",
            gw_gefahrgut_only: "",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "貯水車両",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "ホース車両",
            hems: "HEMS",
            hlf_only: "救助工作車",
            hlf_or_rw_and_lf: "救助工作車または特別高度救助部隊車両と消防車",
            hondengeleider: "",
            k9: "警察犬ユニット",
            kdow_lna: "",
            kdow_orgl: "救急車指揮官",
            ktw_b: "",
            ktw_or_rtw: "一次／二次救命処置",
            lf_only: "消防車",
            long_distance_ambulance: "一時救命処置救急車",
            mask_service_unit: "空気充填照明車",
            mek_mtf: "",
            mek_zf: "",
            mtw: "消防隊員用車両",
            mzb: "多目的ボート",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "救急車",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "パトカー",
            polizeihubschrauber: "警察ヘリコプター",
            rescue_vehicle: "大型救助車両",
            rescue_vehicle_only: "特別高度救助部隊車両のみ",
            rescueboat: "大型救助ボート",
            rettungstreppe: "",
            rth_only: "ヘリコプター",
            schlauchwagen: "ウォータータンカー",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SWAT",
            swat_armored_vehicle: "SWAT装甲車両",
            swat_suv: "SWAT SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_tauchkraftwagen: "潜水チーム",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "タンカートラック",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "プラットフォームトラック",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "次は新しいステーションに名前を付けてくれ！分かりやすく、二か所目以降もつけやすい名前にしよう！例えば、「消防局#0001」が一つとして挙げられる。できたら「次へ」をクリックだ！",
                        build_with_credits: "今度はクレジットを使って建物を建てよう！",
                        new_building: "「新たな建物」をクリック！",
                        select_building: "スタートしたい建物の種類を選ぼう。消防から始めるのがお勧めだ！とりあえず、小さいステーションから始めるといいぞ！",
                        select_position: "最初のステーションを建てたい所に青色のマーカーを動かそう！"
                    },
                    pick_location: "まずはスタート地点を選ぶ！スタートしたい場所の名前を検索バーに入力するか、地図から見つけよう！君の出身地はどうかな？",
                    welcome: "ミッションチーフへようこそ！緊急サービスキャリアをスタートするためのレッスンをしよう。"
                },
                mobile: {
                    build_building: {
                        add_name: "次は新しいステーションに名前を付けてくれ！分かりやすく、二か所目以降もつけやすい名前にしよう！例えば、「消防局#0001」が一つとして挙げられる。できたら「次へ」をクリックだ！",
                        build_with_credits: "今度はクレジットを使って建物を建てよう！",
                        new_building: "まずはスタート地点を選んで、最初の建設を始めよう！<br /> <br /> 「新たな建物」をクリック！",
                        select_building: "スタートしたい建物の種類を選ぼう。消防から始めるのがお勧めだ！とりあえず、小さいステーションから始めるといいぞ！"
                    },
                    welcome: "ミッションチーフへようこそ！緊急サービスキャリアをスタートするためのレッスンをしよう。"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "これが指令メニューだ。ここからユニットをミッションに派遣するのだ！",
                        dispatch_menu_buttons: "指令ボタンは2つある！一つ目は「指令」だ。選択したユニットをミッションに派遣する。2つ目は最初と同じだが、次のミッションへ向かう。ひとまず、最初のボタンをクリックしよう。",
                        dispatch_menu_mission_general: "ここでは、ミッションに関する全般的な情報、つまりミッションの名前、住所、アイコンを確認できる。既に参加しているミッションは、小さな星のアイコンが人の形になる。",
                        dispatch_menu_mission_progress: "ここでは、このミッションにおける進捗状況、現場にいる人員数、ミッションの残り時間を見ることができる！",
                        dispatch_menu_mission_specific: "ここでは、ミッションに関する詳細な情報、通報に応答しているユニット、既に現場派遣されているユニットを見ることができる。",
                        dispatch_menu_vehicle_list: "これは使える車両の一覧である。ここから車両を選べる。車両をクリックして決定！"
                    },
                    mobile: {
                        dispatch_menu: "これが指令メニューだ。ここからユニットをミッションに派遣するのだ！",
                        dispatch_menu_buttons: "指令ボタンは2つある！一つ目は「指令」だ。選択したユニットをミッションに派遣する。2つ目は最初と同じだが、次のミッションへ向かう。ひとまず、最初のボタンをクリックしよう。",
                        dispatch_menu_mission_general: "ここでは、ミッションに関する全般的な情報、つまりミッションの名前、住所、アイコンを確認できる。既に参加しているミッションは、小さな星のアイコンが人の形になる。",
                        dispatch_menu_mission_progress: "ここでは、このミッションにおける進捗状況、現場にいる人員数、ミッションの残り時間を見ることができる！",
                        dispatch_menu_mission_specific: "ここでは、ミッションに関する詳細な情報、通報に応答しているユニット、既に現場派遣されているユニットを見ることができる。",
                        dispatch_menu_vehicle_list: "これは使える車両の一覧である。ここから車両を選べる。車両をクリックして決定！"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "ここで現場対応の方法を学ぼう。「指令」ボタンをクリックして指令メニューを開いてくれ！",
                        first_mission: "よし、最初の建物が出来たな！最初のミッションが来たぞ！"
                    },
                    mobile: {
                        dispatch_button: "ここで現場対応の方法を学ぼう。「指令」ボタンをクリックして指令メニューを開いてくれ！",
                        first_mission: "よし、最初の建物が出来たな！最初のミッションが来たぞ！"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "いいぞ。一流のミッションチーフになれる日は近いな！コイン%{coins}枚だ。キャリアのスタートに役立ててくれ！</br> ミッションチーフ・チームより"
                },
                mobile: {
                    general: "いいぞ。一流のミッションチーフになれる日は近いな！コイン%{coins}枚だ。キャリアのスタートに役立ててくれ！</br> ミッションチーフ・チームより"
                }
            },
            tips: {
                browser: {
                    contact: "分からないことがあったら、ゲームFAQを参照するか、ゲームフォーラムかFacebookページを訪ねてくれ！",
                    general: "次のステップでは、指令センターを建設し、その後すぐに新しいステーションを増やすことをお勧めする。ミッションの最大数＝各種類（警察、消防、救急）のステーションの最大数＋1であるためだ。例えば、消防局が5軒、救急車ステーションが3軒とすると、ミッション数は6になる。",
                    join_alliance: "また、アライアンスを形成すると、特に駆け出し、ゲーム序盤で大いに役に立つので、それもお勧めしよう。",
                    summary: "ミッションチーフの基本が紹介されているぞ！ミッションを達成し、クレジットを獲得し、ユニットを購入し、拡充しよう。ゲームはこの一連の流れを繰り返して進むぞ。では、楽しんでくれ！</br> ミッションチーフ・チームより"
                },
                mobile: {
                    contact: "分からないことがあったら、ゲームFAQを参照するか、ゲームフォーラムかFacebookページを訪ねてくれ！",
                    general: "次のステップでは、指令センターを建設し、その後すぐに新しいステーションを増やすことをお勧めする。ミッションの最大数＝各種類（警察、消防、救急）のステーションの最大数＋1であるためだ。例えば、消防局が5軒、救急車ステーションが3軒とすると、ミッション数は6になる。",
                    join_alliance: "また、アライアンスを形成すると、特に駆け出し、ゲーム序盤で大いに役に立つので、それもお勧めしよう。",
                    summary: "ミッションチーフの基本が紹介されているぞ！ミッションを達成し、クレジットを獲得し、ユニットを購入し、拡充しよう。ゲームはこの一連の流れを繰り返して進むぞ。では、楽しんでくれ！</br> ミッションチーフ・チームより"
                }
            }
        },
        commons: {
            collect: "獲得",
            "continue": "いいえ",
            end: "終了",
            next: "次へ",
            prev: "前へ",
            skip: "はい",
            skip_hint: "チュートリアルは飛ばすと後で見ることはできません、スキップしてもいいですか？チュートリアル完了報酬が受け取れなくなります。"
        },
        rewards: {
            log: "チュートリアル完了の報酬です。"
        }
    }
}, I18n.translations.ko_KR = {
    common: {
        add: "추가",
        back: "뒤로",
        cancel: "취소",
        change_saved: "변경 저장됨",
        coins_spend: "코인을 사용하시겠습니까?",
        congratulations: "축하합니다!",
        content: "내용",
        copy: "복사",
        credits: "크레딧",
        "delete": "삭제",
        details: "세부 사항",
        edit: "편집",
        error: "오류",
        is_offline: "%{user} 님은 오프라인입니다.",
        is_offline_long: "장기간 오프라인: %{user}",
        is_offline_with_duration: "%{user} 님은 오프라인입니다: %{duration}",
        is_online: "%{user} 님이 온라인입니다.",
        loading: "로딩 중...",
        name: "이름",
        none: "없음",
        of: "/",
        off: "끔",
        on: "켬",
        save: "저장",
        search: "탐색",
        show: "보기",
        user_not_found: "유저를 찾을 수 없음",
        wrong_key: "잘못된 키"
    },
    javascript: {
        alarm: "파견",
        arrival: "도착",
        backalarm: "취소",
        coins: "코인",
        credits: "크레딧",
        days: "일",
        few_seconds: "몇 초 안에",
        finish_in: "완료까지:",
        hours: "시간",
        location_not_found: "찾을 수 없음",
        messages: "메시지",
        minutes: "분",
        missed_vehicle: "부족량:",
        mission_start_in: "시작까지:",
        "new": "새로운",
        not_found_map: "지도상에서 차량을 찾을 수 없습니다",
        now: "지금",
        patient: "환자",
        patient_untouched: "치료받지 않은 환자",
        poi_delete: "이 관심 지역(%{caption})을(를) 삭제하시겠습니까?",
        reload: "다시 불러오기",
        sale: "할인",
        sale_ended: "할인 종료",
        secounds: "초",
        sicherheitswache_error: '충족하지 못한 기준이 있어 "%{caption}" 보안 경비에 실패했습니다.',
        sicherheitswache_success: '"%{caption}"의 보안 경비를 성공적으로 완료했습니다. %{credits} 크레딧을 받았습니다.',
        start_in: "시작까지: ",
        start_username: "시작한 사용자:",
        time_left: "남은 시간:",
        to_building: "건물 보기",
        to_mission: "임무 보기",
        understand: "확인",
        user_not_found: "플레이어를 찾을 수 없습니다.",
        vehicles_not_visible: "차량이 보이지 않습니다. "
    },
    map: {
        alliance: "동맹",
        alliance_chat: "채팅",
        alliance_chat_banned: "현재 동맹 채팅 금지 상태입니다.",
        alliance_chat_banned_admin: "차단자:",
        alliance_chat_banned_timeleft: "남은 시간:",
        alliance_chat_radio_off: "동맹 무전: 끔",
        alliance_chat_radio_on: "동맹 무전: 켬",
        alliance_event: "이벤트",
        alliance_missions: "동맹 임무",
        alliance_missions_event: "이벤트",
        ambulance: "구급차",
        attended: "배정됨",
        cancel_alliance_event: "동맹 이벤트 취소",
        cancel_alliance_event_confirm: "동맹 이벤트를 취소하시겠습니까?",
        challenges: "",
        chat_history: "채팅 이력",
        congratulations: "축하합니다! 이제 진급하셨습니다.",
        create_alliance_event: "동맹 이벤트 시작",
        create_alliance_operation: "대규모 동맹 임무 생성",
        emergency: "응급 상황",
        finishing: "완료 중",
        join_alliance_infos: "동맹에 소속된 상태라면 다른 플레이어로부터 임무를 자유롭게 받을 수 있습니다.",
        map: "지도",
        map_filters: {
            all_buildings: "건물",
            all_missions: "임무",
            alliance_buildings: "동맹 건물",
            alliance_members: "동맹원",
            alliance_missions: "동맹이 공유",
            ambulance_station_missions: "응급실",
            ambulance_station_small_missions: "응급실(소형 관할서)",
            building_complex: "복합 건물",
            buildings_section: "관할서",
            clinic_missions: "클리닉",
            dispatch_center_missions: "지휘센터",
            fire_school_missions: "소방학교",
            firehouse_missions: "소방서",
            firehouse_small_missions: "소방서(소형)",
            hospital_missions: "병원",
            map_filters: "지도 필터 목록",
            mission_positions: "관심 지역(POI)",
            mission_positions_section: "POI",
            missions_section: "임무",
            police_copter_station_missions: "경찰 항공",
            police_school_missions: "경찰 학교",
            police_small_missions: "경찰서(소형 관할서)",
            police_special_forces: "경찰 특공부대",
            police_station_missions: "경찰서",
            prison_missions: "감옥",
            rapid_deployment_group: "빠른 그룹 설정(SEG)",
            rescue_copter_station_missions: "구급 헬리콥터 스테이션",
            riot_police: "진압 경찰",
            riot_police_missions: "진압 경찰",
            staging_area_missions: "집결지",
            technical_aid_organization: "기술 지원 기관(THW)",
            technical_aid_organization_school: "THW 연방 학교",
            user_buildings: "내 건물",
            user_missions: "내 임무",
            water_watch: "수상 구조",
            water_watch_missions: "수상 구조"
        },
        message: "메시지",
        mission: "임무",
        missions_filtered_out: "일부 미션이 필터링 될 수 있습니다. 지도 필터를 확인하십시오.",
        no_alliance_chat_impossible: "동맹에 속해 있지 않습니다.",
        no_alliance_missions: "현재 진행 중인 동맹 임무가 없습니다.",
        no_ambulance_missions: '구급차 임무가 없습니다. 구급차 임무는 구급차와 병원을 보유했을 때에만 발생합니다."이송 환자가 없습니다. 환자는 BLS 및 병원을 보유하는 즉시이송이 이루어집니다."',
        no_emergency_missions: "이용할 수 있는 긴급 임무가 없습니다. 긴급 임무는 첫 번째 관할서를 생성한 후 발생합니다.",
        no_radio_messages: "받은 무전 메시지가 없습니다.",
        radio_messages: "무전기",
        restore_map: "지도 복원",
        server_warning: "Server maintenance at 7 am. 6h downtime expected.",
        show_informations: "녹색 = 임무가 목록에 표시됩니다. 적색 = 임무가 표시되지 않습니다.",
        sicherheitswache: "계획된 출현",
        transport: "수송",
        unattended: "배정되지 않음"
    },
    fms: {
        going: "응답 중",
        not_ready: "서비스 중단",
        on_destination: "수송 목적지로",
        on_place: "현장에 있음",
        patient_transported: "환자 이송 중",
        prisoner_transported: "죄수 호송 중",
        ready_home: "관할서에서 이용 가능",
        ready_traveling: "완료 및 이용 가능",
        talking_wish: "수송 요청",
        waiting_for_vehicle: "견인 차량 기다리는 중"
    },
    intervention_order: {
        back: "뒤로",
        category: "카테고리",
        colour: "색상",
        column: "열",
        column_number: "열 번호",
        column_number_hint: "열 번호를 받으면 등록한 경보 및 대응 항목이 경보 페이지 내 해당 열에 표시됩니다.",
        create_intervention_order: "새 경보 및 대응 규정 생성",
        "delete": "삭제",
        delete_all: "경보 및 대응 규정 완전 삭제",
        delete_all_confirm: "경보 및 대응 규정을 모두 삭제하시겠습니까? 내보낸 기존 항목을 더 이상 사용할 수 없습니다!",
        description: "이름",
        edit: "편집",
        "export": {
            "export": "내보내기",
            "import": "가져오기",
            import_done: "선택한 항목을 가져와 경보 및 대응 계획에 기록했습니다.",
            saved: "경보 및 대응 규정 내보내기",
            saved_text: "경보 및 대응 규정을 내보낼 준비를 마쳤습니다. 링크를 통해 다른 플레이어가 제작한 경보 및 대응 규정을 가져올 수 있습니다. 이 기간 동안 경보 및 대응 규정을 변경할 경우 변경된 내용이 내보내는 항목에 자동으로 적용됩니다."
        },
        hotkey_hint: "이 차량을 선택할 단축키를 지정하세요. 임무 창에서: ALT + 단축키(Firefox의 경우: ALT + SHIFT + 단축키, Mac os의 경우: ctrl + alt + 단축키)를 눌러 선택한 차량을 지정하세요.",
        intervention_order: "경보 및 대응 규정 편집",
        name: "이름",
        no_intervention_created: "경보 및 대응 규정을 생성하지 않았습니다.",
        options: "옵션",
        reset: "경보 창에서 이전 선택을 초기화하세요.",
        reset_hint: "파견 창에서 차량을 선택했을 경우 이 버튼을 사용해 초기화할 수 있습니다.",
        save: "저장",
        station: "관할서",
        station_hint: "건물 선택 시, 선택한 건물 내에 배치한 차량만 선택됩니다.",
        successfully_created: "경보 및 대응 규정을 생성했습니다.",
        successfully_deleted: "경보 및 대응 규정을 삭제했습니다",
        successfully_updated: "경보 및 대응 규정을 업데이트하였습니다.",
        vehicles: {
            ab_atemschutz_only: "공기호흡기(SCBA) 모듈",
            ab_einsatzleitung_only: "지휘 모듈",
            ab_gefahrgut_only: "생화학 모듈",
            ab_oel_only: "기름 유출 모듈",
            ab_ruest: "기술/구조 모듈",
            ab_ruest_rw: "",
            abl2wasser_only: "호스 지원 모듈",
            ambulance: "고급 인명 지원(ALS) 구급차",
            ambulance_or_rapid_responder: "",
            arff: "ARFF(공항 소방차)",
            battalion_chief_unit: "소방대장 유닛",
            boot: "보트(일반)",
            dekon_p: "",
            division_chief_unit: "기동형 지휘차량",
            dlk_or_tm50: "",
            elw1_or_elw2: "소방대장 유닛, 기동형 지휘차량 또는 기동형 지휘 모듈 ",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "응급용 구급차 또는 헬기",
            fire_truck: "소방차",
            fireboat: "대형 소방 보트",
            fly_car: "긴급 이송차",
            fly_car_any: "긴급 이송차 / 일반의",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "다용도 트럭",
            grtw: "대량 사상자용 유닛",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "생화학 차량",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "작업 차량-로프 구조차",
            gw_messtechnik: "작업 차량-측량차",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "유수 관리",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "호스 차량",
            hems: "긴급 의료 서비스(헬기)",
            hlf_only: "구조 공작차",
            hlf_or_rw_and_lf: "구조 공작차 또는 중장비 구조 차량 및 소방차",
            hondengeleider: "",
            k9: "K-9 유닛",
            kdow_lna: "",
            kdow_orgl: "구급 지휘차",
            kdow_orgl_any: "구급 지휘차",
            ktw_b: "",
            ktw_or_rtw: "BLS 또는 ALS",
            lebefkw: "경량형 지휘차량(leBefKw)",
            lf_only: "소방차",
            long_distance_ambulance: "기본 인명 지원(BLS) 구급차",
            mask_service_unit: "이동식 호흡 장비",
            mek_mtf: "",
            mek_zf: "",
            mtw: "소방 부서 차량(MTW)",
            mzb: "다목적 보트",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "구급차",
            oil_unit: "작업 차량-기름 유출 방지",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "순찰차",
            polizeihubschrauber: "경찰 헬기",
            rescue_vehicle: "중장비 구조 차량",
            rescue_vehicle_only: "중장비 구조",
            rescueboat: "대형 구조 보트",
            rettungstreppe: "",
            rth_only: "구급 헬리콥터",
            schlauchwagen: "수상 탱커",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SWAT",
            swat_armored_vehicle: "SWAT 무장 차량",
            swat_suv: "SWAT SUV",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "인원 운송용 기술 차량(MTW-TZ - THW)",
            thw_mzkw: "다목적 차량(MzKW)",
            thw_tauchkraftwagen: "다이빙 팀",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "탱커 트럭",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "플랫폼 트럭",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: '두 번째는 새 관할서에 이름을 붙이는 것입니다! 알기 쉽고 확장 시 구별하기 쉬운 이름으로 만들어 보세요! 예를 들면 "소방서 #0001"처럼 말입니다. 전부 끝났으면 "다음"을 클릭하세요!',
                        build_with_credits: "이제 크레딧을 사용해 건물을 지으세요!",
                        new_building: '"새 건물"을 클릭하세요!',
                        select_building: "먼저 시작할 건물 유형을 선택하세요. 소방서를 강력하게 추천합니다! 어떤 경우라 하더라도 소형 관할서로 시작하는 것을 권장합니다!",
                        select_position: "첫 번째 관할서를 지을 곳으로 파란색 표식을 옮기세요!"
                    },
                    pick_location: "먼저 시작 위치를 선택합니다! 검색 바에서 시작할 위치 이름을 입력하거나 직접 지도에서 찾아보세요! 지금 사는 도시는 어떠신가요?",
                    welcome: "안녕하세요, 미션 치프에 오신 것을 환영합니다!  응급 구조대 이력을 확실하게 쌓을 수 있는 몇 가지 방법을 알려드릴게요!"
                },
                mobile: {
                    build_building: {
                        add_name: '두 번째는 새 관할서에 이름을 붙이는 것입니다! 알기 쉽고 확장 시 구별하기 쉬운 이름으로 만들어 보세요! 예를 들면 "소방서 #0001"처럼 말입니다. 전부 끝났으면 "다음"을 클릭하세요!',
                        build_with_credits: "이제 크레딧을 사용해 건물을 지으세요!",
                        new_building: '먼저 시작 위치를 선택해 첫 번째 건물을 지으세요! <br /> <br /> 건물을 지으려면 "새 건물"을 클릭하세요!',
                        select_building: "먼저 시작할 건물 유형을 선택하세요. 소방서를 강력하게 추천합니다! 어떤 경우라 하더라도 소형 관할서로 시작하는 것을 권장합니다!"
                    },
                    welcome: "안녕하세요, 미션 치프에 오신 것을 환영합니다!  응급 구조대 이력을 확실하게 쌓을 수 있는 몇 가지 방법을 알려드릴게요!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "여기가 파견 메뉴입니다. 이 메뉴에서 유닛을 임무에 보낼 수 있습니다!",
                        dispatch_menu_buttons: '파견 버튼은 두 가지가 있습니다! 첫 번째: "파견"을 사용해 선택한 유닛을 임무에 파견합니다. 두 번째는 첫 번째 방법과 동일하지만, 즉시 다음 임무로 이동합니다. 지금은 첫 번째 버튼을 클릭하세요.',
                        dispatch_menu_mission_general: "여기에서는 이름, 주소, 임무 아이콘 등 임무에 관한 일반 정보를 확인할 수 있습니다. 이미 참여한 임무는 작은 별 대신 작은 사람 아이콘이 표시됩니다.",
                        dispatch_menu_mission_progress: "여기에서는 미션 완료까지의 진행도와 현장 인원, 미션 완료까지 남은 시간을 확인할 수 있습니다!",
                        dispatch_menu_mission_specific: "여기에서는 어떤 유닛이 호출에 반응하는지, 어떤 유닛이 이미 현장에 있는지 등 임무에 대한 자세한 정보를 확인할 수 있습니다.",
                        dispatch_menu_vehicle_list: "이용할 수 있는 차량 목록이 여기에 표시됩니다. 여기서 차량을 선택합니다. 이제 차량을 클릭해 선택하세요!"
                    },
                    mobile: {
                        dispatch_menu: "여기가 파견 메뉴입니다. 이 메뉴에서 유닛을 임무에 보낼 수 있습니다!",
                        dispatch_menu_buttons: '파견 버튼은 두 가지가 있습니다! 첫 번째: "파견"을 사용해 선택한 유닛을 임무에 파견합니다. 두 번째는 첫 번째 방법과 동일하지만, 즉시 다음 임무로 이동합니다. 지금은 첫 번째 버튼을 클릭하세요.',
                        dispatch_menu_mission_general: "여기에서는 이름, 주소, 임무 아이콘 등 임무에 관한 일반 정보를 확인할 수 있습니다. 이미 참여한 임무는 작은 별 대신 작은 사람 아이콘이 표시됩니다.",
                        dispatch_menu_mission_progress: "여기에서는 미션 완료까지의 진행도와 현장 인원, 미션 완료까지 남은 시간을 확인할 수 있습니다!",
                        dispatch_menu_mission_specific: "여기에서는 어떤 유닛이 호출에 반응하는지, 어떤 유닛이 이미 현장에 있는지 등 임무에 대한 자세한 정보를 확인할 수 있습니다.",
                        dispatch_menu_vehicle_list: "이용할 수 있는 차량 목록이 여기에 표시됩니다. 여기서 차량을 선택합니다. 이제 차량을 클릭해 선택하세요!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: '이제 사고를 처리하는 방법을 알아보겠습니다. "파견" 버튼을 클릭해 파견 메뉴를 여세요!',
                        first_mission: "훌륭합니다. 첫 번째 건물이 완성되었네요! 보세요, 첫 번째 임무 신고가 접수되었습니다!"
                    },
                    mobile: {
                        dispatch_button: '이제 사고를 처리하는 방법을 알아보겠습니다. "파견" 버튼을 클릭해 파견 메뉴를 여세요!',
                        first_mission: "훌륭합니다. 첫 번째 건물이 완성되었네요! 보세요, 첫 번째 임무 신고가 접수되었습니다!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "훌륭합니다. 멋진 미션 치프가 되기 위해 임무를 열심히 진행 중이시군요! 순조롭게 시작할 수 있도록 코인 %{coins}개를 드립니다. </br> 미션 치프 팀 올림"
                },
                mobile: {
                    general: "훌륭합니다. 멋진 미션 치프가 되기 위해 임무를 열심히 진행 중이시군요! 순조롭게 시작할 수 있도록 코인 %{coins}개를 드립니다. </br> 미션 치프 팀 올림"
                }
            },
            tips: {
                browser: {
                    contact: "문의 사항은 게임 내 FAQ를 참고하시거나 게임 포럼 또는 Facebook 페이지를 방문해 주세요!",
                    general: "다음 단계는 지휘센터 건설 후 최대한 빨리 새 관할서를 짓는 것을 권장합니다. 최대 임무 수는 여러 유형(경찰서, 소방서, 응급실)의 관할서 중 가장 많이 배치한 관할서 수+1로 정해지기 때문입니다. 예를 들어 소방서 5곳과 응급실 3곳을 보유할 경우 최대 6개의 임무를 받을 수 있습니다.",
                    join_alliance: "또한 게임 초기에 동맹에 가입하면 큰 도움을 받을 수 있으므로 동맹 가입도 권장합니다.",
                    summary: "지금까지 미션 치프의 기본 플레이 방법을 알려드렸습니다! 임무를 완수하고 크레딧을 받아 더 많은 유닛을 구매하며 임무를 반복하세요. 즐겁게 플레이하세요! </br> 미션 치프 팀 올림"
                },
                mobile: {
                    contact: "문의 사항은 게임 내 FAQ를 참고하시거나 게임 포럼 또는 Facebook 페이지를 방문해 주세요!",
                    general: "다음 단계는 지휘센터 건설 후 최대한 빨리 새 관할서를 짓는 것을 권장합니다. 최대 임무 수는 여러 유형(경찰서, 소방서, 응급실)의 관할서 중 가장 많이 배치한 관할서 수+1로 정해지기 때문입니다. 예를 들어 소방서 5곳과 응급실 3곳을 보유할 경우 최대 6개의 임무를 받을 수 있습니다.",
                    join_alliance: "또한 게임 초기에 동맹에 가입하면 큰 도움을 받을 수 있으므로 동맹 가입도 권장합니다.",
                    summary: "지금까지 미션 치프의 기본 플레이 방법을 알려드렸습니다! 임무를 완수하고 크레딧을 받아 더 많은 유닛을 구매하며 임무를 반복하세요. 즐겁게 플레이하세요! </br> 미션 치프 팀 올림"
                }
            }
        },
        commons: {
            collect: "수집",
            "continue": "아니요",
            end: "마지막",
            next: "다음",
            prev: "이전",
            skip: "예",
            skip_hint: "정말 튜토리얼을 취소할까요? 이후 다시 확인할 수 없습니다.튜토리얼 완료 보상 자격을 받지 못하게 됩니다."
        },
        rewards: {
            log: "튜토리얼 완료에 대한 보상."
        }
    }
}, I18n.translations.ro_RO = {
    common: {
        add: "Adaugă",
        back: "Înapoi",
        cancel: "Anulează",
        change_saved: "Schimbări salvate",
        coins_spend: "Chiar vrei să cheltuiești aceste monede?",
        congratulations: "Felicitări!",
        content: "Conţinut",
        copy: "Copiază",
        credits: "Credite",
        "delete": "Șterge",
        details: "Detalii",
        edit: "Editează",
        error: "Eroare",
        is_offline: "%{user} este offline.",
        is_offline_long: "Perioadă îndelungată: %{user} este offline",
        is_offline_with_duration: "%{user} este offline: %{duration}",
        is_online: "%{user} este online.",
        loading: "Se încarcă...",
        name: "Nume",
        none: "Niciunul/niciuna",
        of: "din",
        off: "Dezactivat",
        on: "Activat",
        save: "Salvează",
        search: "Caută",
        show: "Arată",
        user_not_found: "Utilizatorul nu a fost găsit",
        wrong_key: "Tastă greșită"
    },
    javascript: {
        alarm: "Trimitere",
        arrival: "Sosire",
        backalarm: "Anulează",
        coins: "Monede",
        credits: "Credite",
        days: "zile",
        few_seconds: "în câteva secunde",
        finish_in: "Termină în:",
        hours: "H",
        location_not_found: "Nu a fost găsit",
        messages: "Mesaje",
        minutes: "min.",
        missed_vehicle: "Îi lipsește:",
        mission_start_in: "Începe în:",
        "new": "Nou",
        not_found_map: "Vehiculul nu a fost găsit pe hartă",
        now: "Acum",
        patient: "Pacient",
        patient_untouched: "Pacienți netratați",
        poi_delete: "Ești sigur că vrei să ștergi Punctul de interes: %{caption}?",
        reload: "Reîncarcă",
        sale: "Promoție",
        sale_ended: "Promoția s-a încheiat",
        secounds: "sec.",
        sicherheitswache_error: 'Misiunea de securizare "%{caption}" nu a avut succes, deoarece nu au fost îndeplinite toate criteriile.',
        sicherheitswache_success: 'Misiunea de securizare "%{caption}" a fost îndeplinită cu succes. Primești %{credits} credite.',
        start_in: "Începe în: ",
        start_username: "Starter:",
        time_left: "Timp rămas:",
        to_building: "Vezi clădirea",
        to_mission: "Vezi misiunea",
        understand: "Confirmă",
        user_not_found: "Jucătorul nu a fost găsit.",
        vehicles_not_visible: "Vehiculele nu sunt vizibile. "
    },
    map: {
        alliance: "Alianță",
        alliance_chat: "Chat",
        alliance_chat_banned: "În prezent, îți este interzis accesul la chatul alianței.",
        alliance_chat_banned_admin: "Interzis de:",
        alliance_chat_banned_timeleft: "Timp rămas:",
        alliance_chat_radio_off: "Radio alianță: Dezactivat",
        alliance_chat_radio_on: "Radio alianță: Activat",
        alliance_event: "Eveniment",
        alliance_missions: "Misiuni alianță",
        alliance_missions_event: "Eveniment",
        ambulance: "Ambulanță",
        attended: "Finalizate",
        cancel_alliance_event: "Anulează eveniment de alianță",
        cancel_alliance_event_confirm: "Ești sigur că vrei să anulezi evenimentul de alianță?",
        challenges: "",
        chat_history: "Istoric chat",
        congratulations: "Felicitări! Acum poți fi promovat.",
        create_alliance_event: "Începe eveniment de alianță",
        create_alliance_operation: "Creează o misiune de alianță pe scară largă",
        emergency: "Urgență",
        finishing: "În finalizare",
        join_alliance_infos: "Dacă faci parte dintr-o alianță, alți jucători îți pot încredința misiuni dacă doresc.",
        map: "Hartă",
        map_filters: {
            all_buildings: "Clădiri",
            all_missions: "Misiuni",
            alliance_buildings: "Clădiri de alianță",
            alliance_members: "Membri",
            alliance_missions: "Partajat de alianță",
            ambulance_station_missions: "Stație de ambulanță",
            ambulance_station_small_missions: "Stație de ambulanță (stație mică)",
            building_complex: "Complex de clădiri",
            buildings_section: "Stații",
            clinic_missions: "Clinică",
            dispatch_center_missions: "Dispecerat",
            fire_school_missions: "Academia de Pompieri",
            firehouse_missions: "Stație de pompieri",
            firehouse_small_missions: "Stație de pompieri (mică)",
            hospital_missions: "Spital",
            map_filters: "Lista filtrelor de hartă",
            mission_positions: "Puncte de interes",
            mission_positions_section: "Puncte de interes",
            missions_section: "Misiuni",
            police_copter_station_missions: "Transport aerian pentru forțele de poliție",
            police_school_missions: "Academia de Poliție",
            police_small_missions: "Secție de poliţie (secție mică)",
            police_special_forces: "Forțele speciale ale poliției",
            police_station_missions: "Secție de poliție",
            prison_missions: "Pușcărie",
            rapid_deployment_group: "Grup special de intervenție",
            rescue_copter_station_missions: "Stație de elicopter medical",
            riot_police: "Forțe de poliție speciale împotriva revoltelor stradale",
            riot_police_missions: "Forțe de poliție speciale împotriva revoltelor stradale",
            staging_area_missions: "Zona de așteptare",
            technical_aid_organization: "Agenția Națională de Asistență Tehnică (ANAT)",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Clădirile mele",
            user_missions: "Misiunile mele",
            water_watch: "Salvare acvatică",
            water_watch_missions: "Salvare acvatică"
        },
        message: "Mesaj",
        mission: "Misiune",
        missions_filtered_out: "Unele misiuni ar putea fi eliminate. Vă rugăm să verificați filtrele de hartă.",
        no_alliance_chat_impossible: "Nu faci parte dintr-o alianță.",
        no_alliance_missions: "În prezent nu există misiuni de alianță.",
        no_ambulance_missions: '"Nu există transporturi de pacienți. Transporturile vor putea fi efectuate atunci când vei aveao Ambulanță de tip B (BLS) și un spital."',
        no_emergency_missions: "Nu e disponibilă nicio misiune de urgență. O misiune de urgență poate apărea după ce ți-ai construit prima stație.",
        no_radio_messages: "Nu ai primit niciun mesaj radio.",
        radio_messages: "Radio",
        restore_map: "Restabilește harta",
        server_warning: "Server maintenance at 1 am. 6h downtime expected.",
        show_informations: "Verde = Misiunile sunt afișate pe listă. Roșu = Misiunile nu sunt afișate.",
        sicherheitswache: "Intervenții planificate",
        transport: "Transport",
        unattended: "Nefinalizate"
    },
    fms: {
        going: "Pe drum",
        not_ready: "Nefuncțional",
        on_destination: "La destinația de transport",
        on_place: "La fața locului",
        patient_transported: "Se transportă un pacient",
        prisoner_transported: "Se transportă un deținut",
        ready_home: "Disponibil la stație",
        ready_traveling: "Liber și disponibil",
        talking_wish: "Solicitare transport",
        waiting_for_vehicle: "Se așteaptă vehicul pentru tractare"
    },
    intervention_order: {
        back: "Înapoi",
        category: "Categorie",
        colour: "Culoare",
        column: "Coloană",
        column_number: "Număr coloană",
        column_number_hint: "Dacă este dat un număr de coloană, intrarea de Alarmă și Răspuns va fi afișată în coloana corespunzătoare de pe pagina de alertă.",
        create_intervention_order: "Creează un nou Regulament de Alarmă și Răspuns",
        "delete": "Șterge",
        delete_all: "Șterge complet Regulamentul de Alarmă și Răspuns",
        delete_all_confirm: "Ești sigur că vrei să ștergi complet Regulamentul de Alarmă și Răspuns? Intrările existente care au fost exportate nu mai sunt disponibile!",
        description: "Nume",
        edit: "Editează",
        "export": {
            "export": "Exportă",
            "import": "Importă",
            import_done: "Intrările selectate au fost importate și integrate în planul tău de Alarmă și Răspuns.",
            saved: "Exportări ale Regulamentului de Alarmă și Răspuns",
            saved_text: "Regulamentul tău de Alarmă și Răspuns a fost pregătit pentru exportare. Un alt jucător poate importa Regulamentul de Alarmă și Răspuns prin intermediul linkului. Dacă, între timp, modifici Regulamentul de Alarmă și Răspuns, această modificare se va aplica automat la exportare."
        },
        hotkey_hint: "Alege o tastă rapidă pentru selectarea acestui vehicul. Apasă în fereastra misiunii: ALT + tasta ta rapidă (sau în Firefox: ALT + SHIFT + tasta ta rapidă; sau pe mac os: ctrl + alt + tasta ta rapidă) pentru selectarea vehiculului.",
        intervention_order: "Editează Regulamentul de Alarmă și Răspuns",
        name: "Nume",
        no_intervention_created: "Încă nu ai creat niciun Regulament de Alarmă și Răspuns.",
        options: "Opțiuni",
        reset: "Resetează selecția anterioară în fereastra de alarmă.",
        reset_hint: "Dacă ai selectat vehiculul în fereastra de trimitere, poți utiliza acest buton pentru a-l reseta.",
        save: "Salvează",
        station: "Stație",
        station_hint: "Atunci când ai ales o anumită clădire, vei putea selecta doar vehiculele corespunzătoare acesteia.",
        successfully_created: "Regulament de Alarmă și Răspuns creat cu succes.",
        successfully_deleted: "Regulament de Alarmă și Răspuns șters",
        successfully_updated: "Regulament de Alarmă și Răspuns actualizat cu succes.",
        vehicles: {
            ab_atemschutz_only: "Modul Aparat de respirat izolant",
            ab_einsatzleitung_only: "Modul de comandă",
            ab_gefahrgut_only: "Modul materiale periculoase",
            ab_oel_only: "Modul scurgere petrol",
            ab_ruest: "Modul Tehnologie/Salvare",
            ab_ruest_rw: "",
            abl2wasser_only: "Modul alimentare furtun",
            ambulance: "Ambulanță ALS (asistență avansată în vederea menținerii funcțiilor vitale)",
            ambulance_or_rapid_responder: "",
            arff: "Salvare Aeriană și Luptă împotriva Incendiilor (Mașina de pompieri a aeroportului)",
            battalion_chief_unit: "Unitate Șef batalion",
            boot: "Bărci (general)",
            dekon_p: "",
            division_chief_unit: "Vehicul comandă forțe mobile",
            dlk_or_tm50: "",
            elw1_or_elw2: "Unitate șef batalion sau mașină de comanda și control",
            elw2_or_ab_elw: "nul",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulanță de urgență sau elicopter",
            fire_truck: "Mașini de pompieri",
            fireboat: "Barcă de stins incendii mare",
            fly_car: "Vehicul EMS netransportant",
            fly_car_any: "Vehicul EMS netransportant / Medic generalist",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Camionetă utilitară",
            grtw: "Unitate Victime multiple",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "Mașină de suport logistic",
            gw_gefahrgut: "Materiale periculoase",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "Vehicul pentru salvare și evacuare de la înălțime (cu frânghia)",
            gw_messtechnik: "Vehicul-metrologie",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Mașină de salvare acvatică",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Vehicul cu furtun",
            hems: "Elicopter SMURD",
            hlf_only: "Mașină de intervenții accidente colective",
            hlf_or_rw_and_lf: "Mașină de intervenții accidente colective sau vehicul greu de salvare și pompă de incendiu",
            hondengeleider: "",
            k9: "Unitate canină",
            kdow_lna: "",
            kdow_orgl: "Unitate transport Supervizor",
            kdow_orgl_any: "Unitate transport Supervizor",
            ktw_b: "",
            ktw_or_rtw: "Ambulanță tip B (BLS) sau C (ALS)",
            lebefkw: "Vehicul comandă ușor",
            lf_only: "Mașini de pompieri",
            long_distance_ambulance: "Ambulanță BLS (asistență de bază pentru menținerea funcțiilor vitale)",
            mask_service_unit: "Unitate Aer mobil",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Transportor blindat pentru personal",
            mzb: "Vas multifuncțional",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulanță",
            oil_unit: "Vehicul-colectare ulei",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Mașină de patrulare",
            polizeihubschrauber: "Elicopter de poliție",
            rescue_vehicle: "Vehicul greu de salvare",
            rescue_vehicle_only: "Doar vehicol de salvare",
            rescueboat: "Barcă de salvare mare",
            rettungstreppe: "",
            rth_only: "Elicopter SMURD",
            schlauchwagen: "Cisternă de apă",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SIAS",
            swat_armored_vehicle: "Vehicul blindat SIAS",
            swat_suv: "SUV SIAS",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Transportor blindat pentru personalul tehnic (TBPT - ANAT)",
            thw_mzkw: "Vehicul multifuncțional",
            thw_tauchkraftwagen: "Echipa de scafandri",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Camion cisternă",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Camioane cu platformă",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "În al doilea rând, noua ta stație va avea nevoie de un nume! Ar fi bine ca acesta să fie ușor de recunoscut și numerotat! Exemplu: „Stația de pompieri #0001”. După ce termini, apasă pe „Următorul”!",
                        build_with_credits: "Acum construiește-ți clădirea folosind credite!",
                        new_building: "Dă clic pe „Clădire nouă”!",
                        select_building: "Alege în primul rând tipul de clădire cu care dorești să începi - îți sugerăm să începi cu pompierii! În orice caz, se recomandă să începi cu o stație mică!",
                        select_position: "Mută marcatorul albastru acolo unde dorești să construiești prima ta stație!"
                    },
                    pick_location: "Mai întâi, alege o locație în care să începi! Introdu numele locației de pornire în bara de căutare sau caut-o chiar tu pe hartă! Ce zici de orașul tău natal?",
                    welcome: "Salut. Bine ai venit în Dispecerat 112!  Îți voi arăta câteva lucruri care te vor ajuta să-ți începi cu dreptul cariera în domeniul serviciilor de urgență!"
                },
                mobile: {
                    build_building: {
                        add_name: "În al doilea rând, noua ta stație va avea nevoie de un nume! Ar fi bine ca acesta să fie ușor de recunoscut și numerotat! Exemplu: „Stația de pompieri #0001”. După ce termini, apasă pe „Următorul”!",
                        build_with_credits: "Acum construiește-ți clădirea folosind credite!",
                        new_building: "Mai întâi, vom alege o locație pentru a începe și construi prima ta clădire! <br /> <br />Pentru asta, dă clic pe „Clădire nouă”!",
                        select_building: "Alege în primul rând tipul de clădire cu care dorești să începi - îți sugerăm să începi cu pompierii! În orice caz, se recomandă să începi cu o stație mică!"
                    },
                    welcome: "Salut. Bine ai venit în Dispecerat 112!  Îți voi arăta câteva lucruri care te vor ajuta să-ți începi cu dreptul cariera în domeniul serviciilor de urgență!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Acesta este meniul de trimitere. De aici, îți trimiți unitățile în misiuni!",
                        dispatch_menu_buttons: "Acestea sunt cele două butoane de trimitere! Primul: „Trimite” - trimite unitățile selectate în misiune. Cel de-al doilea face același lucru, însă trecând la următoarea misiune. Deocamdată, dă clic pe primul buton.",
                        dispatch_menu_mission_general: "Aici poți vedea informațiile generale despre misiune, adică numele, adresa și pictograma acesteia. În misiunile la care ai participat deja, mini-pictograma cu omulețul apare și înlocuiește o stea mică.",
                        dispatch_menu_mission_progress: "Aici poți vedea progresul făcut în cadrul acestei misiuni, efectivele prezente la fața locului și timpul rămas pentru a îndeplini misiunea!",
                        dispatch_menu_mission_specific: "Aici poți vedea mai multe informații despre misiune, ce unități răspund la apel și care sunt deja la fața locului.",
                        dispatch_menu_vehicle_list: "Aceasta este lista vehiculelor disponibile. Aici, selectezi vehiculele. Acum dă clic pe un vehicul pentru a-l selecta!"
                    },
                    mobile: {
                        dispatch_menu: "Acesta este meniul de trimitere. De aici, îți trimiți unitățile în misiuni!",
                        dispatch_menu_buttons: "Acestea sunt cele două butoane de trimitere! Primul: „Trimite” - trimite unitățile selectate în misiune. Cel de-al doilea face același lucru, însă trecând la următoarea misiune. Deocamdată, dă clic pe primul buton.",
                        dispatch_menu_mission_general: "Aici poți vedea informațiile generale despre misiune, adică numele, adresa și pictograma acesteia. În misiunile la care ai participat deja, mini-pictograma cu omulețul apare și înlocuiește o stea mică.",
                        dispatch_menu_mission_progress: "Aici poți vedea progresul făcut în cadrul acestei misiuni, efectivele prezente la fața locului și timpul rămas pentru a îndeplini misiunea!",
                        dispatch_menu_mission_specific: "Aici poți vedea mai multe informații despre misiune, ce unități răspund la apel și care sunt deja la fața locului.",
                        dispatch_menu_vehicle_list: "Aceasta este lista vehiculelor disponibile. Aici, selectezi vehiculele. Acum dă clic pe un vehicul pentru a-l selecta!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Acum dorim să aflăm cum să abordăm incidentele. Deschide meniul de trimitere dând clic pe butonul „trimite”!",
                        first_mission: "Grozav, ai construit prima ta clădire! Vezi, primele misiuni ți-au fost semnalate!"
                    },
                    mobile: {
                        dispatch_button: "Acum dorim să aflăm cum să abordăm incidentele. Deschide meniul de trimitere dând clic pe butonul „trimite”!",
                        first_mission: "Grozav, ai construit prima ta clădire! Vezi, primele misiuni ți-au fost semnalate!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Grozav, ești pe cale să devii un Șef de Dispecerat extraordinar! Poftim %{coins} monede. Acestea te vor ajuta să începi cu dreptul! </br> Echipa ta Dispecerat 112"
                },
                mobile: {
                    general: "Grozav, ești pe cale să devii un Șef de Dispecerat extraordinar! Poftim %{coins} monede. Acestea te vor ajuta să începi cu dreptul! </br> Echipa ta Dispecerat 112"
                }
            },
            tips: {
                browser: {
                    contact: "Dacă ai întrebări, poți consulta secțiunea Întrebări Frecvente în cadrul jocului. De asemenea, poți vizita forumurile jocului sau pagina noastră de Facebook!",
                    general: "În continuare, te sfătuim să construiești un dispecerat, iar apoi câteva stații noi. Ar fi bine să faci acest lucru cât mai curând posibil, deoarece numărul maxim de misiuni este echivalent cu cel mai înalt număr de stații de un alt tip (poliție, pompieri, ambulanță) + 1. Spre exemplu: 5 stații de pompieri și 3 de ambulanță = 6 misiuni.",
                    join_alliance: "În plus, aderarea la o alianță te-ar ajuta foarte mult, mai ales la început - așa că îți sugerăm să faci și acest pas.",
                    summary: "Acestea sunt regulile de bază ale jocului Dispecerat 112! Îndeplinește misiuni, obține credite, cumpără mai multe unități, repetă. Distracție plăcută! </br> Echipa ta Dispecerat 112"
                },
                mobile: {
                    contact: "Dacă ai întrebări, poți consulta secțiunea Întrebări Frecvente în cadrul jocului. De asemenea, poți vizita forumurile jocului sau pagina noastră de Facebook!",
                    general: "În continuare, te sfătuim să construiești un dispecerat, iar apoi câteva stații noi. Ar fi bine să faci acest lucru cât mai curând posibil, deoarece numărul maxim de misiuni este echivalent cu cel mai înalt număr de stații de un alt tip (poliție, pompieri, ambulanță) + 1. Spre exemplu: 5 stații de pompieri și 3 de ambulanță = 6 misiuni.",
                    join_alliance: "În plus, aderarea la o alianță te-ar ajuta foarte mult, mai ales la început - așa că îți sugerăm să faci și acest pas.",
                    summary: "Acestea sunt regulile de bază ale jocului Dispecerat 112! Îndeplinește misiuni, obține credite, cumpără mai multe unități, repetă. Distracție plăcută! </br> Echipa ta Dispecerat 112"
                }
            }
        },
        commons: {
            collect: "Colectează",
            "continue": "Nu",
            end: "Sfârșit",
            next: "Urm.",
            prev: "Ant.",
            skip: "Da",
            skip_hint: "Ești sigur că vrei să anulezi tutorialul? Acesta nu poate fi accesat mai târziu. Nu vei fi eligibil pentru recompensa de finalizare a tutorialului."
        },
        rewards: {
            log: "Recompensă pentru terminarea tutorialului."
        }
    }
}, I18n.translations.fi_FI = {
    common: {
        add: "Lisää",
        back: "Palaa",
        cancel: "Peruuta",
        change_saved: "Muutokset tallennettu",
        coins_spend: "Haluatko varmasti käyttää nämä kolikot?",
        congratulations: "Onnittelut!",
        content: "Sisältö",
        copy: "Kopioi",
        credits: "Krediittiä",
        "delete": "Poista",
        details: "Lisätiedot",
        edit: "Muokkaa",
        error: "Virhe",
        is_offline: "%{user} ei ole verkossa",
        is_offline_long: "Kauan: %{user} ei ole verkossa",
        is_offline_with_duration: "%{user} ei ole verkossa: %{duration}",
        is_online: "%{user} on verkossa.",
        loading: "Ladataan...",
        name: "Nimi",
        none: "Ei mitään",
        of: "/",
        off: "Ei käytössä",
        on: "Käytössä",
        save: "Tallenna",
        search: "Haku",
        show: "Näytä",
        user_not_found: "Käyttäjää ei löytynyt",
        wrong_key: "Väärä avain"
    },
    javascript: {
        alarm: "Lähetä",
        arrival: "Saapumisaika",
        backalarm: "Peruuta",
        coins: "Kolikot",
        credits: "Krediitit",
        days: "päivää",
        few_seconds: "muutaman sekunnin kuluttua",
        finish_in: "Päättymiseen:",
        hours: "h",
        location_not_found: "Ei löytynyt",
        messages: "Viestit",
        minutes: "min",
        missed_vehicle: "Puuttuu:",
        mission_start_in: "Alkamiseen:",
        "new": "Uusi",
        not_found_map: "Ajoneuvoa ei löytynyt kartalta.",
        now: "Nyt",
        patient: "Potilas",
        patient_untouched: "Hoitamattomat potilaat",
        poi_delete: 'Haluatko varmasti poistaa kohdepisteen "%{caption}"?',
        reload: "Lataa uudelleen",
        sale: "Ale",
        sale_ended: "Ale päättynyt",
        secounds: "s",
        sicherheitswache_error: 'Turvaamistehtävä "%{caption}" ei onnistunut, koska kaikki ehdot eivät täyttyneet.',
        sicherheitswache_success: 'Turvaamistehtävän "%{caption}" suoritus onnistui. Saat %{credits} krediittiä.',
        start_in: "Alkamiseen: ",
        start_username: "Aloittaja:",
        time_left: "Aikaa jäljellä:",
        to_building: "Näytä rakennus",
        to_mission: "Näytä tehtävä",
        understand: "Kuittaa",
        user_not_found: "Pelaajaa ei löytynyt.",
        vehicles_not_visible: "Ajoneuvoja ei näytetä. "
    },
    map: {
        alliance: "Liittoutuma",
        alliance_chat: "Chatti",
        alliance_chat_banned: "Sinut on tällä hetkellä estetty liittoutuman chatista.",
        alliance_chat_banned_admin: "Estäjä:",
        alliance_chat_banned_timeleft: "Jäljellä oleva aika:",
        alliance_chat_radio_off: "Liittoutuman radio: Ei käytössä",
        alliance_chat_radio_on: "Liittoutuman radio: Käytössä",
        alliance_event: "Tapahtuma",
        alliance_missions: "Liittoutuman tehtävät",
        alliance_missions_event: "Tapahtuma",
        ambulance: "Ambulanssi",
        attended: "Hoidettu",
        cancel_alliance_event: "Peruuta liittoumatapahtuma",
        cancel_alliance_event_confirm: "Haluatko varmasti peruuttaa liittoumatapahtuman?",
        challenges: "",
        chat_history: "Chattihistoria",
        congratulations: "Onnittelut! Voit nyt saada ylennyksen.",
        create_alliance_event: "Aloita liittoutumatapahtuma",
        create_alliance_operation: "Luo laaja liittoutumatehtävä",
        emergency: "Hätätilanne",
        finishing: "Päättymässä",
        join_alliance_infos: "Jos kuulut johonkin liittoutumaan, muut pelaajat voivat antaa sinulle tehtäviä.",
        map: "Kartta",
        map_filters: {
            all_buildings: "Rakennukset",
            all_missions: "Tehtävät",
            alliance_buildings: "Liittoutumarakennukset",
            alliance_members: "Jäsenet",
            alliance_missions: "Liittoutuman jakama",
            ambulance_station_missions: "Ambulanssiasema",
            ambulance_station_small_missions: "Ambulanssiasema (pieni asema)",
            building_complex: "Rakennuskompleksi",
            buildings_section: "Asemat",
            clinic_missions: "Klinikka",
            dispatch_center_missions: "Hätäkeskus",
            fire_school_missions: "Pelastajaoppilaitos",
            firehouse_missions: "Paloasema",
            firehouse_small_missions: "Paloasema (pieni)",
            hospital_missions: "Sairaala",
            map_filters: "Karttasuodatinlista",
            mission_positions: "Kohdepisteet",
            mission_positions_section: "Kohdepisteet",
            missions_section: "Tehtävät",
            police_copter_station_missions: "Poliisihelikopteritukikohta",
            police_school_missions: "Poliisiammattikorkeakoulu",
            police_small_missions: "Poliisiasema (pieni asema)",
            police_special_forces: "Poliisin erikoisjoukot",
            police_station_missions: "Poliisiasema",
            prison_missions: "Vankila",
            rapid_deployment_group: "Ensivasteyksikkö",
            rescue_copter_station_missions: "Lääkintähelikopteriasema",
            riot_police: "Mellakkapoliisi",
            riot_police_missions: "Mellakkapoliisi",
            staging_area_missions: "Kokoontumispaikka",
            technical_aid_organization: "VPK",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Omat rakennukset",
            user_missions: "Omat tehtävät",
            water_watch: "Vesipelastus",
            water_watch_missions: "Vesipelastus"
        },
        message: "Viesti",
        mission: "Tehtävä",
        missions_filtered_out: "Jotkut tehtävät voidaan suodattaa pois. Tarkista karttasuodattimet.",
        no_alliance_chat_impossible: "Et kuulu mihinkään liittoutumaan.",
        no_alliance_missions: "Ei liittoutumatehtäviä",
        no_ambulance_missions: "Ei ambulanssitehtäviä Ambulanssitehtäviä syntyy vain kun sinulla on ambulanssi ja sairaala.",
        no_emergency_missions: "Ei hätätehtäviä Hätätehtäviä syntyy, kun olet rakentanut ensimmäisen asemasi.",
        no_radio_messages: "Et ole saanut radioviestejä.",
        radio_messages: "Radio",
        restore_map: "Palauta kartta",
        server_warning: "Palvelinhuolto alkaa 01:00, palvelukatkon arvioitu kesto noin 6 tuntia",
        show_informations: "Vihreä = tehtävät näkyvät luettelossa. Punainen = tehtävät eivät näy.",
        sicherheitswache: "Suunnitellut tehtävät",
        transport: "Kuljetus",
        unattended: "Ei hoidettu"
    },
    fms: {
        going: "Matkalla",
        not_ready: "Ei toiminnassa",
        on_destination: "Kuljetuksen määränpäässä",
        on_place: "Tapahtumapaikalla",
        patient_transported: "Kuljettaa potilasta",
        prisoner_transported: "Kuljettaa vankia",
        ready_home: "Käytettävissä asemalla",
        ready_traveling: "Vapaana",
        talking_wish: "Kuljetuspyyntö",
        waiting_for_vehicle: "Odottaa vetoautoa"
    },
    intervention_order: {
        back: "Palaa",
        category: "Luokka",
        colour: "Väri",
        column: "Sarake",
        column_number: "Sarakkeen numero",
        column_number_hint: "Jos sarakkeen numero on annettu, hälytysjärjestelymerkintä näkyy hälytyssivun vastaavassa sarakkeessa.",
        create_intervention_order: "Luo uusi hälytysjärjestely",
        "delete": "Poista",
        delete_all: "Poista hälytysjärjestely kokonaan",
        delete_all_confirm: "Haluatko varmasti poistaa koko hälytysjärjestelyn? Vietyjä merkintöjä ei voi enää käyttää.",
        description: "Nimi",
        edit: "Muokkaa",
        "export": {
            "export": "Vie",
            "import": "Tuo",
            import_done: "Valitut merkinnät on tuotu ja kirjoitettu hälytysjärjestelyyn.",
            saved: "Hälytysjärjestely viety",
            saved_text: "Hälytysjärjestely on valmis vientiä varten. Toinen pelaaja voi tuoda hälytysjärjestelyn linkin kautta. Jos muutat hälytysjärjestelyä tällä välin, muutos vaikuttaa myös vientiin."
        },
        hotkey_hint: "Valitse pikanäppäin tämän ajoneuvon valintaa varten. Valitse ajoneuvo painamalla tehtäväikkunassa: ALT + pikanäppäin (Firefox: ALT + VAIHTO + pikanäppäin; mac os: ctrl + alt + pikanäppäin).",
        intervention_order: "Muokkaa hälytysjärjestelyä",
        name: "Nimi",
        no_intervention_created: "Et ole vielä luonut yhtään hälytysjärjestelyä.",
        options: "Asetukset",
        reset: "Nollaa aiempi valinta hälytysikkunassa.",
        reset_hint: "Jos olet valinnut ajoneuvon lähetysikkunassa, voit nollata valinnan tällä painikkeella.",
        save: "Tallenna",
        station: "Asema",
        station_hint: "Kun rakennus valitaan, vain kyseisen rakennuksen ajoneuvot valitaan.",
        successfully_created: "Hälytysjärjestelyn luonti onnistui.",
        successfully_deleted: "Hälytysjärjestely poistettu",
        successfully_updated: "Hälytysjärjestelyn päivitys onnistui.",
        vehicles: {
            ab_atemschutz_only: "Paineilmahuoltokontti",
            ab_einsatzleitung_only: "Johtomoduuli",
            ab_gefahrgut_only: "Kemikaalitorjuntamoduuli",
            ab_oel_only: "Öljyvahinkomoduuli",
            ab_ruest: "Tekniikka-/pelastusmoduuli",
            ab_ruest_rw: "",
            abl2wasser_only: "Letkumoduuli",
            ambulance: "Hoitotason ambulanssi",
            ambulance_or_rapid_responder: "",
            arff: "Lentokenttäpaloauto",
            battalion_chief_unit: "Johtoauto",
            boot: "Alukset (yleinen)",
            dekon_p: "",
            division_chief_unit: "Johtokeskusauto",
            dlk_or_tm50: "",
            elw1_or_elw2: "johtoauto, johtokeskusauto tai johtokeskuskontti",
            elw2_or_ab_elw: "",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Ambulanssi tai Helikopteri",
            fire_truck: "Paloautot",
            fireboat: "Iso sammutusalus",
            fly_car: "Ensivasteauto",
            fly_car_any: "EVA-yksikkö, EVY-yksikkö tai Ensihoidon lääkäri",
            fukw: "",
            fustw_or_police_motorcycle: "Partioauto tai Poliisimoottoripyörä",
            fwk: "",
            gefkw: "",
            gkw: "Kalustoauto",
            grtw: "Suuronnettomuusyksikkö",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "Kemikaalitorjunta",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Vesipelastus",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Letkuauto",
            hems: "Lääkärihelikopteri (HEMS)",
            hlf_only: "Pelastusauto",
            hlf_or_rw_and_lf: "Pelastusauto tai Raskas pelastusauto ja Sammutusauto",
            hondengeleider: "",
            k9: "Koirayksikkö",
            kdow_lna: "",
            kdow_orgl: "Ensihoidon kenttäjohtaja",
            kdow_orgl_any: "Ensihoidon kenttäjohtaja",
            ktw_b: "",
            ktw_or_rtw: "",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Paloautot",
            long_distance_ambulance: "Perustason ambulanssi",
            mask_service_unit: "Paineilmalaiteyksikkö",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Miehistönkuljetusauto",
            mzb: "Monitoimialus",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Ambulanssi",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Partioauto",
            police_motorcycle: "Poliisimoottoripyörä",
            polizeihubschrauber: "Poliisihelikopteri",
            rescue_vehicle: "Raskas pelastusauto",
            rescue_vehicle_only: "Raskas pelastus",
            rescueboat: "Iso pelastusalus",
            rettungstreppe: "",
            rth_only: "Lääkärihelikopteri (HEMS)",
            schlauchwagen: "Säiliöauto",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "VATI",
            swat_armored_vehicle: "VATI miehistönkuljetusajoneuvo",
            swat_suv: "VATI-partio",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Sukellusryhmä",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Säiliöauto",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "Nostolava-autot",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Anna seuraavaksi asemalle nimi! Tee siitä helposti tunnistettava ja skaalautuva. Esim. ”Paloasema 0001”. Kun olet valmis, valitse Seuraava.",
                        build_with_credits: "Rakenna rakennus krediiteillä!",
                        new_building: "Napsauta Uusi rakennus -kohtaa!",
                        select_building: "Valitse ensin rakennuksen tyyppi. Suosittelen aloittamaan paloasemalla! Joka tapauksessa on parasta aloittaa pienellä asemalla.",
                        select_position: "Siirrä sininen merkki siihen kohtaan, johon haluat rakentaa ensimmäisen aseman."
                    },
                    pick_location: "Aloita valitsemalla sijainti. Kirjoita haluamasi paikan nimi hakukenttään tai etsi se itse kartalta. Miten olisi kotipaikkakuntasi?",
                    welcome: "Moi! Tervetuloa Hätäkeskuspeliin!  Annan sinulle joitakin ohjeita, jotta pääset hyvin alkuun hätäkeskustyössäsi."
                },
                mobile: {
                    build_building: {
                        add_name: "Anna seuraavaksi asemalle nimi! Tee siitä helposti tunnistettava ja skaalautuva. Esim. ”Paloasema 0001”. Kun olet valmis, valitse Seuraava.",
                        build_with_credits: "Rakenna rakennus krediiteillä!",
                        new_building: "Ensin valitaan aloitussijainti ja rakennetaan ensimmäinen rakennus. <br /> <br /> Tee niin napsauttamalla Uusi rakennus -kohtaa!",
                        select_building: "Valitse ensin rakennuksen tyyppi. Suosittelen aloittamaan paloasemalla! Joka tapauksessa on parasta aloittaa pienellä asemalla."
                    },
                    welcome: "Moi! Tervetuloa Hätäkeskuspeliin!  Annan sinulle joitakin ohjeita, jotta pääset hyvin alkuun hätäkeskustyössäsi."
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Tämä on lähetysvalikko. Täältä voit lähettää yksiköitä tehtäviin.",
                        dispatch_menu_buttons: "Nämä kaksi ovat molemmat lähetyspainikkeita! Ensimmäinen: ”Lähetä” lähettää valitut yksiköt tehtävään. Toinen toimii samalla tavalla, mutta siirtyy seuraavaan tehtävään. Napsauta nyt ensimmäistä painiketta.",
                        dispatch_menu_mission_general: "Tässä näkyvät tehtävän yleistiedot, eli sen nimen, osoitteen ja kuvakkeen. Pieni ihmiskuvake korvaa tähtikuvakkeen niissä tehtävissä, joihin olet jo osallistunut.",
                        dispatch_menu_mission_progress: "Tässä näkyy, miten tehtävien käsittely on edistynyt, sekä paikalla olevan henkilöstön määrän ja tehtävän jäljellä olevan käsittelyajan.",
                        dispatch_menu_mission_specific: "Tässä näkyvät tehtävän lisätiedot, kutsuun vastaavat yksiköt ja paikalla jo olevat yksiköt.",
                        dispatch_menu_vehicle_list: "Tässä näkyy käytettävissä olevien ajoneuvojen lista. Tässä valitset ajoneuvot. Valitse ajoneuvo napsauttamalla sitä."
                    },
                    mobile: {
                        dispatch_menu: "Tämä on lähetysvalikko. Täältä voit lähettää yksiköitä tehtäviin.",
                        dispatch_menu_buttons: "Nämä kaksi ovat molemmat lähetyspainikkeita! Ensimmäinen: ”Lähetä” lähettää valitut yksiköt tehtävään. Toinen toimii samalla tavalla, mutta siirtyy seuraavaan tehtävään. Napsauta nyt ensimmäistä painiketta.",
                        dispatch_menu_mission_general: "Tässä näkyvät tehtävän yleistiedot, eli sen nimen, osoitteen ja kuvakkeen. Pieni ihmiskuvake korvaa tähtikuvakkeen niissä tehtävissä, joihin olet jo osallistunut.",
                        dispatch_menu_mission_progress: "Tässä näkyy, miten tehtävien käsittely on edistynyt, sekä paikalla olevan henkilöstön määrän ja tehtävän jäljellä olevan käsittelyajan.",
                        dispatch_menu_mission_specific: "Tässä näkyvät tehtävän lisätiedot, kutsuun vastaavat yksiköt ja paikalla jo olevat yksiköt.",
                        dispatch_menu_vehicle_list: "Tässä näkyy käytettävissä olevien ajoneuvojen lista. Tässä valitset ajoneuvot. Valitse ajoneuvo napsauttamalla sitä."
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Nyt on aika oppia, miten tapauksia käsitellään. Avaa lähetysvalikko napsauttamalla Lähetä-painiketta.",
                        first_mission: "Hienoa, ensimmäinen rakennus on valmis! Katso, olet saanut ilmoituksen ensimmäisistä tehtävistä!"
                    },
                    mobile: {
                        dispatch_button: "Nyt on aika oppia, miten tapauksia käsitellään. Avaa lähetysvalikko napsauttamalla Lähetä-painiketta.",
                        first_mission: "Hienoa, ensimmäinen rakennus on valmis! Katso, olet saanut ilmoituksen ensimmäisistä tehtävistä!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Hienoa, sinusta on jo tulossa erinomainen hätäkeskusjohtaja! Tässä %{coins} kolikkoa, jotta pääset alkuun! </br> Hätäkeskuspelin tiimi"
                },
                mobile: {
                    general: "Hienoa, sinusta on jo tulossa erinomainen hätäkeskusjohtaja! Tässä %{coins} kolikkoa, jotta pääset alkuun! </br> Hätäkeskuspelin tiimi"
                }
            },
            tips: {
                browser: {
                    contact: "Jos sinulla on kysyttävää, voit tutustua pelin UKK-sivuun tai käydä pelin keskustelupalstalla tai Facebook-sivullamme.",
                    general: "Seuraavaksi suosittelen rakentamaan hätäkeskuksen ja sitten mahdollisimman pian uusia asemia, sillä tehtävien enimmäismäärä on sama kuin erityyppisten asemien (poliisiasema, paloasema, ambulanssiasema) enimmäismäärä plus 1, eli 5 palo- ja 3 ambulanssiasemaa = 6 tehtävää.",
                    join_alliance: "Myös liittoutumaan liittyminen on hyödyksi erityisesti alussa, joten sekin on suositeltavaa.",
                    summary: "Tässä olivat Hätäkeskuspelin perusteet! Suorita tehtäviä, kerää krediittejä, osta uusia yksiköitä, toista. Hauskaa pelaamista! </br> Hätäkeskuspelin tiimi"
                },
                mobile: {
                    contact: "Jos sinulla on kysyttävää, voit tutustua pelin UKK-sivuun tai käydä pelin keskustelupalstalla tai Facebook-sivullamme.",
                    general: "Seuraavaksi suosittelen rakentamaan hätäkeskuksen ja sitten mahdollisimman pian uusia asemia, sillä tehtävien enimmäismäärä on sama kuin erityyppisten asemien (poliisiasema, paloasema, ambulanssiasema) enimmäismäärä plus 1, eli 5 palo- ja 3 ambulanssiasemaa = 6 tehtävää.",
                    join_alliance: "Myös liittoutumaan liittyminen on hyödyksi erityisesti alussa, joten sekin on suositeltavaa.",
                    summary: "Tässä olivat Hätäkeskuspelin perusteet! Suorita tehtäviä, kerää krediittejä, osta uusia yksiköitä, toista. Hauskaa pelaamista! </br> Hätäkeskuspelin tiimi"
                }
            }
        },
        commons: {
            collect: "Kerää",
            "continue": "Ei",
            end: "Loppu",
            next: "Seur.",
            prev: "Edell.",
            skip: "Kyllä",
            skip_hint: "Haluatko varmasti peruuttaa opetuspelin? Siihen ei voi palata myöhemmin. Et saa opetuspelin suorituspalkintoa."
        },
        rewards: {
            log: "Palkinto opetuspelin pelaamisesta loppuun."
        }
    },
    policechief: {
        tutorial: {
            beginner: {
                building: {
                    browser: {
                        build_building: {
                            add_name: "Anna seuraavaksi asemalle nimi! Tee siitä helposti tunnistettava ja skaalautuva. Esim. ”Poliisiasema 0001”. Kun olet valmis, valitse Seuraava.",
                            select_building: "Valitse ensin rakennuksen tyyppi. Suosittelen aloittamaan poliisiasemalla! Joka tapauksessa on parasta aloittaa pienellä asemalla."
                        },
                        welcome: "Moi! Tervetuloa Hätäkeskuspeliin Poliisi!  Annan sinulle joitakin ohjeita, jotta pääset hyvin alkuun hätäkeskustyössäsi."
                    },
                    mobile: {
                        build_building: {
                            add_name: "Anna seuraavaksi asemalle nimi! Tee siitä helposti tunnistettava ja skaalautuva. Esim. ”Poliisiasema 0001”. Kun olet valmis, valitse Seuraava.",
                            select_building: "Valitse ensin rakennuksen tyyppi. Suosittelen aloittamaan poliisiasemalla! Joka tapauksessa on parasta aloittaa pienellä asemalla."
                        },
                        welcome: "Moi! Tervetuloa Hätäkeskuspeliin Poliisi!  Annan sinulle joitakin ohjeita, jotta pääset hyvin alkuun hätäkeskustyössäsi."
                    }
                },
                rewards: {
                    browser: {
                        general: "Hienoa, sinusta on jo tulossa erinomainen hätäkeskusjohtaja! Tässä %{coins} kolikkoa, jotta pääset alkuun! </br> Hätäkeskuspelin Polisii tiimi"
                    },
                    mobile: {
                        general: "Hienoa, sinusta on jo tulossa erinomainen hätäkeskusjohtaja! Tässä %{coins} kolikkoa, jotta pääset alkuun! </br> Hätäkeskuspelin Polisii tiimi"
                    }
                },
                tips: {
                    browser: {
                        summary: "Tässä olivat Hätäkeskuspelin Poliisi perusteet! Suorita tehtäviä, kerää krediittejä, osta uusia yksiköitä, toista. Hauskaa pelaamista! </br> Hätäkeskuspelin Poliisi tiimi"
                    },
                    mobile: {
                        summary: "Tässä olivat Hätäkeskuspelin Poliisi perusteet! Suorita tehtäviä, kerää krediittejä, osta uusia yksiköitä, toista. Hauskaa pelaamista! </br> Hätäkeskuspelin Poliisi tiimi"
                    }
                }
            }
        }
    }
}, I18n.translations.sk_SK = {
    common: {
        add: "Pridať",
        back: "Späť",
        cancel: "Zrušiť",
        change_saved: "Zmeny uložené",
        coins_spend: "Naozaj chcete minúť tieto mince?",
        congratulations: "Gratulujeme!",
        content: "Obsah",
        copy: "Kopírovať",
        credits: "Kredity",
        "delete": "Vymazať",
        details: "Podrobnosti",
        edit: "Upraviť",
        error: "Chyba",
        is_offline: "%{user} je offline.",
        is_offline_long: "Dlho: %{user} je offline",
        is_offline_with_duration: "%{user} je offline: %{duration}",
        is_online: "%{user} je online.",
        loading: "Načítava sa...",
        name: "Názov",
        none: "Žiadne",
        of: "z",
        off: "Vyp.",
        on: "Zap.",
        save: "Uložiť",
        search: "Vyhľadať",
        show: "Zobraziť",
        user_not_found: "Používateľ sa nenašiel",
        wrong_key: "Nesprávny kľúč"
    },
    javascript: {
        alarm: "Vyslať",
        arrival: "Príchod",
        backalarm: "Zrušiť",
        coins: "Mince",
        credits: "Kredity",
        days: "dní",
        few_seconds: "o niekoľko sekúnd",
        finish_in: "Koniec:",
        hours: "H",
        location_not_found: "Nenašlo sa",
        messages: "Správy",
        minutes: "min.",
        missed_vehicle: "Chýba:",
        mission_start_in: "Začiatok:",
        "new": "Nový",
        not_found_map: "Vozidlo sa nenašlo na mape",
        now: "Teraz",
        patient: "Pacient",
        patient_untouched: "Neliečení pacienti",
        poi_delete: "Naozaj chcete vymazať POI: %{caption}?",
        reload: "Znovu načítať",
        sale: "Predať",
        sale_ended: "Predaj ukončený",
        secounds: "sek.",
        sicherheitswache_error: 'Ochrana "%{caption}" nebola úspešná, pretože neboli splnené všetky kritériá.',
        sicherheitswache_success: 'Ochrana "%{caption}" prebehla úspešne. Získaj %{credits} kreditov.',
        start_in: "Začiatok: ",
        start_username: "Štartér:",
        time_left: "Zostávajúci čas:",
        to_building: "Zobraziť budovu",
        to_mission: "Zobraziť misiu",
        understand: "Potvrdiť príjem",
        user_not_found: "Hráč sa nenašiel.",
        vehicles_not_visible: "Vozidlo nie je viditeľné. "
    },
    map: {
        alliance: "Aliancia",
        alliance_chat: "Chat",
        alliance_chat_banned: "Momentálne máte zakázaný aliančný chat.",
        alliance_chat_banned_admin: "Zákaz od:",
        alliance_chat_banned_timeleft: "Zostávajúci čas:",
        alliance_chat_radio_off: "Aliančná vysielačka: Vyp.",
        alliance_chat_radio_on: "Aliančná vysielačka: Zap.",
        alliance_event: "Udalosť",
        alliance_missions: "Misie aliancie",
        alliance_missions_event: "Udalosť",
        ambulance: "Sanitné vozidlo",
        attended: "Riešené",
        cancel_alliance_event: "Zrušiť udalosť aliancie",
        cancel_alliance_event_confirm: "Naozaj chcete zrušiť udalosť aliancie?",
        challenges: "",
        chat_history: "História chatu",
        congratulations: "Gratulujeme! Teraz môžete byť povýšený.",
        create_alliance_event: "Spustiť udalosť aliancie",
        create_alliance_operation: "Vytvorte rozsiahlu aliančnú misiu",
        emergency: "Mimoriadna udalosť",
        finishing: "Prebieha dokončovanie",
        join_alliance_infos: "Ak ste v aliancii, ostatní hráči vám môžu zadarmo dávať misie.",
        map: "Mapa",
        map_filters: {
            all_buildings: "Budovy",
            all_missions: "Misie",
            alliance_buildings: "Aliančné budovy",
            alliance_members: "Členovia",
            alliance_missions: "Zdieľané alianciou",
            ambulance_station_missions: "Stanica ZZS",
            ambulance_station_small_missions: "Stanica ZZS (malá stanica)",
            building_complex: "Výjazdové centrum",
            buildings_section: "Stanice",
            clinic_missions: "Klinika",
            dispatch_center_missions: "Dispečerské centrum",
            fire_school_missions: "Hasičská akadémia",
            firehouse_missions: "Hasiči",
            firehouse_small_missions: "Hasiči (malá)",
            hospital_missions: "Nemocnica",
            map_filters: "Zoznam filtrov mapy",
            mission_positions: "Body záujmu (POI)",
            mission_positions_section: "POI",
            missions_section: "Misie",
            police_copter_station_missions: "Policajné letectvo",
            police_school_missions: "Policajná akadémia",
            police_small_missions: "Policajná stanica (malá stanica)",
            police_special_forces: "Policajné špeciálne jednotky",
            police_station_missions: "Policajná stanica",
            prison_missions: "Väzenie",
            rapid_deployment_group: "Skupina rýchleho nasadenia (SEG)",
            rescue_copter_station_missions: "Stanica VZZS",
            riot_police: "Poriadková polícia",
            riot_police_missions: "Poriadková polícia",
            staging_area_missions: "Skúšobná oblasť",
            technical_aid_organization: "Organizácia technickej pomoci",
            technical_aid_organization_school: "THW Bundesschule",
            user_buildings: "Moje budovy",
            user_missions: "Moje misie",
            water_watch: "Vodná záchranná služba",
            water_watch_missions: "Vodná záchranná služba"
        },
        message: "Správa",
        mission: "Misia",
        missions_filtered_out: "Niektoré misie môžu byť odfiltrované. Skontrolujte filtre máp.",
        no_alliance_chat_impossible: "Nie ste v aliancii.",
        no_alliance_missions: "Momentálne nie sú žiadne misie aliancie.",
        no_ambulance_missions: "Zatiaľ nemáte žiadne požiadavky na transport pacienta, objavia sa akonáhle budete vlastniť stanicu ZZS a nemocnicu.",
        no_emergency_missions: "Momentálne nie sú žiadne núdzové misie. Núdzová misia sa môže vyskytnúť iba v prípade, že vybudujete prvú stanicu.",
        no_radio_messages: "Nedostali ste žiadne rádiové správy.",
        radio_messages: "Vysielačka",
        restore_map: "Obnoviť mapu",
        server_warning: "Údržba servera o polnoci. Očakáva sa výpadok 6 hodiny.",
        show_informations: "Zelená = Misie sú zobrazené v zozname. Červená = Misie nie sú zobrazené.",
        sicherheitswache: "Plánované výskyty",
        transport: "Transport",
        unattended: "Neriešené"
    },
    fms: {
        going: "Reagovať",
        not_ready: "Mimo prevádzky",
        on_destination: "V cieli transportu",
        on_place: "Na scéne",
        patient_transported: "Transportovanie pacienta",
        prisoner_transported: "Transportovanie väzňa",
        ready_home: "Dostupné na stanici",
        ready_traveling: "Jasné a dostupné",
        talking_wish: "Požiadavka na transport",
        waiting_for_vehicle: "Čaká vlečné vozidlo"
    },
    intervention_order: {
        back: "Späť",
        category: "Kategória",
        colour: "Farba",
        column: "Stĺpec",
        column_number: "Číslo stĺpca",
        column_number_hint: "Ak je zadané číslo stĺpca, zobrazí sa v príslušnom stĺpci na stránke s upozorneniami položka Alarm a reakcia.",
        create_intervention_order: "Vytvoriť nové riadenie alarmov a reakcií",
        "delete": "Vymazať",
        delete_all: "Úplne vymazať riadenie alarmov a reakcií",
        delete_all_confirm: "Naozaj chcete vymazať celé riadenie alarmov a reakcií? Existujúce exportované položky už nie sú k dispozícii!",
        description: "Názov",
        edit: "Upraviť",
        "export": {
            "export": "Exportovať",
            "import": "Importovať",
            import_done: "Vybrané položky boli importované a zapísané do plánu alarmov a reakcií.",
            saved: "Riadenie alarmov a reakcií sa exportuje",
            saved_text: "Vaše riadenie alarmov a reakcií bolo pripravené na export. Cez odkaz môže iný hráč importovať riadenie alarmov a reakcií. Ak medzitým zmeníte svoje riadenia alarmov a reakcií, aplikuje sa táto zmena automaticky v exporte."
        },
        hotkey_hint: "Vyberte klávesovú skratku na tento výber vozidla. Stlačte pri okne svojej misie: ALT + váš kláves (alebo vo Firefox: ALT + SHIFT + váš kláves alebo v OS Mac: ctrl + alt + váš kláves) a zvoľte svoj výber vozidla.",
        intervention_order: "Upraviť riadenie alarmov a reakcií",
        name: "Názov",
        no_intervention_created: "Ešte ste nevytvorili žiadne riadenie alarmov a reakcií.",
        options: "Možnosti",
        reset: "Resetujte predchádzajúci výber v okne alarmu.",
        reset_hint: "Ak ste vozidlo vybrali v okne dispečingu, môžete toto tlačidlo použiť na resetovanie.",
        save: "Uložiť",
        station: "Stanica",
        station_hint: "Keď je vybraná budova, budú sa dať vybrať iba vozidlá príslušnej budovy.",
        successfully_created: "Riadenie alarmov a reakcií úspešne vytvorené.",
        successfully_deleted: "Riadenie alarmov a reakcií vymazané",
        successfully_updated: "Riadenie alarmov a reakcií úspešne aktualizované.",
        vehicles: {
            ab_atemschutz_only: "Modul SCBA",
            ab_einsatzleitung_only: "Veliteľský modul",
            ab_gefahrgut_only: "Modul nebezpečného materiálu",
            ab_oel_only: "Modul rozliateho oleja",
            ab_ruest: "Modul tech./záchrany",
            ab_ruest_rw: "",
            abl2wasser_only: "Modul hadicového prívodu",
            ambulance: "Sanitné vozidlo",
            ambulance_or_rapid_responder: "",
            arff: "ŠHA (špeciálny hasičský automobil)",
            battalion_chief_unit: "VEA",
            boot: "Člny (všeobecné)",
            dekon_p: "",
            division_chief_unit: "Mobilný veliteľský automobil",
            dlk_or_tm50: "",
            elw1_or_elw2: "Veliteľský automobil, mobilný veliteľský automobil alebo mobilný veliteľský modul ",
            elw2_or_ab_elw: "nula",
            elw3: "",
            elw_airport: "",
            emergency_ambulance: "Sanitné vozidlo alebo vrtuľník VZZS",
            fire_truck: "Hasičské automobily",
            fireboat: "Veľký hasičský čln",
            fly_car: "Rýchle výjazdové vozidlo",
            fly_car_any: "Rýchle výjazdové vozidlo / Lekárske vozidlo",
            fukw: "",
            fwk: "",
            gefkw: "",
            gkw: "Úžitkové vozidlo",
            grtw: "Úrazové oddelenie",
            grtw0: "",
            grtw1: "",
            grukw: "",
            gw_atemschutz_only: "",
            gw_gefahrgut: "EKOA",
            gw_gefahrgut_only: "",
            gw_hoehenrettung: "GW-Höhenrettung",
            gw_messtechnik: "GW-Messtechnik",
            gw_oel_only: "",
            gw_san: "",
            gw_taucher: "",
            gw_wasserrettung: "Vozidlo vodnej záchrany",
            gw_werkfeuerwehr: "",
            gwl2wasser_only: "Automobilová striekačka",
            hems: "Vrtuľník VZZS",
            hlf_only: "nula",
            hlf_or_rw_and_lf: "nula",
            hondengeleider: "",
            k9: "Jednotka K-9",
            kdow_lna: "",
            kdow_orgl: "Veliteľ pohotovostnej lekárskej služby",
            ktw_b: "",
            ktw_or_rtw: "ambulancia DZS alebo RZP",
            lebefkw: "Leichter Befehlskraftwagen (leBefKw)",
            lf_only: "Kombinované hasičské automobily",
            long_distance_ambulance: "Sanitné vozidlo",
            mask_service_unit: "Autonómny dýchací prístroj",
            mek_mtf: "",
            mek_zf: "",
            mtw: "Automobil na prepravu hasičov",
            mzb: "Viacúčelový čln",
            naw: "",
            naw_or_rtw_and_nef: "",
            naw_or_rtw_and_nef_or_rth: "",
            nef_only: "Sanitné vozidlo",
            oil_unit: "GW-Öl",
            only_ab_dekon_p: "",
            only_dekon_p: "",
            ovd_p: "",
            police_car: "Hliadkové vozidlo",
            polizeihubschrauber: "Policajný vrtuľník",
            rescue_vehicle: "AHZS 4",
            rescue_vehicle_only: "AHZS 4",
            rescueboat: "Veľký záchranný čln",
            rettungstreppe: "",
            rth_only: "Vrtuľník VZZS",
            schlauchwagen: "KHA",
            seg_elw: "",
            sek_mtf: "",
            sek_zf: "",
            swat: "SWAT",
            swat_armored_vehicle: "Obrnené vozidlo SWAT",
            swat_suv: "SUV SWAT",
            thw_anh_mzab: "",
            thw_anh_mzb: "",
            thw_anh_schlb: "",
            thw_brmg_r: "",
            thw_dle: "",
            thw_lkw: "",
            thw_lkw_7_lkr_19_tm: "",
            thw_mlw5: "",
            thw_mtw: "Mannschaftstransportwagen Technischer Zug (MTW-TZ - THW)",
            thw_mzkw: "Mehrzweckkraftwagen (MzKW)",
            thw_tauchkraftwagen: "Potápačský tím",
            thw_tauchkraftwagen_or_gw_taucher: "",
            tlf_only: "Kombinovaný hasičský automobil",
            tm50: "",
            turboloescher: "",
            turntable_ladder: "AR",
            ulf: "",
            wasserwerfer: "",
            water_amount: "",
            water_amount_tlf: ""
        }
    },
    tutorial: {
        beginner: {
            building: {
                browser: {
                    build_building: {
                        add_name: "Potom svoju novú stanicu pomenujte! Vyberte názov, ktorý je rozpoznateľný a rozšíriteľný! Napr. „Hasičská stanica č. 0001“. Po dokončení kliknite na „Ďalej“!",
                        build_with_credits: "Teraz postavte svoju budovu pomocou kreditov!",
                        new_building: "Kliknite na možnosť „Nová budova“!",
                        select_building: "Najskôr vyberte typ budovy, s ktorou chcete začať. Veľmi vám odporúčame, aby ste začali s hasičskými službami! V každom prípade vám odporúčame, aby ste začali s malou stanicou!",
                        select_position: "Modrú značku presuňte na miesto, kde chcete postaviť svoju prvú stanicu!"
                    },
                    pick_location: "Najskôr si vyberte miesto, kde začnete! Do vyhľadávacej lišty zadajte názov miesta, kde chcete začať, alebo ho nájdite na mape! A čo tak vaše rodné mesto?",
                    welcome: "Dobrý deň, vitajte v Dispečerskom centre!  Naučím vás niekoľko lekcií, ktoré vám pomôžu na začiatku vašej kariéry v pohotovostných službách!"
                },
                mobile: {
                    build_building: {
                        add_name: "Potom svoju novú stanicu pomenujte! Vyberte názov, ktorý je rozpoznateľný a rozšíriteľný! Napr. „Hasičská stanica č. 0001“. Po dokončení kliknite na „Ďalej“!",
                        build_with_credits: "Teraz postavte svoju budovu pomocou kreditov!",
                        new_building: "Najskôr vyberte miesto, kde začnete a postavte svoju prvú budovu! <br /> <br /> Spravíte to tak, že kliknete na možnosť „Nová budova“!",
                        select_building: "Najskôr vyberte typ budovy, s ktorou chcete začať. Veľmi vám odporúčame, aby ste začali s hasičskými službami! V každom prípade vám odporúčame, aby ste začali s malou stanicou!"
                    },
                    welcome: "Dobrý deň, vitajte v Dispečerskom centre!  Naučím vás niekoľko lekcií, ktoré vám pomôžu na začiatku vašej kariéry v pohotovostných službách!"
                }
            },
            mission: {
                detail: {
                    browser: {
                        dispatch_menu: "Toto je ponuka vysielania. Odtiaľto posielate svoje jednotky na misie!",
                        dispatch_menu_buttons: "Toto sú vaše dve tlačidlá vysielania! Prvé: „Vyslať“ posiela vybrané jednotky na misiu. Druhé má rovnakú funkciu ako to prvé, ale jednotky posiela na ďalšiu misiu. Tentoraz kliknite na prvé tlačidlo.",
                        dispatch_menu_mission_general: "Na tomto mieste nájdete všeobecné informácie o misii, t. j. názov, adresu, ikonu misie. Na misiách, na ktorých ste sa už zúčastnili, sa objaví malá ikona muža a nahrádza hviezdičku.",
                        dispatch_menu_mission_progress: "Na tomto mieste vidíte, aký veľký pokrok ste dosiahli pri riešení tejto misie, ako aj počet zamestnancov na mieste a zostávajúci čas na dokončenie tejto misie!",
                        dispatch_menu_mission_specific: "Na tomto mieste nájdete viac informácií o misii, ktoré jednotky reagujú na hovor a ktoré sú už na mieste.",
                        dispatch_menu_vehicle_list: "Toto je zoznam vašich dostupných vozidiel. Na tomto mieste vyberáte vozidlá. Kliknutím vyberte vozidlo!"
                    },
                    mobile: {
                        dispatch_menu: "Toto je ponuka vysielania. Odtiaľto posielate svoje jednotky na misie!",
                        dispatch_menu_buttons: "Toto sú vaše dve tlačidlá vysielania! Prvé: „Vyslať“ posiela vybrané jednotky na misiu. Druhé má rovnakú funkciu ako to prvé, ale jednotky posiela na ďalšiu misiu. Tentoraz kliknite na prvé tlačidlo.",
                        dispatch_menu_mission_general: "Na tomto mieste nájdete všeobecné informácie o misii, t. j. názov, adresu, ikonu misie. Na misiách, na ktorých ste sa už zúčastnili, sa objaví malá ikona muža a nahrádza hviezdičku.",
                        dispatch_menu_mission_progress: "Na tomto mieste vidíte, aký veľký pokrok ste dosiahli pri riešení tejto misie, ako aj počet zamestnancov na mieste a zostávajúci čas na dokončenie tejto misie!",
                        dispatch_menu_mission_specific: "Na tomto mieste nájdete viac informácií o misii, ktoré jednotky reagujú na hovor a ktoré sú už na mieste.",
                        dispatch_menu_vehicle_list: "Toto je zoznam vašich dostupných vozidiel. Na tomto mieste vyberáte vozidlá. Kliknutím vyberte vozidlo!"
                    }
                },
                overview: {
                    browser: {
                        dispatch_button: "Teraz by sme sa mohli naučiť, ako riešiť nehody. Kliknutím na tlačidlo „Vyslať“ otvorte ponuku vysielania!",
                        first_mission: "Výborne, postavili ste svoju prvú budovu! Aha, boli vám nahlásené prvé misie!"
                    },
                    mobile: {
                        dispatch_button: "Teraz by sme sa mohli naučiť, ako riešiť nehody. Kliknutím na tlačidlo „Vyslať“ otvorte ponuku vysielania!",
                        first_mission: "Výborne, postavili ste svoju prvú budovu! Aha, boli vám nahlásené prvé misie!"
                    }
                }
            },
            rewards: {
                browser: {
                    general: "Výborne, vydali ste sa na cestu ku skvelému dispečerskému centru! Nech sa páči, %{coins} mincí, ktoré vám pomôžu začať! </br> Váš tím Dispečerského centra"
                },
                mobile: {
                    general: "Výborne, vydali ste sa na cestu ku skvelému dispečerskému centru! Nech sa páči, %{coins} mincí, ktoré vám pomôžu začať! </br> Váš tím Dispečerského centra"
                }
            },
            tips: {
                browser: {
                    contact: "Ak máte otázky, môžete sa obrátiť na časté otázky v hre, navštíviť herné fóra alebo našu stránku na Facebooku!",
                    general: "Ako ďalší krok vám odporúčame, aby ste vybudovali dispečerské centrum a potom čo najskôr nové stanice, pretože maximálny počet misií je rovnaký, ako najvyšší počet staníc jedného typu (polícia, hasiči, záchranka) plus 1; napr. 5 hasičských staníc a 3 záchranné stanice = 6 misií.",
                    join_alliance: "Hlavne na začiatku vám veľmi pomôže, keď sa pripojíte k aliancii, preto vám to tiež odporúčame.",
                    summary: "Toto sú základy Dispečerského centra! Plňte misie, získavajte kredity, kupujte viac jednotiek, opakujte. Prajeme vám dobrú zábavu! </br> Váš tím Dispečerského centra"
                },
                mobile: {
                    contact: "Ak máte otázky, môžete sa obrátiť na časté otázky v hre, navštíviť herné fóra alebo našu stránku na Facebooku!",
                    general: "Ako ďalší krok vám odporúčame, aby ste vybudovali dispečerské centrum a potom čo najskôr nové stanice, pretože maximálny počet misií je rovnaký, ako najvyšší počet staníc jedného typu (polícia, hasiči, záchranka) plus 1; napr. 5 hasičských staníc a 3 záchranné stanice = 6 misií.",
                    join_alliance: "Hlavne na začiatku vám veľmi pomôže, keď sa pripojíte k aliancii, preto vám to tiež odporúčame.",
                    summary: "Toto sú základy Dispečerského centra! Plňte misie, získavajte kredity, kupujte viac jednotiek, opakujte. Prajeme vám dobrú zábavu! </br> Váš tím Dispečerského centra"
                }
            }
        },
        commons: {
            collect: "Vyzdvihnúť",
            "continue": "Nie",
            end: "Koniec",
            next: "Ďalej",
            prev: "Dozadu",
            skip: "Áno",
            skip_hint: "Naozaj chcete zrušiť nácvik? Neskôr ho už nebudete môcť spustiť. Nebudete mať nárok na odmenu za absolvovanie nácviku."
        },
        rewards: {
            log: "Odmena za dokončenie nácviku."
        }
    }
}, /*!
   * jQuery JavaScript Library v1.10.0
   * http://jquery.com/
   *
   * Includes Sizzle.js
   * http://sizzlejs.com/
   *
   * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2013-05-24T18:39Z
   */
((e, t) => {
    function i(e) {
        const t = e.length;
        const i = ut.type(e);
        return ut.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === i || "function" !== i && (
          0 === t || "number" == typeof t && t > 0 && t - 1 in e)
    }

    function n(e) {
        const t = zt[e] = {};
        return ut.each(e.match(ht) || [], (e, i) => {
            t[i] = !0
        }), t;
    }

    function o(e, i, n, o) {
        if (ut.acceptData(e)) {
            let s;
            let a;
            const r = ut.expando;
            const l = e.nodeType;
            const c = l ? ut.cache : e;
            let u = l ? e[r] : e[r] && r;
            if (u && c[u] && (o || c[u].data) || n !== t || "string" != typeof i) return u || (u = l ? e[
              r] = tt.pop() || ut.guid++ : r), c[u] || (c[u] = l ? {} : {
                toJSON: ut.noop
            }), ("object" == typeof i || "function" == typeof i) && (o ? c[u] = ut.extend(c[u],
              i) : c[u].data = ut.extend(c[u].data, i)), a = c[u], o || (a.data || (a
              .data = {}), a = a.data), n !== t && (a[ut.camelCase(i)] = n), "string" ==
            typeof i ? (s = a[i], null == s && (s = a[ut.camelCase(i)])) : s = a, s
        }
    }

    function s(e, t, i) {
        if (ut.acceptData(e)) {
            let n;
            let o;
            const s = e.nodeType;
            const a = s ? ut.cache : e;
            const l = s ? e[ut.expando] : ut.expando;
            if (a[l]) {
                if (t && (n = i ? a[l] : a[l].data)) {
                    ut.isArray(t) ? t = t.concat(ut.map(t, ut.camelCase)) : t in n ? t = [t] : (t = ut
                      .camelCase(t), t = t in n ? [t] : t.split(" ")), o = t.length;
                    for (; o--;) delete n[t[o]];
                    if (i ? !r(n) : !ut.isEmptyObject(n)) return
                }(i || (delete a[l].data, r(a[l]))) && (s ? ut.cleanData([e], !0) : ut.support
                  .deleteExpando || a != a.window ? delete a[l] : a[l] = null)
            }
        }
    }

    function a(e, i, n) {
        if (n === t && 1 === e.nodeType) {
            const o = `data-${i.replace(St, "-$1")
  .toLowerCase()}`;
            if (n = e.getAttribute(o), "string" == typeof n) {
                try {
                    n = "true" === n ? !0 : "false" === n ? !1 : "null" === n ? null : `${+n}` === n ? +
                      n : Tt.test(n) ? ut.parseJSON(n) : n
                } catch (s) {}
                ut.data(e, i, n)
            } else n = t
        }
        return n
    }

    function r(e) {
        let t;
        for (t in e)
            if (("data" !== t || !ut.isEmptyObject(e[t])) && "toJSON" !== t) return !1;
        return !0
    }

    function l() {
        return !0
    }

    function c() {
        return !1
    }

    function u() {
        try {
            return Y.activeElement
        } catch (e) {}
    }

    function d(e, t) {
        do e = e[t]; while (e && 1 !== e.nodeType);
        return e
    }

    function h(e, t, i) {
        if (ut.isFunction(t)) return ut.grep(e, (e, n) => !!t.call(e, n, e) !== i);
        if (t.nodeType) return ut.grep(e, e => e === t !== i);
        if ("string" == typeof t) {
            if (Ht.test(t)) return ut.filter(t, e, i);
            t = ut.filter(t, e)
        }
        return ut.grep(e, e => ut.inArray(e, t) >= 0 !== i);
    }

    function p(e) {
        const t = Ut.split("|");
        const i = e.createDocumentFragment();
        if (i.createElement)
            for (; t.length;) i.createElement(t.pop());
        return i
    }

    function m(e, t) {
        return ut.nodeName(e, "table") && ut.nodeName(1 === t.nodeType ? t : t.firstChild, "tr") ? e
          .getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
    }

    function f(e) {
        return e.type = `${null !== ut.find.attr(e, "type")}/${e.type}`, e;
    }

    function _(e) {
        const t = oi.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"), e
    }

    function g(e, t) {
        for (let i, n = 0; null != (i = e[n]); n++) ut._data(i, "globalEval", !t || ut._data(t[n],
          "globalEval"))
    }

    function v(e, t) {
        if (1 === t.nodeType && ut.hasData(e)) {
            let i;
            let n;
            let o;
            const s = ut._data(e);
            const a = ut._data(t, s);
            const r = s.events;
            if (r) {
                delete a.handle, a.events = {};
                for (i in r)
                    for (n = 0, o = r[i].length; o > n; n++) ut.event.add(t, i, r[i][n])
            }
            a.data && (a.data = ut.extend({}, a.data))
        }
    }

    function b(e, t) {
        let i;
        let n;
        let o;
        if (1 === t.nodeType) {
            if (i = t.nodeName.toLowerCase(), !ut.support.noCloneEvent && t[ut.expando]) {
                o = ut._data(t);
                for (n in o.events) ut.removeEvent(t, n, o.handle);
                t.removeAttribute(ut.expando)
            }
            "script" === i && t.text !== e.text ? (f(t)
              .text = e.text, _(t)) : "object" === i ? (t.parentNode && (t.outerHTML = e.outerHTML),
            ut.support.html5Clone && e.innerHTML && !ut.trim(t.innerHTML) && (t.innerHTML = e
              .innerHTML)) : "input" === i && ti.test(e.type) ? (t.defaultChecked = t.checked =
              e.checked, t.value !== e.value && (t.value = e.value)) : "option" === i ? t
              .defaultSelected = t.selected = e.defaultSelected : ("input" === i || "textarea" === i) &&
              (t.defaultValue = e.defaultValue)
        }
    }

    function y(e, i) {
        let n;
        let o;
        let s = 0;

        let a = typeof e.getElementsByTagName !== G ? e.getElementsByTagName(i || "*") : typeof e
          .querySelectorAll !== G ? e.querySelectorAll(i || "*") : t;

        if (!a)
            for (a = [], n = e.childNodes || e; null != (o = n[s]); s++) !i || ut.nodeName(o, i) ? a.push(
              o) : ut.merge(a, y(o, i));
        return i === t || i && ut.nodeName(e, i) ? ut.merge([e], a) : a
    }

    function w(e) {
        ti.test(e.type) && (e.defaultChecked = e.checked)
    }

    function k(e, t) {
        if (t in e) return t;
        for (var i = t.charAt(0)
          .toUpperCase() + t.slice(1), n = t, o = Ci.length; o--;)
            if (t = Ci[o] + i, t in e) return t;
        return n
    }

    function x(e, t) {
        return e = t || e, "none" === ut.css(e, "display") || !ut.contains(e.ownerDocument, e)
    }

    function C(e, t) {
        for (var i, n, o, s = [], a = 0, r = e.length; r > a; a++) n = e[a], n.style && (s[a] = ut._data(
          n, "olddisplay"), i = n.style.display, t ? (s[a] || "none" !== i || (n.style.display =
          ""), "" === n.style.display && x(n) && (s[a] = ut._data(n, "olddisplay", A(n
          .nodeName)))) : s[a] || (o = x(n), (i && "none" !== i || !o) && ut._data(n,
          "olddisplay", o ? i : ut.css(n, "display"))));
        for (a = 0; r > a; a++) n = e[a], n.style && (t && "none" !== n.style.display && "" !== n.style
          .display || (n.style.display = t ? s[a] || "" : "none"));
        return e
    }

    function z(e, t, i) {
        const n = gi.exec(t);
        return n ? Math.max(0, n[1] - (i || 0)) + (n[2] || "px") : t
    }

    function T(e, t, i, n, o) {
        for (var s = i === (n ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; 4 > s; s += 2)
            "margin" === i && (a += ut.css(e, i + xi[s], !0, o)), n ? ("content" === i && (a -= ut.css(e,
              `padding${xi[s]}`, !0, o)), "margin" !== i && (a -= ut.css(e, `border${xi[s]}Width`, !0, o))) : (a += ut.css(e, `padding${xi[s]}`, !0, o), "padding" !== i && (a += ut
              .css(e, `border${xi[s]}Width`, !0, o)));
        return a
    }

    function S(e, t, i) {
        let n = !0;
        let o = "width" === t ? e.offsetWidth : e.offsetHeight;
        const s = ui(e);
        const a = ut.support.boxSizing && "border-box" === ut.css(e, "boxSizing", !1, s);
        if (0 >= o || null == o) {
            if (o = di(e, t, s), (0 > o || null == o) && (o = e.style[t]), vi.test(o)) return o;
            n = a && (ut.support.boxSizingReliable || o === e.style[t]), o = parseFloat(o) || 0
        }
        return `${o + T(e, t, i || (a ? "border" : "content"), n, s)}px`;
    }

    function A(e) {
        let t = Y;
        let i = yi[e];
        return i || (i = E(e, t), "none" !== i && i || (ci = (ci || ut(
            "<iframe frameborder='0' width='0' height='0'/>")
            .css("cssText", "display:block !important"))
            .appendTo(t.documentElement), t = (ci[0].contentWindow || ci[0].contentDocument)
            .document, t.write("<!doctype html><html><body>"), t.close(), i = E(e, t), ci.detach()
        ), yi[e] = i), i
    }

    function E(e, t) {
        const i = ut(t.createElement(e))
            .appendTo(t.body);

        const n = ut.css(i[0], "display");
        return i.remove(), n
    }

    function P(e, t, i, n) {
        let o;
        if (ut.isArray(t)) ut.each(t, (t, o) => {
            i || Ti.test(e) ? n(e, o) : P(`${e}[${"object" == typeof o ? t : ""}]`, o, i,
              n)
        });
        else if (i || "object" !== ut.type(t)) n(e, t);
        else
            for (o in t) P(`${e}[${o}]`, t[o], i, n)
    }

    function I(e) {
        return (t, i) => {
            "string" != typeof t && (i = t, t = "*");
            let n;
            let o = 0;

            const s = t.toLowerCase()
              .match(ht) || [];

            if (ut.isFunction(i))
                for (; n = s[o++];) "+" === n[0] ? (n = n.slice(1) || "*", (e[n] = e[n] || [])
                  .unshift(i)) : (e[n] = e[n] || [])
                  .push(i)
        };
    }

    function M(e, t, i, n) {
        function o(r) {
            let l;
            return s[r] = !0, ut.each(e[r] || [], (e, r) => {
                const c = r(t, i, n);
                return "string" != typeof c || a || s[c] ? a ? !(l = c) : void 0 : (t.dataTypes
                  .unshift(c), o(c), !1)
            }), l;
        }
        var s = {};
        var a = e === Wi;
        return o(t.dataTypes[0]) || !s["*"] && o("*")
    }

    function j(e, i) {
        let n;
        let o;
        const s = ut.ajaxSettings.flatOptions || {};
        for (o in i) i[o] !== t && ((s[o] ? e : n || (n = {}))[o] = i[o]);
        return n && ut.extend(!0, e, n), e
    }

    function D({contents, dataTypes, mimeType, converters}, i, n) {
        for (var o, s, a, r, l = contents, c = dataTypes;
             "*" === c[0];) c.shift(), s === t && (s = mimeType || i.getResponseHeader("Content-Type"));
        if (s)
            for (r in l)
                if (l[r] && l[r].test(s)) {
                    c.unshift(r);
                    break
                } if (c[0] in n) a = c[0];
        else {
            for (r in n) {
                if (!c[0] || converters[`${r} ${c[0]}`]) {
                    a = r;
                    break
                }
                o || (o = r)
            }
            a = a || o
        }
        return a ? (a !== c[0] && c.unshift(a), n[a]) : void 0
    }

    function N(e, t, i, n) {
        let o;
        let s;
        let a;
        let r;
        let l;
        const c = {};
        const u = e.dataTypes.slice();
        if (u[1])
            for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
        for (s = u.shift(); s;)
            if (e.responseFields[s] && (i[e.responseFields[s]] = t), !l && n && e.dataFilter && (t = e
              .dataFilter(t, e.dataType)), l = s, s = u.shift())
                if ("*" === s) s = l;
                else if ("*" !== l && l !== s) {
                    if (a = c[`${l} ${s}`] || c[`* ${s}`], !a)
                        for (o in c)
                            if (r = o.split(" "), r[1] === s && (a = c[`${l} ${r[0]}`] || c[`* ${r[0]}`])) {
                                a === !0 ? a = c[o] : c[o] !== !0 && (s = r[0], u.unshift(r[1]));
                                break
                            } if (a !== !0)
                        if (a && e["throws"]) t = a(t);
                        else try {
                            t = a(t)
                        } catch (d) {
                            return {
                                state: "parsererror",
                                error: a ? d : `No conversion from ${l} to ${s}`
                            };
                        }
                }
        return {
            state: "success",
            data: t
        }
    }

    function L() {
        try {
            return new e.XMLHttpRequest
        } catch (t) {}
    }

    function O() {
        try {
            return new e.ActiveXObject("Microsoft.XMLHTTP")
        } catch (t) {}
    }

    function R() {
        return setTimeout(() => {
            Qi = t
        }), Qi = ut.now();
    }

    function $(e, t, i) {
        for (let n,
            o = (sn[t] || [])
              .concat(sn["*"]),
            s = 0,
            a = o.length; a > s; s++)
            if (n = o[s].call(i, t, e)) return n
    }

    function F(e, t, i) {
        let n;
        let o;
        let s = 0;
        const a = on.length;

        const r = ut.Deferred()
          .always(() => {
              delete l.elem
          });

        var l = () => {
            if (o) return !1;
            for (var t = Qi || R(), i = Math.max(0, c.startTime + c.duration - t), n = i / c
              .duration || 0, s = 1 - n, a = 0, l = c.tweens.length; l > a; a++) c.tweens[a]
              .run(s);
            return r.notifyWith(e, [c, s, i]), 1 > s && l ? i : (r.resolveWith(e, [c]), !1)
        };

        var c = r.promise({
            elem: e,
            props: ut.extend({}, t),
            opts: ut.extend(!0, {
                specialEasing: {}
            }, i),
            originalProperties: t,
            originalOptions: i,
            startTime: Qi || R(),
            duration: i.duration,
            tweens: [],
            createTween(t, i) {
                const n = ut.Tween(e, c.opts, t, i, c.opts.specialEasing[t] || c.opts.easing);
                return c.tweens.push(n), n
            },
            stop(t) {
                let i = 0;
                const n = t ? c.tweens.length : 0;
                if (o) return this;
                for (o = !0; n > i; i++) c.tweens[i].run(1);
                return t ? r.resolveWith(e, [c, t]) : r.rejectWith(e, [c, t]), this
            }
        });

        const u = c.props;
        for (B(u, c.opts.specialEasing); a > s; s++)
            if (n = on[s].call(c, e, u, c.opts)) return n;
        return ut.map(u, $, c), ut.isFunction(c.opts.start) && c.opts.start.call(e, c), ut.fx.timer(ut
          .extend(l, {
              elem: e,
              anim: c,
              queue: c.opts.queue
          })), c.progress(c.opts.progress)
          .done(c.opts.done, c.opts.complete)
          .fail(c.opts.fail)
          .always(c.opts.always)
    }

    function B(e, t) {
        let i;
        let n;
        let o;
        let s;
        let a;
        for (i in e)
            if (n = ut.camelCase(i), o = t[n], s = e[i], ut.isArray(s) && (o = s[1], s = e[i] = s[0]),
            i !== n && (e[n] = s, delete e[i]), a = ut.cssHooks[n], a && "expand" in a) {
                s = a.expand(s), delete e[n];
                for (i in s) i in e || (e[i] = s[i], t[i] = o)
            } else t[n] = o
    }

    function H(e, t, i) {
        let n;
        let o;
        let s;
        let a;
        let r;
        let l;
        const c = this;
        const u = {};
        const d = e.style;
        let h = e.nodeType && x(e);
        let p = ut._data(e, "fxshow");
        i.queue || (r = ut._queueHooks(e, "fx"), null == r.unqueued && (r.unqueued = 0, l = r.empty.fire,
          r.empty.fire = () => {
              r.unqueued || l()
          }), r.unqueued++, c.always(() => {
            c.always(() => {
                r.unqueued--, ut.queue(e, "fx")
                  .length || r.empty.fire()
            })
        })), 1 === e.nodeType && ("height" in t || "width" in t) && (i.overflow = [d.overflow, d
          .overflowX, d.overflowY], "inline" === ut.css(e, "display") && "none" === ut.css(e,
          "float") && (ut.support.inlineBlockNeedsLayout && "inline" !== A(e.nodeName) ? d
          .zoom = 1 : d.display = "inline-block")), i.overflow && (d.overflow = "hidden", ut.support
          .shrinkWrapBlocks || c.always(() => {
            d.overflow = i.overflow[0], d.overflowX = i.overflow[1], d.overflowY = i.overflow[
              2]
        }));
        for (n in t)
            if (o = t[n], en.exec(o)) {
                if (delete t[n], s = s || "toggle" === o, o === (h ? "hide" : "show")) continue;
                u[n] = p && p[n] || ut.style(e, n)
            }if (!ut.isEmptyObject(u)) {
                p ? "hidden" in p && (h = p.hidden) : p = ut._data(e, "fxshow", {}), s && (p.hidden = !h), h ?
                  ut(e)
                    .show() : c.done(() => {
                      ut(e)
                        .hide()
                  }), c.done(() => {
                    let t;
                    ut._removeData(e, "fxshow");
                    for (t in u) ut.style(e, t, u[t])
                });
                for (n in u) a = $(h ? p[n] : 0, n, c), n in p || (p[n] = a.start, h && (a.end = a.start, a
                  .start = "width" === n || "height" === n ? 1 : 0))
            }
    }

    function W(e, t, i, n, o) {
        return new W.prototype.init(e, t, i, n, o)
    }

    function V(e, t) {
        let i;

        const n = {
              height: e
          };

        let o = 0;
        for (t = t ? 1 : 0; 4 > o; o += 2 - t) i = xi[o], n[`margin${i}`] = n[`padding${i}`] = e;
        return t && (n.opacity = n.width = e), n
    }

    function q(e) {
        return ut.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1
    }
    let U;
    let Z;
    var G = typeof t;
    const K = e.location;
    var Y = e.document;
    const J = Y.documentElement;
    const Q = e.jQuery;
    const X = e.$;
    const et = {};
    var tt = [];
    const it = "1.10.0";
    const nt = tt.concat;
    const ot = tt.push;
    const st = tt.slice;
    const at = tt.indexOf;
    const rt = et.toString;
    const lt = et.hasOwnProperty;
    const ct = it.trim;
    var ut = (e, t) => new ut.fn.init(e, t, Z);
    const dt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var ht = /\S+/g;
    const pt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    const mt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
    const ft = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    const _t = /^[\],:{}\s]*$/;
    const gt = /(?:^|:|,)(?:\s*\[)+/g;
    const vt = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g;
    const bt = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g;
    const yt = /^-ms-/;
    const wt = /-([\da-z])/gi;
    const kt = (e, t) => t.toUpperCase();

    const xt = ({type}) => {
        (Y.addEventListener || "load" === type || "complete" === Y.readyState) && (Ct(), ut.ready())
    };

    var Ct = () => {
        Y.addEventListener ? (Y.removeEventListener("DOMContentLoaded", xt, !1), e
          .removeEventListener("load", xt, !1)) : (Y.detachEvent("onreadystatechange", xt), e
          .detachEvent("onload", xt))
    };

    ut.fn = ut.prototype = {
        jquery: it,
        constructor: ut,
        init(e, i, n) {
            let o;
            let s;
            if (!e) return this;
            if ("string" == typeof e) {
                if (o = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [
                    null, e, null] : mt.exec(e), !o || !o[1] && i) return !i || i.jquery ? (
                  i || n)
                  .find(e) : this.constructor(i)
                  .find(e);
                if (o[1]) {
                    if (i = i instanceof ut ? i[0] : i, ut.merge(this, ut.parseHTML(o[1], i && i
                      .nodeType ? i.ownerDocument || i : Y, !0)), ft.test(o[1]) && ut
                      .isPlainObject(i))
                        for (o in i) ut.isFunction(this[o]) ? this[o](i[o]) : this.attr(o, i[o]);
                    return this
                }
                if (s = Y.getElementById(o[2]), s && s.parentNode) {
                    if (s.id !== o[2]) return n.find(e);
                    this.length = 1, this[0] = s
                }
                return this.context = Y, this.selector = e, this
            }
            return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : ut
              .isFunction(e) ? n.ready(e) : (e.selector !== t && (this.selector = e.selector,
              this.context = e.context), ut.makeArray(e, this))
        },
        selector: "",
        length: 0,
        toArray() {
            return st.call(this)
        },
        get(e) {
            return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e]
        },
        pushStack(e) {
            const t = ut.merge(this.constructor(), e);
            return t.prevObject = this, t.context = this.context, t
        },
        each(e, t) {
            return ut.each(this, e, t)
        },
        ready(e) {
            return ut.ready.promise()
              .done(e), this
        },
        slice(...args) {
            return this.pushStack(st.apply(this, args));
        },
        first() {
            return this.eq(0)
        },
        last() {
            return this.eq(-1)
        },
        eq(e) {
            const t = this.length;
            const i = +e + (0 > e ? t : 0);
            return this.pushStack(i >= 0 && t > i ? [this[i]] : [])
        },
        map(e) {
            return this.pushStack(ut.map(this, (t, i) => e.call(t, i, t)));
        },
        end() {
            return this.prevObject || this.constructor(null)
        },
        push: ot,
        sort: [].sort,
        splice: [].splice
    }, ut.fn.init.prototype = ut.fn, ut.extend = ut.fn.extend = function(...args) {
        let e;
        let i;
        let n;
        let o;
        let s;
        let a;
        let r = args[0] || {};
        let l = 1;
        const c = args.length;
        let u = !1;
        for ("boolean" == typeof r && (u = r, r = args[1] || {}, l = 2), "object" == typeof r ||
        ut.isFunction(r) || (r = {}), c === l && (r = this, --l); c > l; l++)
            if (null != (s = args[l]))
                for (o in s) e = r[o], n = s[o], r !== n && (u && n && (ut.isPlainObject(n) || (i = ut
                  .isArray(n))) ? (i ? (i = !1, a = e && ut.isArray(e) ? e : []) : a = e &&
                ut.isPlainObject(e) ? e : {}, r[o] = ut.extend(u, a, n)) : n !== t && (r[
                  o] = n));
        return r
    }, ut.extend({
        expando: `jQuery${(it + Math.random())
  .replace(/\D/g, "")}`,
        noConflict(t) {
            return e.$ === ut && (e.$ = X), t && e.jQuery === ut && (e.jQuery = Q), ut
        },
        isReady: !1,
        readyWait: 1,
        holdReady(e) {
            e ? ut.readyWait++ : ut.ready(!0)
        },
        ready(e) {
            if (e === !0 ? !--ut.readyWait : !ut.isReady) {
                if (!Y.body) return setTimeout(ut.ready);
                ut.isReady = !0, e !== !0 && --ut.readyWait > 0 || (U.resolveWith(Y, [ut]), ut
                  .fn.trigger && ut(Y)
                  .trigger("ready")
                  .off("ready"))
            }
        },
        isFunction(e) {
            return "function" === ut.type(e)
        },
        isArray: Array.isArray || (e => "array" === ut.type(e)),
        isWindow(e) {
            return null != e && e == e.window
        },
        isNumeric(e) {
            return !isNaN(parseFloat(e)) && isFinite(e)
        },
        type(e) {
            return null == e ? String(e) : "object" == typeof e || "function" == typeof e ?
              et[rt.call(e)] || "object" : typeof e
        },
        isPlainObject(e) {
            let i;
            if (!e || "object" !== ut.type(e) || e.nodeType || ut.isWindow(e)) return !1;
            try {
                if (e.constructor && !lt.call(e, "constructor") && !lt.call(e.constructor
                  .prototype, "isPrototypeOf")) return !1
            } catch (n) {
                return !1
            }
            if (ut.support.ownLast)
                for (i in e) return lt.call(e, i);
            for (i in e);
            return i === t || lt.call(e, i)
        },
        isEmptyObject(e) {
            let t;
            for (t in e) return !1;
            return !0
        },
        error(e) {
            throw new Error(e)
        },
        parseHTML(e, t, i) {
            if (!e || "string" != typeof e) return null;
            "boolean" == typeof t && (i = t, t = !1), t = t || Y;
            let n = ft.exec(e);
            const o = !i && [];
            return n ? [t.createElement(n[1])] : (n = ut.buildFragment([e], t, o), o && ut(o)
              .remove(), ut.merge([], n.childNodes))
        },
        parseJSON(t) {
            return e.JSON && e.JSON.parse ? e.JSON.parse(t) : null === t ? t : "string" ==
            typeof t && (t = ut.trim(t), t && _t.test(t.replace(vt, "@")
              .replace(bt, "]")
              .replace(gt, ""))) ? new Function(`return ${t}`)() : (ut.error(
              `Invalid JSON: ${t}`), void 0);
        },
        parseXML(i) {
            let n;
            let o;
            if (!i || "string" != typeof i) return null;
            try {
                e.DOMParser ? (o = new DOMParser, n = o.parseFromString(i, "text/xml")) : (n =
                    new ActiveXObject("Microsoft.XMLDOM"), n.async = "false", n.loadXML(i)
                )
            } catch (s) {
                n = t
            }
            return n && n.documentElement && !n.getElementsByTagName("parsererror")
              .length || ut.error(`Invalid XML: ${i}`), n;
        },
        noop() {},
        globalEval(t) {
            t && ut.trim(t) && (e.execScript || (t => {
                e.eval.call(e, t)
            }))(t)
        },
        camelCase(e) {
            return e.replace(yt, "ms-")
              .replace(wt, kt)
        },
        nodeName({nodeName}, t) {
            return nodeName && nodeName.toLowerCase() === t.toLowerCase();
        },
        each(e, t, n) {
            let o;
            let s = 0;
            const a = e.length;
            const r = i(e);
            if (n) {
                if (r)
                    for (; a > s && (o = t.apply(e[s], n), o !== !1); s++);
                else
                    for (s in e)
                        if (o = t.apply(e[s], n), o === !1) break
            } else if (r)
                for (; a > s && (o = t.call(e[s], s, e[s]), o !== !1); s++);
            else
                for (s in e)
                    if (o = t.call(e[s], s, e[s]), o === !1) break;
            return e
        },
        trim: ct && !ct.call("﻿ ") ? e => null == e ? "" : ct.call(e) : e => null == e ? "" : (`${e}`)
          .replace(pt, ""),
        makeArray(e, t) {
            const n = t || [];
            return null != e && (i(Object(e)) ? ut.merge(n, "string" == typeof e ? [e] : e) :
              ot.call(n, e)), n
        },
        inArray(e, t, i) {
            let n;
            if (t) {
                if (at) return at.call(t, e, i);
                for (n = t.length, i = i ? 0 > i ? Math.max(0, n + i) : i : 0; n > i; i++)
                    if (i in t && t[i] === e) return i
            }
            return -1
        },
        merge(e, i) {
            const n = i.length;
            let o = e.length;
            let s = 0;
            if ("number" == typeof n)
                for (; n > s; s++) e[o++] = i[s];
            else
                for (; i[s] !== t;) e[o++] = i[s++];
            return e.length = o, e
        },
        grep(e, t, i) {
            let n;
            const o = [];
            let s = 0;
            const a = e.length;
            for (i = !!i; a > s; s++) n = !!t(e[s], s), i !== n && o.push(e[s]);
            return o
        },
        map(e, t, n) {
            let o;
            let s = 0;
            const a = e.length;
            const r = i(e);
            const l = [];
            if (r)
                for (; a > s; s++) o = t(e[s], s, n), null != o && (l[l.length] = o);
            else
                for (s in e) o = t(e[s], s, n), null != o && (l[l.length] = o);
            return nt.apply([], l)
        },
        guid: 1,
        proxy(e, i) {
            let n;
            let o;
            let s;
            return "string" == typeof i && (s = e[i], i = e, e = s), ut.isFunction(e) ? (n =
              st.call(arguments, 2), o = function(...args) {
                return e.apply(i || this, n.concat(st.call(args)));
            }, o.guid = e.guid = e.guid || ut.guid++, o) : t;
        },
        access(e, i, n, o, s, a, r) {
            let l = 0;
            const c = e.length;
            let u = null == n;
            if ("object" === ut.type(n)) {
                s = !0;
                for (l in n) ut.access(e, i, l, n[l], !0, a, r)
            } else if (o !== t && (s = !0, ut.isFunction(o) || (r = !0), u && (r ? (i.call(e,
              o), i = null) : (u = i, i = (e, t, i) => u.call(ut(e), i))), i))
                for (; c > l; l++) i(e[l], n, r ? o : o.call(e[l], l, i(e[l], n)));
            return s ? e : u ? i.call(e) : c ? i(e[0], n) : a
        },
        now() {
            return (new Date)
              .getTime()
        },
        swap(e, t, i, n) {
            let o;
            let s;
            const a = {};
            for (s in t) a[s] = e.style[s], e.style[s] = t[s];
            o = i.apply(e, n || []);
            for (s in t) e.style[s] = a[s];
            return o
        }
    }), ut.ready.promise = t => {
        if (!U)
            if (U = ut.Deferred(), "complete" === Y.readyState) setTimeout(ut.ready);
            else if (Y.addEventListener) Y.addEventListener("DOMContentLoaded", xt, !1), e
              .addEventListener("load", xt, !1);
            else {
                Y.attachEvent("onreadystatechange", xt), e.attachEvent("onload", xt);
                let i = !1;
                try {
                    i = null == e.frameElement && Y.documentElement
                } catch (n) {}
                i && i.doScroll && function o() {
                    if (!ut.isReady) {
                        try {
                            i.doScroll("left")
                        } catch (e) {
                            return setTimeout(o, 50)
                        }
                        Ct(), ut.ready()
                    }
                }()
            }
        return U.promise(t)
    }, ut.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), (e, t) => {
        et[`[object ${t}]`] = t.toLowerCase()
    }), Z = ut(Y), /*!
         * Sizzle CSS Selector Engine v1.9.4-pre
         * http://sizzlejs.com/
         *
         * Copyright 2013 jQuery Foundation, Inc. and other contributors
         * Released under the MIT license
         * http://jquery.org/license
         *
         * Date: 2013-05-15
         */
    ((e, t) => {
        function i(e, t, i, n) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            if ((t ? t.ownerDocument || t : V) !== L && N(t), t = t || L, i = i || [], !e ||
            "string" != typeof e) return i;
            if (1 !== (r = t.nodeType) && 9 !== r) return [];
            if (R && !n) {
                if (o = xt.exec(e))
                    if (a = o[1]) {
                        if (9 === r) {
                            if (s = t.getElementById(a), !s || !s.parentNode) return i;
                            if (s.id === a) return i.push(s), i
                        } else if (t.ownerDocument && (s = t.ownerDocument.getElementById(a)) && H(t,
                          s) && s.id === a) return i.push(s), i
                    } else {
                        if (o[2]) return ot.apply(i, t.getElementsByTagName(e)), i;
                        if ((a = o[3]) && S.getElementsByClassName && t.getElementsByClassName)
                            return ot.apply(i, t.getElementsByClassName(a)), i
                    } if (S.qsa && (!$ || !$.test(e))) {
                    if (d = u = W, h = t, p = 9 === r && e, 1 === r && "object" !== t.nodeName
                      .toLowerCase()) {
                        for (c = f(e), (u = t.getAttribute("id")) ? d = u.replace(Tt, "\\$&") : t
                          .setAttribute("id", d), d = `[id='${d}'] `, l = c.length; l--;) c[
                          l] = d + _(c[l]);
                        h = gt.test(e) && t.parentNode || t, p = c.join(",")
                    }
                    if (p) try {
                        return ot.apply(i, h.querySelectorAll(p)), i
                    } catch (m) {} finally {
                        u || t.removeAttribute("id")
                    }
                }
            }
            return C(e.replace(mt, "$1"), t, i, n)
        }

        function n(e) {
            return kt.test(`${e}`);
        }

        function o() {
            function e(i, n) {
                return t.push(i += " ") > E.cacheLength && delete e[t.shift()], e[i] = n
            }
            var t = [];
            return e
        }

        function s(e) {
            return e[W] = !0, e
        }

        function a(e) {
            let t = L.createElement("div");
            try {
                return !!e(t)
            } catch (i) {
                return !1
            } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null
            }
        }

        function r(e, t, i) {
            e = e.split("|");
            for (let n, o = e.length, s = i ? null : t; o--;)(n = E.attrHandle[e[o]]) && n !== t || (E
              .attrHandle[e[o]] = s)
        }

        function l(e, t) {
            const i = e.getAttributeNode(t);
            return i && i.specified ? i.value : e[t] === !0 ? t.toLowerCase() : null
        }

        function c(e, t) {
            return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
        }

        function u({nodeName, defaultValue}) {
            return "input" === nodeName.toLowerCase() ? defaultValue : void 0;
        }

        function d(e, t) {
            let i = t && e;

            const n = i && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || X) - (~e
              .sourceIndex || X);

            if (n) return n;
            if (i)
                for (; i = i.nextSibling;)
                    if (i === t) return -1;
            return e ? 1 : -1
        }

        function h(e) {
            return ({nodeName, type}) => {
                const i = nodeName.toLowerCase();
                return "input" === i && type === e;
            };
        }

        function p(e) {
            return ({nodeName, type}) => {
                const i = nodeName.toLowerCase();
                return ("input" === i || "button" === i) && type === e;
            };
        }

        function m(e) {
            return s(t => (t = +t, s((i, n) => {
                for (let o, s = e([], i.length, t), a = s.length; a--;) i[o = s[
                  a]] && (i[o] = !(n[o] = i[o]))
            })));
        }

        function f(e, t) {
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            const u = G[`${e} `];
            if (u) return t ? 0 : u.slice(0);
            for (r = e, l = [], c = E.preFilter; r;) {
                (!n || (o = ft.exec(r))) && (o && (r = r.slice(o[0].length) || r), l.push(s = [])), n
                  = !1, (o = _t.exec(r)) && (n = o.shift(), s.push({
                    value: n,
                    type: o[0].replace(mt, " ")
                }), r = r.slice(n.length));
                for (a in E.filter) !(o = wt[a].exec(r)) || c[a] && !(o = c[a](o)) || (n = o.shift(),
                  s.push({
                      value: n,
                      type: a,
                      matches: o
                  }), r = r.slice(n.length));
                if (!n) break
            }
            return t ? r.length : r ? i.error(e) : G(e, l)
              .slice(0)
        }

        function _(e) {
            for (var t = 0, i = e.length, n = ""; i > t; t++) n += e[t].value;
            return n
        }

        function g(e, {dir, first}, i) {
            const n = dir;
            const o = i && "parentNode" === n;
            const s = U++;
            return first ? (t, i, s) => {
                for (; t = t[n];)
                    if (1 === t.nodeType || o) return e(t, i, s)
            } : (t, i, a) => {
                let r;
                let l;
                let c;
                const u = `${q} ${s}`;
                if (a) {
                    for (; t = t[n];)
                        if ((1 === t.nodeType || o) && e(t, i, a)) return !0
                } else
                    for (; t = t[n];)
                        if (1 === t.nodeType || o)
                            if (c = t[W] || (t[W] = {}), (l = c[n]) && l[0] === u) {
                                if ((r = l[1]) === !0 || r === A) return r === !0
                            } else if (l = c[n] = [u], l[1] = e(t, i, a) || A, l[1] === !0)
                                return !0
            };
        }

        function v(e) {
            return e.length > 1 ? (t, i, n) => {
                for (let o = e.length; o--;)
                    if (!e[o](t, i, n)) return !1;
                return !0
            } : e[0];
        }

        function b(e, t, i, n, o) {
            for (var s, a = [], r = 0, l = e.length, c = null != t; l > r; r++)(s = e[r]) && (!i || i(
              s, n, o)) && (a.push(s), c && t.push(r));
            return a
        }

        function y(e, t, i, n, o, a) {
            return n && !n[W] && (n = y(n)), o && !o[W] && (o = y(o, a)), s((s, a, r, l) => {
                let c;
                let u;
                let d;
                const h = [];
                const p = [];
                const m = a.length;
                const f = s || x(t || "*", r.nodeType ? [r] : r, []);
                const _ = !e || !s && t ? f : b(f, h, e, r, l);
                let g = i ? o || (s ? e : m || n) ? [] : a : _;
                if (i && i(_, g, r, l), n)
                    for (c = b(g, p), n(c, [], r, l), u = c.length; u--;)(d = c[u]) && (g[p[
                      u]] = !(_[p[u]] = d));
                if (s) {
                    if (o || e) {
                        if (o) {
                            for (c = [], u = g.length; u--;)(d = g[u]) && c.push(_[u] = d);
                            o(null, g = [], c, l)
                        }
                        for (u = g.length; u--;)(d = g[u]) && (c = o ? at.call(s, d) : h[u]) >
                        -1 && (s[c] = !(a[c] = d))
                    }
                } else g = b(g === a ? g.splice(m, g.length) : g), o ? o(null, a, g, l) : ot
                  .apply(a, g)
            });
        }

        function w(e) {
            for (var t, i, n, o = e.length, s = E.relative[e[0].type], a = s || E.relative[" "], r =
              s ? 1 : 0, l = g(e => e === t, a, !0), c = g(e => at.call(t, e) > -1, a, !0), u = [(e, i, n) => !s && (n || i !== j) || ((t = i)
              .nodeType ? l(e, i, n) : c(e, i, n))]; o > r; r++)
                if (i = E.relative[e[r].type]) u = [g(v(u), i)];
                else {
                    if (i = E.filter[e[r].type].apply(null, e[r].matches), i[W]) {
                        for (n = ++r; o > n && !E.relative[e[n].type]; n++);
                        return y(r > 1 && v(u), r > 1 && _(e.slice(0, r - 1)
                          .concat({
                              value: " " === e[r - 2].type ? "*" : ""
                          }))
                          .replace(mt, "$1"), i, n > r && w(e.slice(r, n)), o > n && w(e = e
                          .slice(n)), o > n && _(e))
                    }
                    u.push(i)
                } return v(u)
        }

        function k(e, t) {
            let n = 0;
            const o = t.length > 0;
            const a = e.length > 0;

            const r = (s, r, l, c, u) => {
                let d;
                let h;
                let p;
                let m = [];
                let f = 0;
                let _ = "0";
                const g = s && [];
                const v = null != u;
                const y = j;
                const w = s || a && E.find.TAG("*", u && r.parentNode || r);
                const k = q += null == y ? 1 : Math.random() || .1;
                for (v && (j = r !== L && r, A = n); null != (d = w[_]); _++) {
                    if (a && d) {
                        for (h = 0; p = e[h++];)
                            if (p(d, r, l)) {
                                c.push(d);
                                break
                            } v && (q = k, A = ++n)
                    }
                    o && ((d = !p && d) && f--, s && g.push(d))
                }
                if (f += _, o && _ !== f) {
                    for (h = 0; p = t[h++];) p(g, m, r, l);
                    if (s) {
                        if (f > 0)
                            for (; _--;) g[_] || m[_] || (m[_] = it.call(c));
                        m = b(m)
                    }
                    ot.apply(c, m), v && !s && m.length > 0 && f + t.length > 1 && i.uniqueSort(c)
                }
                return v && (q = k, j = y), g
            };

            return o ? s(r) : r
        }

        function x(e, t, n) {
            for (let o = 0, s = t.length; s > o; o++) i(e, t[o], n);
            return n
        }

        function C(e, t, i, n) {
            let o;
            let s;
            let a;
            let r;
            let l;
            const c = f(e);
            if (!n && 1 === c.length) {
                if (s = c[0] = c[0].slice(0), s.length > 2 && "ID" === (a = s[0])
                  .type && S.getById && 9 === t.nodeType && R && E.relative[s[1].type]) {
                    if (t = (E.find.ID(a.matches[0].replace(St, At), t) || [])[0], !t) return i;
                    e = e.slice(s.shift()
                      .value.length)
                }
                for (o = wt.needsContext.test(e) ? 0 : s.length; o-- && (a = s[o], !E.relative[r = a
                  .type]);)
                    if ((l = E.find[r]) && (n = l(a.matches[0].replace(St, At), gt.test(s[0].type) &&
                      t.parentNode || t))) {
                        if (s.splice(o, 1), e = n.length && _(s), !e) return ot.apply(i, n), i;
                        break
                    }
            }
            return M(e, c)(n, t, !R, i, gt.test(e)), i
        }

        function z() {}
        let T;
        var S;
        var A;
        var E;
        let P;
        let I;
        var M;
        var j;
        let D;
        var N;
        var L;
        let O;
        var R;
        var $;
        let F;
        let B;
        var H;
        var W = `sizzle${-new Date}`;
        var V = e.document;
        var q = 0;
        var U = 0;
        const Z = o();
        var G = o();
        const K = o();
        let Y = !1;
        let J = () => 0;
        const Q = typeof t;
        var X = 1 << 31;
        const et = {}.hasOwnProperty;
        let tt = [];
        var it = tt.pop;
        const nt = tt.push;
        var ot = tt.push;
        const st = tt.slice;

        var at = tt.indexOf || function (e) {
            for (let t = 0, i = this.length; i > t; t++)
                if (this[t] === e) return t;
            return -1
        };

        const rt =
          "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped";

        const lt = "[\\x20\\t\\r\\n\\f]";
        const ct = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+";
        const dt = ct.replace("w", "w#");
        const ht = `\\[${lt}*(${ct})${lt}*(?:([*^$|!~]?=)${lt}*(?:(['"])((?:\\\\.|[^\\\\])*?)\\3|(${dt})|)|)${lt}*\\]`;

        const pt = `:(${ct})(?:\\(((['"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|${ht
  .replace(3, 8)})*)|.*)\\)|)`;

        var mt = new RegExp(`^${lt}+|((?:^|[^\\\\])(?:\\\\.)*)${lt}+$`, "g");
        var ft = new RegExp(`^${lt}*,${lt}*`);
        var _t = new RegExp(`^${lt}*([>+~]|${lt})${lt}*`);
        var gt = new RegExp(`${lt}*[+~]`);
        const vt = new RegExp(`=${lt}*([^\\]'"]*)${lt}*\\]`, "g");
        const bt = new RegExp(pt);
        const yt = new RegExp(`^${dt}$`);

        var wt = {
            ID: new RegExp(`^#(${ct})`),
            CLASS: new RegExp(`^\\.(${ct})`),
            TAG: new RegExp(`^(${ct.replace("w", "w*")})`),
            ATTR: new RegExp(`^${ht}`),
            PSEUDO: new RegExp(`^${pt}`),
            CHILD: new RegExp(`^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(${lt}*(even|odd|(([+-]|)(\\d*)n|)${lt}*(?:([+-]|)${lt}*(\\d+)|))${lt}*\\)|)`, "i"),
            bool: new RegExp(`^(?:${rt})$`, "i"),
            needsContext: new RegExp(`^${lt}*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(${lt}*((?:-\\d)?\\d*)${lt}*\\)|)(?=[^-]|$)`, "i")
        };

        var kt = /^[^{]+\{\s*\[native \w/;
        var xt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/;
        const Ct = /^(?:input|select|textarea|button)$/i;
        const zt = /^h\d$/i;
        var Tt = /'|\\/g;
        var St = new RegExp(`\\\\([\\da-f]{1,6}${lt}?|(${lt})|.)`, "ig");

        var At = (e, t, i) => {
            const n = `0x${t}` - 65536;
            return n !== n || i ? t : 0 > n ? String.fromCharCode(n + 65536) : String
              .fromCharCode(55296 | n >> 10, 56320 | 1023 & n)
        };

        try {
            ot.apply(tt = st.call(V.childNodes), V.childNodes), tt[V.childNodes.length].nodeType
        } catch (Et) {
            ot = {
                apply: tt.length ? (e, t) => {
                    nt.apply(e, st.call(t))
                } : (e, t) => {
                    for (var i = e.length, n = 0; e[i++] = t[n++];);
                    e.length = i - 1
                }
            }
        }
        I = i.isXML = e => {
            const t = e && (e.ownerDocument || e)
              .documentElement;
            return t ? "HTML" !== t.nodeName : !1
        }, S = i.support = {}, N = i.setDocument = e => {
            const t = e ? e.ownerDocument || e : V;
            return t !== L && 9 === t.nodeType && t.documentElement ? (L = t, O = t
              .documentElement, R = !I(t), S.attributes = a(e => (e.innerHTML = "<a href='#'></a>", r("type|href|height|width",
              c, "#" === e.firstChild.getAttribute("href")), r(rt, l,
              null == e.getAttribute("disabled")), e.className = "i", !e
              .getAttribute("className"))), S.input = a(e => (e.innerHTML = "<input>", e.firstChild.setAttribute("value",
              ""), "" === e.firstChild.getAttribute("value"))), r("value", u, S.attributes && S.input), S.getElementsByTagName = a(
              e => (e.appendChild(t.createComment("")), !e.getElementsByTagName(
                "*")
                .length)), S.getElementsByClassName = a(e => (e.innerHTML = "<div class='a'></div><div class='a i'></div>", e
              .firstChild.className = "i", 2 === e.getElementsByClassName("i")
              .length)), S.getById = a(e => (O.appendChild(e)
              .id = W, !t.getElementsByName || !t.getElementsByName(W)
              .length)), S.getById ? (E.find.ID = (e, t) => {
                if (typeof t.getElementById !== Q && R) {
                    const i = t.getElementById(e);
                    return i && i.parentNode ? [i] : []
                }
            }, E.filter.ID = e => {
                const t = e.replace(St, At);
                return e => e.getAttribute("id") === t;
            }) : (delete E.find.ID, E.filter.ID = e => {
                const t = e.replace(St, At);
                return e => {
                    const i = typeof e.getAttributeNode !== Q && e.getAttributeNode(
                      "id");
                    return i && i.value === t
                };
            }), E.find.TAG = S.getElementsByTagName ? (e, t) => typeof t.getElementsByTagName !== Q ? t.getElementsByTagName(e) :
              void 0 : (e, t) => {
                let i;
                const n = [];
                let o = 0;
                const s = t.getElementsByTagName(e);
                if ("*" === e) {
                    for (; i = s[o++];) 1 === i.nodeType && n.push(i);
                    return n
                }
                return s
            }, E.find.CLASS = S.getElementsByClassName && ((e, t) => typeof t.getElementsByClassName !== Q && R ? t
              .getElementsByClassName(e) : void 0), F = [], $ = [], (S.qsa = n(t.querySelectorAll)) && (a(e => {
                e.innerHTML = "<select><option selected=''></option></select>", e
                  .querySelectorAll("[selected]")
                  .length || $.push(`\\[${lt}*(?:value|${rt})`), e
                  .querySelectorAll(":checked")
                  .length || $.push(":checked")
            }), a(e => {
                const i = t.createElement("input");
                i.setAttribute("type", "hidden"), e.appendChild(i)
                  .setAttribute("t", ""), e.querySelectorAll("[t^='']")
                  .length && $.push(`[*^$]=${lt}*(?:''|"")`), e
                  .querySelectorAll(":enabled")
                  .length || $.push(":enabled", ":disabled"), e
                  .querySelectorAll("*,:x"), $.push(",.*:")
            })), (S.matchesSelector = n(B = O.webkitMatchesSelector || O
              .mozMatchesSelector || O.oMatchesSelector || O.msMatchesSelector)) && a(
              e => {
                  S.disconnectedMatch = B.call(e, "div"), B.call(e, "[s!='']:x"), F
                    .push("!=", pt)
              }), $ = $.length && new RegExp($.join("|")), F = F.length && new RegExp(F
              .join("|")), H = n(O.contains) || O.compareDocumentPosition ? (e, t) => {
                const i = 9 === e.nodeType ? e.documentElement : e;
                const n = t && t.parentNode;
                return e === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(
                  n) : e.compareDocumentPosition && 16 & e
                  .compareDocumentPosition(n)))
            } : (e, t) => {
                if (t)
                    for (; t = t.parentNode;)
                        if (t === e) return !0;
                return !1
            }, S.sortDetached = a(e => 1 & e.compareDocumentPosition(t.createElement("div"))), J = O.compareDocumentPosition ? (e, i) => {
                if (e === i) return Y = !0, 0;
                const n = i.compareDocumentPosition && e.compareDocumentPosition && e
                  .compareDocumentPosition(i);
                return n ? 1 & n || !S.sortDetached && i.compareDocumentPosition(e) ===
                n ? e === t || H(V, e) ? -1 : i === t || H(V, i) ? 1 : D ? at.call(D,
                  e) - at.call(D, i) : 0 : 4 & n ? -1 : 1 : e
                  .compareDocumentPosition ? -1 : 1
            } : (e, i) => {
                let n;
                let o = 0;
                const s = e.parentNode;
                const a = i.parentNode;
                const r = [e];
                const l = [i];
                if (e === i) return Y = !0, 0;
                if (!s || !a) return e === t ? -1 : i === t ? 1 : s ? -1 : a ? 1 : D ? at
                  .call(D, e) - at.call(D, i) : 0;
                if (s === a) return d(e, i);
                for (n = e; n = n.parentNode;) r.unshift(n);
                for (n = i; n = n.parentNode;) l.unshift(n);
                for (; r[o] === l[o];) o++;
                return o ? d(r[o], l[o]) : r[o] === V ? -1 : l[o] === V ? 1 : 0
            }, t) : L;
        }, i.matches = (e, t) => i(e, null, null, t), i.matchesSelector = (e, t) => {
            if ((e.ownerDocument || e) !== L && N(e), t = t.replace(vt, "='$1']"), !(!S
              .matchesSelector || !R || F && F.test(t) || $ && $.test(t))) try {
                const n = B.call(e, t);
                if (n || S.disconnectedMatch || e.document && 11 !== e.document.nodeType)
                    return n
            } catch (o) {}
            return i(t, L, null, [e])
              .length > 0
        }, i.contains = (e, t) => ((e.ownerDocument || e) !== L && N(e), H(e, t)), i.attr = (e, i) => {
            (e.ownerDocument || e) !== L && N(e);
            const n = E.attrHandle[i.toLowerCase()];
            let o = n && et.call(E.attrHandle, i.toLowerCase()) ? n(e, i, !R) : t;
            return o === t ? S.attributes || !R ? e.getAttribute(i) : (o = e.getAttributeNode(
              i)) && o.specified ? o.value : null : o
        }, i.error = e => {
            throw new Error(`Syntax error, unrecognized expression: ${e}`)
        }, i.uniqueSort = e => {
            let t;
            const i = [];
            let n = 0;
            let o = 0;
            if (Y = !S.detectDuplicates, D = !S.sortStable && e.slice(0), e.sort(J), Y) {
                for (; t = e[o++];) t === e[o] && (n = i.push(o));
                for (; n--;) e.splice(i[n], 1)
            }
            return e
        }, P = i.getText = e => {
            let t;
            let i = "";
            let n = 0;
            const o = e.nodeType;
            if (o) {
                if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) i += P(e)
                } else if (3 === o || 4 === o) return e.nodeValue
            } else
                for (; t = e[n]; n++) i += P(t);
            return i
        }, E = i.selectors = {
            cacheLength: 50,
            createPseudo: s,
            match: wt,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR(e) {
                    return e[1] = e[1].replace(St, At), e[3] = (e[4] || e[5] || "")
                      .replace(St, At), "~=" === e[2] && (e[3] = ` ${e[3]} `), e.slice(
                      0, 4);
                },
                CHILD(e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || i
                      .error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" ===
                      e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[
                      3])) : e[3] && i.error(e[0]), e
                },
                PSEUDO(e) {
                    let i;
                    const n = !e[5] && e[2];
                    return wt.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] :
                      n && bt.test(n) && (i = f(n, !0)) && (i = n.indexOf(")", n
                        .length - i) - n.length) && (e[0] = e[0].slice(0, i), e[2] = n
                        .slice(0, i)), e.slice(0, 3))
                }
            },
            filter: {
                TAG(e) {
                    const t = e.replace(St, At)
                      .toLowerCase();
                    return "*" === e ? () => !0 : ({nodeName}) => nodeName && nodeName.toLowerCase() === t;
                },
                CLASS(e) {
                    let t = Z[`${e} `];
                    return t || (t = new RegExp(`(^|${lt})${e}(${lt}|$)`)) &&
                      Z(e, e => t.test("string" == typeof e.className && e.className ||
                        typeof e.getAttribute !== Q && e.getAttribute(
                          "class") || ""));
                },
                ATTR(e, t, n) {
                    return o => {
                        let s = i.attr(o, e);
                        return null == s ? "!=" === t : t ? (s += "", "=" === t ? s ===
                          n : "!=" === t ? s !== n : "^=" === t ? n && 0 === s
                          .indexOf(n) : "*=" === t ? n && s.includes(n) :
                          "$=" === t ? n && s.slice(-n.length) === n : "~=" === t ?
                            ` ${s} `.includes(n) : "|=" === t ? s === n || s.slice(0, n
                              .length + 1) === `${n}-` : !1) : !0;
                    };
                },
                CHILD(e, t, i, n, o) {
                    const s = "nth" !== e.slice(0, 3);
                    const a = "last" !== e.slice(-4);
                    const r = "of-type" === t;
                    return 1 === n && 0 === o ? ({parentNode}) => !!parentNode : (t, i, l) => {
                        let c;
                        let u;
                        let d;
                        let h;
                        let p;
                        let m;

                        let f = s !== a ? "nextSibling" :
                          "previousSibling";

                        const _ = t.parentNode;
                        const g = r && t.nodeName.toLowerCase();
                        const v = !l && !r;
                        if (_) {
                            if (s) {
                                for (; f;) {
                                    for (d = t; d = d[f];)
                                        if (r ? d.nodeName.toLowerCase() === g : 1 === d
                                          .nodeType) return !1;
                                    m = f = "only" === e && !m && "nextSibling"
                                }
                                return !0
                            }
                            if (m = [a ? _.firstChild : _.lastChild], a && v) {
                                for (u = _[W] || (_[W] = {}), c = u[e] || [], p = c[0] ===
                                  q && c[1], h = c[0] === q && c[2], d = p && _
                                  .childNodes[p]; d = ++p && d && d[f] || (h = p = 0) ||
                                  m.pop();)
                                    if (1 === d.nodeType && ++h && d === t) {
                                        u[e] = [q, p, h];
                                        break
                                    }
                            } else if (v && (c = (t[W] || (t[W] = {}))[e]) && c[0] === q)
                                h = c[1];
                            else
                                for (;
                                  (d = ++p && d && d[f] || (h = p = 0) || m.pop()) && ((
                                    r ? d.nodeName.toLowerCase() !== g : 1 !== d
                                      .nodeType) || !++h || (v && ((d[W] || (d[
                                    W] = {}))[e] = [q, h]), d !== t)););
                            return h -= o, h === n || 0 === h % n && h / n >= 0
                        }
                    };
                },
                PSEUDO(e, t) {
                    let n;

                    const o = E.pseudos[e] || E.setFilters[e.toLowerCase()] || i.error(
                      `unsupported pseudo: ${e}`);

                    return o[W] ? o(t) : o.length > 1 ? (n = [e, e, "", t], E.setFilters
                      .hasOwnProperty(e.toLowerCase()) ? s((e, i) => {
                        for (let n, s = o(e, t), a = s.length; a--;) n = at.call(
                          e, s[a]), e[n] = !(i[n] = s[a])
                    }) : e => o(e, 0, n)) : o;
                }
            },
            pseudos: {
                not: s(e => {
                    const t = [];
                    const i = [];
                    const n = M(e.replace(mt, "$1"));
                    return n[W] ? s((e, t, i, o) => {
                        for (let s, a = n(e, null, o, []), r = e.length; r--;)(s =
                          a[r]) && (e[r] = !(t[r] = s))
                    }) : (e, o, s) => (t[0] = e, n(t, null, s, i), !i.pop());
                }),
                has: s(e => t => i(e, t)
                  .length > 0),
                contains: s(e => t => (t.textContent || t.innerText || P(t)).includes(e)),
                lang: s(e => (yt.test(e || "") || i.error(`unsupported lang: ${e}`), e = e
                  .replace(St, At)
                  .toLowerCase(), t => {
                    let i;
                    do
                        if (i = R ? t.lang : t.getAttribute("xml:lang") || t
                          .getAttribute("lang")) return i = i.toLowerCase(),
                        i === e || 0 === i.indexOf(`${e}-`); while ((t = t
                      .parentNode) && 1 === t.nodeType);
                    return !1
                })),
                target({id}) {
                    const i = e.location && e.location.hash;
                    return i && i.slice(1) === id;
                },
                root(e) {
                    return e === O
                },
                focus(e) {
                    return e === L.activeElement && (!L.hasFocus || L.hasFocus()) && !!(e
                      .type || e.href || ~e.tabIndex)
                },
                enabled({disabled}) {
                    return disabled === !1;
                },
                disabled({disabled}) {
                    return disabled === !0;
                },
                checked({nodeName, checked, selected}) {
                    const t = nodeName.toLowerCase();
                    return "input" === t && !!checked || "option" === t && !!selected;
                },
                selected({parentNode, selected}) {
                    return parentNode && parentNode.selectedIndex, selected === !0;
                },
                empty(e) {
                    for (e = e.firstChild; e; e = e.nextSibling)
                        if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType) return !
                          1;
                    return !0
                },
                parent(e) {
                    return !E.pseudos.empty(e)
                },
                header({nodeName}) {
                    return zt.test(nodeName);
                },
                input({nodeName}) {
                    return Ct.test(nodeName);
                },
                button({nodeName, type}) {
                    const t = nodeName.toLowerCase();
                    return "input" === t && "button" === type || "button" === t;
                },
                text(e) {
                    let t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (
                      null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type
                    )
                },
                first: m(() => [0]),
                last: m((e, t) => [t - 1]),
                eq: m((e, t, i) => [0 > i ? i + t : i]),
                even: m((e, t) => {
                    for (let i = 0; t > i; i += 2) e.push(i);
                    return e
                }),
                odd: m((e, t) => {
                    for (let i = 1; t > i; i += 2) e.push(i);
                    return e
                }),
                lt: m((e, t, i) => {
                    for (let n = 0 > i ? i + t : i; --n >= 0;) e.push(n);
                    return e
                }),
                gt: m((e, t, i) => {
                    for (let n = 0 > i ? i + t : i; ++n < t;) e.push(n);
                    return e
                })
            }
        };
        for (T in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) E.pseudos[T] = h(T);
        for (T in {
            submit: !0,
            reset: !0
        }) E.pseudos[T] = p(T);
        M = i.compile = (e, t) => {
            let i;
            const n = [];
            const o = [];
            let s = K[`${e} `];
            if (!s) {
                for (t || (t = f(e)), i = t.length; i--;) s = w(t[i]), s[W] ? n.push(s) : o.push(
                  s);
                s = K(e, k(o, n))
            }
            return s
        }, E.pseudos.nth = E.pseudos.eq, z.prototype = E.filters = E.pseudos, E.setFilters =
          new z, S.sortStable = W.split("")
          .sort(J)
          .join("") === W, N(), [0, 0].sort(J), S.detectDuplicates = Y, ut.find = i, ut.expr = i
          .selectors, ut.expr[":"] = ut.expr.pseudos, ut.unique = i.uniqueSort, ut.text = i.getText,
          ut.isXMLDoc = i.isXML, ut.contains = i.contains
    })(e);
    var zt = {};
    ut.Callbacks = e => {
        e = "string" == typeof e ? zt[e] || n(e) : ut.extend({}, e);
        let i;
        let o;
        let s;
        let a;
        let r;
        let l;
        let c = [];
        let u = !e.once && [];

        const d = t => {
            for (o = e.memory && t, s = !0, r = l || 0, l = 0, a = c.length, i = !0; c && a >
            r; r++)
                if (c[r].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
                    o = !1;
                    break
                } i = !1, c && (u ? u.length && d(u.shift()) : o ? c = [] : h.disable())
        };

        var h = {
            add(...args) {
                if (c) {
                    const t = c.length;
                    ! function n(t) {
                        ut.each(t, (t, i) => {
                            const o = ut.type(i);
                            "function" === o ? e.unique && h.has(i) || c.push(i) :
                              i && i.length && "string" !== o && n(i)
                        })
                    }(args), i ? a = c.length : o && (l = t, d(o))
                }
                return this
            },
            remove(...args) {
                return c && ut.each(args, (e, t) => {
                    for (let n;
                         (n = ut.inArray(t, c, n)) > -1;) c.splice(n, 1), i && (a >=
                    n && a--, r >= n && r--)
                }), this;
            },
            has(e) {
                return e ? ut.inArray(e, c) > -1 : !(!c || !c.length)
            },
            empty() {
                return c = [], a = 0, this
            },
            disable() {
                return c = u = o = t, this
            },
            disabled() {
                return !c
            },
            lock() {
                return u = t, o || h.disable(), this
            },
            locked() {
                return !u
            },
            fireWith(e, t) {
                return t = t || [], t = [e, t.slice ? t.slice() : t], !c || s && !u || (i ? u
                  .push(t) : d(t)), this
            },
            fire(...args) {
                return h.fireWith(this, args), this;
            },
            fired() {
                return !!s
            }
        };

        return h
    }, ut.extend({
        Deferred(e) {
            const t = [["resolve", "done", ut.Callbacks("once memory"), "resolved"], ["reject",
                  "fail", ut.Callbacks("once memory"), "rejected"], ["notify",
                  "progress", ut.Callbacks("memory")]];

            let i = "pending";

            const n = {
                state() {
                    return i
                },
                always(...args) {
                    return o.done(args)
                      .fail(args), this;
                },
                then(...args) {
                    let e = args;
                    return ut.Deferred(i => {
                        ut.each(t, (t, s) => {
                            const a = s[0], r = ut.isFunction(e[t]) && e[t];
                            o[s[1]](function(...args) {
                                const e = r && r.apply(this,
                                  args);
                                e && ut.isFunction(e
                                  .promise) ? e.promise()
                                  .done(i.resolve)
                                  .fail(i.reject)
                                  .progress(i.notify) : i[
                                `${a}With`](this ===
                                n ? i.promise() :
                                  this, r ? [e] :
                                  args)
                            })
                        }), e = null
                    })
                      .promise();
                },
                promise(e) {
                    return null != e ? ut.extend(e, n) : n
                }
            };

            var o = {};
            return n.pipe = n.then, ut.each(t, (e, s) => {
                const a = s[2];
                const r = s[3];
                n[s[1]] = a.add, r && a.add(() => {
                    i = r
                }, t[1 ^ e][2].disable, t[2][2].lock), o[s[0]] = function(...args) {
                    return o[`${s[0]}With`](this === o ? n : this, args),
                      this;
                }, o[`${s[0]}With`] = a.fireWith
            }), n.promise(o), e && e.call(o, o), o;
        },
        when(e) {
            let t;
            let i;
            let n;
            let o = 0;
            const s = st.call(arguments);
            const a = s.length;
            let r = 1 !== a || e && ut.isFunction(e.promise) ? a : 0;
            const l = 1 === r ? e : ut.Deferred();

            const c = (e, i, n) => (function(o) {
                i[e] = this, n[e] = arguments.length > 1 ? st.call(arguments) : o,
                  n === t ? l.notifyWith(i, n) : --r || l.resolveWith(i, n)
            });

            if (a > 1)
                for (t = new Array(a), i = new Array(a), n = new Array(a); a > o; o++) s[o] &&
                ut.isFunction(s[o].promise) ? s[o].promise()
                  .done(c(o, n, s))
                  .fail(l.reject)
                  .progress(c(o, i, t)) : --r;
            return r || l.resolveWith(n, s), l.promise()
        }
    }), ut.support = (t => {
        let i;
        let n;
        let o;
        let s;
        let a;
        let r;
        let l;
        let c;
        let u;
        let d = Y.createElement("div");
        if (d.setAttribute("className", "t"), d.innerHTML =
          "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", i = d
          .getElementsByTagName("*") || [], n = d.getElementsByTagName("a")[0], !n || !n.style || !i
          .length) return t;
        s = Y.createElement("select"), r = s.appendChild(Y.createElement("option")), o = d
          .getElementsByTagName("input")[0], n.style.cssText = "top:1px;float:left;opacity:.5", t
          .getSetAttribute = "t" !== d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType,
          t.tbody = !d.getElementsByTagName("tbody")
            .length, t.htmlSerialize = !!d.getElementsByTagName("link")
          .length, t.style = /top/.test(n.getAttribute("style")), t.hrefNormalized = "/a" === n
          .getAttribute("href"), t.opacity = /^0.5/.test(n.style.opacity), t.cssFloat = !!n.style
          .cssFloat, t.checkOn = !!o.value, t.optSelected = r.selected, t.enctype = !!Y
          .createElement("form")
          .enctype, t.html5Clone = "<:nav></:nav>" !== Y.createElement("nav")
          .cloneNode(!0)
          .outerHTML, t.inlineBlockNeedsLayout = !1, t.shrinkWrapBlocks = !1, t.pixelPosition = !1,
          t.deleteExpando = !0, t.noCloneEvent = !0, t.reliableMarginRight = !0, t
          .boxSizingReliable = !0, o.checked = !0, t.noCloneChecked = o.cloneNode(!0)
          .checked, s.disabled = !0, t.optDisabled = !r.disabled;
        try {
            delete d.test
        } catch (h) {
            t.deleteExpando = !1
        }
        o = Y.createElement("input"), o.setAttribute("value", ""), t.input = "" === o.getAttribute(
          "value"), o.value = "t", o.setAttribute("type", "radio"), t.radioValue = "t" === o
          .value, o.setAttribute("checked", "t"), o.setAttribute("name", "t"), a = Y
          .createDocumentFragment(), a.appendChild(o), t.appendChecked = o.checked, t.checkClone = a
          .cloneNode(!0)
          .cloneNode(!0)
          .lastChild.checked, d.attachEvent && (d.attachEvent("onclick", () => {
            t.noCloneEvent = !1
        }), d.cloneNode(!0)
          .click());
        for (u in {
            submit: !0,
            change: !0,
            focusin: !0
        }) d.setAttribute(l = `on${u}`, "t"), t[`${u}Bubbles`] = l in e || d.attributes[l]
          .expando === !1;
        d.style.backgroundClip = "content-box", d.cloneNode(!0)
          .style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip;
        for (u in ut(t)) break;
        return t.ownLast = "0" !== u, ut(() => {
            let i;
            let n;
            let o;

            const s =
                "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;";

            const a = Y.getElementsByTagName("body")[0];
            a && (i = Y.createElement("div"), i.style.cssText =
              "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",
              a.appendChild(i)
                .appendChild(d), d.innerHTML =
              "<table><tr><td></td><td>t</td></tr></table>", o = d.getElementsByTagName(
              "td"), o[0].style.cssText =
              "padding:0;margin:0;border:0;display:none", c = 0 === o[0].offsetHeight,
              o[0].style.display = "", o[1].style.display = "none", t
              .reliableHiddenOffsets = c && 0 === o[0].offsetHeight, d.innerHTML = "", d
              .style.cssText =
              "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",
              ut.swap(a, null != a.style.zoom ? {
                  zoom: 1
              } : {}, () => {
                  t.boxSizing = 4 === d.offsetWidth
              }), e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(
              d, null) || {})
              .top, t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) ||
              {
                  width: "4px"
              })
              .width, n = d.appendChild(Y.createElement("div")), n.style.cssText = d
              .style.cssText = s, n.style.marginRight = n.style.width = "0", d.style
              .width = "1px", t.reliableMarginRight = !parseFloat((e
              .getComputedStyle(n, null) || {})
              .marginRight)), typeof d.style.zoom !== G && (d.innerHTML = "", d
              .style.cssText = `${s}width:1px;padding:1px;display:inline;zoom:1`, t
              .inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =
              "block", d.innerHTML = "<div></div>", d.firstChild.style.width =
              "5px", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t
              .inlineBlockNeedsLayout && (a.style.zoom = 1)), a.removeChild(i), i =
              d = o = n = null)
        }), i = s = a = r = n = o = null, t;
    })({});
    var Tt = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/;
    var St = /([A-Z])/g;
    ut.extend({
        cache: {},
        noData: {
            applet: !0,
            embed: !0,
            object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData(e) {
            return e = e.nodeType ? ut.cache[e[ut.expando]] : e[ut.expando], !!e && !r(e)
        },
        data(e, t, i) {
            return o(e, t, i)
        },
        removeData(e, t) {
            return s(e, t)
        },
        _data(e, t, i) {
            return o(e, t, i, !0)
        },
        _removeData(e, t) {
            return s(e, t, !0)
        },
        acceptData(e) {
            if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType) return !1;
            const t = e.nodeName && ut.noData[e.nodeName.toLowerCase()];
            return !t || t !== !0 && e.getAttribute("classid") === t
        }
    }), ut.fn.extend({
        data(e, i) {
            let n;
            let o;
            let s = null;
            let r = 0;
            const l = this[0];
            if (e === t) {
                if (this.length && (s = ut.data(l), 1 === l.nodeType && !ut._data(l,
                  "parsedAttrs"))) {
                    for (n = l.attributes; r < n.length; r++) o = n[r].name, 0 === o.indexOf(
                      "data-") && (o = ut.camelCase(o.slice(5)), a(l, o, s[o]));
                    ut._data(l, "parsedAttrs", !0)
                }
                return s
            }
            return "object" == typeof e ? this.each(function () {
                ut.data(this, e)
            }) : arguments.length > 1 ? this.each(function () {
                ut.data(this, e, i)
            }) : l ? a(l, e, ut.data(l, e)) : null
        },
        removeData(e) {
            return this.each(function () {
                ut.removeData(this, e)
            })
        }
    }), ut.extend({
        queue(e, t, i) {
            let n;
            return e ? (t = `${t || "fx"}queue`, n = ut._data(e, t), i && (!n || ut.isArray(
              i) ? n = ut._data(e, t, ut.makeArray(i)) : n.push(i)), n || []) : void 0;
        },
        dequeue(e, t = "fx") {
            const i = ut.queue(e, t);
            let n = i.length;
            let o = i.shift();
            const s = ut._queueHooks(e, t);

            const a = () => {
                ut.dequeue(e, t)
            };

            "inprogress" === o && (o = i.shift(), n--), s.cur = o, o && ("fx" === t && i
              .unshift("inprogress"), delete s.stop, o.call(e, a, s)), !n && s && s
              .empty.fire()
        },
        _queueHooks(e, t) {
            const i = `${t}queueHooks`;
            return ut._data(e, i) || ut._data(e, i, {
                empty: ut.Callbacks("once memory")
                  .add(() => {
                      ut._removeData(e, `${t}queue`), ut._removeData(e, i)
                  })
            });
        }
    }), ut.fn.extend({
        queue(e, i) {
            let n = 2;
            return "string" != typeof e && (i = e, e = "fx", n--), arguments.length < n ? ut
              .queue(this[0], e) : i === t ? this : this.each(function () {
                const t = ut.queue(this, e, i);
                ut._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && ut
                  .dequeue(this, e)
            });
        },
        dequeue(e) {
            return this.each(function () {
                ut.dequeue(this, e)
            })
        },
        delay(e, t) {
            return e = ut.fx ? ut.fx.speeds[e] || e : e, t = t || "fx", this.queue(t,
              (t, i) => {
                  const n = setTimeout(t, e);
                  i.stop = () => {
                      clearTimeout(n)
                  }
              });
        },
        clearQueue(e) {
            return this.queue(e || "fx", [])
        },
        promise(e, i) {
            let n;
            let o = 1;
            const s = ut.Deferred();
            const a = this;
            let r = this.length;

            const l = () => {
                --o || s.resolveWith(a, [a])
            };

            for ("string" != typeof e && (i = e, e = t), e = e || "fx"; r--;) n = ut._data(a[
              r], `${e}queueHooks`), n && n.empty && (o++, n.empty.add(l));
            return l(), s.promise(i)
        }
    });
    let At;
    var Et;
    const Pt = /[\t\r\n\f]/g;
    const It = /\r/g;
    const Mt = /^(?:input|select|textarea|button|object)$/i;
    const jt = /^(?:a|area)$/i;
    const Dt = /^(?:checked|selected)$/i;
    const Nt = ut.support.getSetAttribute;
    const Lt = ut.support.input;
    ut.fn.extend({
        attr(e, t) {
            return ut.access(this, ut.attr, e, t, arguments.length > 1)
        },
        removeAttr(e) {
            return this.each(function () {
                ut.removeAttr(this, e)
            })
        },
        prop(e, t) {
            return ut.access(this, ut.prop, e, t, arguments.length > 1)
        },
        removeProp(e) {
            return e = ut.propFix[e] || e, this.each(function () {
                try {
                    this[e] = t, delete this[e]
                } catch (i) {}
            })
        },
        addClass(e) {
            let t;
            let i;
            let n;
            let o;
            let s;
            let a = 0;
            const r = this.length;
            const l = "string" == typeof e && e;
            if (ut.isFunction(e)) return this.each(function (t) {
                ut(this)
                  .addClass(e.call(this, t, this.className))
            });
            if (l)
                for (t = (e || "")
                  .match(ht) || []; r > a; a++)
                    if (i = this[a], n = 1 === i.nodeType && (i.className ? (` ${i
  .className} `)
                      .replace(Pt, " ") : " ")) {
                        for (s = 0; o = t[s++];) !n.includes(` ${o} `) && (n += `${o} `);
                        i.className = ut.trim(n)
                    }return this
        },
        removeClass(e) {
            let t;
            let i;
            let n;
            let o;
            let s;
            let a = 0;
            const r = this.length;
            const l = 0 === arguments.length || "string" == typeof e && e;
            if (ut.isFunction(e)) return this.each(function (t) {
                ut(this)
                  .removeClass(e.call(this, t, this.className))
            });
            if (l)
                for (t = (e || "")
                  .match(ht) || []; r > a; a++)
                    if (i = this[a], n = 1 === i.nodeType && (i.className ? (` ${i
  .className} `)
                      .replace(Pt, " ") : "")) {
                        for (s = 0; o = t[s++];)
                            for (; n.includes(` ${o} `);) n = n.replace(` ${o} `, " ");
                        i.className = e ? ut.trim(n) : ""
                    }return this
        },
        toggleClass(e, t) {
            const i = typeof e;
            const n = "boolean" == typeof t;
            return ut.isFunction(e) ? this.each(function (i) {
                ut(this)
                  .toggleClass(e.call(this, i, this.className, t), t)
            }) : this.each(function () {
                if ("string" === i)
                    for (let o, s = 0, a = ut(this), r = t, l = e.match(ht) || []; o =
                      l[s++];) r = n ? r : !a.hasClass(o), a[r ? "addClass" :
                      "removeClass"](o);
                else(i === G || "boolean" === i) && (this.className && ut._data(this,
                  "__className__", this.className), this.className = this
                  .className || e === !1 ? "" : ut._data(this,
                  "__className__") || "")
            });
        },
        hasClass(e) {
            for (let t = ` ${e} `, i = 0, n = this.length; n > i; i++)
                if (1 === this[i].nodeType && (` ${this[i].className} `)
                  .replace(Pt, " ").includes(t)) return !0;
            return !1
        },
        val(e) {
            let i;
            let n;
            let o;
            const s = this[0];
            {
                    if (arguments.length) return o = ut.isFunction(e), this.each(function (i) {
                        let s;
                        1 === this.nodeType && (s = o ? e.call(this, i, ut(this)
                          .val()) : e, null == s ? s = "" : "number" ==
                        typeof s ? s += "" : ut.isArray(s) && (s = ut.map(s,
                          e => null == e ? "" : `${e}`)), n = ut.valHooks[this.type] || ut.valHooks[
                          this.nodeName.toLowerCase()], n && "set" in n && n
                          .set(this, s, "value") !== t || (this.value = s))
                    });
                    if (s) return n = ut.valHooks[s.type] || ut.valHooks[s.nodeName
                      .toLowerCase()], n && "get" in n && (i = n.get(s, "value")) !== t ? i : (
                      i = s.value, "string" == typeof i ? i.replace(It, "") : null ==
                      i ? "" : i)
                }
        }
    }), ut.extend({
        valHooks: {
            option: {
                get(e) {
                    const t = ut.find.attr(e, "value");
                    return null != t ? t : e.text
                }
            },
            select: {
                get({options, selectedIndex, type}) {
                    for (var t, i, n = options, o = selectedIndex, s = "select-one" === type || 0 > o, a = s ? null : [], r = s ? o + 1 : n.length, l =
                      0 > o ? r : s ? o : 0; r > l; l++)
                        if (i = n[l], !(!i.selected && l !== o || (ut.support.optDisabled ? i
                            .disabled : null !== i.getAttribute("disabled")) || i
                            .parentNode.disabled && ut.nodeName(i.parentNode, "optgroup")
                        )) {
                            if (t = ut(i)
                              .val(), s) return t;
                            a.push(t)
                        } return a
                },
                set(e, t) {
                    for (var i, n, o = e.options, s = ut.makeArray(t), a = o.length; a--;) n =
                      o[a], (n.selected = ut.inArray(ut(n)
                      .val(), s) >= 0) && (i = !0);
                    return i || (e.selectedIndex = -1), s
                }
            }
        },
        attr(e, i, n) {
            let o;
            let s;
            const a = e.nodeType;
            if (e && 3 !== a && 8 !== a && 2 !== a) return typeof e.getAttribute === G ? ut
              .prop(e, i, n) : (1 === a && ut.isXMLDoc(e) || (i = i.toLowerCase(), o =
              ut.attrHooks[i] || (ut.expr.match.bool.test(i) ? Et : At)), n ===
            t ? o && "get" in o && null !== (s = o.get(e, i)) ? s : (s = ut.find
              .attr(e, i), null == s ? t : s) : null !== n ? o && "set" in o &&
            (s = o.set(e, n, i)) !== t ? s : (e.setAttribute(i, `${n}`), n) : (ut
              .removeAttr(e, i), void 0));
        },
        removeAttr(e, t) {
            let i;
            let n;
            let o = 0;
            const s = t && t.match(ht);
            if (s && 1 === e.nodeType)
                for (; i = s[o++];) n = ut.propFix[i] || i, ut.expr.match.bool.test(i) ? Lt &&
                Nt || !Dt.test(i) ? e[n] = !1 : e[ut.camelCase(`default-${i}`)] = e[n] = !
                  1 : ut.attr(e, i, ""), e.removeAttribute(Nt ? i : n)
        },
        attrHooks: {
            type: {
                set(e, t) {
                    if (!ut.support.radioValue && "radio" === t && ut.nodeName(e, "input")) {
                        const i = e.value;
                        return e.setAttribute("type", t), i && (e.value = i), t
                    }
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop(e, i, n) {
            let o;
            let s;
            let a;
            const r = e.nodeType;
            if (e && 3 !== r && 8 !== r && 2 !== r) return a = 1 !== r || !ut.isXMLDoc(e),
            a && (i = ut.propFix[i] || i, s = ut.propHooks[i]), n !== t ? s &&
            "set" in s && (o = s.set(e, n, i)) !== t ? o : e[i] = n : s && "get" in
            s && null !== (o = s.get(e, i)) ? o : e[i]
        },
        propHooks: {
            tabIndex: {
                get(e) {
                    const t = ut.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : Mt.test(e.nodeName) || jt.test(e.nodeName) &&
                    e.href ? 0 : -1
                }
            }
        }
    }), Et = {
        set(e, t, i) {
            return t === !1 ? ut.removeAttr(e, i) : Lt && Nt || !Dt.test(i) ? e.setAttribute(!
              Nt && ut.propFix[i] || i, i) : e[ut.camelCase(`default-${i}`)] = e[i] = !0, i;
        }
    }, ut.each(ut.expr.match.bool.source.match(/\w+/g), (e, i) => {
        const n = ut.expr.attrHandle[i] || ut.find.attr;
        ut.expr.attrHandle[i] = Lt && Nt || !Dt.test(i) ? (e, i, o) => {
            const s = ut.expr.attrHandle[i];

            const a = o ? t : (ut.expr.attrHandle[i] = t) != n(e, i, o) ? i.toLowerCase() :
              null;

            return ut.expr.attrHandle[i] = s, a
        } : (e, i, n) => n ? t : e[ut.camelCase(`default-${i}`)] ? i.toLowerCase() : null
    }), Lt && Nt || (ut.attrHooks.value = {
        set(e, t, i) {
            return ut.nodeName(e, "input") ? (e.defaultValue = t, void 0) : At && At.set(e, t,
              i)
        }
    }), Nt || (At = {
        set(e, i, n) {
            let o = e.getAttributeNode(n);
            return o || e.setAttributeNode(o = e.ownerDocument.createAttribute(n)), o.value =
              i += "", "value" === n || i === e.getAttribute(n) ? i : t
        }
    }, ut.expr.attrHandle.id = ut.expr.attrHandle.name = ut.expr.attrHandle.coords = (e, i, n) => {
        let o;
        return n ? t : (o = e.getAttributeNode(i)) && "" !== o.value ? o.value : null
    }, ut.valHooks.button = {
        get(e, i) {
            const n = e.getAttributeNode(i);
            return n && n.specified ? n.value : t
        },
        set: At.set
    }, ut.attrHooks.contenteditable = {
        set(e, t, i) {
            At.set(e, "" === t ? !1 : t, i)
        }
    }, ut.each(["width", "height"], (e, t) => {
        ut.attrHooks[t] = {
            set(e, i) {
                return "" === i ? (e.setAttribute(t, "auto"), i) : void 0
            }
        }
    })), ut.support.hrefNormalized || ut.each(["href", "src"], (e, t) => {
        ut.propHooks[t] = {
            get(e) {
                return e.getAttribute(t, 4)
            }
        }
    }), ut.support.style || (ut.attrHooks.style = {
        get({style}) {
            return style.cssText || t;
        },
        set({style}, t) {
            return style.cssText = `${t}`;
        }
    }), ut.support.optSelected || (ut.propHooks.selected = {
        get({parentNode}) {
            const t = parentNode;
            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null
        }
    }), ut.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan",
        "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        ut.propFix[this.toLowerCase()] = this
    }), ut.support.enctype || (ut.propFix.enctype = "encoding"), ut.each(["radio", "checkbox"],
      function () {
          ut.valHooks[this] = {
              set(e, t) {
                  return ut.isArray(t) ? e.checked = ut.inArray(ut(e)
                    .val(), t) >= 0 : void 0
              }
          }, ut.support.checkOn || (ut.valHooks[this].get = e => null === e.getAttribute("value") ? "on" : e.value)
      });
    const Ot = /^(?:input|select|textarea)$/i;
    const Rt = /^key/;
    const $t = /^(?:mouse|contextmenu)|click/;
    const Ft = /^(?:focusinfocus|focusoutblur)$/;
    const Bt = /^([^.]*)(?:\.(.+)|)$/;
    ut.event = {
        global: {},
        add(e, i, n, o, s) {
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            let f;
            let _;
            const g = ut._data(e);
            if (g) {
                for (n.handler && (c = n, n = c.handler, s = c.selector), n.guid || (n.guid = ut
                  .guid++), (r = g.events) || (r = g.events = {}), (d = g.handle) || (d = g
                  .handle = function (e) {
                    return typeof ut === G || e && ut.event.triggered === e.type ? t : ut
                      .event.dispatch.apply(d.elem, arguments)
                }, d.elem = e), i = (i || "")
                  .match(ht) || [""], l = i.length; l--;) a = Bt.exec(i[l]) || [], m = _ = a[1],
                  f = (a[2] || "")
                    .split(".")
                    .sort(), m && (u = ut.event.special[m] || {}, m = (s ? u.delegateType : u
                  .bindType) || m, u = ut.event.special[m] || {}, h = ut.extend({
                    type: m,
                    origType: _,
                    data: o,
                    handler: n,
                    guid: n.guid,
                    selector: s,
                    needsContext: s && ut.expr.match.needsContext.test(s),
                    namespace: f.join(".")
                }, c), (p = r[m]) || (p = r[m] = [], p.delegateCount = 0, u.setup && u
                  .setup.call(e, o, f, d) !== !1 || (e.addEventListener ? e
                  .addEventListener(m, d, !1) : e.attachEvent && e.attachEvent(
                  `on${m}`, d))), u.add && (u.add.call(e, h), h.handler.guid ||
                (h.handler.guid = n.guid)), s ? p.splice(p.delegateCount++, 0, h) : p
                  .push(h), ut.event.global[m] = !0);
                e = null
            }
        },
        remove(e, t, i, n, o) {
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            let f;
            const _ = ut.hasData(e) && ut._data(e);
            if (_ && (u = _.events)) {
                for (t = (t || "")
                  .match(ht) || [""], c = t.length; c--;)
                    if (r = Bt.exec(t[c]) || [], p = f = r[1], m = (r[2] || "")
                      .split(".")
                      .sort(), p) {
                        for (d = ut.event.special[p] || {}, p = (n ? d.delegateType : d
                          .bindType) || p, h = u[p] || [], r = r[2] && new RegExp(`(^|\\.)${m
  .join("\\.(?:.*\\.|)")}(\\.|$)`), l = s = h.length; s--;) a =
                          h[s], !o && f !== a.origType || i && i.guid !== a.guid || r && !r
                          .test(a.namespace) || n && n !== a.selector && ("**" !== n || !a
                          .selector) || (h.splice(s, 1), a.selector && h.delegateCount--, d
                          .remove && d.remove.call(e, a));
                        l && !h.length && (d.teardown && d.teardown.call(e, m, _.handle) !== !1 ||
                        ut.removeEvent(e, p, _.handle), delete u[p])
                    } else
                        for (p in u) ut.event.remove(e, p + t[c], i, n, !0);
                ut.isEmptyObject(u) && (delete _.handle, ut._removeData(e, "events"))
            }
        },
        trigger(i, n, o, s) {
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            const p = [o || Y];
            let m = lt.call(i, "type") ? i.type : i;
            let f = lt.call(i, "namespace") ? i.namespace.split(".") : [];
            if (l = d = o = o || Y, 3 !== o.nodeType && 8 !== o.nodeType && !Ft.test(m + ut.event
              .triggered) && (m.includes(".") && (f = m.split("."), m = f.shift(), f
              .sort()), r = !m.includes(":") && `on${m}`, i = i[ut.expando] ? i :
              new ut.Event(m, "object" == typeof i && i), i.isTrigger = s ? 2 : 3, i
              .namespace = f.join("."), i.namespace_re = i.namespace ? new RegExp(
              `(^|\\.)${f.join("\\.(?:.*\\.|)")}(\\.|$)`) : null, i.result = t, i
              .target || (i.target = o), n = null == n ? [i] : ut.makeArray(n, [i]), u = ut
              .event.special[m] || {}, s || !u.trigger || u.trigger.apply(o, n) !== !1)) {
                if (!s && !u.noBubble && !ut.isWindow(o)) {
                    for (c = u.delegateType || m, Ft.test(c + m) || (l = l.parentNode); l; l = l
                      .parentNode) p.push(l), d = l;
                    d === (o.ownerDocument || Y) && p.push(d.defaultView || d.parentWindow || e)
                }
                for (h = 0;
                     (l = p[h++]) && !i.isPropagationStopped();) i.type = h > 1 ? c : u.bindType ||
                  m, a = (ut._data(l, "events") || {})[i.type] && ut._data(l, "handle"), a && a
                  .apply(l, n), a = r && l[r], a && ut.acceptData(l) && a.apply && a.apply(l,
                  n) === !1 && i.preventDefault();
                if (i.type = m, !s && !i.isDefaultPrevented() && (!u._default || u._default.apply(
                  p.pop(), n) === !1) && ut.acceptData(o) && r && o[m] && !ut.isWindow(o)) {
                    d = o[r], d && (o[r] = null), ut.event.triggered = m;
                    try {
                        o[m]()
                    } catch (_) {}
                    ut.event.triggered = t, d && (o[r] = d)
                }
                return i.result
            }
        },
        dispatch(e) {
            e = ut.event.fix(e);
            let i;
            let n;
            let o;
            let s;
            let a;
            let r = [];
            const l = st.call(arguments);
            const c = (ut._data(this, "events") || {})[e.type] || [];
            const u = ut.event.special[e.type] || {};
            if (l[0] = e, e.delegateTarget = this, !u.preDispatch || u.preDispatch.call(this,
              e) !== !1) {
                for (r = ut.event.handlers.call(this, e, c), i = 0;
                     (s = r[i++]) && !e.isPropagationStopped();)
                    for (e.currentTarget = s.elem, a = 0;
                         (o = s.handlers[a++]) && !e.isImmediatePropagationStopped();)(!e
                      .namespace_re || e.namespace_re.test(o.namespace)) && (e.handleObj =
                      o, e.data = o.data, n = ((ut.event.special[o.origType] || {})
                      .handle || o.handler)
                      .apply(s.elem, l), n !== t && (e.result = n) === !1 && (e
                      .preventDefault(), e.stopPropagation()));
                return u.postDispatch && u.postDispatch.call(this, e), e.result
            }
        },
        handlers(e, i) {
            let n;
            let o;
            let s;
            let a;
            const r = [];
            const l = i.delegateCount;
            let c = e.target;
            if (l && c.nodeType && (!e.button || "click" !== e.type))
                for (; c != this; c = c.parentNode || this)
                    if (1 === c.nodeType && (c.disabled !== !0 || "click" !== e.type)) {
                        for (s = [], a = 0; l > a; a++) o = i[a], n = `${o.selector} `, s[n] ===
                        t && (s[n] = o.needsContext ? ut(n, this)
                          .index(c) >= 0 : ut.find(n, this, null, [c])
                          .length), s[n] && s.push(o);
                        s.length && r.push({
                            elem: c,
                            handlers: s
                        })
                    }return l < i.length && r.push({
                    elem: this,
                    handlers: i.slice(l)
                }), r
        },
        fix(e) {
            if (e[ut.expando]) return e;
            let t;
            let i;
            let n;
            const o = e.type;
            const s = e;
            let a = this.fixHooks[o];
            for (a || (this.fixHooks[o] = a = $t.test(o) ? this.mouseHooks : Rt.test(o) ? this
              .keyHooks : {}), n = a.props ? this.props.concat(a.props) : this.props, e =
              new ut.Event(s), t = n.length; t--;) i = n[t], e[i] = s[i];
            return e.target || (e.target = s.srcElement || Y), 3 === e.target.nodeType && (e
              .target = e.target.parentNode), e.metaKey = !!e.metaKey, a.filter ? a.filter(
              e, s) : e
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which"
          .split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter(e, {charCode, keyCode}) {
                return null == e.which && (e.which = null != charCode ? charCode : keyCode),
                  e;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement"
              .split(" "),
            filter(e, i) {
                let n;
                let o;
                let s;
                const a = i.button;
                const r = i.fromElement;
                return null == e.pageX && null != i.clientX && (o = e.target.ownerDocument || Y,
                  s = o.documentElement, n = o.body, e.pageX = i.clientX + (s && s
                  .scrollLeft || n && n.scrollLeft || 0) - (s && s.clientLeft || n && n
                  .clientLeft || 0), e.pageY = i.clientY + (s && s.scrollTop || n && n
                  .scrollTop || 0) - (s && s.clientTop || n && n.clientTop || 0)), !e
                  .relatedTarget && r && (e.relatedTarget = r === e.target ? i.toElement : r), e
                  .which || a === t || (e.which = 1 & a ? 1 : 2 & a ? 3 : 4 & a ? 2 : 0), e
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger() {
                    if (this !== u() && this.focus) try {
                        return this.focus(), !1
                    } catch (e) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger() {
                    return this === u() && this.blur ? (this.blur(), !1) : void 0
                },
                delegateType: "focusout"
            },
            click: {
                trigger() {
                    return ut.nodeName(this, "input") && "checkbox" === this.type && this.click ?
                      (this.click(), !1) : void 0
                },
                _default(e) {
                    return ut.nodeName(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch({result, originalEvent}) {
                    result !== t && (originalEvent.returnValue = result)
                }
            }
        },
        simulate(e, t, i, n) {
            const o = ut.extend(new ut.Event, i, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            n ? ut.event.trigger(o, null, t) : ut.event.dispatch.call(t, o), o
              .isDefaultPrevented() && i.preventDefault()
        }
    }, ut.removeEvent = Y.removeEventListener ? (e, t, i) => {
        e.removeEventListener && e.removeEventListener(t, i, !1)
    } : (e, t, i) => {
        const n = `on${t}`;
        e.detachEvent && (typeof e[n] === G && (e[n] = null), e.detachEvent(n, i))
    }, ut.Event = function (e, t) {
        return this instanceof ut.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type,
          this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e
            .getPreventDefault && e.getPreventDefault() ? l : c) : this.type = e, t && ut
          .extend(this, t), this.timeStamp = e && e.timeStamp || ut.now(), this[ut.expando] = !
          0, void 0) : new ut.Event(e, t)
    }, ut.Event.prototype = {
        isDefaultPrevented: c,
        isPropagationStopped: c,
        isImmediatePropagationStopped: c,
        preventDefault() {
            const e = this.originalEvent;
            this.isDefaultPrevented = l, e && (e.preventDefault ? e.preventDefault() : e
              .returnValue = !1)
        },
        stopPropagation() {
            const e = this.originalEvent;
            this.isPropagationStopped = l, e && (e.stopPropagation && e.stopPropagation(), e
              .cancelBubble = !0)
        },
        stopImmediatePropagation() {
            this.isImmediatePropagationStopped = l, this.stopPropagation()
        }
    }, ut.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, (e, t) => {
        ut.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle(e) {
                let i;
                const n = this;
                const o = e.relatedTarget;
                const s = e.handleObj;
                return (!o || o !== n && !ut.contains(n, o)) && (e.type = s.origType, i =
                  s.handler.apply(this, arguments), e.type = t), i
            }
        }
    }), ut.support.submitBubbles || (ut.event.special.submit = {
        setup() {
            return ut.nodeName(this, "form") ? !1 : (ut.event.add(this,
              "click._submit keypress._submit",
              e => {
                  const i = e.target;

                  const n = ut.nodeName(i, "input") || ut.nodeName(i, "button") ? i
                    .form : t;

                  n && !ut._data(n, "submitBubbles") && (ut.event.add(n,
                    "submit._submit",
                    e => {
                        e._submit_bubble = !0
                    }), ut._data(n, "submitBubbles", !0))
              }), void 0);
        },
        postDispatch(e) {
            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger &&
            ut.event.simulate("submit", this.parentNode, e, !0))
        },
        teardown() {
            return ut.nodeName(this, "form") ? !1 : (ut.event.remove(this, "._submit"),
              void 0)
        }
    }), ut.support.changeBubbles || (ut.event.special.change = {
        setup() {
            return Ot.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this
              .type) && (ut.event.add(this, "propertychange._change", function({originalEvent}) {
                "checked" === originalEvent.propertyName && (this
                  ._just_changed = !0)
            }), ut.event.add(this, "click._change", function (e) {
                this._just_changed && !e.isTrigger && (this._just_changed = !
                  1), ut.event.simulate("change", this, e, !0)
            })), !1) : (ut.event.add(this, "beforeactivate._change", e => {
                const t = e.target;
                Ot.test(t.nodeName) && !ut._data(t, "changeBubbles") && (ut.event
                  .add(t, "change._change", function (e) {
                      !this.parentNode || e.isSimulated || e
                        .isTrigger || ut.event.simulate("change", this
                        .parentNode, e, !0)
                  }), ut._data(t, "changeBubbles", !0))
            }), void 0);
        },
        handle(e) {
            const t = e.target;
            return this !== t || e.isSimulated || e.isTrigger || "radio" !== t.type &&
            "checkbox" !== t.type ? e.handleObj.handler.apply(this, arguments) : void 0
        },
        teardown() {
            return ut.event.remove(this, "._change"), !Ot.test(this.nodeName)
        }
    }), ut.support.focusinBubbles || ut.each({
        focus: "focusin",
        blur: "focusout"
    }, (e, t) => {
        let i = 0;

        const n = e => {
            ut.event.simulate(t, e.target, ut.event.fix(e), !0)
        };

        ut.event.special[t] = {
            setup() {
                0 === i++ && Y.addEventListener(e, n, !0)
            },
            teardown() {
                0 === --i && Y.removeEventListener(e, n, !0)
            }
        }
    }), ut.fn.extend({
        on(e, i, n, o, s) {
            let a;
            let r;
            if ("object" == typeof e) {
                "string" != typeof i && (n = n || i, i = t);
                for (a in e) this.on(a, i, n, e[a], s);
                return this
            }
            if (null == n && null == o ? (o = i, n = i = t) : null == o && ("string" ==
            typeof i ? (o = n, n = t) : (o = n, n = i, i = t)), o === !1) o = c;
            else if (!o) return this;
            return 1 === s && (r = o, o = function (e) {
                return ut()
                  .off(e), r.apply(this, arguments)
            }, o.guid = r.guid || (r.guid = ut.guid++)), this.each(function () {
                ut.event.add(this, e, o, n, i)
            })
        },
        one(e, t, i, n) {
            return this.on(e, t, i, n, 1)
        },
        off(e, i, n) {
            let o;
            let s;
            if (e && e.preventDefault && e.handleObj) return o = e.handleObj, ut(e
              .delegateTarget)
              .off(o.namespace ? `${o.origType}.${o.namespace}` : o.origType, o
                .selector, o.handler), this;
            if ("object" == typeof e) {
                for (s in e) this.off(s, i, e[s]);
                return this
            }
            return (i === !1 || "function" == typeof i) && (n = i, i = t), n === !1 && (n =
              c), this.each(function () {
                ut.event.remove(this, e, n, i)
            })
        },
        trigger(e, t) {
            return this.each(function () {
                ut.event.trigger(e, t, this)
            })
        },
        triggerHandler(e, t) {
            const i = this[0];
            return i ? ut.event.trigger(e, t, i, !0) : void 0
        }
    });
    var Ht = /^.[^:#\[\.,]*$/;
    const Wt = /^(?:parents|prev(?:Until|All))/;
    const Vt = ut.expr.match.needsContext;

    const qt = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };

    ut.fn.extend({
        find(e) {
            let t;
            let i = [];
            const n = this;
            const o = n.length;
            if ("string" != typeof e) return this.pushStack(ut(e)
              .filter(function () {
                  for (t = 0; o > t; t++)
                      if (ut.contains(n[t], this)) return !0
              }));
            for (t = 0; o > t; t++) ut.find(e, n[t], i);
            return i = this.pushStack(o > 1 ? ut.unique(i) : i), i.selector = this.selector ?
              `${this.selector} ${e}` : e, i;
        },
        has(e) {
            let t;
            const i = ut(e, this);
            const n = i.length;
            return this.filter(function () {
                for (t = 0; n > t; t++)
                    if (ut.contains(this, i[t])) return !0
            })
        },
        not(e) {
            return this.pushStack(h(this, e || [], !0))
        },
        filter(e) {
            return this.pushStack(h(this, e || [], !1))
        },
        is(e) {
            return !!h(this, "string" == typeof e && Vt.test(e) ? ut(e) : e || [], !1)
              .length
        },
        closest(e, t) {
            for (var i, n = 0, o = this.length, s = [], a = Vt.test(e) || "string" !=
            typeof e ? ut(e, t || this.context) : 0; o > n; n++)
                for (i = this[n]; i && i !== t; i = i.parentNode)
                    if (i.nodeType < 11 && (a ? a.index(i) > -1 : 1 === i.nodeType && ut.find
                      .matchesSelector(i, e))) {
                        i = s.push(i);
                        break
                    } return this.pushStack(s.length > 1 ? ut.unique(s) : s)
        },
        index(e) {
            return e ? "string" == typeof e ? ut.inArray(this[0], ut(e)) : ut.inArray(e
              .jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first()
              .prevAll()
              .length : -1
        },
        add(e, t) {
            const i = "string" == typeof e ? ut(e, t) : ut.makeArray(e && e.nodeType ? [e] : e);
            const n = ut.merge(this.get(), i);
            return this.pushStack(ut.unique(n))
        },
        addBack(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    }), ut.each({
        parent({parentNode}) {
            const t = parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents(e) {
            return ut.dir(e, "parentNode")
        },
        parentsUntil(e, t, i) {
            return ut.dir(e, "parentNode", i)
        },
        next(e) {
            return d(e, "nextSibling")
        },
        prev(e) {
            return d(e, "previousSibling")
        },
        nextAll(e) {
            return ut.dir(e, "nextSibling")
        },
        prevAll(e) {
            return ut.dir(e, "previousSibling")
        },
        nextUntil(e, t, i) {
            return ut.dir(e, "nextSibling", i)
        },
        prevUntil(e, t, i) {
            return ut.dir(e, "previousSibling", i)
        },
        siblings(e) {
            return ut.sibling((e.parentNode || {})
              .firstChild, e)
        },
        children({firstChild}) {
            return ut.sibling(firstChild);
        },
        contents(e) {
            return ut.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document :
              ut.merge([], e.childNodes)
        }
    }, (e, t) => {
        ut.fn[e] = function (i, n) {
            let o = ut.map(this, t, i);
            return "Until" !== e.slice(-5) && (n = i), n && "string" == typeof n && (o = ut
              .filter(n, o)), this.length > 1 && (qt[e] || (o = ut.unique(o)), Wt.test(
              e) && (o = o.reverse())), this.pushStack(o)
        }
    }), ut.extend({
        filter(e, t, i) {
            const n = t[0];
            return i && (e = `:not(${e})`), 1 === t.length && 1 === n.nodeType ? ut.find
              .matchesSelector(n, e) ? [n] : [] : ut.find.matches(e, ut.grep(t, ({nodeType}) => 1 === nodeType));
        },
        dir(e, i, n) {
            for (var o = [], s = e[i]; s && 9 !== s.nodeType && (n === t || 1 !== s
              .nodeType || !ut(s)
              .is(n));) 1 === s.nodeType && o.push(s), s = s[i];
            return o
        },
        sibling(e, t) {
            for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
            return i
        }
    });

    var Ut =
        "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video";

    const Zt = / jQuery\d+="(?:null|\d+)"/g;
    const Gt = new RegExp(`<(?:${Ut})[\\s/>]`, "i");
    const Kt = /^\s+/;
    const Yt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    const Jt = /<([\w:]+)/;
    const Qt = /<tbody/i;
    const Xt = /<|&#?\w+;/;
    const ei = /<(?:script|style|link)/i;
    var ti = /^(?:checkbox|radio)$/i;
    const ii = /checked\s*(?:[^=]|=\s*.checked.)/i;
    const ni = /^$|\/(?:java|ecma)script/i;
    var oi = /^true\/(.*)/;
    const si = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    const ai = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        area: [1, "<map>", "</map>"],
        param: [1, "<object>", "</object>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: ut.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
    };

    const ri = p(Y);
    const li = ri.appendChild(Y.createElement("div"));
    ai.optgroup = ai.option, ai.tbody = ai.tfoot = ai.colgroup = ai.caption = ai.thead, ai.th = ai.td, ut
      .fn.extend({
          text(e) {
              return ut.access(this, function (e) {
                  return e === t ? ut.text(this) : this.empty()
                    .append((this[0] && this[0].ownerDocument || Y)
                      .createTextNode(e))
              }, null, e, arguments.length)
          },
          append(...args) {
              return this.domManip(args, function (e) {
                  if (1 === this.nodeType || 11 === this.nodeType || 9 === this
                    .nodeType) {
                      const t = m(this, e);
                      t.appendChild(e)
                  }
              });
          },
          prepend(...args) {
              return this.domManip(args, function (e) {
                  if (1 === this.nodeType || 11 === this.nodeType || 9 === this
                    .nodeType) {
                      const t = m(this, e);
                      t.insertBefore(e, t.firstChild)
                  }
              });
          },
          before(...args) {
              return this.domManip(args, function (e) {
                  this.parentNode && this.parentNode.insertBefore(e, this)
              });
          },
          after(...args) {
              return this.domManip(args, function (e) {
                  this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
              });
          },
          remove(e, t) {
              for (let i, n = e ? ut.filter(e, this) : this, o = 0; null != (i = n[o]); o++)
                  t || 1 !== i.nodeType || ut.cleanData(y(i)), i.parentNode && (t && ut
                    .contains(i.ownerDocument, i) && g(y(i, "script")), i.parentNode
                    .removeChild(i));
              return this
          },
          empty() {
              for (let e, t = 0; null != (e = this[t]); t++) {
                  for (1 === e.nodeType && ut.cleanData(y(e, !1)); e.firstChild;) e.removeChild(
                    e.firstChild);
                  e.options && ut.nodeName(e, "select") && (e.options.length = 0)
              }
              return this
          },
          clone(e, t) {
              return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function () {
                  return ut.clone(this, e, t)
              })
          },
          html(e) {
              return ut.access(this, function (e) {
                  let i = this[0] || {};
                  let n = 0;
                  const o = this.length;
                  if (e === t) return 1 === i.nodeType ? i.innerHTML.replace(Zt, "") :
                    t;
                  if (!("string" != typeof e || ei.test(e) || !ut.support
                    .htmlSerialize && Gt.test(e) || !ut.support
                    .leadingWhitespace && Kt.test(e) || ai[(Jt.exec(e) || ["",
                      ""])[1].toLowerCase()])) {
                      e = e.replace(Yt, "<$1></$2>");
                      try {
                          for (; o > n; n++) i = this[n] || {}, 1 === i.nodeType && (ut
                            .cleanData(y(i, !1)), i.innerHTML = e);
                          i = 0
                      } catch (s) {}
                  }
                  i && this.empty()
                    .append(e)
              }, null, e, arguments.length);
          },
          replaceWith(...args) {
              const e = ut.map(this, ({nextSibling, parentNode}) => [nextSibling, parentNode]);
              let t = 0;
              return this.domManip(args, function (i) {
                  let n = e[t++];
                  const o = e[t++];
                  o && (n && n.parentNode !== o && (n = this.nextSibling), ut(this)
                    .remove(), o.insertBefore(i, n))
              }, !0), t ? this : this.remove();
          },
          detach(e) {
              return this.remove(e, !0)
          },
          domManip(e, t, i) {
              e = nt.apply([], e);
              let n;
              let o;
              let s;
              let a;
              let r;
              let l;
              let c = 0;
              const u = this.length;
              const d = this;
              const h = u - 1;
              const p = e[0];
              const m = ut.isFunction(p);
              if (m || !(1 >= u || "string" != typeof p || ut.support.checkClone) && ii.test(p))
                  return this.each(function (n) {
                      const o = d.eq(n);
                      m && (e[0] = p.call(this, n, o.html())), o.domManip(e, t, i)
                  });
              if (u && (l = ut.buildFragment(e, this[0].ownerDocument, !1, !i && this), n = l
                .firstChild, 1 === l.childNodes.length && (l = n), n)) {
                  for (a = ut.map(y(l, "script"), f), s = a.length; u > c; c++) o = l, c !==
                  h && (o = ut.clone(o, !0, !0), s && ut.merge(a, y(o, "script"))), t.call(
                    this[c], o, c);
                  if (s)
                      for (r = a[a.length - 1].ownerDocument, ut.map(a, _), c = 0; s > c; c++)
                          o = a[c], ni.test(o.type || "") && !ut._data(o, "globalEval") && ut
                            .contains(r, o) && (o.src ? ut._evalUrl(o.src) : ut.globalEval((o
                            .text || o.textContent || o.innerHTML || "")
                            .replace(si, "")));
                  l = n = null
              }
              return this
          }
      }), ut.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, (e, t) => {
        ut.fn[e] = function (e) {
            for (var i, n = 0, o = [], s = ut(e), a = s.length - 1; a >= n; n++) i = n === a ?
              this : this.clone(!0), ut(s[n])[t](i), ot.apply(o, i.get());
            return this.pushStack(o)
        }
    }), ut.extend({
        clone(e, t, i) {
            let n;
            let o;
            let s;
            let a;
            let r;
            const l = ut.contains(e.ownerDocument, e);
            if (ut.support.html5Clone || ut.isXMLDoc(e) || !Gt.test(`<${e.nodeName}>`) ?
              s = e.cloneNode(!0) : (li.innerHTML = e.outerHTML, li.removeChild(s = li
                .firstChild)), !(ut.support.noCloneEvent && ut.support.noCloneChecked ||
              1 !== e.nodeType && 11 !== e.nodeType || ut.isXMLDoc(e)))
                for (n = y(s), r = y(e), a = 0; null != (o = r[a]); ++a) n[a] && b(o, n[a]);
            if (t)
                if (i)
                    for (r = r || y(e), n = n || y(s), a = 0; null != (o = r[a]); a++) v(o, n[
                      a]);
                else v(e, s);
            return n = y(s, "script"), n.length > 0 && g(n, !l && y(e, "script")), n = r = o =
              null, s
        },
        buildFragment(e, t, i, n) {
            for (var o, s, a, r, l, c, u, d = e.length, h = p(t), m = [], f = 0; d > f; f++)
                if (s = e[f], s || 0 === s)
                    if ("object" === ut.type(s)) ut.merge(m, s.nodeType ? [s] : s);
                    else if (Xt.test(s)) {
                        for (r = r || h.appendChild(t.createElement("div")), l = (Jt.exec(s) || ["",
                            ""])[1].toLowerCase(), u = ai[l] || ai._default, r.innerHTML = u[1] +
                          s.replace(Yt, "<$1></$2>") + u[2], o = u[0]; o--;) r = r.lastChild;
                        if (!ut.support.leadingWhitespace && Kt.test(s) && m.push(t.createTextNode(Kt
                          .exec(s)[0])), !ut.support.tbody)
                            for (s = "table" !== l || Qt.test(s) ? "<table>" !== u[1] || Qt.test(s) ?
                              0 : r : r.firstChild, o = s && s.childNodes.length; o--;) ut.nodeName(
                              c = s.childNodes[o], "tbody") && !c.childNodes.length && s
                              .removeChild(c);
                        for (ut.merge(m, r.childNodes), r.textContent = ""; r.firstChild;) r
                          .removeChild(r.firstChild);
                        r = h.lastChild
                    } else m.push(t.createTextNode(s));
            for (r && h.removeChild(r), ut.support.appendChecked || ut.grep(y(m, "input"), w),
                   f = 0; s = m[f++];)
                if ((!n || -1 === ut.inArray(s, n)) && (a = ut.contains(s.ownerDocument, s),
                  r = y(h.appendChild(s), "script"), a && g(r), i))
                    for (o = 0; s = r[o++];) ni.test(s.type || "") && i.push(s);
            return r = null, h
        },
        cleanData(e, t) {
            for (let i,
                n,
                o,
                s,
                a = 0,
                r = ut.expando,
                l = ut.cache,
                c = ut.support
                  .deleteExpando,
                u = ut.event.special; null != (i = e[a]); a++)
                if ((t || ut.acceptData(i)) && (o = i[r], s = o && l[o])) {
                    if (s.events)
                        for (n in s.events) u[n] ? ut.event.remove(i, n) : ut.removeEvent(i,
                          n, s.handle);
                    l[o] && (delete l[o], c ? delete i[r] : typeof i.removeAttribute !== G ? i
                      .removeAttribute(r) : i[r] = null, tt.push(o))
                }
        },
        _evalUrl(e) {
            return ut.ajax({
                url: e,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }
    }), ut.fn.extend({
        wrapAll(e) {
            if (ut.isFunction(e)) return this.each(function (t) {
                ut(this)
                  .wrapAll(e.call(this, t))
            });
            if (this[0]) {
                const t = ut(e, this[0].ownerDocument)
                  .eq(0)
                  .clone(!0);
                this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
                    for (var e = this; e.firstChild && 1 === e.firstChild.nodeType;)
                        e = e.firstChild;
                    return e
                })
                  .append(this)
            }
            return this
        },
        wrapInner(e) {
            return ut.isFunction(e) ? this.each(function (t) {
                ut(this)
                  .wrapInner(e.call(this, t))
            }) : this.each(function () {
                const t = ut(this);
                const i = t.contents();
                i.length ? i.wrapAll(e) : t.append(e)
            });
        },
        wrap(e) {
            const t = ut.isFunction(e);
            return this.each(function (i) {
                ut(this)
                  .wrapAll(t ? e.call(this, i) : e)
            })
        },
        unwrap() {
            return this.parent()
              .each(function () {
                  ut.nodeName(this, "body") || ut(this)
                    .replaceWith(this.childNodes)
              })
              .end()
        }
    });
    var ci;
    var ui;
    var di;
    const hi = /alpha\([^)]*\)/i;
    const pi = /opacity\s*=\s*([^)]*)/;
    const mi = /^(top|right|bottom|left)$/;
    const fi = /^(none|table(?!-c[ea]).+)/;
    const _i = /^margin/;
    var gi = new RegExp(`^(${dt})(.*)$`, "i");
    var vi = new RegExp(`^(${dt})(?!px)[a-z%]+$`, "i");
    const bi = new RegExp(`^([+-])=(${dt})`, "i");

    var yi = {
        BODY: "block"
    };

    const wi = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    };

    const ki = {
        letterSpacing: 0,
        fontWeight: 400
    };

    var xi = ["Top", "Right", "Bottom", "Left"];
    var Ci = ["Webkit", "O", "Moz", "ms"];
    ut.fn.extend({
        css(e, i) {
            return ut.access(this, (e, i, n) => {
                let o;
                let s;
                const a = {};
                let r = 0;
                if (ut.isArray(i)) {
                    for (s = ui(e), o = i.length; o > r; r++) a[i[r]] = ut.css(e, i[
                      r], !1, s);
                    return a
                }
                return n !== t ? ut.style(e, i, n) : ut.css(e, i)
            }, e, i, arguments.length > 1);
        },
        show() {
            return C(this, !0)
        },
        hide() {
            return C(this)
        },
        toggle(e) {
            const t = "boolean" == typeof e;
            return this.each(function () {
                (t ? e : x(this)) ? ut(this)
                  .show(): ut(this)
                  .hide()
            })
        }
    }), ut.extend({
        cssHooks: {
            opacity: {
                get(e, t) {
                    if (t) {
                        const i = di(e, "opacity");
                        return "" === i ? "1" : i
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": ut.support.cssFloat ? "cssFloat" : "styleFloat"
        },
        style(e, i, n, o) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                let s;
                let a;
                let r;
                const l = ut.camelCase(i);
                const c = e.style;
                if (i = ut.cssProps[l] || (ut.cssProps[l] = k(c, l)), r = ut.cssHooks[i] || ut
                  .cssHooks[l], n === t) return r && "get" in r && (s = r.get(e, !1, o)) !==
                t ? s : c[i];
                if (a = typeof n, "string" === a && (s = bi.exec(n)) && (n = (s[1] + 1) * s[
                  2] + parseFloat(ut.css(e, i)), a = "number"), !(null == n ||
                  "number" === a && isNaN(n) || ("number" !== a || ut.cssNumber[l] || (
                    n += "px"), ut.support.clearCloneStyle || "" !== n || 0 !== i
                    .indexOf("background") || (c[i] = "inherit"), r && "set" in r && (
                    n = r.set(e, n, o)) === t))) try {
                    c[i] = n
                } catch (u) {}
            }
        },
        css(e, i, n, o) {
            let s;
            let a;
            let r;
            const l = ut.camelCase(i);
            return i = ut.cssProps[l] || (ut.cssProps[l] = k(e.style, l)), r = ut.cssHooks[
              i] || ut.cssHooks[l], r && "get" in r && (a = r.get(e, !0, n)), a === t && (
              a = di(e, i, o)), "normal" === a && i in ki && (a = ki[i]), "" === n ||
            n ? (s = parseFloat(a), n === !0 || ut.isNumeric(s) ? s || 0 : a) : a
        }
    }), e.getComputedStyle ? (ui = t => e.getComputedStyle(t, null), di = (e, i, n) => {
        let o;
        let s;
        let a;
        const r = n || ui(e);
        let l = r ? r.getPropertyValue(i) || r[i] : t;
        const c = e.style;
        return r && ("" !== l || ut.contains(e.ownerDocument, e) || (l = ut.style(e, i)), vi.test(
          l) && _i.test(i) && (o = c.width, s = c.minWidth, a = c.maxWidth, c.minWidth =
          c.maxWidth = c.width = l, l = r.width, c.width = o, c.minWidth = s, c
          .maxWidth = a)), l
    }) : Y.documentElement.currentStyle && (ui = ({currentStyle}) => currentStyle, di = (e, i, n) => {
        let o;
        let s;
        let a;
        const r = n || ui(e);
        let l = r ? r[i] : t;
        const c = e.style;
        return null == l && c && c[i] && (l = c[i]), vi.test(l) && !mi.test(i) && (o = c.left, s =
          e.runtimeStyle, a = s && s.left, a && (s.left = e.currentStyle.left), c.left =
          "fontSize" === i ? "1em" : l, l = `${c.pixelLeft}px`, c.left = o, a && (s.left =
          a)), "" === l ? "auto" : l;
    }), ut.each(["height", "width"], (e, t) => {
        ut.cssHooks[t] = {
            get(e, i, n) {
                return i ? 0 === e.offsetWidth && fi.test(ut.css(e, "display")) ? ut.swap(
                  e, wi,
                  () => S(e, t, n)) : S(e, t, n) : void 0;
            },
            set(e, i, n) {
                const o = n && ui(e);
                return z(e, i, n ? T(e, t, n, ut.support.boxSizing && "border-box" === ut
                  .css(e, "boxSizing", !1, o), o) : 0)
            }
        }
    }), ut.support.opacity || (ut.cssHooks.opacity = {
        get({currentStyle, style}, t) {
            return pi.test((t && currentStyle ? currentStyle.filter : style.filter) ||
              "") ? `${.01 * parseFloat(RegExp.$1)}` : t ? "1" : "";
        },
        set({style, currentStyle}, t) {
            const i = style;
            const n = currentStyle;
            const o = ut.isNumeric(t) ? `alpha(opacity=${100 * t})` : "";
            const s = n && n.filter || i.filter || "";
            i.zoom = 1, (t >= 1 || "" === t) && "" === ut.trim(s.replace(hi, "")) && i
              .removeAttribute && (i.removeAttribute("filter"), "" === t || n && !n
              .filter) || (i.filter = hi.test(s) ? s.replace(hi, o) : `${s} ${o}`)
        }
    }), ut(() => {
        ut.support.reliableMarginRight || (ut.cssHooks.marginRight = {
            get(e, t) {
                return t ? ut.swap(e, {
                    display: "inline-block"
                }, di, [e, "marginRight"]) : void 0
            }
        }), !ut.support.pixelPosition && ut.fn.position && ut.each(["top", "left"], (e, t) => {
            ut.cssHooks[t] = {
                get(e, i) {
                    return i ? (i = di(e, t), vi.test(i) ? `${ut(e)
  .position()[t]}px` : i) : void 0;
                }
            }
        })
    }), ut.expr && ut.expr.filters && (ut.expr.filters.hidden = e => e.offsetWidth <= 0 && e.offsetHeight <= 0 || !ut.support.reliableHiddenOffsets &&
      "none" === (e.style && e.style.display || ut.css(e, "display")), ut.expr.filters.visible = e => !ut.expr.filters.hidden(e)), ut.each({
        margin: "",
        padding: "",
        border: "Width"
    }, (e, t) => {
        ut.cssHooks[e + t] = {
            expand(i) {
                for (var n = 0, o = {}, s = "string" == typeof i ? i.split(" ") : [i]; 4 >
                n; n++) o[e + xi[n] + t] = s[n] || s[n - 2] || s[0];
                return o
            }
        }, _i.test(e) || (ut.cssHooks[e + t].set = z)
    });
    const zi = /%20/g;
    var Ti = /\[\]$/;
    const Si = /\r?\n/g;
    const Ai = /^(?:submit|button|image|reset|file)$/i;
    const Ei = /^(?:input|select|textarea|keygen)/i;
    ut.fn.extend({
        serialize() {
            return ut.param(this.serializeArray())
        },
        serializeArray() {
            return this.map(function () {
                const e = ut.prop(this, "elements");
                return e ? ut.makeArray(e) : this
            })
              .filter(function () {
                  const e = this.type;
                  return this.name && !ut(this)
                    .is(":disabled") && Ei.test(this.nodeName) && !Ai.test(e) && (this
                    .checked || !ti.test(e))
              })
              .map(function(e, {name}) {
                  const i = ut(this)
                    .val();
                  return null == i ? null : ut.isArray(i) ? ut.map(i, e => ({
                      name: name,
                      value: e.replace(Si, "\r\n")
                  })) : {
                      name: name,
                      value: i.replace(Si, "\r\n")
                  };
              })
              .get();
        }
    }), ut.param = (e, i) => {
        let n;
        const o = [];

        const s = (e, t) => {
            t = ut.isFunction(t) ? t() : null == t ? "" : t, o[o.length] = `${encodeURIComponent(e)}=${encodeURIComponent(t)}`
        };

        if (i === t && (i = ut.ajaxSettings && ut.ajaxSettings.traditional), ut.isArray(e) || e
          .jquery && !ut.isPlainObject(e)) ut.each(e, function () {
            s(this.name, this.value)
        });
        else
            for (n in e) P(n, e[n], i, s);
        return o.join("&")
          .replace(zi, "+")
    }, ut.each(
      "blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu"
        .split(" "),
      (e, t) => {
          ut.fn[t] = function (e, i) {
              return arguments.length > 0 ? this.on(t, null, e, i) : this.trigger(t)
          }
      }), ut.fn.extend({
        hover(e, t) {
            return this.mouseenter(e)
              .mouseleave(t || e)
        },
        bind(e, t, i) {
            return this.on(e, null, t, i)
        },
        unbind(e, t) {
            return this.off(e, null, t)
        },
        delegate(e, t, i, n) {
            return this.on(t, e, i, n)
        },
        undelegate(e, t, i) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
        }
    });
    let Pi;
    let Ii;
    let Mi = ut.now();
    const ji = /\?/;
    const Di = /#.*$/;
    const Ni = /([?&])_=[^&]*/;
    const Li = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm;
    const Oi = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/;
    const Ri = /^(?:GET|HEAD)$/;
    const $i = /^\/\//;
    const Fi = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/;
    const Bi = ut.fn.load;
    const Hi = {};
    var Wi = {};
    const Vi = "*/".concat("*");
    try {
        Ii = K.href
    } catch (qi) {
        Ii = Y.createElement("a"), Ii.href = "", Ii = Ii.href
    }
    Pi = Fi.exec(Ii.toLowerCase()) || [], ut.fn.load = function (e, i, n) {
        if ("string" != typeof e && Bi) return Bi.apply(this, arguments);
        let o;
        let s;
        let a;
        const r = this;
        const l = e.indexOf(" ");
        return l >= 0 && (o = e.slice(l, e.length), e = e.slice(0, l)), ut.isFunction(i) ? (n = i, i =
          t) : i && "object" == typeof i && (a = "POST"), r.length > 0 && ut.ajax({
            url: e,
            type: a,
            dataType: "html",
            data: i
        })
          .done(function (e) {
              s = arguments, r.html(o ? ut("<div>")
                .append(ut.parseHTML(e))
                .find(o) : e)
          })
          .complete(n && ((e, t) => {
              r.each(n, s || [e.responseText, t, e])
          })), this;
    }, ut.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"],
      (e, t) => {
          ut.fn[t] = function (e) {
              return this.on(t, e)
          }
      }), ut.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ii,
            type: "GET",
            isLocal: Oi.test(Pi[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Vi,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": ut.parseJSON,
                "text xml": ut.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup(e, t) {
            return t ? j(j(e, ut.ajaxSettings), t) : j(ut.ajaxSettings, e)
        },
        ajaxPrefilter: I(Hi),
        ajaxTransport: I(Wi),
        ajax(e, i) {
            function n(e, i, n, o) {
                let s;
                let d;
                let v;
                let b;
                let w;
                let x = i;
                2 !== y && (y = 2, l && clearTimeout(l), u = t, r = o || "", k.readyState =
                  e > 0 ? 4 : 0, s = e >= 200 && 300 > e || 304 === e, n && (b = D(h, k,
                  n)), b = N(h, b, k, s), s ? (h.ifModified && (w = k
                  .getResponseHeader("Last-Modified"), w && (ut.lastModified[
                  a] = w), w = k.getResponseHeader("etag"), w && (ut.etag[
                  a] = w)), 204 === e || "HEAD" === h.type ? x =
                  "nocontent" : 304 === e ? x = "notmodified" : (x = b.state, d = b
                  .data, v = b.error, s = !v)) : (v = x, (e || !x) && (x =
                  "error", 0 > e && (e = 0))), k.status = e, k.statusText = `${i ||
  x}`, s ? f.resolveWith(p, [d, x, k]) : f.rejectWith(p, [k, x, v]),
                  k.statusCode(g), g = t, c && m.trigger(s ? "ajaxSuccess" :
                  "ajaxError", [k, h, s ? d : v]), _.fireWith(p, [k, x]), c && (m
                  .trigger("ajaxComplete", [k, h]), --ut.active || ut.event.trigger(
                  "ajaxStop")))
            }
            "object" == typeof e && (i = e, e = t), i = i || {};
            let o;
            let s;
            var a;
            var r;
            var l;
            var c;
            var u;
            let d;
            var h = ut.ajaxSetup({}, i);
            var p = h.context || h;
            var m = h.context && (p.nodeType || p.jquery) ? ut(p) : ut.event;
            var f = ut.Deferred();
            var _ = ut.Callbacks("once memory");
            var g = h.statusCode || {};
            const v = {};
            const b = {};
            var y = 0;
            let w = "canceled";

            var k = {
                readyState: 0,
                getResponseHeader(e) {
                    let t;
                    if (2 === y) {
                        if (!d)
                            for (d = {}; t = Li.exec(r);) d[t[1].toLowerCase()] = t[
                              2];
                        t = d[e.toLowerCase()]
                    }
                    return null == t ? null : t
                },
                getAllResponseHeaders() {
                    return 2 === y ? r : null
                },
                setRequestHeader(e, t) {
                    const i = e.toLowerCase();
                    return y || (e = b[i] = b[i] || e, v[e] = t), this
                },
                overrideMimeType(e) {
                    return y || (h.mimeType = e), this
                },
                statusCode(e) {
                    let t;
                    if (e)
                        if (2 > y)
                            for (t in e) g[t] = [g[t], e[t]];
                        else k.always(e[k.status]);
                    return this
                },
                abort(e) {
                    const t = e || w;
                    return u && u.abort(t), n(0, t), this
                }
            };

            if (f.promise(k)
              .complete = _.add, k.success = k.done, k.error = k.fail, h.url = (`${e || h
  .url || Ii}`)
              .replace(Di, "")
              .replace($i, `${Pi[1]}//`), h.type = i.method || i.type || h.method || h.type,
              h.dataTypes = ut.trim(h.dataType || "*")
                .toLowerCase()
                .match(ht) || [""], null == h.crossDomain && (o = Fi.exec(h.url
              .toLowerCase()), h.crossDomain = !(!o || o[1] === Pi[1] && o[2] === Pi[2] && (
              o[3] || ("http:" === o[1] ? "80" : "443")) === (Pi[3] || (
              "http:" === Pi[1] ? "80" : "443")))), h.data && h.processData &&
            "string" != typeof h.data && (h.data = ut.param(h.data, h.traditional)), M(Hi,
              h, i, k), 2 === y) return k;
            c = h.global, c && 0 === ut.active++ && ut.event.trigger("ajaxStart"), h.type = h
              .type.toUpperCase(), h.hasContent = !Ri.test(h.type), a = h.url, h
              .hasContent || (h.data && (a = h.url += (ji.test(a) ? "&" : "?") + h.data,
              delete h.data), h.cache === !1 && (h.url = Ni.test(a) ? a.replace(Ni,
              `$1_=${Mi++}`) : `${a + (ji.test(a) ? "&" : "?")}_=${Mi++}`)), h
              .ifModified && (ut.lastModified[a] && k.setRequestHeader("If-Modified-Since",
              ut.lastModified[a]), ut.etag[a] && k.setRequestHeader("If-None-Match",
              ut.etag[a])), (h.data && h.hasContent && h.contentType !== !1 || i
              .contentType) && k.setRequestHeader("Content-Type", h.contentType), k
              .setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h
                .accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? `, ${Vi}; q=0.01` : "") : h.accepts["*"]);
            for (s in h.headers) k.setRequestHeader(s, h.headers[s]);
            if (h.beforeSend && (h.beforeSend.call(p, k, h) === !1 || 2 === y)) return k
              .abort();
            w = "abort";
            for (s in {
                success: 1,
                error: 1,
                complete: 1
            }) k[s](h[s]);
            if (u = M(Wi, h, i, k)) {
                k.readyState = 1, c && m.trigger("ajaxSend", [k, h]), h.async && h.timeout >
                0 && (l = setTimeout(() => {
                    k.abort("timeout")
                }, h.timeout));
                try {
                    y = 1, u.send(v, n)
                } catch (x) {
                    if (!(2 > y)) throw x;
                    n(-1, x)
                }
            } else n(-1, "No Transport");
            return k
        },
        getJSON(e, t, i) {
            return ut.get(e, t, i, "json")
        },
        getScript(e, i) {
            return ut.get(e, t, i, "script")
        }
    }), ut.each(["get", "post"], (e, i) => {
        ut[i] = (e, n, o, s) => (ut.isFunction(n) && (s = s || o, o = n, n = t), ut.ajax({
            url: e,
            type: i,
            dataType: s,
            data: n,
            success: o
        }))
    }), ut.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function (e) {
                return ut.globalEval(e), e
            }
        }
    }), ut.ajaxPrefilter("script", e => {
        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1)
    }), ut.ajaxTransport("script", e => {
        if (e.crossDomain) {
            let i;
            const n = Y.head || ut("head")[0] || Y.documentElement;
            return {
                send(t, o) {
                    i = Y.createElement("script"), i.async = !0, e.scriptCharset && (i
                      .charset = e.scriptCharset), i.src = e.url, i.onload = i
                      .onreadystatechange = (e, t) => {
                        (t || !i.readyState || /loaded|complete/.test(i.readyState)) && (i
                          .onload = i.onreadystatechange = null, i.parentNode && i
                          .parentNode.removeChild(i), i = null, t || o(200, "success"))
                    }, n.insertBefore(i, n.firstChild)
                },
                abort() {
                    i && i.onload(t, !0)
                }
            };
        }
    });
    const Ui = [];
    const Zi = /(=)\?(?=&|$)|\?\?/;
    ut.ajaxSetup({
        jsonp: "callback",
        jsonpCallback() {
            const e = Ui.pop() || `${ut.expando}_${Mi++}`;
            return this[e] = !0, e
        }
    }), ut.ajaxPrefilter("json jsonp", (i, {jsonpCallback}, o) => {
        let s;
        let a;
        let r;

        const l = i.jsonp !== !1 && (Zi.test(i.url) ? "url" : "string" == typeof i.data &&
          !(i.contentType || "")
            .indexOf("application/x-www-form-urlencoded") && Zi.test(i.data) && "data");

        return l || "jsonp" === i.dataTypes[0] ? (s = i.jsonpCallback = ut.isFunction(i
          .jsonpCallback) ? i.jsonpCallback() : i.jsonpCallback, l ? i[l] = i[l]
          .replace(Zi, `$1${s}`) : i.jsonp !== !1 && (i.url += `${(ji.test(i.url) ? "&" :
  "?") + i.jsonp}=${s}`), i.converters["script json"] = () => (r || ut.error(`${s} was not called`), r[0]), i.dataTypes[0] = "json", a = e[s], e[s] = function(...args) {
            r = args
        }, o.always(() => {
            e[s] = a, i[s] && (i.jsonpCallback = jsonpCallback, Ui.push(s)), r && ut
              .isFunction(a) && a(r[0]), r = a = t
        }), "script") : void 0;
    });
    let Gi;
    let Ki;
    let Yi = 0;

    const Ji = e.ActiveXObject && (() => {
        let e;
        for (e in Gi) Gi[e](t, !0)
    });

    ut.ajaxSettings.xhr = e.ActiveXObject ? function () {
        return !this.isLocal && L() || O()
    } : L, Ki = ut.ajaxSettings.xhr(), ut.support.cors = !!Ki && "withCredentials" in Ki, Ki = ut
      .support.ajax = !!Ki, Ki && ut.ajaxTransport(i => {
        if (!i.crossDomain || ut.support.cors) {
            let n;
            return {
                send(o, s) {
                    let a;
                    let r;
                    const l = i.xhr();
                    if (i.username ? l.open(i.type, i.url, i.async, i.username, i.password) :
                      l.open(i.type, i.url, i.async), i.xhrFields)
                        for (r in i.xhrFields) l[r] = i.xhrFields[r];
                    i.mimeType && l.overrideMimeType && l.overrideMimeType(i.mimeType), i
                      .crossDomain || o["X-Requested-With"] || (o["X-Requested-With"] =
                      "XMLHttpRequest");
                    try {
                        for (r in o) l.setRequestHeader(r, o[r])
                    } catch (c) {}
                    l.send(i.hasContent && i.data || null), n = (e, o) => {
                        let r;
                        let c;
                        let u;
                        let d;
                        try {
                            if (n && (o || 4 === l.readyState))
                                if (n = t, a && (l.onreadystatechange = ut.noop, Ji &&
                                delete Gi[a]), o) 4 !== l.readyState && l.abort();
                                else {
                                    d = {}, r = l.status, c = l.getAllResponseHeaders(),
                                    "string" == typeof l.responseText && (d.text = l
                                      .responseText);
                                    try {
                                        u = l.statusText
                                    } catch (h) {
                                        u = ""
                                    }
                                    r || !i.isLocal || i.crossDomain ? 1223 === r && (r =
                                      204) : r = d.text ? 200 : 404
                                }
                        } catch (p) {
                            o || s(-1, p)
                        }
                        d && s(r, u, d, c)
                    }, i.async ? 4 === l.readyState ? setTimeout(n) : (a = ++Yi, Ji && (
                      Gi || (Gi = {}, ut(e)
                        .unload(Ji)), Gi[a] = n), l.onreadystatechange = n) : n()
                },
                abort() {
                    n && n(t, !0)
                }
            };
        }
    });
    var Qi;
    let Xi;
    var en = /^(?:toggle|show|hide)$/;
    const tn = new RegExp(`^(?:([+-])=|)(${dt})([a-z%]*)$`, "i");
    const nn = /queueHooks$/;
    var on = [H];

    var sn = {
        "*": [function (e, t) {
            const i = this.createTween(e, t);
            const n = i.cur();
            let o = tn.exec(t);
            let s = o && o[3] || (ut.cssNumber[e] ? "" : "px");
            let a = (ut.cssNumber[e] || "px" !== s && +n) && tn.exec(ut.css(i.elem, e));
            let r = 1;
            let l = 20;
            if (a && a[3] !== s) {
                s = s || a[3], o = o || [], a = +n || 1;
                do r = r || ".5", a /= r, ut.style(i.elem, e, a + s); while (r !== (r = i
                  .cur() / n) && 1 !== r && --l)
            }
            return o && (i.unit = s, i.start = +a || +n || 0, i.end = o[1] ? a + (o[1] + 1) *
              o[2] : +o[2]), i
        }]
    };

    ut.Animation = ut.extend(F, {
        tweener(e, t) {
            ut.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
            for (let i, n = 0, o = e.length; o > n; n++) i = e[n], sn[i] = sn[i] || [], sn[i]
              .unshift(t)
        },
        prefilter(e, t) {
            t ? on.unshift(e) : on.push(e)
        }
    }), ut.Tween = W, W.prototype = {
        constructor: W,
        init(e, t, i, n, o, s) {
            this.elem = e, this.prop = i, this.easing = o || "swing", this.options = t, this
              .start = this.now = this.cur(), this.end = n, this.unit = s || (ut.cssNumber[i] ?
              "" : "px")
        },
        cur() {
            const e = W.propHooks[this.prop];
            return e && e.get ? e.get(this) : W.propHooks._default.get(this)
        },
        run(e) {
            let t;
            const i = W.propHooks[this.prop];
            return this.pos = t = this.options.duration ? ut.easing[this.easing](e, this.options
              .duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this
              .start) * t + this.start, this.options.step && this.options.step.call(this
              .elem, this.now, this), i && i.set ? i.set(this) : W.propHooks._default.set(
              this), this
        }
    }, W.prototype.init.prototype = W.prototype, W.propHooks = {
        _default: {
            get({elem, prop}) {
                let t;
                return null == elem[prop] || elem.style && null != elem.style[prop] ? (
                  t = ut.css(elem, prop, ""), t && "auto" !== t ? t : 0) : elem[prop];
            },
            set(e) {
                ut.fx.step[e.prop] ? ut.fx.step[e.prop](e) : e.elem.style && (null != e.elem
                  .style[ut.cssProps[e.prop]] || ut.cssHooks[e.prop]) ? ut.style(e.elem, e
                  .prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    }, W.propHooks.scrollTop = W.propHooks.scrollLeft = {
        set({elem, prop, now}) {
            elem.nodeType && elem.parentNode && (elem[prop] = now)
        }
    }, ut.each(["toggle", "show", "hide"], (e, t) => {
        const i = ut.fn[t];
        ut.fn[t] = function (e, n, o) {
            return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this
              .animate(V(t, !0), e, n, o)
        }
    }), ut.fn.extend({
        fadeTo(e, t, i, n) {
            return this.filter(x)
              .css("opacity", 0)
              .show()
              .end()
              .animate({
                  opacity: t
              }, e, i, n)
        },
        animate(e, t, i, n) {
            const o = ut.isEmptyObject(e);
            const s = ut.speed(t, i, n);

            const a = function () {
                const t = F(this, ut.extend({}, e), s);
                a.finish = () => {
                    t.stop(!0)
                }, (o || ut._data(this, "finish")) && t.stop(!0)
            };

            return a.finish = a, o || s.queue === !1 ? this.each(a) : this.queue(s.queue, a)
        },
        stop(e, i, n) {
            const o = ({stop}) => {
                const t = stop;
                delete stop, t(n)
            };
            return "string" != typeof e && (n = i, i = e, e = t), i && e !== !1 && this.queue(
              e || "fx", []), this.each(function () {
                let t = !0;
                let i = null != e && `${e}queueHooks`;
                const s = ut.timers;
                const a = ut._data(this);
                if (i) a[i] && a[i].stop && o(a[i]);
                else
                    for (i in a) a[i] && a[i].stop && nn.test(i) && o(a[i]);
                for (i = s.length; i--;) s[i].elem !== this || null != e && s[i]
                  .queue !== e || (s[i].anim.stop(n), t = !1, s.splice(i, 1));
                (t || !n) && ut.dequeue(this, e)
            });
        },
        finish(e) {
            return e !== !1 && (e = e || "fx"), this.each(function () {
                let t;
                const i = ut._data(this);
                const n = i[`${e}queue`];
                const o = i[`${e}queueHooks`];
                const s = ut.timers;
                const a = n ? n.length : 0;
                for (i.finish = !0, ut.queue(this, e, []), o && o.cur && o.cur
                  .finish && o.cur.finish.call(this), t = s.length; t--;) s[t]
                  .elem === this && s[t].queue === e && (s[t].anim.stop(!0), s
                  .splice(t, 1));
                for (t = 0; a > t; t++) n[t] && n[t].finish && n[t].finish.call(this);
                delete i.finish
            });
        }
    }), ut.each({
        slideDown: V("show"),
        slideUp: V("hide"),
        slideToggle: V("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, (e, t) => {
        ut.fn[e] = function (e, i, n) {
            return this.animate(t, e, i, n)
        }
    }), ut.speed = (e, t, i) => {
        const n = e && "object" == typeof e ? ut.extend({}, e) : {
            complete: i || !i && t || ut.isFunction(e) && e,
            duration: e,
            easing: i && t || t && !ut.isFunction(t) && t
        };
        return n.duration = ut.fx.off ? 0 : "number" == typeof n.duration ? n.duration : n.duration in
        ut.fx.speeds ? ut.fx.speeds[n.duration] : ut.fx.speeds._default, (null == n.queue || n
          .queue === !0) && (n.queue = "fx"), n.old = n.complete, n.complete = function () {
            ut.isFunction(n.old) && n.old.call(this), n.queue && ut.dequeue(this, n.queue)
        }, n
    }, ut.easing = {
        linear(e) {
            return e
        },
        swing(e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }
    }, ut.timers = [], ut.fx = W.prototype.init, ut.fx.tick = () => {
        let e;
        const i = ut.timers;
        let n = 0;
        for (Qi = ut.now(); n < i.length; n++) e = i[n], e() || i[n] !== e || i.splice(n--, 1);
        i.length || ut.fx.stop(), Qi = t
    }, ut.fx.timer = e => {
        e() && ut.timers.push(e) && ut.fx.start()
    }, ut.fx.interval = 13, ut.fx.start = () => {
        Xi || (Xi = setInterval(ut.fx.tick, ut.fx.interval))
    }, ut.fx.stop = () => {
        clearInterval(Xi), Xi = null
    }, ut.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, ut.fx.step = {}, ut.expr && ut.expr.filters && (ut.expr.filters.animated = e => ut.grep(ut.timers, ({elem}) => e === elem)
      .length), ut.fn.offset = function (e) {
        if (arguments.length) return e === t ? this : this.each(function (t) {
            ut.offset.setOffset(this, e, t)
        });
        let i;
        let n;

        let o = {
              top: 0,
              left: 0
          };

        const s = this[0];
        const a = s && s.ownerDocument;
        if (a) return i = a.documentElement, ut.contains(i, s) ? (typeof s.getBoundingClientRect !==
        G && (o = s.getBoundingClientRect()), n = q(a), {
            top: o.top + (n.pageYOffset || i.scrollTop) - (i.clientTop || 0),
            left: o.left + (n.pageXOffset || i.scrollLeft) - (i.clientLeft || 0)
        }) : o
    }, ut.offset = {
        setOffset(e, t, i) {
            const n = ut.css(e, "position");
            "static" === n && (e.style.position = "relative");
            let o;
            let s;
            const a = ut(e);
            const r = a.offset();
            const l = ut.css(e, "top");
            const c = ut.css(e, "left");
            const u = ("absolute" === n || "fixed" === n) && ut.inArray("auto", [l, c]) > -1;
            const d = {};
            let h = {};
            u ? (h = a.position(), o = h.top, s = h.left) : (o = parseFloat(l) || 0, s =
              parseFloat(c) || 0), ut.isFunction(t) && (t = t.call(e, i, r)), null != t
              .top && (d.top = t.top - r.top + o), null != t.left && (d.left = t.left - r.left +
              s), "using" in t ? t.using.call(e, d) : a.css(d)
        }
    }, ut.fn.extend({
        position() {
            if (this[0]) {
                let e;
                let t;

                let i = {
                      top: 0,
                      left: 0
                  };

                const n = this[0];
                return "fixed" === ut.css(n, "position") ? t = n.getBoundingClientRect() : (
                  e = this.offsetParent(), t = this.offset(), ut.nodeName(e[0],
                    "html") || (i = e.offset()), i.top += ut.css(e[0], "borderTopWidth", !
                    0), i.left += ut.css(e[0], "borderLeftWidth", !0)), {
                    top: t.top - i.top - ut.css(n, "marginTop", !0),
                    left: t.left - i.left - ut.css(n, "marginLeft", !0)
                }
            }
        },
        offsetParent() {
            return this.map(function () {
                for (var e = this.offsetParent || J; e && !ut.nodeName(e, "html") &&
                "static" === ut.css(e, "position");) e = e.offsetParent;
                return e || J
            })
        }
    }), ut.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, (e, i) => {
        const n = /Y/.test(i);
        ut.fn[e] = function (o) {
            return ut.access(this, (e, o, s) => {
                const a = q(e);
                return s === t ? a ? i in a ? a[i] : a.document.documentElement[o] :
                  e[o] : (a ? a.scrollTo(n ? ut(a)
                  .scrollLeft() : s, n ? s : ut(a)
                  .scrollTop()) : e[o] = s, void 0)
            }, e, o, arguments.length, null);
        }
    }), ut.each({
        Height: "height",
        Width: "width"
    }, (e, i) => {
        ut.each({
            padding: `inner${e}`,
            content: i,
            "": `outer${e}`
        }, (n, o) => {
            ut.fn[o] = function (o, s) {
                const a = arguments.length && (n || "boolean" != typeof o);
                const r = n || (o === !0 || s === !0 ? "margin" : "border");
                return ut.access(this, (i, n, o) => {
                    let s;
                    return ut.isWindow(i) ? i.document.documentElement[
                    `client${e}`] : 9 === i.nodeType ? (s = i
                      .documentElement, Math.max(i.body[`scroll${e}`],
                      s[`scroll${e}`], i.body[`offset${e}`], s[
                      `offset${e}`], s[`client${e}`])) : o ===
                    t ? ut.css(i, n, r) : ut.style(i, n, o, r);
                }, i, a ? o : t, a, null);
            }
        })
    }), ut.fn.size = function () {
        return this.length
    }, ut.fn.andSelf = ut.fn.addBack, "object" == typeof module && "object" == typeof module.exports ?
      module.exports = ut : (e.jQuery = e.$ = ut, "function" == typeof define && define.amd && define(
        "jquery", [],
        () => ut))
})(window), /*! jQuery UI - v1.11.4 - 2015-07-12
   * http://jqueryui.com
   * Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, menu.js, progressbar.js, selectmenu.js, slider.js, spinner.js, tabs.js, tooltip.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js
   * Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
(e => {
    "function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
})(e => {
    function t(t, n) {
        let o;
        let s;
        let a;
        const r = t.nodeName.toLowerCase();
        return "area" === r ? (o = t.parentNode, s = o.name, t.href && s && "map" === o.nodeName
          .toLowerCase() ? (a = e(`img[usemap='#${s}']`)[0], !!a && i(a)) : !1) : (
          /^(input|select|textarea|button|object)$/.test(r) ? !t.disabled : "a" === r ? t
            .href || n : n) && i(t);
    }

    function i(t) {
        return e.expr.filters.visible(t) && !e(t)
          .parents()
          .addBack()
          .filter(function () {
              return "hidden" === e.css(this, "visibility")
          })
          .length
    }

    function n(e) {
        for (let t, i; e.length && e[0] !== document;) {
            if (t = e.css("position"), ("absolute" === t || "relative" === t || "fixed" === t) && (i =
              parseInt(e.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
            e = e.parent()
        }
        return 0
    }

    function o() {
        this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this
          ._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this
          ._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this
          ._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this
          ._disableClass = "ui-datepicker-disabled", this._unselectableClass =
          "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this
          ._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August",
                "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
                "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
                "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: !1,
            showMonthAfterYear: !1,
            yearSuffix: ""
        }, this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: !1,
            hideIfNoPrevNext: !1,
            navigationAsDateFormat: !1,
            gotoCurrent: !1,
            changeMonth: !1,
            changeYear: !1,
            yearRange: "c-10:c+10",
            showOtherMonths: !1,
            selectOtherMonths: !1,
            showWeek: !1,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: !0,
            showButtonPanel: !1,
            autoSize: !1,
            disabled: !1
        }, e.extend(this._defaults, this.regional[""]), this.regional.en = e.extend(!0, {}, this
          .regional[""]), this.regional["en-US"] = e.extend(!0, {}, this.regional.en), this
          .dpDiv = s(e(`<div id='${this._mainDivId}' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>`
        ))
    }

    function s(t) {
        const i = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return t.delegate(i, "mouseout", function () {
            e(this)
              .removeClass("ui-state-hover"), this.className.includes("ui-datepicker-prev") && e(this)
              .removeClass("ui-datepicker-prev-hover"), this.className.includes("ui-datepicker-next") && e(this)
              .removeClass("ui-datepicker-next-hover")
        })
          .delegate(i, "mouseover", a);
    }

    function a() {
        e.datepicker._isDisabledDatepicker(g.inline ? g.dpDiv.parent()[0] : g.input[0]) || (e(this)
          .parents(".ui-datepicker-calendar")
          .find("a")
          .removeClass("ui-state-hover"), e(this)
          .addClass("ui-state-hover"), this.className.includes("ui-datepicker-prev") && e(
          this)
          .addClass("ui-datepicker-prev-hover"), this.className.includes("ui-datepicker-next") && e(this)
          .addClass("ui-datepicker-next-hover"))
    }

    function r(t, i) {
        e.extend(t, i);
        for (const n in i) null == i[n] && (t[n] = i[n]);
        return t
    }
    /*!
       * jQuery UI Spinner 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/spinner/
       */
    function l(e) {
        return function(...args) {
            const t = this.element.val();
            e.apply(this, args), this._refresh(), t !== this.element.val() && this._trigger(
              "change")
        };
    }
    /*!
       * jQuery UI Core 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/category/ui-core/
       */
    e.ui = e.ui || {}, e.extend(e.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), e.fn.extend({
        scrollParent(t) {
            const i = this.css("position");
            const n = "absolute" === i;
            const o = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/;

            const s = this.parents()
              .filter(function () {
                  const t = e(this);
                  return n && "static" === t.css("position") ? !1 : o.test(t.css(
                    "overflow") + t.css("overflow-y") + t.css(
                    "overflow-x"))
              })
              .eq(0);

            return "fixed" !== i && s.length ? s : e(this[0].ownerDocument || document)
        },
        uniqueId: (() => {
            let e = 0;
            return function () {
                return this.each(function () {
                    this.id || (this.id = `ui-id-${++e}`)
                });
            };
        })(),
        removeUniqueId() {
            return this.each(function () {
                /^ui-id-\d+$/.test(this.id) && e(this)
                  .removeAttr("id")
            })
        }
    }), e.extend(e.expr[":"], {
        data: e.expr.createPseudo ? e.expr.createPseudo(t => i => !!e.data(i, t)) : (t, i, n) => !!e.data(t, n[3]),
        focusable(i) {
            return t(i, !isNaN(e.attr(i, "tabindex")))
        },
        tabbable(i) {
            const n = e.attr(i, "tabindex");
            const o = isNaN(n);
            return (o || n >= 0) && t(i, !o)
        }
    }), e("<a>")
      .outerWidth(1)
      .jquery || e.each(["Width", "Height"], (t, i) => {
        function n(t, i, n, s) {
            return e.each(o, function () {
                i -= parseFloat(e.css(t, `padding${this}`)) || 0, n && (i -=
                  parseFloat(e.css(t, `border${this}Width`)) || 0), s && (
                  i -= parseFloat(e.css(t, `margin${this}`)) || 0)
            }), i;
        }
        var o = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"];
        const s = i.toLowerCase();

        const a = {
            innerWidth: e.fn.innerWidth,
            innerHeight: e.fn.innerHeight,
            outerWidth: e.fn.outerWidth,
            outerHeight: e.fn.outerHeight
        };

        e.fn[`inner${i}`] = function (t) {
            return void 0 === t ? a[`inner${i}`].call(this) : this.each(function () {
                e(this)
                  .css(s, `${n(this, t)}px`)
            });
        }, e.fn[`outer${i}`] = function (t, o) {
            return "number" != typeof t ? a[`outer${i}`].call(this, t) : this.each(
              function () {
                  e(this)
                    .css(s, `${n(this, t, !0, o)}px`)
              });
        }
    }), e.fn.addBack || (e.fn.addBack = function (e) {
        return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
    }), e("<a>")
      .data("a-b", "a")
      .removeData("a-b")
      .data("a-b") && (e.fn.removeData = (t => (function(i) {
        return arguments.length ? t.call(this, e.camelCase(i)) : t.call(this)
    }))(e.fn.removeData)), e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), e.fn
      .extend({
          focus: (t => (function(i, n) {
              return "number" == typeof i ? this.each(function () {
                  const t = this;
                  setTimeout(() => {
                      e(t)
                        .focus(), n && n.call(t)
                  }, i)
              }) : t.apply(this, arguments);
          }))(e.fn.focus),
          disableSelection: (() => {
              const e = "onselectstart" in document.createElement("div") ? "selectstart" :
                "mousedown";
              return function () {
                  return this.bind(`${e}.ui-disableSelection`, e => {
                      e.preventDefault()
                  });
              };
          })(),
          enableSelection() {
              return this.unbind(".ui-disableSelection")
          },
          zIndex(t) {
              if (void 0 !== t) return this.css("zIndex", t);
              if (this.length)
                  for (let i, n, o = e(this[0]); o.length && o[0] !== document;) {
                      if (i = o.css("position"), ("absolute" === i || "relative" === i ||
                        "fixed" === i) && (n = parseInt(o.css("zIndex"), 10), !isNaN(
                        n) && 0 !== n)) return n;
                      o = o.parent()
                  }
              return 0
          }
      }), e.ui.plugin = {
        add(t, i, n) {
            let o;
            const s = e.ui[t].prototype;
            for (o in n) s.plugins[o] = s.plugins[o] || [], s.plugins[o].push([i, n[o]])
        },
        call({plugins, element, options}, t, i, n) {
            let o;
            const s = plugins[t];
            if (s && (n || element[0].parentNode && 11 !== element[0].parentNode
              .nodeType))
                for (o = 0; o < s.length; o++) options[s[o][0]] && s[o][1].apply(element,
                  i)
        }
    };

    /*!
       * jQuery UI Widget 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/jQuery.widget/
       */
    let c = 0;

    const u = Array.prototype.slice;
    e.cleanData = (t => i => {
        let n;
        let o;
        let s;
        for (s = 0; null != (o = i[s]); s++) try {
            n = e._data(o, "events"), n && n.remove && e(o)
              .triggerHandler("remove")
        } catch (a) {}
        t(i)
    })(e.cleanData), e.widget = (t, i, n) => {
        let o;
        let s;
        let a;
        let r;
        const l = {};
        const c = t.split(".")[0];
        return t = t.split(".")[1], o = `${c}-${t}`, n || (n = i, i = e.Widget), e.expr[":"][o
          .toLowerCase()] = t => !!e.data(t, o), e[c] = e[c] || {}, s = e[c][t], a = e[c][t] = function (e, t) {
            return this._createWidget ? (arguments.length && this._createWidget(e, t),
              void 0) : new a(e, t)
        }, e.extend(a, s, {
            version: n.version,
            _proto: e.extend({}, n),
            _childConstructors: []
        }), r = new i, r.options = e.widget.extend({}, r.options), e.each(n, (t, n) => e.isFunction(n) ? (l[t] = (() => {
            const e = function(...args) {
                  return i.prototype[t].apply(this, args);
              };

            const o = function (e) {
                return i.prototype[t].apply(this, e)
            };

            return function(...args) {
                let t;
                const i = this._super;
                const s = this._superApply;
                return this._super = e, this._superApply = o, t = n.apply(
                  this, args), this._super = i, this
                  ._superApply = s, t;
            };
        })(), void 0) : (l[t] = n, void 0)), a.prototype = e.widget.extend(r, {
            widgetEventPrefix: s ? r.widgetEventPrefix || t : t
        }, l, {
            constructor: a,
            namespace: c,
            widgetName: t,
            widgetFullName: o
        }), s ? (e.each(s._childConstructors, (t, {prototype, _proto}) => {
            const n = prototype;
            e.widget(`${n.namespace}.${n.widgetName}`, a, _proto)
        }), delete s._childConstructors) : i._childConstructors.push(a), e.widget.bridge(t,
          a), a;
    }, e.widget.extend = function (t) {
        for (let i, n, o = u.call(arguments, 1), s = 0, a = o.length; a > s; s++)
            for (i in o[s]) n = o[s][i], o[s].hasOwnProperty(i) && void 0 !== n && (t[i] = e
              .isPlainObject(n) ? e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], n) : e
              .widget.extend({}, n) : n);
        return t
    }, e.widget.bridge = (t, i) => {
        const n = i.prototype.widgetFullName || t;
        e.fn[t] = function (o) {
            const s = "string" == typeof o;
            const a = u.call(arguments, 1);
            let r = this;
            return s ? this.each(function () {
                let i;
                const s = e.data(this, n);
                return "instance" === o ? (r = s, !1) : s ? e.isFunction(s[o]) &&
                "_" !== o.charAt(0) ? (i = s[o](...a), i !== s && void 0 !==
                i ? (r = i && i.jquery ? r.pushStack(i.get()) : i, !1) :
                  void 0) : e.error(`no such method '${o}' for ${t} widget instance`) : e.error(`cannot call methods on ${t} prior to initialization; attempted to call method '${o}'`);
            }) : (a.length && (o = e.widget.extend.apply(null, [o].concat(a))), this.each(
              function () {
                  const t = e.data(this, n);
                  t ? (t.option(o || {}), t._init && t._init()) : e.data(this, n,
                    new i(o, this))
              })), r;
        }
    }, e.Widget = () => {}, e.Widget._childConstructors = [], e.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            create: null
        },
        _createWidget(t, i) {
            i = e(i || this.defaultElement || this)[0], this.element = e(i), this.uuid = c++,
              this.eventNamespace = `.${this.widgetName}${this.uuid}`, this.bindings = e(),
              this.hoverable = e(), this.focusable = e(), i !== this && (e.data(i, this
                .widgetFullName, this), this._on(!0, this.element, {
                  remove(e) {
                      e.target === i && this.destroy()
                  }
              }), this.document = e(i.style ? i.ownerDocument : i.document || i), this
                .window = e(this.document[0].defaultView || this.document[0].parentWindow)
            ), this.options = e.widget.extend({}, this.options, this
              ._getCreateOptions(), t), this._create(), this._trigger("create", null,
              this._getCreateEventData()), this._init()
        },
        _getCreateOptions: e.noop,
        _getCreateEventData: e.noop,
        _create: e.noop,
        _init: e.noop,
        destroy() {
            this._destroy(), this.element.unbind(this.eventNamespace)
              .removeData(this.widgetFullName)
              .removeData(e.camelCase(this.widgetFullName)), this.widget()
              .unbind(this.eventNamespace)
              .removeAttr("aria-disabled")
              .removeClass(`${this.widgetFullName}-disabled ui-state-disabled`), this
              .bindings.unbind(this.eventNamespace), this.hoverable.removeClass(
              "ui-state-hover"), this.focusable.removeClass("ui-state-focus")
        },
        _destroy: e.noop,
        widget() {
            return this.element
        },
        option(t, i) {
            let n;
            let o;
            let s;
            let a = t;
            if (0 === arguments.length) return e.widget.extend({}, this.options);
            if ("string" == typeof t)
                if (a = {}, n = t.split("."), t = n.shift(), n.length) {
                    for (o = a[t] = e.widget.extend({}, this.options[t]), s = 0; s < n
                      .length - 1; s++) o[n[s]] = o[n[s]] || {}, o = o[n[s]];
                    if (t = n.pop(), 1 === arguments.length) return void 0 === o[t] ? null :
                      o[t];
                    o[t] = i
                } else {
                    if (1 === arguments.length) return void 0 === this.options[t] ? null :
                      this.options[t];
                    a[t] = i
                }return this._setOptions(a), this
        },
        _setOptions(e) {
            let t;
            for (t in e) this._setOption(t, e[t]);
            return this
        },
        _setOption(e, t) {
            return this.options[e] = t, "disabled" === e && (this.widget()
              .toggleClass(`${this.widgetFullName}-disabled`, !!t), t && (this.hoverable
              .removeClass("ui-state-hover"), this.focusable.removeClass(
              "ui-state-focus"))), this;
        },
        enable() {
            return this._setOptions({
                disabled: !1
            })
        },
        disable() {
            return this._setOptions({
                disabled: !0
            })
        },
        _on(t, i, n) {
            let o;
            const s = this;
            "boolean" != typeof t && (n = i, i = t, t = !1), n ? (i = o = e(i), this
              .bindings = this.bindings.add(i)) : (n = i, i = this.element, o = this
              .widget()), e.each(n, (n, a) => {
                function r(...args) {
                    return t || s.options.disabled !== !0 && !e(this)
                      .hasClass("ui-state-disabled") ? ("string" == typeof a ? s[
                      a] : a)
                      .apply(s, args) : void 0;
                }
                "string" != typeof a && (r.guid = a.guid = a.guid || r.guid || e
                  .guid++);
                const l = n.match(/^([\w:-]*)\s*(.*)$/);
                const c = l[1] + s.eventNamespace;
                const u = l[2];
                u ? o.delegate(u, c, r) : i.bind(c, r)
            })
        },
        _off(t, i) {
            i = (i || "")
              .split(" ")
              .join(`${this.eventNamespace} `) + this.eventNamespace, t.unbind(i)
              .undelegate(i), this.bindings = e(this.bindings.not(t)
              .get()), this.focusable = e(this.focusable.not(t)
              .get()), this.hoverable = e(this.hoverable.not(t)
              .get())
        },
        _delay(e, t) {
            function i(...args) {
                return ("string" == typeof e ? n[e] : e)
                  .apply(n, args);
            }
            var n = this;
            return setTimeout(i, t || 0)
        },
        _hoverable(t) {
            this.hoverable = this.hoverable.add(t), this._on(t, {
                mouseenter({currentTarget}) {
                    e(currentTarget)
                      .addClass("ui-state-hover")
                },
                mouseleave({currentTarget}) {
                    e(currentTarget)
                      .removeClass("ui-state-hover")
                }
            })
        },
        _focusable(t) {
            this.focusable = this.focusable.add(t), this._on(t, {
                focusin({currentTarget}) {
                    e(currentTarget)
                      .addClass("ui-state-focus")
                },
                focusout({currentTarget}) {
                    e(currentTarget)
                      .removeClass("ui-state-focus")
                }
            })
        },
        _trigger(t, i, n) {
            let o;
            let s;
            const a = this.options[t];
            if (n = n || {}, i = e.Event(i), i.type = (t === this.widgetEventPrefix ? t : this
              .widgetEventPrefix + t)
              .toLowerCase(), i.target = this.element[0], s = i.originalEvent)
                for (o in s) o in i || (i[o] = s[o]);
            return this.element.trigger(i, n), !(e.isFunction(a) && a.apply(this.element[0], [
                i].concat(n)) === !1 || i.isDefaultPrevented())
        }
    }, e.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, (t, i) => {
        e.Widget.prototype[`_${t}`] = (n, o, s) => {
            "string" == typeof o && (o = {
                effect: o
            });
            let a;
            const r = o ? o === !0 || "number" == typeof o ? i : o.effect || i : t;
            o = o || {}, "number" == typeof o && (o = {
                duration: o
            }), a = !e.isEmptyObject(o), o.complete = s, o.delay && n.delay(o.delay),
              a && e.effects && e.effects.effect[r] ? n[t](o) : r !== t && n[r] ? n[r](o
                .duration, o.easing, s) : n.queue(function (i) {
                  e(this)[t](), s && s.call(n[0]), i()
              })
        }
    }), e.widget;
    /*!
       * jQuery UI Mouse 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/mouse/
       */
    let d = !1;
    e(document)
      .mouseup(() => {
          d = !1
      }), e.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit() {
            const t = this;
            this.element.bind(`mousedown.${this.widgetName}`, e => t._mouseDown(e))
              .bind(`click.${this.widgetName}`, i => !0 === e.data(i.target, `${t.widgetName}.preventClickEvent`) ? (e.removeData(i.target, `${t
  .widgetName}.preventClickEvent`), i
              .stopImmediatePropagation(), !1) : void 0), this.started = !1
        },
        _mouseDestroy() {
            this.element.unbind(`.${this.widgetName}`), this._mouseMoveDelegate && this
              .document.unbind(`mousemove.${this.widgetName}`, this._mouseMoveDelegate)
              .unbind(`mouseup.${this.widgetName}`, this._mouseUpDelegate)
        },
        _mouseDown(t) {
            if (!d) {
                this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this
                  ._mouseDownEvent = t;
                const i = this;
                const n = 1 === t.which;

                const o = "string" == typeof this.options.cancel && t.target.nodeName ? e(t
                  .target)
                  .closest(this.options.cancel)
                  .length : !1;

                return n && !o && this._mouseCapture(t) ? (this.mouseDelayMet = !this
                  .options.delay, this.mouseDelayMet || (this._mouseDelayTimer =
                  setTimeout(() => {
                      i.mouseDelayMet = !0
                  }, this.options.delay)), this._mouseDistanceMet(t) && this
                  ._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(
                  t) !== !1, !this._mouseStarted) ? (t.preventDefault(), !0) : (
                  !0 === e.data(t.target, `${this.widgetName}.preventClickEvent`) && e.removeData(t.target, `${this
  .widgetName}.preventClickEvent`), this
                    ._mouseMoveDelegate = e => i._mouseMove(e), this._mouseUpDelegate = e => i._mouseUp(e), this.document.bind(`mousemove.${this.widgetName}`, this
                    ._mouseMoveDelegate)
                    .bind(`mouseup.${this.widgetName}`, this._mouseUpDelegate), t
                    .preventDefault(), d = !0, !0)) : !0;
            }
        },
        _mouseMove(t) {
            if (this._mouseMoved) {
                if (e.ui.ie && (!document.documentMode || document.documentMode < 9) && !t
                  .button) return this._mouseUp(t);
                if (!t.which) return this._mouseUp(t)
            }
            return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ?
              (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) &&
              this._mouseDelayMet(t) && (this._mouseStarted = this._mouseStart(this
                ._mouseDownEvent, t) !== !1, this._mouseStarted ? this
                ._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
        },
        _mouseUp(t) {
            return this.document.unbind(`mousemove.${this.widgetName}`, this
              ._mouseMoveDelegate)
              .unbind(`mouseup.${this.widgetName}`, this._mouseUpDelegate), this
              ._mouseStarted && (this._mouseStarted = !1, t.target === this
              ._mouseDownEvent.target && e.data(t.target, `${this.widgetName}.preventClickEvent`, !0), this._mouseStop(t)), d = !1, !1;
        },
        _mouseDistanceMet({pageX, pageY}) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - pageX), Math.abs(this
              ._mouseDownEvent.pageY - pageY)) >= this.options.distance;
        },
        _mouseDelayMet() {
            return this.mouseDelayMet
        },
        _mouseStart() {},
        _mouseDrag() {},
        _mouseStop() {},
        _mouseCapture() {
            return !0
        }
    }), /*!
         * jQuery UI Position 1.11.4
         * http://jqueryui.com
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * http://api.jqueryui.com/position/
         */
    (() => {
        function t(e, t, i) {
            return [parseFloat(e[0]) * (p.test(e[0]) ? t / 100 : 1), parseFloat(e[1]) * (p.test(e[
              1]) ? i / 100 : 1)]
        }

        function i(t, i) {
            return parseInt(e.css(t, i), 10) || 0
        }

        function n(t) {
            const i = t[0];
            return 9 === i.nodeType ? {
                width: t.width(),
                height: t.height(),
                offset: {
                    top: 0,
                    left: 0
                }
            } : e.isWindow(i) ? {
                width: t.width(),
                height: t.height(),
                offset: {
                    top: t.scrollTop(),
                    left: t.scrollLeft()
                }
            } : i.preventDefault ? {
                width: 0,
                height: 0,
                offset: {
                    top: i.pageY,
                    left: i.pageX
                }
            } : {
                width: t.outerWidth(),
                height: t.outerHeight(),
                offset: t.offset()
            }
        }
        e.ui = e.ui || {};
        let o;
        let s;
        const a = Math.max;
        const r = Math.abs;
        const l = Math.round;
        const c = /left|center|right/;
        const u = /top|center|bottom/;
        const d = /[\+\-]\d+(\.[\d]+)?%?/;
        const h = /^\w+/;
        var p = /%$/;
        const m = e.fn.position;
        e.position = {
            scrollbarWidth() {
                if (void 0 !== o) return o;
                let t;
                let i;

                const n = e(
                  "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"
                  );

                const s = n.children()[0];
                return e("body")
                  .append(n), t = s.offsetWidth, n.css("overflow", "scroll"), i = s
                  .offsetWidth, t === i && (i = n[0].clientWidth), n.remove(), o = t - i
            },
            getScrollInfo(t) {
                const i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x");
                const n = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y");

                const o = "scroll" === i || "auto" === i && t.width < t.element[0]
                  .scrollWidth;

                const s = "scroll" === n || "auto" === n && t.height < t.element[0]
                  .scrollHeight;

                return {
                    width: s ? e.position.scrollbarWidth() : 0,
                    height: o ? e.position.scrollbarWidth() : 0
                }
            },
            getWithinInfo(t) {
                const i = e(t || window);
                const n = e.isWindow(i[0]);
                const o = !!i[0] && 9 === i[0].nodeType;
                return {
                    element: i,
                    isWindow: n,
                    isDocument: o,
                    offset: i.offset() || {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: i.scrollLeft(),
                    scrollTop: i.scrollTop(),
                    width: n || o ? i.width() : i.outerWidth(),
                    height: n || o ? i.height() : i.outerHeight()
                }
            }
        }, e.fn.position = function (o) {
            if (!o || !o.of) return m.apply(this, arguments);
            o = e.extend({}, o);
            let p;
            let f;
            let _;
            let g;
            let v;
            let b;
            const y = e(o.of);
            const w = e.position.getWithinInfo(o.within);
            const k = e.position.getScrollInfo(w);

            const x = (o.collision || "flip")
              .split(" ");

            const C = {};
            return b = n(y), y[0].preventDefault && (o.at = "left top"), f = b.width, _ = b
              .height, g = b.offset, v = e.extend({}, g), e.each(["my", "at"], function () {
                let e;
                let t;

                let i = (o[this] || "")
                  .split(" ");

                1 === i.length && (i = c.test(i[0]) ? i.concat(["center"]) : u.test(i[
                  0]) ? ["center"].concat(i) : ["center", "center"]), i[0] = c
                  .test(i[0]) ? i[0] : "center", i[1] = u.test(i[1]) ? i[1] :
                  "center", e = d.exec(i[0]), t = d.exec(i[1]), C[this] = [e ? e[
                  0] : 0, t ? t[0] : 0], o[this] = [h.exec(i[0])[0], h.exec(i[
                  1])[0]]
            }), 1 === x.length && (x[1] = x[0]), "right" === o.at[0] ? v.left += f :
              "center" === o.at[0] && (v.left += f / 2), "bottom" === o.at[1] ? v.top += _ :
              "center" === o.at[1] && (v.top += _ / 2), p = t(C.at, f, _), v.left += p[0], v
              .top += p[1], this.each(function () {
                let n;
                let c;
                const u = e(this);
                const d = u.outerWidth();
                const h = u.outerHeight();
                const m = i(this, "marginLeft");
                const b = i(this, "marginTop");
                const z = d + m + i(this, "marginRight") + k.width;
                const T = h + b + i(this, "marginBottom") + k.height;
                const S = e.extend({}, v);
                const A = t(C.my, u.outerWidth(), u.outerHeight());
                "right" === o.my[0] ? S.left -= d : "center" === o.my[0] && (S.left -=
                  d / 2), "bottom" === o.my[1] ? S.top -= h : "center" === o.my[
                  1] && (S.top -= h / 2), S.left += A[0], S.top += A[1], s || (S
                  .left = l(S.left), S.top = l(S.top)), n = {
                    marginLeft: m,
                    marginTop: b
                }, e.each(["left", "top"], (t, i) => {
                    e.ui.position[x[t]] && e.ui.position[x[t]][i](S, {
                        targetWidth: f,
                        targetHeight: _,
                        elemWidth: d,
                        elemHeight: h,
                        collisionPosition: n,
                        collisionWidth: z,
                        collisionHeight: T,
                        offset: [p[0] + A[0], p[1] + A[1]],
                        my: o.my,
                        at: o.at,
                        within: w,
                        elem: u
                    })
                }), o.using && (c = function (e) {
                    const t = g.left - S.left;
                    const i = t + f - d;
                    const n = g.top - S.top;
                    const s = n + _ - h;

                    const l = {
                        target: {
                            element: y,
                            left: g.left,
                            top: g.top,
                            width: f,
                            height: _
                        },
                        element: {
                            element: u,
                            left: S.left,
                            top: S.top,
                            width: d,
                            height: h
                        },
                        horizontal: 0 > i ? "left" : t > 0 ? "right" :
                          "center",
                        vertical: 0 > s ? "top" : n > 0 ? "bottom" :
                          "middle"
                    };

                    d > f && r(t + i) < f && (l.horizontal = "center"), h >
                    _ && r(n + s) < _ && (l.vertical = "middle"), l
                      .important = a(r(t), r(i)) > a(r(n), r(s)) ?
                      "horizontal" : "vertical", o.using.call(this, e, l)
                }), u.offset(e.extend(S, {
                    using: c
                }))
            });
        }, e.ui.position = {
            fit: {
                left(e, {within, collisionPosition, collisionWidth}) {
                    let i;
                    const n = within;
                    const o = n.isWindow ? n.scrollLeft : n.offset.left;
                    const s = n.width;
                    const r = e.left - collisionPosition.marginLeft;
                    const l = o - r;
                    const c = r + collisionWidth - s - o;
                    collisionWidth > s ? l > 0 && 0 >= c ? (i = e.left + l + collisionWidth - s - o, e.left += l - i) : e.left = c > 0 &&
                    0 >= l ? o : l > c ? o + s - collisionWidth : o : l > 0 ? e
                      .left += l : c > 0 ? e.left -= c : e.left = a(e.left - r, e.left)
                },
                top(e, {within, collisionPosition, collisionHeight}) {
                    let i;
                    const n = within;
                    const o = n.isWindow ? n.scrollTop : n.offset.top;
                    const s = within.height;
                    const r = e.top - collisionPosition.marginTop;
                    const l = o - r;
                    const c = r + collisionHeight - s - o;
                    collisionHeight > s ? l > 0 && 0 >= c ? (i = e.top + l + collisionHeight - s - o, e.top += l - i) : e.top = c > 0 &&
                    0 >= l ? o : l > c ? o + s - collisionHeight : o : l > 0 ? e
                      .top += l : c > 0 ? e.top -= c : e.top = a(e.top - r, e.top)
                }
            },
            flip: {
                left(e, t) {
                    let i;
                    let n;
                    const o = t.within;
                    const s = o.offset.left + o.scrollLeft;
                    const a = o.width;
                    const l = o.isWindow ? o.scrollLeft : o.offset.left;
                    const c = e.left - t.collisionPosition.marginLeft;
                    const u = c - l;
                    const d = c + t.collisionWidth - a - l;

                    const h = "left" === t.my[0] ? -t.elemWidth : "right" === t.my[0] ? t
                      .elemWidth : 0;

                    const p = "left" === t.at[0] ? t.targetWidth : "right" === t.at[0] ? -t
                      .targetWidth : 0;

                    const m = -2 * t.offset[0];
                    0 > u ? (i = e.left + h + p + m + t.collisionWidth - a - s, (0 > i ||
                      i < r(u)) && (e.left += h + p + m)) : d > 0 && (n = e.left - t
                      .collisionPosition.marginLeft + h + p + m - l, (n > 0 || r(
                      n) < d) && (e.left += h + p + m))
                },
                top(e, t) {
                    let i;
                    let n;
                    const o = t.within;
                    const s = o.offset.top + o.scrollTop;
                    const a = o.height;
                    const l = o.isWindow ? o.scrollTop : o.offset.top;
                    const c = e.top - t.collisionPosition.marginTop;
                    const u = c - l;
                    const d = c + t.collisionHeight - a - l;
                    const h = "top" === t.my[1];
                    const p = h ? -t.elemHeight : "bottom" === t.my[1] ? t.elemHeight : 0;

                    const m = "top" === t.at[1] ? t.targetHeight : "bottom" === t.at[1] ? -t
                      .targetHeight : 0;

                    const f = -2 * t.offset[1];
                    0 > u ? (n = e.top + p + m + f + t.collisionHeight - a - s, (0 > n ||
                      n < r(u)) && (e.top += p + m + f)) : d > 0 && (i = e.top - t
                      .collisionPosition.marginTop + p + m + f - l, (i > 0 || r(i) <
                      d) && (e.top += p + m + f))
                }
            },
            flipfit: {
                left(...args) {
                    e.ui.position.flip.left.apply(this, args), e.ui.position.fit.left
                      .apply(this, args)
                },
                top(...args) {
                    e.ui.position.flip.top.apply(this, args), e.ui.position.fit.top
                      .apply(this, args)
                }
            }
        }, (() => {
            let t;
            let i;
            let n;
            let o;
            let a;
            const r = document.getElementsByTagName("body")[0];
            const l = document.createElement("div");
            t = document.createElement(r ? "div" : "body"), n = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            }, r && e.extend(n, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
            for (a in n) t.style[a] = n[a];
            t.appendChild(l), i = r || document.documentElement, i.insertBefore(t, i
              .firstChild), l.style.cssText = "position: absolute; left: 10.7432222px;",
              o = e(l)
                .offset()
                .left, s = o > 10 && 11 > o, t.innerHTML = "", i.removeChild(t)
        })()
    })(), e.ui.position, /*!
         * jQuery UI Draggable 1.11.4
         * http://jqueryui.com
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * http://api.jqueryui.com/draggable/
         */
    e.widget("ui.draggable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            drag: null,
            start: null,
            stop: null
        },
        _create() {
            "original" === this.options.helper && this._setPositionRelative(), this
              .options.addClasses && this.element.addClass("ui-draggable"), this.options
              .disabled && this.element.addClass("ui-draggable-disabled"), this
              ._setHandleClassName(), this._mouseInit()
        },
        _setOption(e, t) {
            this._super(e, t), "handle" === e && (this._removeHandleClassName(), this
              ._setHandleClassName())
        },
        _destroy() {
            return (this.helper || this.element)
              .is(".ui-draggable-dragging") ? (this.destroyOnClear = !0, void 0) : (this
              .element.removeClass(
                "ui-draggable ui-draggable-dragging ui-draggable-disabled"), this
              ._removeHandleClassName(), this._mouseDestroy(), void 0)
        },
        _mouseCapture(t) {
            const i = this.options;
            return this._blurActiveElement(t), this.helper || i.disabled || e(t.target)
              .closest(".ui-resizable-handle")
              .length > 0 ? !1 : (this.handle = this._getHandle(t), this.handle ? (this
                ._blockFrames(i.iframeFix === !0 ? "iframe" : i.iframeFix), !0) :
              !1)
        },
        _blockFrames(t) {
            this.iframeBlocks = this.document.find(t)
              .map(function () {
                  const t = e(this);
                  return e("<div>")
                    .css("position", "absolute")
                    .appendTo(t.parent())
                    .outerWidth(t.outerWidth())
                    .outerHeight(t.outerHeight())
                    .offset(t.offset())[0]
              })
        },
        _unblockFrames() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
        },
        _blurActiveElement(t) {
            const i = this.document[0];
            if (this.handleElement.is(t.target)) try {
                i.activeElement && "body" !== i.activeElement.nodeName
                  .toLowerCase() && e(i.activeElement)
                  .blur()
            } catch (n) {}
        },
        _mouseStart(t) {
            const i = this.options;
            return this.helper = this._createHelper(t), this.helper.addClass(
              "ui-draggable-dragging"), this._cacheHelperProportions(), e.ui
              .ddmanager && (e.ui.ddmanager.current = this), this._cacheMargins(), this
              .cssPosition = this.helper.css("position"), this.scrollParent = this
              .helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(),
              this.hasFixedAncestor = this.helper.parents()
                .filter(function () {
                    return "fixed" === e(this)
                      .css("position")
                })
                .length > 0, this.positionAbs = this.element.offset(), this
              ._refreshOffsets(t), this.originalPosition = this.position = this
              ._generatePosition(t, !1), this.originalPageX = t.pageX, this
              .originalPageY = t.pageY, i.cursorAt && this._adjustOffsetFromHelper(i
              .cursorAt), this._setContainment(), this._trigger("start", t) === !1 ?
              (this._clear(), !1) : (this._cacheHelperProportions(), e.ui.ddmanager && !
                i.dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this
                ._normalizeRightBottom(), this._mouseDrag(t, !0), e.ui.ddmanager && e
                .ui.ddmanager.dragStart(this, t), !0)
        },
        _refreshOffsets({pageX, pageY}) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: !1,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }, this.offset.click = {
                left: pageX - this.offset.left,
                top: pageY - this.offset.top
            }
        },
        _mouseDrag(t, i) {
            if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()),
              this.position = this._generatePosition(t, !0), this.positionAbs = this
              ._convertPositionTo("absolute"), !i) {
                const n = this._uiHash();
                if (this._trigger("drag", t, n) === !1) return this._mouseUp({}), !1;
                this.position = n.position
            }
            return this.helper[0].style.left = `${this.position.left}px`, this.helper[0]
              .style.top = `${this.position.top}px`, e.ui.ddmanager && e.ui.ddmanager
              .drag(this, t), !1;
        },
        _mouseStop(t) {
            const i = this;
            let n = !1;
            return e.ui.ddmanager && !this.options.dropBehaviour && (n = e.ui.ddmanager
              .drop(this, t)), this.dropped && (n = this.dropped, this.dropped = !
              1), "invalid" === this.options.revert && !n || "valid" === this.options
              .revert && n || this.options.revert === !0 || e.isFunction(this.options
              .revert) && this.options.revert.call(this.element, n) ? e(this.helper)
              .animate(this.originalPosition, parseInt(this.options.revertDuration, 10),
                () => {
                    i._trigger("stop", t) !== !1 && i._clear()
                }) : this._trigger("stop", t) !== !1 && this._clear(), !1;
        },
        _mouseUp(t) {
            return this._unblockFrames(), e.ui.ddmanager && e.ui.ddmanager.dragStop(this,
              t), this.handleElement.is(t.target) && this.element.focus(), e.ui
              .mouse.prototype._mouseUp.call(this, t)
        },
        cancel() {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this
              ._clear(), this
        },
        _getHandle(t) {
            return this.options.handle ? !!e(t.target)
              .closest(this.element.find(this.options.handle))
              .length : !0
        },
        _setHandleClassName() {
            this.handleElement = this.options.handle ? this.element.find(this.options
              .handle) : this.element, this.handleElement.addClass(
              "ui-draggable-handle")
        },
        _removeHandleClassName() {
            this.handleElement.removeClass("ui-draggable-handle")
        },
        _createHelper(t) {
            const i = this.options;
            const n = e.isFunction(i.helper);

            const o = n ? e(i.helper.apply(this.element[0], [t])) : "clone" === i.helper ?
              this.element.clone()
                .removeAttr("id") : this.element;

            return o.parents("body")
              .length || o.appendTo("parent" === i.appendTo ? this.element[0]
              .parentNode : i.appendTo), n && o[0] === this.element[0] && this
              ._setPositionRelative(), o[0] === this.element[0] || /(fixed|absolute)/
              .test(o.css("position")) || o.css("position", "absolute"), o
        },
        _setPositionRelative() {
            /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style
              .position = "relative")
        },
        _adjustOffsetFromHelper(t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left),
            "right" in t && (this.offset.click.left = this.helperProportions.width - t
              .right + this.margins.left), "top" in t && (this.offset.click.top = t
              .top + this.margins.top), "bottom" in t && (this.offset.click.top =
              this.helperProportions.height - t.bottom + this.margins.top)
        },
        _isRootNode(e) {
            return /(html|body)/i.test(e.tagName) || e === this.document[0]
        },
        _getParentOffset() {
            let t = this.offsetParent.offset();
            const i = this.document[0];
            return "absolute" === this.cssPosition && this.scrollParent[0] !== i && e
              .contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this
              .scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()),
            this._isRootNode(this.offsetParent[0]) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) ||
                  0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"),
                  10) || 0)
            }
        },
        _getRelativeOffset() {
            if ("relative" !== this.cssPosition) return {
                top: 0,
                left: 0
            };
            const e = this.element.position();
            const t = this._isRootNode(this.scrollParent[0]);
            return {
                top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + (t ? 0 : this
                  .scrollParent.scrollTop()),
                left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + (t ? 0 :
                  this.scrollParent.scrollLeft())
            }
        },
        _cacheMargins() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            }
        },
        _cacheHelperProportions() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            }
        },
        _setContainment() {
            let t;
            let i;
            let n;
            const o = this.options;
            const s = this.document[0];
            return this.relativeContainer = null, o.containment ? "window" === o
              .containment ? (this.containment = [e(window)
                .scrollLeft() - this.offset.relative.left - this.offset.parent
                .left, e(window)
                .scrollTop() - this.offset.relative.top - this.offset.parent.top,
                  e(window)
                    .scrollLeft() + e(window)
                    .width() - this.helperProportions.width - this.margins.left, e(
                  window)
                    .scrollTop() + (e(window)
                    .height() || s.body.parentNode.scrollHeight) - this
                    .helperProportions.height - this.margins.top], void 0) :
              "document" === o.containment ? (this.containment = [0, 0, e(s)
                .width() - this.helperProportions.width - this.margins.left, (e(s)
                .height() || s.body.parentNode.scrollHeight) - this
                .helperProportions.height - this.margins.top], void 0) : o.containment
                .constructor === Array ? (this.containment = o.containment, void 0) : (
                "parent" === o.containment && (o.containment = this.helper[0]
                  .parentNode), i = e(o.containment), n = i[0], n && (t =
                  /(scroll|auto)/.test(i.css("overflow")), this.containment = [(
                  parseInt(i.css("borderLeftWidth"), 10) || 0) + (parseInt(i
                  .css("paddingLeft"), 10) || 0), (parseInt(i.css(
                  "borderTopWidth"), 10) || 0) + (parseInt(i.css(
                  "paddingTop"), 10) || 0), (t ? Math.max(n.scrollWidth, n
                  .offsetWidth) : n.offsetWidth) - (parseInt(i.css(
                  "borderRightWidth"), 10) || 0) - (parseInt(i.css(
                  "paddingRight"), 10) || 0) - this.helperProportions
                  .width - this.margins.left - this.margins.right, (t ? Math
                  .max(n.scrollHeight, n.offsetHeight) : n.offsetHeight) - (
                  parseInt(i.css("borderBottomWidth"), 10) || 0) - (
                  parseInt(i.css("paddingBottom"), 10) || 0) - this
                  .helperProportions.height - this.margins.top - this.margins
                  .bottom], this.relativeContainer = i), void 0) : (this
              .containment = null, void 0)
        },
        _convertPositionTo(e, t) {
            t || (t = this.position);
            const i = "absolute" === e ? 1 : -1;
            const n = this._isRootNode(this.scrollParent[0]);
            return {
                top: t.top + this.offset.relative.top * i + this.offset.parent.top * i - (
                  "fixed" === this.cssPosition ? -this.offset.scroll.top : n ? 0 :
                    this.offset.scroll.top) * i,
                left: t.left + this.offset.relative.left * i + this.offset.parent.left *
                  i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : n ? 0 :
                    this.offset.scroll.left) * i
            }
        },
        _generatePosition({pageX, pageY}, t) {
            let i;
            let n;
            let o;
            let s;
            const a = this.options;
            const r = this._isRootNode(this.scrollParent[0]);
            let l = pageX;
            let c = pageY;
            return r && this.offset.scroll || (this.offset.scroll = {
                top: this.scrollParent.scrollTop(),
                left: this.scrollParent.scrollLeft()
            }), t && (this.containment && (this.relativeContainer ? (n = this
              .relativeContainer.offset(), i = [this.containment[0] + n
              .left, this.containment[1] + n.top, this.containment[2] +
            n.left, this.containment[3] + n.top]) : i = this
              .containment, pageX - this.offset.click.left < i[0] && (l = i[
              0] + this.offset.click.left), pageY - this.offset.click
              .top < i[1] && (c = i[1] + this.offset.click.top), pageX - this
              .offset.click.left > i[2] && (l = i[2] + this.offset.click.left),
            pageY - this.offset.click.top > i[3] && (c = i[3] + this.offset
              .click.top)), a.grid && (o = a.grid[1] ? this.originalPageY +
                Math.round((c - this.originalPageY) / a.grid[1]) * a.grid[1] :
                this.originalPageY, c = i ? o - this.offset.click.top >= i[1] ||
              o - this.offset.click.top > i[3] ? o : o - this.offset.click
                .top >= i[1] ? o - a.grid[1] : o + a.grid[1] : o, s = a.grid[0] ?
                this.originalPageX + Math.round((l - this.originalPageX) / a.grid[
                  0]) * a.grid[0] : this.originalPageX, l = i ? s - this.offset
                .click.left >= i[0] || s - this.offset.click.left > i[2] ? s : s -
              this.offset.click.left >= i[0] ? s - a.grid[0] : s + a.grid[0] : s
            ), "y" === a.axis && (l = this.originalPageX), "x" === a.axis && (
              c = this.originalPageY)), {
                top: c - this.offset.click.top - this.offset.relative.top - this
                  .offset.parent.top + ("fixed" === this.cssPosition ? -this.offset
                  .scroll.top : r ? 0 : this.offset.scroll.top),
                left: l - this.offset.click.left - this.offset.relative.left - this
                  .offset.parent.left + ("fixed" === this.cssPosition ? -this.offset
                  .scroll.left : r ? 0 : this.offset.scroll.left)
            };
        },
        _clear() {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this
              .element[0] || this.cancelHelperRemoval || this.helper.remove(), this
              .helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this
              .destroy()
        },
        _normalizeRightBottom() {
            "y" !== this.options.axis && "auto" !== this.helper.css("right") && (this
              .helper.width(this.helper.width()), this.helper.css("right", "auto")),
            "x" !== this.options.axis && "auto" !== this.helper.css("bottom") && (this
              .helper.height(this.helper.height()), this.helper.css("bottom",
              "auto"))
        },
        _trigger(t, i, n) {
            return n = n || this._uiHash(), e.ui.plugin.call(this, t, [i, n, this], !0),
            /^(drag|start|stop)/.test(t) && (this.positionAbs = this
              ._convertPositionTo("absolute"), n.offset = this.positionAbs), e
              .Widget.prototype._trigger.call(this, t, i, n)
        },
        plugins: {},
        _uiHash() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            }
        }
    }), e.ui.plugin.add("draggable", "connectToSortable", {
        start(t, i, n) {
            const o = e.extend({}, i, {
                item: n.element
            });
            n.sortables = [], e(n.options.connectToSortable)
              .each(function () {
                  const i = e(this)
                    .sortable("instance");
                  i && !i.options.disabled && (n.sortables.push(i), i
                    .refreshPositions(), i._trigger("activate", t, o))
              })
        },
        stop(t, i, n) {
            const o = e.extend({}, i, {
                item: n.element
            });
            n.cancelHelperRemoval = !1, e.each(n.sortables, function () {
                const e = this;
                e.isOver ? (e.isOver = 0, n.cancelHelperRemoval = !0, e
                    .cancelHelperRemoval = !1, e._storedCSS = {
                      position: e.placeholder.css("position"),
                      top: e.placeholder.css("top"),
                      left: e.placeholder.css("left")
                  }, e._mouseStop(t), e.options.helper = e.options._helper
                ) : (e.cancelHelperRemoval = !0, e._trigger("deactivate",
                  t, o))
            })
        },
        drag(t, i, n) {
            e.each(n.sortables, function () {
                let o = !1;
                const s = this;
                s.positionAbs = n.positionAbs, s.helperProportions = n
                  .helperProportions, s.offset.click = n.offset.click, s
                  ._intersectsWith(s.containerCache) && (o = !0, e.each(n
                    .sortables,
                  function () {
                      return this.positionAbs = n.positionAbs, this
                        .helperProportions = n.helperProportions, this
                        .offset.click = n.offset.click, this !== s &&
                      this._intersectsWith(this.containerCache) && e
                        .contains(s.element[0], this.element[0]) && (
                        o = !1), o
                  })), o ? (s.isOver || (s.isOver = 1, n._parent = i.helper
                  .parent(), s.currentItem = i.helper.appendTo(s
                  .element)
                  .data("ui-sortable-item", !0), s.options._helper = s
                  .options.helper, s.options.helper = () => i.helper[0], t.target = s.currentItem[0], s._mouseCapture(t, !
                  0), s._mouseStart(t, !0, !0), s.offset.click.top = n
                  .offset.click.top, s.offset.click.left = n.offset
                  .click.left, s.offset.parent.left -= n.offset.parent
                  .left - s.offset.parent.left, s.offset.parent.top -= n
                  .offset.parent.top - s.offset.parent.top, n._trigger(
                  "toSortable", t), n.dropped = s.element, e.each(n
                    .sortables,
                  function () {
                      this.refreshPositions()
                  }), n.currentItem = n.element, s.fromOutside = n),
                s.currentItem && (s._mouseDrag(t), i.position = s
                  .position)) : s.isOver && (s.isOver = 0, s
                  .cancelHelperRemoval = !0, s.options._revert = s.options
                  .revert, s.options.revert = !1, s._trigger("out", t, s
                  ._uiHash(s)), s._mouseStop(t, !0), s.options.revert =
                  s.options._revert, s.options.helper = s.options._helper, s
                  .placeholder && s.placeholder.remove(), i.helper.appendTo(
                  n._parent), n._refreshOffsets(t), i.position = n
                  ._generatePosition(t, !0), n._trigger("fromSortable", t),
                  n.dropped = !1, e.each(n.sortables, function () {
                    this.refreshPositions()
                }))
            })
        }
    }), e.ui.plugin.add("draggable", "cursor", {
        start(t, i, {options}) {
            const o = e("body");
            const s = options;
            o.css("cursor") && (s._cursor = o.css("cursor")), o.css("cursor", s.cursor)
        },
        stop(t, i, {options}) {
            const o = options;
            o._cursor && e("body")
              .css("cursor", o._cursor)
        }
    }), e.ui.plugin.add("draggable", "opacity", {
        start(t, {helper}, {options}) {
            const o = e(helper);
            const s = options;
            o.css("opacity") && (s._opacity = o.css("opacity")), o.css("opacity", s
              .opacity)
        },
        stop(t, {helper}, {options}) {
            const o = options;
            o._opacity && e(helper)
              .css("opacity", o._opacity)
        }
    }), e.ui.plugin.add("draggable", "scroll", {
        start(e, t, i) {
            i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!
              1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i
              .scrollParentNotHidden[0].tagName && (i.overflowOffset = i
              .scrollParentNotHidden.offset())
        },
        drag(t, i, n) {
            const o = n.options;
            let s = !1;
            const a = n.scrollParentNotHidden[0];
            const r = n.document[0];
            a !== r && "HTML" !== a.tagName ? (o.axis && "x" === o.axis || (n
              .overflowOffset.top + a.offsetHeight - t.pageY < o
              .scrollSensitivity ? a.scrollTop = s = a.scrollTop + o
              .scrollSpeed : t.pageY - n.overflowOffset.top < o
              .scrollSensitivity && (a.scrollTop = s = a.scrollTop - o
              .scrollSpeed)), o.axis && "y" === o.axis || (n.overflowOffset
              .left + a.offsetWidth - t.pageX < o.scrollSensitivity ? a
              .scrollLeft = s = a.scrollLeft + o.scrollSpeed : t.pageX - n
              .overflowOffset.left < o.scrollSensitivity && (a.scrollLeft = s =
              a.scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (t
              .pageY - e(r)
              .scrollTop() < o.scrollSensitivity ? s = e(r)
              .scrollTop(e(r)
                .scrollTop() - o.scrollSpeed) : e(window)
              .height() - (t.pageY - e(r)
              .scrollTop()) < o.scrollSensitivity && (s = e(r)
              .scrollTop(e(r)
                .scrollTop() + o.scrollSpeed))), o.axis && "y" === o
              .axis || (t.pageX - e(r)
              .scrollLeft() < o.scrollSensitivity ? s = e(r)
              .scrollLeft(e(r)
                .scrollLeft() - o.scrollSpeed) : e(window)
              .width() - (t.pageX - e(r)
              .scrollLeft()) < o.scrollSensitivity && (s = e(r)
              .scrollLeft(e(r)
                .scrollLeft() + o.scrollSpeed)))), s !== !1 && e.ui
              .ddmanager && !o.dropBehaviour && e.ui.ddmanager.prepareOffsets(n, t)
        }
    }), e.ui.plugin.add("draggable", "snap", {
        start(t, i, n) {
            const o = n.options;
            n.snapElements = [], e(o.snap.constructor !== String ? o.snap.items ||
              ":data(ui-draggable)" : o.snap)
              .each(function () {
                const t = e(this);
                const i = t.offset();
                this !== n.element[0] && n.snapElements.push({
                    item: this,
                    width: t.outerWidth(),
                    height: t.outerHeight(),
                    top: i.top,
                    left: i.left
                })
            })
        },
        drag(t, i, n) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            const m = n.options;
            const f = m.snapTolerance;
            const _ = i.offset.left;
            const g = _ + n.helperProportions.width;
            const v = i.offset.top;
            const b = v + n.helperProportions.height;
            for (h = n.snapElements.length - 1; h >= 0; h--) l = n.snapElements[h].left -
              n.margins.left, c = l + n.snapElements[h].width, u = n.snapElements[h]
              .top - n.margins.top, d = u + n.snapElements[h].height, l - f > g || _ >
            c + f || u - f > b || v > d + f || !e.contains(n.snapElements[h].item
              .ownerDocument, n.snapElements[h].item) ? (n.snapElements[h]
              .snapping && n.options.snap.release && n.options.snap.release.call(n
              .element, t, e.extend(n._uiHash(), {
                snapItem: n.snapElements[h].item
            })), n.snapElements[h].snapping = !1) : ("inner" !== m.snapMode &&
            (o = Math.abs(u - b) <= f, s = Math.abs(d - v) <= f, a = Math.abs(l -
              g) <= f, r = Math.abs(c - _) <= f, o && (i.position.top = n
              ._convertPositionTo("relative", {
                  top: u - n.helperProportions.height,
                  left: 0
              })
              .top), s && (i.position.top = n._convertPositionTo(
              "relative", {
                  top: d,
                  left: 0
              })
              .top), a && (i.position.left = n._convertPositionTo(
              "relative", {
                  top: 0,
                  left: l - n.helperProportions.width
              })
              .left), r && (i.position.left = n._convertPositionTo(
              "relative", {
                  top: 0,
                  left: c
              })
              .left)), p = o || s || a || r, "outer" !== m.snapMode && (o = Math
              .abs(u - v) <= f, s = Math.abs(d - b) <= f, a = Math.abs(l - _) <=
              f, r = Math.abs(c - g) <= f, o && (i.position.top = n
              ._convertPositionTo("relative", {
                  top: u,
                  left: 0
              })
              .top), s && (i.position.top = n._convertPositionTo(
              "relative", {
                  top: d - n.helperProportions.height,
                  left: 0
              })
              .top), a && (i.position.left = n._convertPositionTo(
              "relative", {
                  top: 0,
                  left: l
              })
              .left), r && (i.position.left = n._convertPositionTo(
              "relative", {
                  top: 0,
                  left: c - n.helperProportions.width
              })
              .left)), !n.snapElements[h].snapping && (o || s || a || r ||
              p) && n.options.snap.snap && n.options.snap.snap.call(n.element,
              t, e.extend(n._uiHash(), {
                  snapItem: n.snapElements[h].item
              })), n.snapElements[h].snapping = o || s || a || r || p)
        }
    }), e.ui.plugin.add("draggable", "stack", {
        start(t, i, {options}) {
            let o;
            const s = options;

            const a = e.makeArray(e(s.stack))
              .sort((t, i) => (parseInt(e(t)
              .css("zIndex"), 10) || 0) - (parseInt(e(i)
              .css("zIndex"), 10) || 0));

            a.length && (o = parseInt(e(a[0])
              .css("zIndex"), 10) || 0, e(a)
              .each(function (t) {
                  e(this)
                    .css("zIndex", o + t)
              }), this.css("zIndex", o + a.length))
        }
    }), e.ui.plugin.add("draggable", "zIndex", {
        start(t, {helper}, {options}) {
            const o = e(helper);
            const s = options;
            o.css("zIndex") && (s._zIndex = o.css("zIndex")), o.css("zIndex", s.zIndex)
        },
        stop(t, {helper}, {options}) {
            const o = options;
            o._zIndex && e(helper)
              .css("zIndex", o._zIndex)
        }
    }), e.ui.draggable, /*!
         * jQuery UI Droppable 1.11.4
         * http://jqueryui.com
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * http://api.jqueryui.com/droppable/
         */
    e.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create() {
            let t;
            const i = this.options;
            const n = i.accept;
            this.isover = !1, this.isout = !0, this.accept = e.isFunction(n) ? n :
              e => e.is(n), this.proportions = function(...args) {
                return args.length ? (t = args[0], void 0) : t ? t : t = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                };
            }, this._addToManager(i.scope), i.addClasses && this.element.addClass(
              "ui-droppable")
        },
        _addToManager(t) {
            e.ui.ddmanager.droppables[t] = e.ui.ddmanager.droppables[t] || [], e.ui
              .ddmanager.droppables[t].push(this)
        },
        _splice(e) {
            for (let t = 0; t < e.length; t++) e[t] === this && e.splice(t, 1)
        },
        _destroy() {
            const t = e.ui.ddmanager.droppables[this.options.scope];
            this._splice(t), this.element.removeClass(
              "ui-droppable ui-droppable-disabled")
        },
        _setOption(t, i) {
            if ("accept" === t) this.accept = e.isFunction(i) ? i : e => e.is(i);
            else if ("scope" === t) {
                const n = e.ui.ddmanager.droppables[this.options.scope];
                this._splice(n), this._addToManager(i)
            }
            this._super(t, i)
        },
        _activate(t) {
            const i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass),
            i && this._trigger("activate", t, this.ui(i))
        },
        _deactivate(t) {
            const i = e.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options
              .activeClass), i && this._trigger("deactivate", t, this.ui(i))
        },
        _over(t) {
            const i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(
              this.element[0], i.currentItem || i.element) && (this.options
              .hoverClass && this.element.addClass(this.options.hoverClass), this
              ._trigger("over", t, this.ui(i)))
        },
        _out(t) {
            const i = e.ui.ddmanager.current;
            i && (i.currentItem || i.element)[0] !== this.element[0] && this.accept.call(
              this.element[0], i.currentItem || i.element) && (this.options
              .hoverClass && this.element.removeClass(this.options.hoverClass), this
              ._trigger("out", t, this.ui(i)))
        },
        _drop(t, i) {
            const n = i || e.ui.ddmanager.current;
            let o = !1;
            return n && (n.currentItem || n.element)[0] !== this.element[0] ? (this
              .element.find(":data(ui-droppable)")
              .not(".ui-draggable-dragging")
              .each(function () {
                  const i = e(this)
                    .droppable("instance");
                  return i.options.greedy && !i.options.disabled && i.options
                    .scope === n.options.scope && i.accept.call(i.element[0],
                    n.currentItem || n.element) && e.ui.intersect(n, e
                    .extend(i, {
                        offset: i.element.offset()
                    }), i.options.tolerance, t) ? (o = !0, !1) : void 0
              }), o ? !1 : this.accept.call(this.element[0], n.currentItem || n
              .element) ? (this.options.activeClass && this.element.removeClass(
              this.options.activeClass), this.options.hoverClass && this
              .element.removeClass(this.options.hoverClass), this._trigger(
              "drop", t, this.ui(n)), this.element) : !1) : !1;
        },
        ui(e) {
            return {
                draggable: e.currentItem || e.element,
                helper: e.helper,
                position: e.position,
                offset: e.positionAbs
            }
        }
    }), e.ui.intersect = (() => {
        function e(e, t, i) {
            return e >= t && t + i > e
        }
        return (t, i, n, {pageY, pageX}) => {
            if (!i.offset) return !1;

            const s = (t.positionAbs || t.position.absolute)
                .left + t.margins.left;

            const a = (t.positionAbs || t.position.absolute)
              .top + t.margins.top;

            const r = s + t.helperProportions.width;
            const l = a + t.helperProportions.height;
            const c = i.offset.left;
            const u = i.offset.top;

            const d = c + i.proportions()
              .width;

            const h = u + i.proportions()
              .height;

            switch (n) {
                case "fit":
                    return s >= c && d >= r && a >= u && h >= l;
                case "intersect":
                    return c < s + t.helperProportions.width / 2 && r - t.helperProportions
                      .width / 2 < d && u < a + t.helperProportions.height / 2 && l - t
                      .helperProportions.height / 2 < h;
                case "pointer":
                    return e(pageY, u, i.proportions()
                      .height) && e(pageX, c, i.proportions()
                      .width);
                case "touch":
                    return (a >= u && h >= a || l >= u && h >= l || u > a && l > h) && (s >= c &&
                      d >= s || r >= c && d >= r || c > s && r > d);
                default:
                    return !1
            }
        };
    })(), e.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets(t, i) {
            let n;
            let o;
            const s = e.ui.ddmanager.droppables[t.options.scope] || [];
            const a = i ? i.type : null;

            const r = (t.currentItem || t.element)
              .find(":data(ui-droppable)")
              .addBack();

            e: for (n = 0; n < s.length; n++)
                if (!(s[n].options.disabled || t && !s[n].accept.call(s[n].element[0], t
                  .currentItem || t.element))) {
                    for (o = 0; o < r.length; o++)
                        if (r[o] === s[n].element[0]) {
                            s[n].proportions()
                              .height = 0;
                            continue e
                        } s[n].visible = "none" !== s[n].element.css("display"), s[n]
                      .visible && ("mousedown" === a && s[n]._activate.call(s[n], i), s[
                      n].offset = s[n].element.offset(), s[n].proportions({
                        width: s[n].element[0].offsetWidth,
                        height: s[n].element[0].offsetHeight
                    }))
                }
        },
        drop(t, i) {
            let n = !1;
            return e.each((e.ui.ddmanager.droppables[t.options.scope] || [])
                .slice(),
              function () {
                  this.options && (!this.options.disabled && this.visible && e.ui
                    .intersect(t, this, this.options.tolerance, i) && (n = this
                    ._drop.call(this, i) || n), !this.options.disabled && this
                    .visible && this.accept.call(this.element[0], t.currentItem ||
                    t.element) && (this.isout = !0, this.isover = !1, this
                    ._deactivate.call(this, i)))
              }), n
        },
        dragStart(t, i) {
            t.element.parentsUntil("body")
              .bind("scroll.droppable", () => {
                  t.options.refreshPositions || e.ui.ddmanager.prepareOffsets(t, i)
              })
        },
        drag(t, i) {
            t.options.refreshPositions && e.ui.ddmanager.prepareOffsets(t, i), e.each(e.ui
              .ddmanager.droppables[t.options.scope] || [],
              function () {
                  if (!this.options.disabled && !this.greedyChild && this.visible) {
                      let n;
                      let o;
                      let s;

                      const a = e.ui.intersect(t, this, this.options.tolerance,
                        i);

                      const r = !a && this.isover ? "isout" : a && !this.isover ?
                        "isover" : null;

                      r && (this.options.greedy && (o = this.options.scope, s = this
                        .element.parents(":data(ui-droppable)")
                        .filter(function () {
                            return e(this)
                              .droppable("instance")
                              .options.scope === o
                        }), s.length && (n = e(s[0])
                        .droppable("instance"), n.greedyChild =
                        "isover" === r)), n && "isover" === r && (n
                        .isover = !1, n.isout = !0, n._out.call(n, i)), this[
                        r] = !0, this["isout" === r ? "isover" : "isout"] = !
                        1, this["isover" === r ? "_over" : "_out"].call(this, i),
                      n && "isout" === r && (n.isout = !1, n.isover = !0, n
                        ._over.call(n, i)))
                  }
              })
        },
        dragStop(t, i) {
            t.element.parentsUntil("body")
              .unbind("scroll.droppable"), t.options.refreshPositions || e.ui.ddmanager
              .prepareOffsets(t, i)
        }
    }, e.ui.droppable, /*!
         * jQuery UI Resizable 1.11.4
         * http://jqueryui.com
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * http://api.jqueryui.com/resizable/
         */
    e.widget("ui.resizable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num(e) {
            return parseInt(e, 10) || 0
        },
        _isNumber(e) {
            return !isNaN(parseInt(e, 10))
        },
        _hasScroll(t, i) {
            if ("hidden" === e(t)
              .css("overflow")) return !1;
            const n = i && "left" === i ? "scrollLeft" : "scrollTop";
            let o = !1;
            return t[n] > 0 ? !0 : (t[n] = 1, o = t[n] > 0, t[n] = 0, o)
        },
        _create() {
            let t;
            let i;
            let n;
            let o;
            let s;
            const a = this;
            const r = this.options;
            if (this.element.addClass("ui-resizable"), e.extend(this, {
                _aspectRatio: !!r.aspectRatio,
                aspectRatio: r.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: r.helper || r.ghost || r.animate ? r.helper ||
                  "ui-resizable-helper" : null
            }), this.element[0].nodeName.match(
              /^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(
              e("<div class='ui-wrapper' style='overflow: hidden;'></div>")
                .css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                })), this.element = this.element.parent()
              .data("ui-resizable", this.element.resizable("instance")), this
              .elementIsWrapper = !0, this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), this.originalResizeStyle = this.originalElement.css("resize"),
              this.originalElement.css("resize", "none"), this
              ._proportionallyResizeElements.push(this.originalElement.css({
                  position: "static",
                  zoom: 1,
                  display: "block"
              })), this.originalElement.css({
                margin: this.originalElement.css("margin")
            }), this._proportionallyResize()), this.handles = r.handles || (e(
              ".ui-resizable-handle", this.element)
              .length ? {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            } : "e,s,se"), this._handles = e(), this.handles.constructor ===
            String)
                for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), t =
                  this.handles.split(","), this.handles = {}, i = 0; i < t.length; i++)
                    n = e.trim(t[i]), s = `ui-resizable-${n}`, o = e(
                      `<div class='ui-resizable-handle ${s}'></div>`), o.css({
                        zIndex: r.zIndex
                    }), "se" === n && o.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),
                      this.handles[n] = `.ui-resizable-${n}`, this.element.append(o);
            this._renderAxis = function (t) {
                let i;
                let n;
                let o;
                let s;
                t = t || this.element;
                for (i in this.handles) this.handles[i].constructor === String ? this
                  .handles[i] = this.element.children(this.handles[i])
                  .first()
                  .show() : (this.handles[i].jquery || this.handles[i].nodeType) &&
                  (this.handles[i] = e(this.handles[i]), this._on(this.handles[i], {
                      mousedown: a._mouseDown
                  })), this.elementIsWrapper && this.originalElement[0].nodeName
                  .match(/^(textarea|input|select|button)$/i) && (n = e(this
                  .handles[i], this.element), s = /sw|ne|nw|se|n|s/.test(
                  i) ? n.outerHeight() : n.outerWidth(), o = ["padding",
                    /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" :
                      /^e$/.test(i) ? "Right" : "Left"].join(""), t.css(o, s),
                  this._proportionallyResize()), this._handles = this._handles
                  .add(this.handles[i])
            }, this._renderAxis(this.element), this._handles = this._handles.add(this
              .element.find(".ui-resizable-handle")), this._handles
              .disableSelection(), this._handles.mouseover(function () {
                a.resizing || (this.className && (o = this.className.match(
                  /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), a.axis = o &&
                o[1] ? o[1] : "se")
            }), r.autoHide && (this._handles.hide(), e(this.element)
              .addClass("ui-resizable-autohide")
              .mouseenter(function () {
                  r.disabled || (e(this)
                    .removeClass("ui-resizable-autohide"), a._handles
                    .show())
              })
              .mouseleave(function () {
                  r.disabled || a.resizing || (e(this)
                    .addClass("ui-resizable-autohide"), a._handles.hide())
              })), this._mouseInit()
        },
        _destroy() {
            this._mouseDestroy();
            let t;

            const i = t => {
                e(t)
                  .removeClass(
                    "ui-resizable ui-resizable-disabled ui-resizable-resizing")
                  .removeData("resizable")
                  .removeData("ui-resizable")
                  .unbind(".resizable")
                  .find(".ui-resizable-handle")
                  .remove()
            };

            return this.elementIsWrapper && (i(this.element), t = this.element, this
              .originalElement.css({
                  position: t.css("position"),
                  width: t.outerWidth(),
                  height: t.outerHeight(),
                  top: t.css("top"),
                  left: t.css("left")
              })
              .insertAfter(t), t.remove()), this.originalElement.css("resize", this
              .originalResizeStyle), i(this.originalElement), this
        },
        _mouseCapture(t) {
            let i;
            let n;
            let o = !1;
            for (i in this.handles) n = e(this.handles[i])[0], (n === t.target || e
              .contains(n, t.target)) && (o = !0);
            return !this.options.disabled && o
        },
        _mouseStart(t) {
            let i;
            let n;
            let o;
            const s = this.options;
            const a = this.element;
            return this.resizing = !0, this._renderProxy(), i = this._num(this.helper.css(
              "left")), n = this._num(this.helper.css("top")), s.containment && (
              i += e(s.containment)
                .scrollLeft() || 0, n += e(s.containment)
                .scrollTop() || 0), this.offset = this.helper.offset(), this
              .position = {
                left: i,
                top: n
            }, this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: a.width(),
                height: a.height()
            }, this.originalSize = this._helper ? {
                width: a.outerWidth(),
                height: a.outerHeight()
            } : {
                width: a.width(),
                height: a.height()
            }, this.sizeDiff = {
                width: a.outerWidth() - a.width(),
                height: a.outerHeight() - a.height()
            }, this.originalPosition = {
                left: i,
                top: n
            }, this.originalMousePosition = {
                left: t.pageX,
                top: t.pageY
            }, this.aspectRatio = "number" == typeof s.aspectRatio ? s.aspectRatio :
              this.originalSize.width / this.originalSize.height || 1, o = e(
              `.ui-resizable-${this.axis}`)
              .css("cursor"), e("body")
              .css("cursor", "auto" === o ? `${this.axis}-resize` : o), a.addClass(
              "ui-resizable-resizing"), this._propagate("start", t), !0;
        },
        _mouseDrag(t) {
            let i;
            let n;
            const o = this.originalMousePosition;
            const s = this.axis;
            const a = t.pageX - o.left || 0;
            const r = t.pageY - o.top || 0;
            const l = this._change[s];
            return this._updatePrevProperties(), l ? (i = l.apply(this, [t, a, r]), this
              ._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t
              .shiftKey) && (i = this._updateRatio(i, t)), i = this
              ._respectSize(i, t), this._updateCache(i), this._propagate("resize",
              t), n = this._applyChanges(), !this._helper && this
              ._proportionallyResizeElements.length && this._proportionallyResize(),
            e.isEmptyObject(n) || (this._updatePrevProperties(), this._trigger(
              "resize", t, this.ui()), this._applyChanges()), !1) : !1
        },
        _mouseStop(t) {
            this.resizing = !1;
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            const c = this.options;
            const u = this;
            return this._helper && (i = this._proportionallyResizeElements, n = i
              .length && /textarea/i.test(i[0].nodeName), o = n && this._hasScroll(
              i[0], "left") ? 0 : u.sizeDiff.height, s = n ? 0 : u.sizeDiff
              .width, a = {
                width: u.helper.width() - s,
                height: u.helper.height() - o
            }, r = parseInt(u.element.css("left"), 10) + (u.position.left - u
              .originalPosition.left) || null, l = parseInt(u.element.css(
              "top"), 10) + (u.position.top - u.originalPosition.top) || null, c
              .animate || this.element.css(e.extend(a, {
                top: l,
                left: r
            })), u.helper.height(u.size.height), u.helper.width(u.size.width),
            this._helper && !c.animate && this._proportionallyResize()), e("body")
              .css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"),
              this._propagate("stop", t), this._helper && this.helper.remove(), !1
        },
        _updatePrevProperties() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            }, this.prevSize = {
                width: this.size.width,
                height: this.size.height
            }
        },
        _applyChanges() {
            const e = {};
            return this.position.top !== this.prevPosition.top && (e.top = `${this.position
  .top}px`), this.position.left !== this.prevPosition.left && (e
              .left = `${this.position.left}px`), this.size.width !== this.prevSize
              .width && (e.width = `${this.size.width}px`), this.size.height !== this
              .prevSize.height && (e.height = `${this.size.height}px`), this.helper.css(
              e), e;
        },
        _updateVirtualBoundaries(e) {
            let t;
            let i;
            let n;
            let o;
            let s;
            const a = this.options;
            s = {
                minWidth: this._isNumber(a.minWidth) ? a.minWidth : 0,
                maxWidth: this._isNumber(a.maxWidth) ? a.maxWidth : 1 / 0,
                minHeight: this._isNumber(a.minHeight) ? a.minHeight : 0,
                maxHeight: this._isNumber(a.maxHeight) ? a.maxHeight : 1 / 0
            }, (this._aspectRatio || e) && (t = s.minHeight * this.aspectRatio, n = s
              .minWidth / this.aspectRatio, i = s.maxHeight * this.aspectRatio, o =
              s.maxWidth / this.aspectRatio, t > s.minWidth && (s.minWidth = t), n >
            s.minHeight && (s.minHeight = n), i < s.maxWidth && (s.maxWidth = i),
            o < s.maxHeight && (s.maxHeight = o)), this._vBoundaries = s
        },
        _updateCache(e) {
            this.offset = this.helper.offset(), this._isNumber(e.left) && (this.position
              .left = e.left), this._isNumber(e.top) && (this.position.top = e.top),
            this._isNumber(e.height) && (this.size.height = e.height), this._isNumber(
              e.width) && (this.size.width = e.width)
        },
        _updateRatio(e) {
            const t = this.position;
            const i = this.size;
            const n = this.axis;
            return this._isNumber(e.height) ? e.width = e.height * this.aspectRatio : this
              ._isNumber(e.width) && (e.height = e.width / this.aspectRatio), "sw" ===
            n && (e.left = t.left + (i.width - e.width), e.top = null), "nw" === n &&
            (e.top = t.top + (i.height - e.height), e.left = t.left + (i.width - e
              .width)), e
        },
        _respectSize(e) {
            const t = this._vBoundaries;
            const i = this.axis;
            const n = this._isNumber(e.width) && t.maxWidth && t.maxWidth < e.width;
            const o = this._isNumber(e.height) && t.maxHeight && t.maxHeight < e.height;
            const s = this._isNumber(e.width) && t.minWidth && t.minWidth > e.width;
            const a = this._isNumber(e.height) && t.minHeight && t.minHeight > e.height;
            const r = this.originalPosition.left + this.originalSize.width;
            const l = this.position.top + this.size.height;
            const c = /sw|nw|w/.test(i);
            const u = /nw|ne|n/.test(i);
            return s && (e.width = t.minWidth), a && (e.height = t.minHeight), n && (e
              .width = t.maxWidth), o && (e.height = t.maxHeight), s && c && (e
              .left = r - t.minWidth), n && c && (e.left = r - t.maxWidth), a &&
            u && (e.top = l - t.minHeight), o && u && (e.top = l - t.maxHeight), e
              .width || e.height || e.left || !e.top ? e.width || e.height || e.top || !
              e.left || (e.left = null) : e.top = null, e
        },
        _getPaddingPlusBorderDimensions(e) {
            for (var t = 0, i = [], n = [e.css("borderTopWidth"), e.css(
              "borderRightWidth"), e.css("borderBottomWidth"), e.css(
              "borderLeftWidth")], o = [e.css("paddingTop"), e.css(
              "paddingRight"), e.css("paddingBottom"), e.css("paddingLeft")]; 4 >
                 t; t++) i[t] = parseInt(n[t], 10) || 0, i[t] += parseInt(o[t], 10) || 0;
            return {
                height: i[0] + i[2],
                width: i[1] + i[3]
            }
        },
        _proportionallyResize() {
            if (this._proportionallyResizeElements.length)
                for (let e, t = 0, i = this.helper || this.element; t < this
                  ._proportionallyResizeElements.length; t++) e = this
                  ._proportionallyResizeElements[t], this.outerDimensions || (this
                  .outerDimensions = this._getPaddingPlusBorderDimensions(e)), e
                  .css({
                      height: i.height() - this.outerDimensions.height || 0,
                      width: i.width() - this.outerDimensions.width || 0
                  })
        },
        _renderProxy() {
            const t = this.element;
            const i = this.options;
            this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper ||
              e("<div style='overflow:hidden;'></div>"), this.helper.addClass(this
              ._helper)
              .css({
                  width: this.element.outerWidth() - 1,
                  height: this.element.outerHeight() - 1,
                  position: "absolute",
                  left: `${this.elementOffset.left}px`,
                  top: `${this.elementOffset.top}px`,
                  zIndex: ++i.zIndex
              }), this.helper.appendTo("body")
              .disableSelection()) : this.helper = this.element
        },
        _change: {
            e(e, t) {
                return {
                    width: this.originalSize.width + t
                }
            },
            w(e, t) {
                const i = this.originalSize;
                const n = this.originalPosition;
                return {
                    left: n.left + t,
                    width: i.width - t
                }
            },
            n(e, t, i) {
                const n = this.originalSize;
                const o = this.originalPosition;
                return {
                    top: o.top + i,
                    height: n.height - i
                }
            },
            s(e, t, i) {
                return {
                    height: this.originalSize.height + i
                }
            },
            se(t, i, n) {
                return e.extend(this._change.s.apply(this, arguments), this._change.e
                  .apply(this, [t, i, n]))
            },
            sw(t, i, n) {
                return e.extend(this._change.s.apply(this, arguments), this._change.w
                  .apply(this, [t, i, n]))
            },
            ne(t, i, n) {
                return e.extend(this._change.n.apply(this, arguments), this._change.e
                  .apply(this, [t, i, n]))
            },
            nw(t, i, n) {
                return e.extend(this._change.n.apply(this, arguments), this._change.w
                  .apply(this, [t, i, n]))
            }
        },
        _propagate(t, i) {
            e.ui.plugin.call(this, t, [i, this.ui()]), "resize" !== t && this._trigger(t,
              i, this.ui())
        },
        plugins: {},
        ui() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            }
        }
    }), e.ui.plugin.add("resizable", "animate", {
        stop(t) {
            const i = e(this)
                .resizable("instance");

            const n = i.options;
            const o = i._proportionallyResizeElements;
            const s = o.length && /textarea/i.test(o[0].nodeName);
            const a = s && i._hasScroll(o[0], "left") ? 0 : i.sizeDiff.height;
            const r = s ? 0 : i.sizeDiff.width;

            const l = {
                width: i.size.width - r,
                height: i.size.height - a
            };

            const c = parseInt(i.element.css("left"), 10) + (i.position.left - i
              .originalPosition.left) || null;

            const u = parseInt(i.element.css("top"), 10) + (i.position.top - i
              .originalPosition.top) || null;

            i.element.animate(e.extend(l, u && c ? {
                top: u,
                left: c
            } : {}), {
                duration: n.animateDuration,
                easing: n.animateEasing,
                step() {
                    const n = {
                        width: parseInt(i.element.css("width"), 10),
                        height: parseInt(i.element.css("height"), 10),
                        top: parseInt(i.element.css("top"), 10),
                        left: parseInt(i.element.css("left"), 10)
                    };
                    o && o.length && e(o[0])
                      .css({
                          width: n.width,
                          height: n.height
                      }), i._updateCache(n), i._propagate("resize", t)
                }
            })
        }
    }), e.ui.plugin.add("resizable", "containment", {
        start() {
            let t;
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;

            const l = e(this)
                .resizable("instance");

            const c = l.options;
            const u = l.element;
            const d = c.containment;

            const h = d instanceof e ? d.get(0) : /parent/.test(d) ? u.parent()
              .get(0) : d;

            h && (l.containerElement = e(h), /document/.test(d) || d === document ? (l
              .containerOffset = {
                left: 0,
                top: 0
            }, l.containerPosition = {
                left: 0,
                top: 0
            }, l.parentData = {
                element: e(document),
                left: 0,
                top: 0,
                width: e(document)
                  .width(),
                height: e(document)
                  .height() || document.body.parentNode.scrollHeight
            }) : (t = e(h), i = [], e(["Top", "Right", "Left", "Bottom"])
              .each((e, n) => {
                  i[e] = l._num(t.css(`padding${n}`))
              }), l.containerOffset = t.offset(), l.containerPosition = t
              .position(), l.containerSize = {
                height: t.innerHeight() - i[3],
                width: t.innerWidth() - i[1]
            }, n = l.containerOffset, o = l.containerSize.height, s = l
              .containerSize.width, a = l._hasScroll(h, "left") ? h
              .scrollWidth : s, r = l._hasScroll(h) ? h.scrollHeight : o, l
              .parentData = {
                element: h,
                left: n.left,
                top: n.top,
                width: a,
                height: r
            }))
        },
        resize({shiftKey}) {
            let i;
            let n;
            let o;
            let s;

            const a = e(this)
                .resizable("instance");

            const r = a.options;
            const l = a.containerOffset;
            const c = a.position;
            const u = a._aspectRatio || shiftKey;

            let d = {
                top: 0,
                left: 0
            };

            const h = a.containerElement;
            let p = !0;
            h[0] !== document && /static/.test(h.css("position")) && (d = l), c.left < (a
              ._helper ? l.left : 0) && (a.size.width = a.size.width + (a._helper ?
              a.position.left - l.left : a.position.left - d.left), u && (a.size
              .height = a.size.width / a.aspectRatio, p = !1), a.position.left =
              r.helper ? l.left : 0), c.top < (a._helper ? l.top : 0) && (a.size
              .height = a.size.height + (a._helper ? a.position.top - l.top : a
              .position.top), u && (a.size.width = a.size.height * a
              .aspectRatio, p = !1), a.position.top = a._helper ? l.top : 0),
              o = a.containerElement.get(0) === a.element.parent()
                .get(0), s = /relative|absolute/.test(a.containerElement.css("position")),
              o && s ? (a.offset.left = a.parentData.left + a.position.left, a.offset
                .top = a.parentData.top + a.position.top) : (a.offset.left = a.element
                .offset()
                .left, a.offset.top = a.element.offset()
                .top), i = Math.abs(a.sizeDiff.width + (a._helper ? a.offset.left - d
              .left : a.offset.left - l.left)), n = Math.abs(a.sizeDiff.height + (a
              ._helper ? a.offset.top - d.top : a.offset.top - l.top)), i + a.size
              .width >= a.parentData.width && (a.size.width = a.parentData.width - i,
            u && (a.size.height = a.size.width / a.aspectRatio, p = !1)), n + a
              .size.height >= a.parentData.height && (a.size.height = a.parentData
              .height - n, u && (a.size.width = a.size.height * a.aspectRatio, p = !
              1)), p || (a.position.left = a.prevPosition.left, a.position.top =
              a.prevPosition.top, a.size.width = a.prevSize.width, a.size.height = a
              .prevSize.height)
        },
        stop() {
            const t = e(this)
                .resizable("instance");

            const i = t.options;
            const n = t.containerOffset;
            const o = t.containerPosition;
            const s = t.containerElement;
            const a = e(t.helper);
            const r = a.offset();
            const l = a.outerWidth() - t.sizeDiff.width;
            const c = a.outerHeight() - t.sizeDiff.height;
            t._helper && !i.animate && /relative/.test(s.css("position")) && e(this)
              .css({
                  left: r.left - o.left - n.left,
                  width: l,
                  height: c
              }), t._helper && !i.animate && /static/.test(s.css("position")) && e(this)
              .css({
                  left: r.left - o.left - n.left,
                  width: l,
                  height: c
              })
        }
    }), e.ui.plugin.add("resizable", "alsoResize", {
        start() {
            const t = e(this)
                .resizable("instance");

            const i = t.options;
            e(i.alsoResize)
              .each(function () {
                  const t = e(this);
                  t.data("ui-resizable-alsoresize", {
                      width: parseInt(t.width(), 10),
                      height: parseInt(t.height(), 10),
                      left: parseInt(t.css("left"), 10),
                      top: parseInt(t.css("top"), 10)
                  })
              })
        },
        resize(t, {originalElement}) {
            const n = e(this)
                .resizable("instance");

            const o = n.options;
            const s = n.originalSize;
            const a = n.originalPosition;

            const r = {
                height: n.size.height - s.height || 0,
                width: n.size.width - s.width || 0,
                top: n.position.top - a.top || 0,
                left: n.position.left - a.left || 0
            };

            e(o.alsoResize)
              .each(function () {
                const t = e(this);

                const n = e(this)
                  .data("ui-resizable-alsoresize");

                const o = {};

                const s = t.parents(originalElement[0])
                  .length ? ["width", "height"] : ["width", "height", "top",
                    "left"];

                e.each(s, (e, t) => {
                    const i = (n[t] || 0) + (r[t] || 0);
                    i && i >= 0 && (o[t] = i || null)
                }), t.css(o)
            })
        },
        stop() {
            e(this)
              .removeData("resizable-alsoresize")
        }
    }), e.ui.plugin.add("resizable", "ghost", {
        start() {
            const t = e(this)
                .resizable("instance");

            const i = t.options;
            const n = t.size;
            t.ghost = t.originalElement.clone(), t.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: n.height,
                width: n.width,
                margin: 0,
                left: 0,
                top: 0
            })
              .addClass("ui-resizable-ghost")
              .addClass("string" == typeof i.ghost ? i.ghost : ""), t.ghost.appendTo(t
              .helper)
        },
        resize() {
            const t = e(this)
              .resizable("instance");
            t.ghost && t.ghost.css({
                position: "relative",
                height: t.size.height,
                width: t.size.width
            })
        },
        stop() {
            const t = e(this)
              .resizable("instance");
            t.ghost && t.helper && t.helper.get(0)
              .removeChild(t.ghost.get(0))
        }
    }), e.ui.plugin.add("resizable", "grid", {
        resize() {
            let t;

            const i = e(this)
                .resizable("instance");

            const n = i.options;
            const o = i.size;
            const s = i.originalSize;
            const a = i.originalPosition;
            const r = i.axis;
            const l = "number" == typeof n.grid ? [n.grid, n.grid] : n.grid;
            const c = l[0] || 1;
            const u = l[1] || 1;
            const d = Math.round((o.width - s.width) / c) * c;
            const h = Math.round((o.height - s.height) / u) * u;
            let p = s.width + d;
            let m = s.height + h;
            const f = n.maxWidth && n.maxWidth < p;
            const _ = n.maxHeight && n.maxHeight < m;
            const g = n.minWidth && n.minWidth > p;
            const v = n.minHeight && n.minHeight > m;
            n.grid = l, g && (p += c), v && (m += u), f && (p -= c), _ && (m -= u),
              /^(se|s|e)$/.test(r) ? (i.size.width = p, i.size.height = m) : /^(ne)$/
                .test(r) ? (i.size.width = p, i.size.height = m, i.position.top = a.top -
                h) : /^(sw)$/.test(r) ? (i.size.width = p, i.size.height = m, i
                .position.left = a.left - d) : ((0 >= m - u || 0 >= p - c) && (t = i
                ._getPaddingPlusBorderDimensions(this)), m - u > 0 ? (i.size
                .height = m, i.position.top = a.top - h) : (m = u - t.height, i
                .size.height = m, i.position.top = a.top + s.height - m), p - c >
              0 ? (i.size.width = p, i.position.left = a.left - d) : (p = c - t
                .width, i.size.width = p, i.position.left = a.left + s.width - p))
        }
    }), e.ui.resizable, e.widget("ui.selectable", e.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: !0,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create() {
            let t;
            const i = this;
            this.element.addClass("ui-selectable"), this.dragged = !1, this.refresh =
              () => {
                  t = e(i.options.filter, i.element[0]), t.addClass("ui-selectee"), t
                    .each(function () {
                      const t = e(this);
                      const i = t.offset();
                      e.data(this, "selectable-item", {
                          element: this,
                          $element: t,
                          left: i.left,
                          top: i.top,
                          right: i.left + t.outerWidth(),
                          bottom: i.top + t.outerHeight(),
                          startselected: !1,
                          selected: t.hasClass("ui-selected"),
                          selecting: t.hasClass("ui-selecting"),
                          unselecting: t.hasClass("ui-unselecting")
                      })
                  })
              }, this.refresh(), this.selectees = t.addClass("ui-selectee"), this
              ._mouseInit(), this.helper = e("<div class='ui-selectable-helper'></div>")
        },
        _destroy() {
            this.selectees.removeClass("ui-selectee")
              .removeData("selectable-item"), this.element.removeClass(
              "ui-selectable ui-selectable-disabled"), this._mouseDestroy()
        },
        _mouseStart(t) {
            const i = this;
            const n = this.options;
            this.opos = [t.pageX, t.pageY], this.options.disabled || (this.selectees = e(n
              .filter, this.element[0]), this._trigger("start", t), e(n
              .appendTo)
              .append(this.helper), this.helper.css({
                left: t.pageX,
                top: t.pageY,
                width: 0,
                height: 0
            }), n.autoRefresh && this.refresh(), this.selectees.filter(
              ".ui-selected")
              .each(function () {
                  const n = e.data(this, "selectable-item");
                  n.startselected = !0, t.metaKey || t.ctrlKey || (n.$element
                    .removeClass("ui-selected"), n.selected = !1, n
                    .$element.addClass("ui-unselecting"), n
                    .unselecting = !0, i._trigger("unselecting", t, {
                      unselecting: n.element
                  }))
              }), e(t.target)
              .parents()
              .addBack()
              .each(function () {
                let n;
                const o = e.data(this, "selectable-item");
                return o ? (n = !t.metaKey && !t.ctrlKey || !o.$element
                  .hasClass("ui-selected"), o.$element.removeClass(n ?
                  "ui-unselecting" : "ui-selected")
                  .addClass(n ? "ui-selecting" : "ui-unselecting"), o
                  .unselecting = !n, o.selecting = n, o.selected = n,
                  n ? i._trigger("selecting", t, {
                      selecting: o.element
                  }) : i._trigger("unselecting", t, {
                      unselecting: o.element
                  }), !1) : void 0
            }))
        },
        _mouseDrag(t) {
            if (this.dragged = !0, !this.options.disabled) {
                let i;
                const n = this;
                const o = this.options;
                let s = this.opos[0];
                let a = this.opos[1];
                let r = t.pageX;
                let l = t.pageY;
                return s > r && (i = r, r = s, s = i), a > l && (i = l, l = a, a = i),
                  this.helper.css({
                      left: s,
                      top: a,
                      width: r - s,
                      height: l - a
                  }), this.selectees.each(function () {
                    const i = e.data(this, "selectable-item");
                    let c = !1;
                    i && i.element !== n.element[0] && ("touch" === o.tolerance ?
                      c = !(i.left > r || i.right < s || i.top > l || i
                        .bottom < a) : "fit" === o.tolerance && (c = i
                      .left > s && i.right < r && i.top > a && i
                      .bottom < l), c ? (i.selected && (i.$element
                      .removeClass("ui-selected"), i.selected = !1),
                    i.unselecting && (i.$element.removeClass(
                      "ui-unselecting"), i.unselecting = !1), i
                      .selecting || (i.$element.addClass(
                      "ui-selecting"), i.selecting = !0, n._trigger(
                      "selecting", t, {
                          selecting: i.element
                      }))) : (i.selecting && ((t.metaKey || t
                      .ctrlKey) && i.startselected ? (i.$element
                      .removeClass("ui-selecting"), i
                      .selecting = !1, i.$element.addClass(
                      "ui-selected"), i.selected = !0) : (i
                      .$element.removeClass("ui-selecting"), i
                      .selecting = !1, i.startselected && (i
                      .$element.addClass("ui-unselecting"),
                      i.unselecting = !0), n._trigger(
                      "unselecting", t, {
                          unselecting: i.element
                      }))), i.selected && (t.metaKey || t
                      .ctrlKey || i.startselected || (i.$element
                      .removeClass("ui-selected"), i
                      .selected = !1, i.$element.addClass(
                      "ui-unselecting"), i.unselecting = !0,
                      n._trigger("unselecting", t, {
                          unselecting: i.element
                      })))))
                }), !1;
            }
        },
        _mouseStop(t) {
            const i = this;
            return this.dragged = !1, e(".ui-unselecting", this.element[0])
              .each(function () {
                  const n = e.data(this, "selectable-item");
                  n.$element.removeClass("ui-unselecting"), n.unselecting = !1, n
                    .startselected = !1, i._trigger("unselected", t, {
                      unselected: n.element
                  })
              }), e(".ui-selecting", this.element[0])
              .each(function () {
                  const n = e.data(this, "selectable-item");
                  n.$element.removeClass("ui-selecting")
                    .addClass("ui-selected"), n.selecting = !1, n.selected = !0, n
                    .startselected = !0, i._trigger("selected", t, {
                      selected: n.element
                  })
              }), this._trigger("stop", t), this.helper.remove(), !1;
        }
    }), e.widget("ui.sortable", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: !1,
        options: {
            appendTo: "parent",
            axis: !1,
            connectWith: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            dropOnEmpty: !0,
            forcePlaceholderSize: !1,
            forceHelperSize: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            items: "> *",
            opacity: !1,
            placeholder: !1,
            revert: !1,
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis(e, t, i) {
            return e >= t && t + i > e
        },
        _isFloating(e) {
            return /left|right/.test(e.css("float")) || /inline|table-cell/.test(e.css(
              "display"))
        },
        _create() {
            this.containerCache = {}, this.element.addClass("ui-sortable"), this
              .refresh(), this.offset = this.element.offset(), this._mouseInit(), this
              ._setHandleClassName(), this.ready = !0
        },
        _setOption(e, t) {
            this._super(e, t), "handle" === e && this._setHandleClassName()
        },
        _setHandleClassName() {
            this.element.find(".ui-sortable-handle")
              .removeClass("ui-sortable-handle"), e.each(this.items, function () {
                (this.instance.options.handle ? this.item.find(this.instance
                  .options.handle) : this.item)
                  .addClass("ui-sortable-handle")
            })
        },
        _destroy() {
            this.element.removeClass("ui-sortable ui-sortable-disabled")
              .find(".ui-sortable-handle")
              .removeClass("ui-sortable-handle"), this._mouseDestroy();
            for (let e = this.items.length - 1; e >= 0; e--) this.items[e].item
              .removeData(`${this.widgetName}-item`);
            return this
        },
        _mouseCapture(t, i) {
            let n = null;
            let o = !1;
            const s = this;
            return this.reverting ? !1 : this.options.disabled || "static" === this
              .options.type ? !1 : (this._refreshItems(t), e(t.target)
              .parents()
              .each(function () {
                  return e.data(this, `${s.widgetName}-item`) === s ? (n = e(
                    this), !1) : void 0;
              }), e.data(t.target, `${s.widgetName}-item`) === s && (n = e(t
              .target)), n ? !this.options.handle || i || (e(this.options
              .handle, n)
              .find("*")
              .addBack()
              .each(function () {
                  this === t.target && (o = !0)
              }), o) ? (this.currentItem = n, this._removeCurrentsFromItems(), !
              0) : !1 : !1);
        },
        _mouseStart(t, i, n) {
            let o;
            let s;
            const a = this.options;
            if (this.currentContainer = this, this.refreshPositions(), this.helper = this
              ._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(),
              this.scrollParent = this.helper.scrollParent(), this.offset = this
              .currentItem.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, e.extend(this.offset, {
                click: {
                    left: t.pageX - this.offset.left,
                    top: t.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.helper.css("position", "absolute"), this.cssPosition = this
              .helper.css("position"), this.originalPosition = this._generatePosition(
              t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, a
              .cursorAt && this._adjustOffsetFromHelper(a.cursorAt), this
              .domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this
              ._createPlaceholder(), a.containment && this._setContainment(), a
              .cursor && "auto" !== a.cursor && (s = this.document.find("body"), this
              .storedCursor = s.css("cursor"), s.css("cursor", a.cursor), this
              .storedStylesheet = e(`<style>*{ cursor: ${a.cursor} !important; }</style>`)
              .appendTo(s)), a.opacity && (this.helper.css("opacity") && (this
              ._storedOpacity = this.helper.css("opacity")), this.helper.css(
              "opacity", a.opacity)), a.zIndex && (this.helper.css("zIndex") && (
              this._storedZIndex = this.helper.css("zIndex")), this.helper.css(
              "zIndex", a.zIndex)), this.scrollParent[0] !== this.document[0] &&
            "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this
              .scrollParent.offset()), this._trigger("start", t, this._uiHash()),
            this._preserveHelperProportions || this._cacheHelperProportions(), !n)
                for (o = this.containers.length - 1; o >= 0; o--) this.containers[o]
                  ._trigger("activate", t, this._uiHash(this));
            return e.ui.ddmanager && (e.ui.ddmanager.current = this), e.ui.ddmanager && !a
              .dropBehaviour && e.ui.ddmanager.prepareOffsets(this, t), this
              .dragging = !0, this.helper.addClass("ui-sortable-helper"), this
              ._mouseDrag(t), !0
        },
        _mouseDrag(t) {
            let i;
            let n;
            let o;
            let s;
            const a = this.options;
            let r = !1;
            for (this.position = this._generatePosition(t), this.positionAbs = this
              ._convertPositionTo("absolute"), this.lastPositionAbs || (this
              .lastPositionAbs = this.positionAbs), this.options.scroll && (this
              .scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[
              0].tagName ? (this.overflowOffset.top + this.scrollParent[0]
              .offsetHeight - t.pageY < a.scrollSensitivity ? this.scrollParent[
              0].scrollTop = r = this.scrollParent[0].scrollTop + a
              .scrollSpeed : t.pageY - this.overflowOffset.top < a
              .scrollSensitivity && (this.scrollParent[0].scrollTop = r = this
              .scrollParent[0].scrollTop - a.scrollSpeed), this
              .overflowOffset.left + this.scrollParent[0].offsetWidth - t
              .pageX < a.scrollSensitivity ? this.scrollParent[0].scrollLeft =
              r = this.scrollParent[0].scrollLeft + a.scrollSpeed : t.pageX -
              this.overflowOffset.left < a.scrollSensitivity && (this
                .scrollParent[0].scrollLeft = r = this.scrollParent[0]
                .scrollLeft - a.scrollSpeed)) : (t.pageY - this.document
              .scrollTop() < a.scrollSensitivity ? r = this.document.scrollTop(
              this.document.scrollTop() - a.scrollSpeed) : this.window
              .height() - (t.pageY - this.document.scrollTop()) < a
              .scrollSensitivity && (r = this.document.scrollTop(this.document
              .scrollTop() + a.scrollSpeed)), t.pageX - this.document
              .scrollLeft() < a.scrollSensitivity ? r = this.document
              .scrollLeft(this.document.scrollLeft() - a.scrollSpeed) : this
              .window.width() - (t.pageX - this.document.scrollLeft()) < a
              .scrollSensitivity && (r = this.document.scrollLeft(this.document
              .scrollLeft() + a.scrollSpeed))), r !== !1 && e.ui
              .ddmanager && !a.dropBehaviour && e.ui.ddmanager.prepareOffsets(this,
              t)), this.positionAbs = this._convertPositionTo("absolute"), this
              .options.axis && "y" === this.options.axis || (this.helper[0].style.left =
              `${this.position.left}px`), this.options.axis && "x" === this.options
              .axis || (this.helper[0].style.top = `${this.position.top}px`), i = this
              .items.length - 1; i >= 0; i--)
                if (n = this.items[i], o = n.item[0], s = this._intersectsWithPointer(n),
                s && n.instance === this.currentContainer && o !== this.currentItem[
                  0] && this.placeholder[1 === s ? "next" : "prev"]()[0] !== o && !e
                  .contains(this.placeholder[0], o) && ("semi-dynamic" === this.options
                  .type ? !e.contains(this.element[0], o) : !0)) {
                    if (this.direction = 1 === s ? "down" : "up", "pointer" !== this
                      .options.tolerance && !this._intersectsWithSides(n)) break;
                    this._rearrange(t, n), this._trigger("change", t, this._uiHash());
                    break
                }return this._contactContainers(t), e.ui.ddmanager && e.ui.ddmanager
                  .drag(this, t), this._trigger("sort", t, this._uiHash()), this
                  .lastPositionAbs = this.positionAbs, !1
        },
        _mouseStop(t, i) {
            if (t) {
                if (e.ui.ddmanager && !this.options.dropBehaviour && e.ui.ddmanager.drop(
                  this, t), this.options.revert) {
                    const n = this;
                    const o = this.placeholder.offset();
                    const s = this.options.axis;
                    const a = {};
                    s && "x" !== s || (a.left = o.left - this.offset.parent.left - this
                      .margins.left + (this.offsetParent[0] === this.document[0]
                      .body ? 0 : this.offsetParent[0].scrollLeft)), s &&
                    "y" !== s || (a.top = o.top - this.offset.parent.top - this
                      .margins.top + (this.offsetParent[0] === this.document[0]
                      .body ? 0 : this.offsetParent[0].scrollTop)), this
                      .reverting = !0, e(this.helper)
                      .animate(a, parseInt(this.options.revert, 10) || 500,
                        () => {
                            n._clear(t)
                        })
                } else this._clear(t, i);
                return !1
            }
        },
        cancel() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                }), "original" === this.options.helper ? this.currentItem.css(this
                  ._storedCSS)
                  .removeClass("ui-sortable-helper") : this.currentItem.show();
                for (let t = this.containers.length - 1; t >= 0; t--) this.containers[t]
                  ._trigger("deactivate", null, this._uiHash(this)), this.containers[t]
                  .containerCache.over && (this.containers[t]._trigger("out", null, this
                  ._uiHash(this)), this.containers[t].containerCache.over = 0)
            }
            return this.placeholder && (this.placeholder[0].parentNode && this
              .placeholder[0].parentNode.removeChild(this.placeholder[0]),
            "original" !== this.options.helper && this.helper && this.helper[0]
              .parentNode && this.helper.remove(), e.extend(this, {
                helper: null,
                dragging: !1,
                reverting: !1,
                _noFinalSort: null
            }), this.domPosition.prev ? e(this.domPosition.prev)
              .after(this.currentItem) : e(this.domPosition.parent)
              .prepend(this.currentItem)), this
        },
        serialize(t) {
            const i = this._getItemsAsjQuery(t && t.connected);
            const n = [];
            return t = t || {}, e(i)
              .each(function () {
                  const i = (e(t.item || this)
                    .attr(t.attribute || "id") || "")
                    .match(t.expression || /(.+)[\-=_](.+)/);
                  i && n.push(`${t.key || `${i[1]}[]`}=${t.key && t
  .expression ? i[1] : i[2]}`)
              }), !n.length && t.key && n.push(`${t.key}=`), n.join("&");
        },
        toArray(t) {
            const i = this._getItemsAsjQuery(t && t.connected);
            const n = [];
            return t = t || {}, i.each(function () {
                n.push(e(t.item || this)
                  .attr(t.attribute || "id") || "")
            }), n
        },
        _intersectsWith(e) {
            const t = this.positionAbs.left;
            const i = t + this.helperProportions.width;
            const n = this.positionAbs.top;
            const o = n + this.helperProportions.height;
            const s = e.left;
            const a = s + e.width;
            const r = e.top;
            const l = r + e.height;
            const c = this.offset.click.top;
            const u = this.offset.click.left;
            const d = "x" === this.options.axis || n + c > r && l > n + c;
            const h = "y" === this.options.axis || t + u > s && a > t + u;
            const p = d && h;
            return "pointer" === this.options.tolerance || this.options
              .forcePointerForContainers || "pointer" !== this.options.tolerance && this
              .helperProportions[this.floating ? "width" : "height"] > e[this.floating ?
              "width" : "height"] ? p : s < t + this.helperProportions.width / 2 &&
              i - this.helperProportions.width / 2 < a && r < n + this.helperProportions
                .height / 2 && o - this.helperProportions.height / 2 < l
        },
        _intersectsWithPointer(e) {
            const t = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top +
              this.offset.click.top, e.top, e.height);

            const i = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left +
              this.offset.click.left, e.left, e.width);

            const n = t && i;
            const o = this._getDragVerticalDirection();
            const s = this._getDragHorizontalDirection();
            return n ? this.floating ? s && "right" === s || "down" === o ? 2 : 1 : o && (
              "down" === o ? 2 : 1) : !1
        },
        _intersectsWithSides(e) {
            const t = this._isOverAxis(this.positionAbs.top + this.offset.click.top, e.top +
              e.height / 2, e.height);

            const i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, e
              .left + e.width / 2, e.width);

            const n = this._getDragVerticalDirection();
            const o = this._getDragHorizontalDirection();
            return this.floating && o ? "right" === o && i || "left" === o && !i : n && (
              "down" === n && t || "up" === n && !t)
        },
        _getDragVerticalDirection() {
            const e = this.positionAbs.top - this.lastPositionAbs.top;
            return 0 !== e && (e > 0 ? "down" : "up")
        },
        _getDragHorizontalDirection() {
            const e = this.positionAbs.left - this.lastPositionAbs.left;
            return 0 !== e && (e > 0 ? "right" : "left")
        },
        refresh(e) {
            return this._refreshItems(e), this._setHandleClassName(), this
              .refreshPositions(), this
        },
        _connectWith() {
            const e = this.options;
            return e.connectWith.constructor === String ? [e.connectWith] : e.connectWith
        },
        _getItemsAsjQuery(t) {
            function i() {
                r.push(this)
            }
            let n;
            let o;
            let s;
            let a;
            var r = [];
            const l = [];
            const c = this._connectWith();
            if (c && t)
                for (n = c.length - 1; n >= 0; n--)
                    for (s = e(c[n], this.document[0]), o = s.length - 1; o >= 0; o--) a =
                      e.data(s[o], this.widgetFullName), a && a !== this && !a.options
                      .disabled && l.push([e.isFunction(a.options.items) ? a.options
                      .items.call(a.element) : e(a.options.items, a.element)
                      .not(".ui-sortable-helper")
                      .not(".ui-sortable-placeholder"), a]);
            for (l.push([e.isFunction(this.options.items) ? this.options.items.call(this
              .element, null, {
                options: this.options,
                item: this.currentItem
            }) : e(this.options.items, this.element)
              .not(".ui-sortable-helper")
              .not(".ui-sortable-placeholder"), this]), n = l.length - 1; n >=
                 0; n--) l[n][0].each(i);
            return e(r)
        },
        _removeCurrentsFromItems() {
            const t = this.currentItem.find(`:data(${this.widgetName}-item)`);
            this.items = e.grep(this.items, ({item}) => {
                for (let i = 0; i < t.length; i++)
                    if (t[i] === item[0]) return !1;
                return !0
            })
        },
        _refreshItems(t) {
            this.items = [], this.containers = [this];
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            const u = this.items;

            const d = [[e.isFunction(this.options.items) ? this.options.items.call(this
              .element[0], t, {
                item: this.currentItem
            }) : e(this.options.items, this.element), this]];

            const h = this._connectWith();
            if (h && this.ready)
                for (i = h.length - 1; i >= 0; i--)
                    for (o = e(h[i], this.document[0]), n = o.length - 1; n >= 0; n--) s =
                      e.data(o[n], this.widgetFullName), s && s !== this && !s.options
                      .disabled && (d.push([e.isFunction(s.options.items) ? s.options
                      .items.call(s.element[0], t, {
                          item: this.currentItem
                      }) : e(s.options.items, s.element), s]), this.containers
                      .push(s));
            for (i = d.length - 1; i >= 0; i--)
                for (a = d[i][1], r = d[i][0], n = 0, c = r.length; c > n; n++) l = e(r[
                  n]), l.data(`${this.widgetName}-item`, a), u.push({
                    item: l,
                    instance: a,
                    width: 0,
                    height: 0,
                    left: 0,
                    top: 0
                })
        },
        refreshPositions(t) {
            this.floating = this.items.length ? "x" === this.options.axis || this
              ._isFloating(this.items[0].item) : !1, this.offsetParent && this.helper &&
            (this.offset.parent = this._getParentOffset());
            let i;
            let n;
            let o;
            let s;
            for (i = this.items.length - 1; i >= 0; i--) n = this.items[i], n.instance !==
            this.currentContainer && this.currentContainer && n.item[0] !== this
              .currentItem[0] || (o = this.options.toleranceElement ? e(this.options
              .toleranceElement, n.item) : n.item, t || (n.width = o
              .outerWidth(), n.height = o.outerHeight()), s = o.offset(), n.left = s
              .left, n.top = s.top);
            if (this.options.custom && this.options.custom.refreshContainers) this.options
              .custom.refreshContainers.call(this);
            else
                for (i = this.containers.length - 1; i >= 0; i--) s = this.containers[i]
                  .element.offset(), this.containers[i].containerCache.left = s.left,
                  this.containers[i].containerCache.top = s.top, this.containers[i]
                  .containerCache.width = this.containers[i].element.outerWidth(), this
                  .containers[i].containerCache.height = this.containers[i].element
                  .outerHeight();
            return this
        },
        _createPlaceholder(t = this) {
            let i;
            const n = t.options;
            n.placeholder && n.placeholder.constructor !== String || (i = n.placeholder, n
              .placeholder = {
                element() {
                    const n = t.currentItem[0].nodeName.toLowerCase();

                    const o = e(`<${n}>`, t.document[0])
                      .addClass(i || `${t.currentItem[0].className} ui-sortable-placeholder`)
                      .removeClass("ui-sortable-helper");

                    return "tbody" === n ? t._createTrPlaceholder(t
                      .currentItem.find("tr")
                      .eq(0), e("<tr>", t.document[0])
                      .appendTo(o)) : "tr" === n ? t
                      ._createTrPlaceholder(t.currentItem, o) : "img" ===
                      n && o.attr("src", t.currentItem.attr("src")), i || o
                      .css("visibility", "hidden"), o
                },
                update(e, o) {
                    (!i || n.forcePlaceholderSize) && (o.height() || o.height(
                      t.currentItem.innerHeight() - parseInt(t
                        .currentItem.css("paddingTop") || 0, 10) -
                      parseInt(t.currentItem.css("paddingBottom") || 0,
                        10)), o.width() || o.width(t.currentItem
                      .innerWidth() - parseInt(t.currentItem.css(
                      "paddingLeft") || 0, 10) - parseInt(t
                      .currentItem.css("paddingRight") || 0, 10)))
                }
            }), t.placeholder = e(n.placeholder.element.call(t.element, t
              .currentItem)), t.currentItem.after(t.placeholder), n.placeholder
              .update(t, t.placeholder)
        },
        _createTrPlaceholder(t, i) {
            const n = this;
            t.children()
              .each(function () {
                  e("<td>&#160;</td>", n.document[0])
                    .attr("colspan", e(this)
                      .attr("colspan") || 1)
                    .appendTo(i)
              })
        },
        _contactContainers(t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h = null;
            let p = null;
            for (i = this.containers.length - 1; i >= 0; i--)
                if (!e.contains(this.currentItem[0], this.containers[i].element[0]))
                    if (this._intersectsWith(this.containers[i].containerCache)) {
                        if (h && e.contains(this.containers[i].element[0], h.element[0]))
                            continue;
                        h = this.containers[i], p = i
                    } else this.containers[i].containerCache.over && (this.containers[i]
                      ._trigger("out", t, this._uiHash(this)), this.containers[i]
                      .containerCache.over = 0);
            if (h)
                if (1 === this.containers.length) this.containers[p].containerCache
                  .over || (this.containers[p]._trigger("over", t, this._uiHash(this)),
                  this.containers[p].containerCache.over = 1);
                else {
                    for (o = 1e4, s = null, u = h.floating || this._isFloating(this
                      .currentItem), a = u ? "left" : "top", r = u ? "width" :
                      "height", d = u ? "clientX" : "clientY", n = this.items.length -
                      1; n >= 0; n--) e.contains(this.containers[p].element[0], this
                      .items[n].item[0]) && this.items[n].item[0] !== this
                      .currentItem[0] && (l = this.items[n].item.offset()[a], c = !1, t[
                      d] - l > this.items[n][r] / 2 && (c = !0), Math.abs(t[d] -
                      l) < o && (o = Math.abs(t[d] - l), s = this.items[n], this
                      .direction = c ? "up" : "down"));
                    if (!s && !this.options.dropOnEmpty) return;
                    if (this.currentContainer === this.containers[p]) return this
                      .currentContainer.containerCache.over || (this.containers[p]
                      ._trigger("over", t, this._uiHash()), this
                      .currentContainer.containerCache.over = 1), void 0;
                    s ? this._rearrange(t, s, null, !0) : this._rearrange(t, null, this
                      .containers[p].element, !0), this._trigger("change", t, this
                      ._uiHash()), this.containers[p]._trigger("change", t, this
                      ._uiHash(this)), this.currentContainer = this.containers[p],
                      this.options.placeholder.update(this.currentContainer, this
                        .placeholder), this.containers[p]._trigger("over", t, this
                      ._uiHash(this)), this.containers[p].containerCache.over = 1
                }
        },
        _createHelper(t) {
            const i = this.options;

            const n = e.isFunction(i.helper) ? e(i.helper.apply(this.element[0], [t, this
              .currentItem])) : "clone" === i.helper ? this.currentItem.clone() :
              this.currentItem;

            return n.parents("body")
              .length || e("parent" !== i.appendTo ? i.appendTo : this.currentItem[0]
              .parentNode)[0].appendChild(n[0]), n[0] === this.currentItem[0] && (
              this._storedCSS = {
                  width: this.currentItem[0].style.width,
                  height: this.currentItem[0].style.height,
                  position: this.currentItem.css("position"),
                  top: this.currentItem.css("top"),
                  left: this.currentItem.css("left")
              }), (!n[0].style.width || i.forceHelperSize) && n.width(this
              .currentItem.width()), (!n[0].style.height || i.forceHelperSize) && n
              .height(this.currentItem.height()), n
        },
        _adjustOffsetFromHelper(t) {
            "string" == typeof t && (t = t.split(" ")), e.isArray(t) && (t = {
                left: +t[0],
                top: +t[1] || 0
            }), "left" in t && (this.offset.click.left = t.left + this.margins.left),
            "right" in t && (this.offset.click.left = this.helperProportions.width - t
              .right + this.margins.left), "top" in t && (this.offset.click.top = t
              .top + this.margins.top), "bottom" in t && (this.offset.click.top =
              this.helperProportions.height - t.bottom + this.margins.top)
        },
        _getParentOffset() {
            this.offsetParent = this.helper.offsetParent();
            let t = this.offsetParent.offset();
            return "absolute" === this.cssPosition && this.scrollParent[0] !== this
              .document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) &&
            (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent
              .scrollTop()), (this.offsetParent[0] === this.document[0].body || this
              .offsetParent[0].tagName && "html" === this.offsetParent[0].tagName
              .toLowerCase() && e.ui.ie) && (t = {
                top: 0,
                left: 0
            }), {
                top: t.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) ||
                  0),
                left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"),
                  10) || 0)
            }
        },
        _getRelativeOffset() {
            if ("relative" === this.cssPosition) {
                const e = this.currentItem.position();
                return {
                    top: e.top - (parseInt(this.helper.css("top"), 10) || 0) + this
                      .scrollParent.scrollTop(),
                    left: e.left - (parseInt(this.helper.css("left"), 10) || 0) + this
                      .scrollParent.scrollLeft()
                }
            }
            return {
                top: 0,
                left: 0
            }
        },
        _cacheMargins() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            }
        },
        _cacheHelperProportions() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            }
        },
        _setContainment() {
            let t;
            let i;
            let n;
            const o = this.options;
            "parent" === o.containment && (o.containment = this.helper[0].parentNode), (
              "document" === o.containment || "window" === o.containment) && (this
              .containment = [0 - this.offset.relative.left - this.offset.parent
              .left, 0 - this.offset.relative.top - this.offset.parent.top,
                "document" === o.containment ? this.document.width() : this.window
                  .width() - this.helperProportions.width - this.margins.left, (
                  "document" === o.containment ? this.document.width() : this
                    .window.height() || this.document[0].body.parentNode
                    .scrollHeight) - this.helperProportions.height - this.margins
                  .top]), /^(document|window|parent)$/.test(o.containment) || (t =
              e(o.containment)[0], i = e(o.containment)
              .offset(), n = "hidden" !== e(t)
              .css("overflow"), this.containment = [i.left + (parseInt(e(t)
              .css("borderLeftWidth"), 10) || 0) + (parseInt(e(t)
              .css("paddingLeft"), 10) || 0) - this.margins.left, i.top + (
              parseInt(e(t)
                .css("borderTopWidth"), 10) || 0) + (parseInt(e(t)
              .css("paddingTop"), 10) || 0) - this.margins.top, i.left + (
              n ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) -
            (parseInt(e(t)
              .css("borderLeftWidth"), 10) || 0) - (parseInt(e(t)
              .css("paddingRight"), 10) || 0) - this.helperProportions
              .width - this.margins.left, i.top + (n ? Math.max(t.scrollHeight,
              t.offsetHeight) : t.offsetHeight) - (parseInt(e(t)
              .css("borderTopWidth"), 10) || 0) - (parseInt(e(t)
              .css("paddingBottom"), 10) || 0) - this.helperProportions
              .height - this.margins.top])
        },
        _convertPositionTo(t, i) {
            i || (i = this.position);
            const n = "absolute" === t ? 1 : -1;

            const o = "absolute" !== this.cssPosition || this.scrollParent[0] !== this
              .document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ?
              this.scrollParent : this.offsetParent;

            const s = /(html|body)/i.test(o[0].tagName);
            return {
                top: i.top + this.offset.relative.top * n + this.offset.parent.top * n - (
                  "fixed" === this.cssPosition ? -this.scrollParent.scrollTop() :
                    s ? 0 : o.scrollTop()) * n,
                left: i.left + this.offset.relative.left * n + this.offset.parent.left *
                  n - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() :
                    s ? 0 : o.scrollLeft()) * n
            }
        },
        _generatePosition({pageX, pageY}) {
            let i;
            let n;
            const o = this.options;
            let s = pageX;
            let a = pageY;

            const r = "absolute" !== this.cssPosition || this.scrollParent[0] !== this
              .document[0] && e.contains(this.scrollParent[0], this.offsetParent[0]) ?
              this.scrollParent : this.offsetParent;

            const l = /(html|body)/i.test(r[0].tagName);
            return "relative" !== this.cssPosition || this.scrollParent[0] !== this
              .document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this
              .offset.relative = this._getRelativeOffset()), this
              .originalPosition && (this.containment && (pageX - this.offset.click
              .left < this.containment[0] && (s = this.containment[0] + this
              .offset.click.left), pageY - this.offset.click.top < this
              .containment[1] && (a = this.containment[1] + this.offset.click
              .top), pageX - this.offset.click.left > this.containment[
              2] && (s = this.containment[2] + this.offset.click.left), pageY - this.offset.click.top > this.containment[3] && (a = this
              .containment[3] + this.offset.click.top)), o.grid && (i = this
              .originalPageY + Math.round((a - this.originalPageY) / o.grid[
              1]) * o.grid[1], a = this.containment ? i - this.offset.click
              .top >= this.containment[1] && i - this.offset.click.top <= this
              .containment[3] ? i : i - this.offset.click.top >= this
              .containment[1] ? i - o.grid[1] : i + o.grid[1] : i, n = this
              .originalPageX + Math.round((s - this.originalPageX) / o.grid[
              0]) * o.grid[0], s = this.containment ? n - this.offset.click
              .left >= this.containment[0] && n - this.offset.click.left <= this
              .containment[2] ? n : n - this.offset.click.left >= this
              .containment[0] ? n - o.grid[0] : n + o.grid[0] : n)), {
                top: a - this.offset.click.top - this.offset.relative.top - this
                  .offset.parent.top + ("fixed" === this.cssPosition ? -this
                  .scrollParent.scrollTop() : l ? 0 : r.scrollTop()),
                left: s - this.offset.click.left - this.offset.relative.left - this
                  .offset.parent.left + ("fixed" === this.cssPosition ? -this
                  .scrollParent.scrollLeft() : l ? 0 : r.scrollLeft())
            };
        },
        _rearrange(e, {item}, i, n) {
            i ? i[0].appendChild(this.placeholder[0]) : item[0].parentNode.insertBefore(
              this.placeholder[0], "down" === this.direction ? item[0] : item[0]
                .nextSibling), this.counter = this.counter ? ++this.counter : 1;
            const o = this.counter;
            this._delay(function () {
                o === this.counter && this.refreshPositions(!n)
            })
        },
        _clear(e, t) {
            function i(e, t, i) {
                return n => {
                    i._trigger(e, n, t._uiHash(t))
                };
            }
            this.reverting = !1;
            let n;
            const o = [];
            if (!this._noFinalSort && this.currentItem.parent()
              .length && this.placeholder.before(this.currentItem), this._noFinalSort =
              null, this.helper[0] === this.currentItem[0]) {
                for (n in this._storedCSS)("auto" === this._storedCSS[n] || "static" ===
                  this._storedCSS[n]) && (this._storedCSS[n] = "");
                this.currentItem.css(this._storedCSS)
                  .removeClass("ui-sortable-helper")
            } else this.currentItem.show();
            for (this.fromOutside && !t && o.push(function (e) {
                this._trigger("receive", e, this._uiHash(this.fromOutside))
            }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev()
              .not(".ui-sortable-helper")[0] && this.domPosition.parent === this
              .currentItem.parent()[0] || t || o.push(function (e) {
                this._trigger("update", e, this._uiHash())
            }), this !== this.currentContainer && (t || (o.push(function (e) {
                this._trigger("remove", e, this._uiHash())
            }), o.push((e => (function(t) {
                e._trigger("receive", t, this._uiHash(this))
            })).call(this, this.currentContainer)), o.push((e => (function(t) {
                e._trigger("update", t, this._uiHash(this))
            })).call(this, this.currentContainer)))), n = this.containers.length -
              1; n >= 0; n--) t || o.push(i("deactivate", this, this.containers[n])),
            this.containers[n].containerCache.over && (o.push(i("out", this, this
              .containers[n])), this.containers[n].containerCache.over = 0);
            if (this.storedCursor && (this.document.find("body")
              .css("cursor", this.storedCursor), this.storedStylesheet.remove()),
            this._storedOpacity && this.helper.css("opacity", this._storedOpacity),
            this._storedZIndex && this.helper.css("zIndex", "auto" === this
              ._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, t ||
            this._trigger("beforeStop", e, this._uiHash()), this.placeholder[0]
              .parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval ||
            (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this
              .helper = null), !t) {
                for (n = 0; n < o.length; n++) o[n].call(this, e);
                this._trigger("stop", e, this._uiHash())
            }
            return this.fromOutside = !1, !this.cancelHelperRemoval
        },
        _trigger(...args) {
            e.Widget.prototype._trigger.apply(this, args) === !1 && this.cancel()
        },
        _uiHash(t) {
            const i = t || this;
            return {
                helper: i.helper,
                placeholder: i.placeholder || e([]),
                position: i.position,
                originalPosition: i.originalPosition,
                offset: i.positionAbs,
                item: i.currentItem,
                sender: t ? t.element : null
            }
        }
    }), e.widget("ui.accordion", {
        version: "1.11.4",
        options: {
            active: 0,
            animate: {},
            collapsible: !1,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
            activate: null,
            beforeActivate: null
        },
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
        _create() {
            const t = this.options;
            this.prevShow = this.prevHide = e(), this.element.addClass(
              "ui-accordion ui-widget ui-helper-reset")
              .attr("role", "tablist"), t.collapsible || t.active !== !1 && null != t
              .active || (t.active = 0), this._processPanels(), t.active < 0 && (t
              .active += this.headers.length), this._refresh()
        },
        _getCreateEventData() {
            return {
                header: this.active,
                panel: this.active.length ? this.active.next() : e()
            }
        },
        _createIcons() {
            const t = this.options.icons;
            t && (e("<span>")
                .addClass(`ui-accordion-header-icon ui-icon ${t.header}`)
                .prependTo(this.headers), this.active.children(
                ".ui-accordion-header-icon")
                .removeClass(t.header)
                .addClass(t.activeHeader), this.headers.addClass("ui-accordion-icons")
            )
        },
        _destroyIcons() {
            this.headers.removeClass("ui-accordion-icons")
              .children(".ui-accordion-header-icon")
              .remove()
        },
        _destroy() {
            let e;
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset")
              .removeAttr("role"), this.headers.removeClass(
              "ui-accordion-header ui-accordion-header-active ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top"
            )
              .removeAttr("role")
              .removeAttr("aria-expanded")
              .removeAttr("aria-selected")
              .removeAttr("aria-controls")
              .removeAttr("tabIndex")
              .removeUniqueId(), this._destroyIcons(), e = this.headers.next()
              .removeClass(
                "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled"
              )
              .css("display", "")
              .removeAttr("role")
              .removeAttr("aria-hidden")
              .removeAttr("aria-labelledby")
              .removeUniqueId(), "content" !== this.options.heightStyle && e.css(
              "height", "")
        },
        _setOption(e, t) {
            return "active" === e ? (this._activate(t), void 0) : ("event" === e && (this
              .options.event && this._off(this.headers, this.options.event),
              this._setupEvents(t)), this._super(e, t), "collapsible" !== e ||
            t || this.options.active !== !1 || this._activate(0), "icons" === e &&
            (this._destroyIcons(), t && this._createIcons()), "disabled" === e &&
            (this.element.toggleClass("ui-state-disabled", !!t)
              .attr("aria-disabled", t), this.headers.add(this.headers.next())
              .toggleClass("ui-state-disabled", !!t)), void 0)
        },
        _keydown(t) {
            if (!t.altKey && !t.ctrlKey) {
                const i = e.ui.keyCode;
                const n = this.headers.length;
                const o = this.headers.index(t.target);
                let s = !1;
                switch (t.keyCode) {
                    case i.RIGHT:
                    case i.DOWN:
                        s = this.headers[(o + 1) % n];
                        break;
                    case i.LEFT:
                    case i.UP:
                        s = this.headers[(o - 1 + n) % n];
                        break;
                    case i.SPACE:
                    case i.ENTER:
                        this._eventHandler(t);
                        break;
                    case i.HOME:
                        s = this.headers[0];
                        break;
                    case i.END:
                        s = this.headers[n - 1]
                }
                s && (e(t.target)
                  .attr("tabIndex", -1), e(s)
                  .attr("tabIndex", 0), s.focus(), t.preventDefault())
            }
        },
        _panelKeyDown({keyCode, ctrlKey, currentTarget}) {
            keyCode === e.ui.keyCode.UP && ctrlKey && e(currentTarget)
              .prev()
              .focus()
        },
        refresh() {
            const t = this.options;
            this._processPanels(), t.active === !1 && t.collapsible === !0 || !this
              .headers.length ? (t.active = !1, this.active = e()) : t.active === !1 ?
              this._activate(0) : this.active.length && !e.contains(this.element[0],
                this.active[0]) ? this.headers.length === this.headers.find(
                ".ui-state-disabled")
                .length ? (t.active = !1, this.active = e()) : this._activate(Math.max(0,
                t.active - 1)) : t.active = this.headers.index(this.active), this
              ._destroyIcons(), this._refresh()
        },
        _processPanels() {
            const e = this.headers;
            const t = this.panels;
            this.headers = this.element.find(this.options.header)
              .addClass("ui-accordion-header ui-state-default ui-corner-all"), this
              .panels = this.headers.next()
              .addClass(
                "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom"
              )
              .filter(":not(.ui-accordion-content-active)")
              .hide(), t && (this._off(e.not(this.headers)), this._off(t.not(this
              .panels)))
        },
        _refresh() {
            let t;
            const i = this.options;
            const n = i.heightStyle;
            const o = this.element.parent();
            this.active = this._findActive(i.active)
              .addClass("ui-accordion-header-active ui-state-active ui-corner-top")
              .removeClass("ui-corner-all"), this.active.next()
              .addClass("ui-accordion-content-active")
              .show(), this.headers.attr("role", "tab")
              .each(function () {
                const t = e(this);

                const i = t.uniqueId()
                  .attr("id");

                const n = t.next();

                const o = n.uniqueId()
                  .attr("id");

                t.attr("aria-controls", o), n.attr("aria-labelledby", i)
            })
              .next()
              .attr("role", "tabpanel"), this.headers.not(this.active)
              .attr({
                  "aria-selected": "false",
                  "aria-expanded": "false",
                  tabIndex: -1
              })
              .next()
              .attr({
                  "aria-hidden": "true"
              })
              .hide(), this.active.length ? this.active.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            })
              .next()
              .attr({
                  "aria-hidden": "false"
              }) : this.headers.eq(0)
              .attr("tabIndex", 0), this._createIcons(), this._setupEvents(i.event),
              "fill" === n ? (t = o.height(), this.element.siblings(":visible")
                .each(function () {
                  const i = e(this);
                  const n = i.css("position");
                  "absolute" !== n && "fixed" !== n && (t -= i.outerHeight(!0))
              }), this.headers.each(function () {
                  t -= e(this)
                    .outerHeight(!0)
              }), this.headers.next()
                .each(function () {
                    e(this)
                      .height(Math.max(0, t - e(this)
                        .innerHeight() + e(this)
                        .height()))
                })
                .css("overflow", "auto")) : "auto" === n && (t = 0, this.headers
                .next()
                .each(function () {
                    t = Math.max(t, e(this)
                      .css("height", "")
                      .height())
                })
                .height(t))
        },
        _activate(t) {
            let i = this._findActive(t)[0];
            i !== this.active[0] && (i = i || this.active[0], this._eventHandler({
                target: i,
                currentTarget: i,
                preventDefault: e.noop
            }))
        },
        _findActive(t) {
            return "number" == typeof t ? this.headers.eq(t) : e()
        },
        _setupEvents(t) {
            const i = {
                keydown: "_keydown"
            };
            t && e.each(t.split(" "), (e, t) => {
                i[t] = "_eventHandler"
            }), this._off(this.headers.add(this.headers.next())), this._on(this
              .headers, i), this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            }), this._hoverable(this.headers), this._focusable(this.headers)
        },
        _eventHandler(t) {
            const i = this.options;
            const n = this.active;
            const o = e(t.currentTarget);
            const s = o[0] === n[0];
            const a = s && i.collapsible;
            const r = a ? e() : o.next();
            const l = n.next();

            const c = {
                oldHeader: n,
                oldPanel: l,
                newHeader: a ? e() : o,
                newPanel: r
            };

            t.preventDefault(), s && !i.collapsible || this._trigger("beforeActivate", t,
              c) === !1 || (i.active = a ? !1 : this.headers.index(o), this.active =
              s ? e() : o, this._toggle(c), n.removeClass(
              "ui-accordion-header-active ui-state-active"), i.icons && n
              .children(".ui-accordion-header-icon")
              .removeClass(i.icons.activeHeader)
              .addClass(i.icons.header), s || (o.removeClass("ui-corner-all")
              .addClass(
                "ui-accordion-header-active ui-state-active ui-corner-top"), i
              .icons && o.children(".ui-accordion-header-icon")
              .removeClass(i.icons.header)
              .addClass(i.icons.activeHeader), o.next()
              .addClass("ui-accordion-content-active")))
        },
        _toggle(t) {
            const i = t.newPanel;
            const n = this.prevShow.length ? this.prevShow : t.oldPanel;
            this.prevShow.add(this.prevHide)
              .stop(!0, !0), this.prevShow = i, this.prevHide = n, this.options
              .animate ? this._animate(i, n, t) : (n.hide(), i.show(), this
              ._toggleComplete(t)), n.attr({
                "aria-hidden": "true"
            }), n.prev()
              .attr({
                  "aria-selected": "false",
                  "aria-expanded": "false"
              }), i.length && n.length ? n.prev()
              .attr({
                  tabIndex: -1,
                  "aria-expanded": "false"
              }) : i.length && this.headers.filter(function () {
                return 0 === parseInt(e(this)
                  .attr("tabIndex"), 10)
            })
              .attr("tabIndex", -1), i.attr("aria-hidden", "false")
              .prev()
              .attr({
                  "aria-selected": "true",
                  "aria-expanded": "true",
                  tabIndex: 0
              })
        },
        _animate(e, t, i) {
            let n;
            let o;
            let s;
            const a = this;
            let r = 0;
            const l = e.css("box-sizing");
            const c = e.length && (!t.length || e.index() < t.index());
            const u = this.options.animate || {};
            const d = c && u.down || u;

            const h = () => {
                a._toggleComplete(i)
            };

            return "number" == typeof d && (s = d), "string" == typeof d && (o = d), o =
              o || d.easing || u.easing, s = s || d.duration || u.duration, t.length ? e
              .length ? (n = e.show()
              .outerHeight(), t.animate(this.hideProps, {
                duration: s,
                easing: o,
                step(e, t) {
                    t.now = Math.round(e)
                }
            }), e.hide()
              .animate(this.showProps, {
                  duration: s,
                  easing: o,
                  complete: h,
                  step(e, i) {
                      i.now = Math.round(e), "height" !== i.prop ?
                        "content-box" === l && (r += i.now) :
                        "content" !== a.options.heightStyle && (i.now =
                          Math.round(n - t.outerHeight() - r), r = 0)
                  }
              }), void 0) : t.animate(this.hideProps, s, o, h) : e.animate(this
              .showProps, s, o, h);
        },
        _toggleComplete(e) {
            const t = e.oldPanel;
            t.removeClass("ui-accordion-content-active")
              .prev()
              .removeClass("ui-corner-top")
              .addClass("ui-corner-all"), t.length && (t.parent()[0].className = t
              .parent()[0].className), this._trigger("activate", null, e)
        }
    }), e.widget("ui.menu", {
        version: "1.11.4",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left-1 top",
                at: "right top"
            },
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create() {
            this.activeMenu = this.element, this.mouseHandled = !1, this.element
              .uniqueId()
              .addClass("ui-menu ui-widget ui-widget-content")
              .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon")
                .length)
              .attr({
                  role: this.options.role,
                  tabIndex: 0
              }), this.options.disabled && this.element.addClass("ui-state-disabled")
              .attr("aria-disabled", "true"), this._on({
                "mousedown .ui-menu-item": function (e) {
                    e.preventDefault()
                },
                "click .ui-menu-item": function (t) {
                    const i = e(t.target);
                    !this.mouseHandled && i.not(".ui-state-disabled")
                      .length && (this.select(t), t
                      .isPropagationStopped() || (this.mouseHandled = !0), i
                      .has(".ui-menu")
                      .length ? this.expand(t) : !this.element.is(
                      ":focus") && e(this.document[0].activeElement)
                      .closest(".ui-menu")
                      .length && (this.element.trigger("focus", [!0]),
                    this.active && 1 === this.active.parents(
                      ".ui-menu")
                      .length && clearTimeout(this.timer)))
                },
                "mouseenter .ui-menu-item": function (t) {
                    if (!this.previousFilter) {
                        const i = e(t.currentTarget);
                        i.siblings(".ui-state-active")
                          .removeClass("ui-state-active"), this.focus(t, i)
                    }
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus(e, t) {
                    const i = this.active || this.element.find(this.options
                      .items)
                      .eq(0);
                    t || this.focus(e, i)
                },
                blur(t) {
                    this._delay(function () {
                        e.contains(this.element[0], this.document[0]
                          .activeElement) || this.collapseAll(t)
                    })
                },
                keydown: "_keydown"
            }), this.refresh(), this._on(this.document, {
                click(e) {
                    this._closeOnDocumentClick(e) && this.collapseAll(e), this
                      .mouseHandled = !1
                }
            })
        },
        _destroy() {
            this.element.removeAttr("aria-activedescendant")
              .find(".ui-menu")
              .addBack()
              .removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front")
              .removeAttr("role")
              .removeAttr("tabIndex")
              .removeAttr("aria-labelledby")
              .removeAttr("aria-expanded")
              .removeAttr("aria-hidden")
              .removeAttr("aria-disabled")
              .removeUniqueId()
              .show(), this.element.find(".ui-menu-item")
              .removeClass("ui-menu-item")
              .removeAttr("role")
              .removeAttr("aria-disabled")
              .removeUniqueId()
              .removeClass("ui-state-hover")
              .removeAttr("tabIndex")
              .removeAttr("role")
              .removeAttr("aria-haspopup")
              .children()
              .each(function () {
                  const t = e(this);
                  t.data("ui-menu-submenu-carat") && t.remove()
              }), this.element.find(".ui-menu-divider")
              .removeClass("ui-menu-divider ui-widget-content")
        },
        _keydown(t) {
            let i;
            let n;
            let o;
            let s;
            let a = !0;
            switch (t.keyCode) {
                case e.ui.keyCode.PAGE_UP:
                    this.previousPage(t);
                    break;
                case e.ui.keyCode.PAGE_DOWN:
                    this.nextPage(t);
                    break;
                case e.ui.keyCode.HOME:
                    this._move("first", "first", t);
                    break;
                case e.ui.keyCode.END:
                    this._move("last", "last", t);
                    break;
                case e.ui.keyCode.UP:
                    this.previous(t);
                    break;
                case e.ui.keyCode.DOWN:
                    this.next(t);
                    break;
                case e.ui.keyCode.LEFT:
                    this.collapse(t);
                    break;
                case e.ui.keyCode.RIGHT:
                    this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
                    break;
                case e.ui.keyCode.ENTER:
                case e.ui.keyCode.SPACE:
                    this._activate(t);
                    break;
                case e.ui.keyCode.ESCAPE:
                    this.collapse(t);
                    break;
                default:
                    a = !1, n = this.previousFilter || "", o = String.fromCharCode(t.keyCode),
                      s = !1, clearTimeout(this.filterTimer), o === n ? s = !0 : o = n + o,
                      i = this._filterMenuItems(o), i = s && -1 !== i.index(this.active
                      .next()) ? this.active.nextAll(".ui-menu-item") : i, i.length || (
                      o = String.fromCharCode(t.keyCode), i = this._filterMenuItems(o)),
                      i.length ? (this.focus(t, i), this.previousFilter = o, this
                        .filterTimer = this._delay(function () {
                          delete this.previousFilter
                      }, 1e3)) : delete this.previousFilter
            }
            a && t.preventDefault()
        },
        _activate(e) {
            this.active.is(".ui-state-disabled") || (this.active.is(
              "[aria-haspopup='true']") ? this.expand(e) : this.select(e))
        },
        refresh() {
            let t;
            let i;
            const n = this;
            const o = this.options.icons.submenu;
            const s = this.element.find(this.options.menus);
            this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon")
              .length), s.filter(":not(.ui-menu)")
              .addClass("ui-menu ui-widget ui-widget-content ui-front")
              .hide()
              .attr({
                  role: this.options.role,
                  "aria-hidden": "true",
                  "aria-expanded": "false"
              })
              .each(function () {
                const t = e(this);
                const i = t.parent();

                const n = e("<span>")
                  .addClass(`ui-menu-icon ui-icon ${o}`)
                  .data("ui-menu-submenu-carat", !0);

                i.attr("aria-haspopup", "true")
                  .prepend(n), t.attr("aria-labelledby", i.attr("id"))
            }), t = s.add(this.element), i = t.find(this.options.items), i.not(
              ".ui-menu-item")
              .each(function () {
                  const t = e(this);
                  n._isDivider(t) && t.addClass("ui-widget-content ui-menu-divider")
              }), i.not(".ui-menu-item, .ui-menu-divider")
              .addClass("ui-menu-item")
              .uniqueId()
              .attr({
                  tabIndex: -1,
                  role: this._itemRole()
              }), i.filter(".ui-state-disabled")
              .attr("aria-disabled", "true"), this.active && !e.contains(this.element[
              0], this.active[0]) && this.blur()
        },
        _itemRole() {
            return {
                menu: "menuitem",
                listbox: "option"
            } [this.options.role]
        },
        _setOption(e, t) {
            "icons" === e && this.element.find(".ui-menu-icon")
              .removeClass(this.options.icons.submenu)
              .addClass(t.submenu), "disabled" === e && this.element.toggleClass(
              "ui-state-disabled", !!t)
              .attr("aria-disabled", t), this._super(e, t)
        },
        focus(e, t) {
            let i;
            let n;
            this.blur(e, e && "focus" === e.type), this._scrollIntoView(t), this.active =
              t.first(), n = this.active.addClass("ui-state-focus")
              .removeClass("ui-state-active"), this.options.role && this.element.attr(
              "aria-activedescendant", n.attr("id")), this.active.parent()
              .closest(".ui-menu-item")
              .addClass("ui-state-active"), e && "keydown" === e.type ? this._close() :
              this.timer = this._delay(function () {
                  this._close()
              }, this.delay), i = t.children(".ui-menu"), i.length && e && /^mouse/
              .test(e.type) && this._startOpening(i), this.activeMenu = t.parent(), this
              ._trigger("focus", e, {
                  item: t
              })
        },
        _scrollIntoView(t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            this._hasScroll() && (i = parseFloat(e.css(this.activeMenu[0],
              "borderTopWidth")) || 0, n = parseFloat(e.css(this.activeMenu[0],
              "paddingTop")) || 0, o = t.offset()
              .top - this.activeMenu.offset()
              .top - i - n, s = this.activeMenu.scrollTop(), a = this.activeMenu
              .height(), r = t.outerHeight(), 0 > o ? this.activeMenu.scrollTop(s +
              o) : o + r > a && this.activeMenu.scrollTop(s + o - a + r))
        },
        blur(e, t) {
            t || clearTimeout(this.timer), this.active && (this.active.removeClass(
              "ui-state-focus"), this.active = null, this._trigger("blur", e, {
                item: this.active
            }))
        },
        _startOpening(e) {
            clearTimeout(this.timer), "true" === e.attr("aria-hidden") && (this.timer =
              this._delay(function () {
                  this._close(), this._open(e)
              }, this.delay))
        },
        _open(t) {
            const i = e.extend({
                of: this.active
            }, this.options.position);
            clearTimeout(this.timer), this.element.find(".ui-menu")
              .not(t.parents(".ui-menu"))
              .hide()
              .attr("aria-hidden", "true"), t.show()
              .removeAttr("aria-hidden")
              .attr("aria-expanded", "true")
              .position(i)
        },
        collapseAll(t, i) {
            clearTimeout(this.timer), this.timer = this._delay(function () {
                let n = i ? this.element : e(t && t.target)
                  .closest(this.element.find(".ui-menu"));
                n.length || (n = this.element), this._close(n), this.blur(t), this
                  .activeMenu = n
            }, this.delay)
        },
        _close(e) {
            e || (e = this.active ? this.active.parent() : this.element), e.find(
              ".ui-menu")
              .hide()
              .attr("aria-hidden", "true")
              .attr("aria-expanded", "false")
              .end()
              .find(".ui-state-active")
              .not(".ui-state-focus")
              .removeClass("ui-state-active")
        },
        _closeOnDocumentClick(t) {
            return !e(t.target)
              .closest(".ui-menu")
              .length
        },
        _isDivider(e) {
            return !/[^\-\u2014\u2013\s]/.test(e.text())
        },
        collapse(e) {
            const t = this.active && this.active.parent()
              .closest(".ui-menu-item", this.element);
            t && t.length && (this._close(), this.focus(e, t))
        },
        expand(e) {
            const t = this.active && this.active.children(".ui-menu ")
              .find(this.options.items)
              .first();
            t && t.length && (this._open(t.parent()), this._delay(function () {
                this.focus(e, t)
            }))
        },
        next(e) {
            this._move("next", "first", e)
        },
        previous(e) {
            this._move("prev", "last", e)
        },
        isFirstItem() {
            return this.active && !this.active.prevAll(".ui-menu-item")
              .length
        },
        isLastItem() {
            return this.active && !this.active.nextAll(".ui-menu-item")
              .length
        },
        _move(e, t, i) {
            let n;
            this.active && (n = "first" === e || "last" === e ? this.active["first" ===
            e ? "prevAll" : "nextAll"](".ui-menu-item")
              .eq(-1) : this.active[`${e}All`](".ui-menu-item")
              .eq(0)), n && n.length && this.active || (n = this.activeMenu.find(
              this.options.items)[t]()), this.focus(i, n)
        },
        nextPage(t) {
            let i;
            let n;
            let o;
            return this.active ? (this.isLastItem() || (this._hasScroll() ? (n = this
              .active.offset()
              .top, o = this.element.height(), this.active.nextAll(
              ".ui-menu-item")
              .each(function () {
                  return i = e(this), i.offset()
                    .top - n - o < 0
              }), this.focus(t, i)) : this.focus(t, this.activeMenu.find(
              this.options.items)[this.active ? "last" : "first"]())), void 0) : (
              this.next(t), void 0)
        },
        previousPage(t) {
            let i;
            let n;
            let o;
            return this.active ? (this.isFirstItem() || (this._hasScroll() ? (n = this
              .active.offset()
              .top, o = this.element.height(), this.active.prevAll(
              ".ui-menu-item")
              .each(function () {
                  return i = e(this), i.offset()
                    .top - n + o > 0
              }), this.focus(t, i)) : this.focus(t, this.activeMenu.find(
              this.options.items)
              .first())), void 0) : (this.next(t), void 0)
        },
        _hasScroll() {
            return this.element.outerHeight() < this.element.prop("scrollHeight")
        },
        select(t) {
            this.active = this.active || e(t.target)
              .closest(".ui-menu-item");
            const i = {
                item: this.active
            };
            this.active.has(".ui-menu")
              .length || this.collapseAll(t, !0), this._trigger("select", t, i)
        },
        _filterMenuItems(t) {
            const i = t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
            const n = new RegExp(`^${i}`, "i");
            return this.activeMenu.find(this.options.items)
              .filter(".ui-menu-item")
              .filter(function () {
                  return n.test(e.trim(e(this)
                    .text()))
              })
        }
    }), /*!
         * jQuery UI Autocomplete 1.11.4
         * http://jqueryui.com
         *
         * Copyright jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * http://api.jqueryui.com/autocomplete/
         */
    e.widget("ui.autocomplete", {
        version: "1.11.4",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: !1,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        requestIndex: 0,
        pending: 0,
        _create() {
            let t;
            let i;
            let n;
            const o = this.element[0].nodeName.toLowerCase();
            const s = "textarea" === o;
            const a = "input" === o;
            this.isMultiLine = s ? !0 : a ? !1 : this.element.prop("isContentEditable"),
              this.valueMethod = this.element[s || a ? "val" : "text"], this
              .isNewMenu = !0, this.element.addClass("ui-autocomplete-input")
              .attr("autocomplete", "off"), this._on(this.element, {
                keydown(o) {
                    if (this.element.prop("readOnly")) return t = !0, n = !0,
                      i = !0, void 0;
                    t = !1, n = !1, i = !1;
                    const s = e.ui.keyCode;
                    switch (o.keyCode) {
                        case s.PAGE_UP:
                            t = !0, this._move("previousPage", o);
                            break;
                        case s.PAGE_DOWN:
                            t = !0, this._move("nextPage", o);
                            break;
                        case s.UP:
                            t = !0, this._keyEvent("previous", o);
                            break;
                        case s.DOWN:
                            t = !0, this._keyEvent("next", o);
                            break;
                        case s.ENTER:
                            this.menu.active && (t = !0, o.preventDefault(), this
                              .menu.select(o));
                            break;
                        case s.TAB:
                            this.menu.active && this.menu.select(o);
                            break;
                        case s.ESCAPE:
                            this.menu.element.is(":visible") && (this
                              .isMultiLine || this._value(this.term), this
                              .close(o), o.preventDefault());
                            break;
                        default:
                            i = !0, this._searchTimeout(o)
                    }
                },
                keypress(n) {
                    if (t) return t = !1, (!this.isMultiLine || this.menu
                      .element.is(":visible")) && n
                      .preventDefault(), void 0;
                    if (!i) {
                        const o = e.ui.keyCode;
                        switch (n.keyCode) {
                            case o.PAGE_UP:
                                this._move("previousPage", n);
                                break;
                            case o.PAGE_DOWN:
                                this._move("nextPage", n);
                                break;
                            case o.UP:
                                this._keyEvent("previous", n);
                                break;
                            case o.DOWN:
                                this._keyEvent("next", n)
                        }
                    }
                },
                input(e) {
                    return n ? (n = !1, e.preventDefault(), void 0) : (this
                      ._searchTimeout(e), void 0)
                },
                focus() {
                    this.selectedItem = null, this.previous = this._value()
                },
                blur(e) {
                    return this.cancelBlur ? (delete this.cancelBlur,
                      void 0) : (clearTimeout(this.searching), this.close(
                      e), this._change(e), void 0)
                }
            }), this._initSource(), this.menu = e("<ul>")
              .addClass("ui-autocomplete ui-front")
              .appendTo(this._appendTo())
              .menu({
                  role: null
              })
              .hide()
              .menu("instance"), this._on(this.menu.element, {
                mousedown(t) {
                    t.preventDefault(), this.cancelBlur = !0, this._delay(
                      function () {
                          delete this.cancelBlur
                      });
                    const i = this.menu.element[0];
                    e(t.target)
                      .closest(".ui-menu-item")
                      .length || this._delay(function () {
                        const t = this;
                        this.document.one("mousedown", n => {
                            n.target === t.element[0] || n
                              .target === i || e.contains(i,
                              n.target) || t.close()
                        })
                    })
                },
                menufocus(t, {item}) {
                    let n;
                    let o;
                    return this.isNewMenu && (this.isNewMenu = !1, t
                      .originalEvent && /^mouse/.test(t.originalEvent
                      .type)) ? (this.menu.blur(), this.document
                      .one("mousemove", () => {
                          e(t.target)
                            .trigger(t.originalEvent)
                      }), void 0) : (o = item.data(
                      "ui-autocomplete-item"), !1 !== this._trigger(
                      "focus", t, {
                          item: o
                      }) && t.originalEvent && /^key/.test(t
                      .originalEvent.type) && this._value(o.value),
                      n = item.attr("aria-label") || o.value, n && e
                      .trim(n)
                      .length && (this.liveRegion.children()
                      .hide(), e("<div>")
                      .text(n)
                      .appendTo(this.liveRegion)), void 0);
                },
                menuselect(e, {item}) {
                    const i = item.data("ui-autocomplete-item");
                    const n = this.previous;
                    this.element[0] !== this.document[0].activeElement && (
                      this.element.focus(), this.previous = n, this
                        ._delay(function () {
                            this.previous = n, this.selectedItem = i
                        })), !1 !== this._trigger("select", e, {
                        item: i
                    }) && this._value(i.value), this.term = this._value(),
                      this.close(e), this.selectedItem = i
                }
            }), this.liveRegion = e("<span>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            })
              .addClass("ui-helper-hidden-accessible")
              .appendTo(this.document[0].body), this._on(this.window, {
                beforeunload() {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _destroy() {
            clearTimeout(this.searching), this.element.removeClass(
              "ui-autocomplete-input")
              .removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion
              .remove()
        },
        _setOption(e, t) {
            this._super(e, t), "source" === e && this._initSource(), "appendTo" === e &&
            this.menu.element.appendTo(this._appendTo()), "disabled" === e && t &&
            this.xhr && this.xhr.abort()
        },
        _appendTo() {
            let t = this.options.appendTo;
            return t && (t = t.jquery || t.nodeType ? e(t) : this.document.find(t)
              .eq(0)), t && t[0] || (t = this.element.closest(".ui-front")), t
              .length || (t = this.document[0].body), t
        },
        _initSource() {
            let t;
            let i;
            const n = this;
            e.isArray(this.options.source) ? (t = this.options.source, this.source =
              ({term}, n) => {
                  n(e.ui.autocomplete.filter(t, term))
              }) : "string" == typeof this.options.source ? (i = this.options
              .source, this.source = (t, o) => {
                n.xhr && n.xhr.abort(), n.xhr = e.ajax({
                    url: i,
                    data: t,
                    dataType: "json",
                    success(e) {
                        o(e)
                    },
                    error() {
                        o([])
                    }
                })
            }) : this.source = this.options.source
        },
        _searchTimeout(e) {
            clearTimeout(this.searching), this.searching = this._delay(function () {
                const t = this.term === this._value();
                const i = this.menu.element.is(":visible");
                const n = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;
                (!t || t && !i && !n) && (this.selectedItem = null, this.search(
                  null, e))
            }, this.options.delay)
        },
        search(e, t) {
            return e = null != e ? e : this._value(), this.term = this._value(), e
              .length < this.options.minLength ? this.close(t) : this._trigger("search",
              t) !== !1 ? this._search(e) : void 0
        },
        _search(e) {
            this.pending++, this.element.addClass("ui-autocomplete-loading"), this
              .cancelSearch = !1, this.source({
                term: e
            }, this._response())
        },
        _response() {
            const t = ++this.requestIndex;
            return e.proxy(function (e) {
                t === this.requestIndex && this.__response(e), this.pending--,
                this.pending || this.element.removeClass(
                  "ui-autocomplete-loading")
            }, this)
        },
        __response(e) {
            e && (e = this._normalize(e)), this._trigger("response", null, {
                content: e
            }), !this.options.disabled && e && e.length && !this.cancelSearch ? (this
              ._suggest(e), this._trigger("open")) : this._close()
        },
        close(e) {
            this.cancelSearch = !0, this._close(e)
        },
        _close(e) {
            this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu
              .blur(), this.isNewMenu = !0, this._trigger("close", e))
        },
        _change(e) {
            this.previous !== this._value() && this._trigger("change", e, {
                item: this.selectedItem
            })
        },
        _normalize(t) {
            return t.length && t[0].label && t[0].value ? t : e.map(t, t => "string" == typeof t ? {
                label: t,
                value: t
            } : e.extend({}, t, {
                label: t.label || t.value,
                value: t.value || t.label
            }));
        },
        _suggest(t) {
            const i = this.menu.element.empty();
            this._renderMenu(i, t), this.isNewMenu = !0, this.menu.refresh(), i.show(),
              this._resizeMenu(), i.position(e.extend({
                of: this.element
            }, this.options.position)), this.options.autoFocus && this.menu.next()
        },
        _resizeMenu() {
            const e = this.menu.element;
            e.outerWidth(Math.max(e.width("")
              .outerWidth() + 1, this.element.outerWidth()))
        },
        _renderMenu(t, i) {
            const n = this;
            e.each(i, (e, i) => {
                n._renderItemData(t, i)
            })
        },
        _renderItemData(e, t) {
            return this._renderItem(e, t)
              .data("ui-autocomplete-item", t)
        },
        _renderItem(t, {label}) {
            return e("<li>")
              .text(label)
              .appendTo(t);
        },
        _move(e, t) {
            return this.menu.element.is(":visible") ? this.menu.isFirstItem() &&
            /^previous/.test(e) || this.menu.isLastItem() && /^next/.test(e) ? (this
              .isMultiLine || this._value(this.term), this.menu.blur(), void 0) : (
              this.menu[e](t), void 0) : (this.search(null, t), void 0)
        },
        widget() {
            return this.menu.element
        },
        _value(...args) {
            return this.valueMethod.apply(this.element, args);
        },
        _keyEvent(e, t) {
            (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(e, t),
              t.preventDefault())
        }
    }), e.extend(e.ui.autocomplete, {
        escapeRegex(e) {
            return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
        },
        filter(t, i) {
            const n = new RegExp(e.ui.autocomplete.escapeRegex(i), "i");
            return e.grep(t, e => n.test(e.label || e.value || e));
        }
    }), e.widget("ui.autocomplete", e.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results(e) {
                    return `${e + (e > 1 ? " results are" : " result is")} available, use up and down arrow keys to navigate.`;
                }
            }
        },
        __response(t) {
            let i;
            this._superApply(arguments), this.options.disabled || this.cancelSearch || (
              i = t && t.length ? this.options.messages.results(t.length) : this
                .options.messages.noResults, this.liveRegion.children()
                .hide(), e("<div>")
                .text(i)
                .appendTo(this.liveRegion))
        }
    }), e.ui.autocomplete;

    /*!
       * jQuery UI Button 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/button/
       */
    let h;

    const p = "ui-button ui-widget ui-state-default ui-corner-all";

    const m =
      "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only";

    const f = function () {
        const t = e(this);
        setTimeout(() => {
            t.find(":ui-button")
              .button("refresh")
        }, 1)
    };

    const _ = ({name, form, ownerDocument}) => {
        let i = name;
        const n = form;
        let o = e([]);
        return i && (i = i.replace(/'/g, "\\'"), o = n ? e(n)
          .find(`[name='${i}'][type=radio]`) : e(`[name='${i}'][type=radio]`, ownerDocument)
          .filter(function () {
              return !this.form
          })), o;
    };

    e.widget("ui.button", {
        version: "1.11.4",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: !0,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create() {
            this.element.closest("form")
              .unbind(`reset${this.eventNamespace}`)
              .bind(`reset${this.eventNamespace}`, f), "boolean" != typeof this.options
              .disabled ? this.options.disabled = !!this.element.prop("disabled") : this
              .element.prop("disabled", this.options.disabled), this
              ._determineButtonType(), this.hasTitle = !!this.buttonElement.attr(
              "title");
            const t = this;
            const i = this.options;
            const n = "checkbox" === this.type || "radio" === this.type;
            const o = n ? "" : "ui-state-active";
            null === i.label && (i.label = "input" === this.type ? this.buttonElement
              .val() : this.buttonElement.html()), this._hoverable(this.buttonElement),
              this.buttonElement.addClass(p)
                .attr("role", "button")
                .bind(`mouseenter${this.eventNamespace}`, function () {
                    i.disabled || this === h && e(this)
                      .addClass("ui-state-active")
                })
                .bind(`mouseleave${this.eventNamespace}`, function () {
                    i.disabled || e(this)
                      .removeClass(o)
                })
                .bind(`click${this.eventNamespace}`, e => {
                    i.disabled && (e.preventDefault(), e.stopImmediatePropagation())
                }), this._on({
                focus() {
                    this.buttonElement.addClass("ui-state-focus")
                },
                blur() {
                    this.buttonElement.removeClass("ui-state-focus")
                }
            }), n && this.element.bind(`change${this.eventNamespace}`, () => {
                t.refresh()
            }), "checkbox" === this.type ? this.buttonElement.bind(`click${this
  .eventNamespace}`,
              () => i.disabled ? !1 : void 0) : "radio" === this.type ? this.buttonElement.bind(`click${this
  .eventNamespace}`,
              function () {
                  if (i.disabled) return !1;
                  e(this)
                    .addClass("ui-state-active"), t.buttonElement.attr(
                    "aria-pressed", "true");
                  const n = t.element[0];
                  _(n)
                    .not(n)
                    .map(function () {
                        return e(this)
                          .button("widget")[0]
                    })
                    .removeClass("ui-state-active")
                    .attr("aria-pressed", "false")
              }) : (this.buttonElement.bind(`mousedown${this.eventNamespace}`,
              function () {
                  return i.disabled ? !1 : (e(this)
                    .addClass("ui-state-active"), h = this, t.document
                    .one("mouseup", () => {
                        h = null
                    }), void 0);
              })
              .bind(`mouseup${this.eventNamespace}`, function () {
                  return i.disabled ? !1 : (e(this)
                    .removeClass("ui-state-active"), void 0)
              })
              .bind(`keydown${this.eventNamespace}`, function({keyCode}) {
                  return i.disabled ? !1 : ((keyCode === e.ui.keyCode.SPACE ||
                    keyCode === e.ui.keyCode.ENTER) && e(this)
                    .addClass("ui-state-active"), void 0);
              })
              .bind(`keyup${this.eventNamespace} blur${this.eventNamespace}`,
                function () {
                    e(this)
                      .removeClass("ui-state-active")
                }), this.buttonElement.is("a") && this.buttonElement.keyup(
              function({keyCode}) {
                  keyCode === e.ui.keyCode.SPACE && e(this)
                    .click()
              })), this._setOption("disabled", i.disabled), this._resetButton()
        },
        _determineButtonType() {
            let e;
            let t;
            let i;
            this.type = this.element.is("[type=checkbox]") ? "checkbox" : this.element.is(
              "[type=radio]") ? "radio" : this.element.is("input") ? "input" :
              "button", "checkbox" === this.type || "radio" === this.type ? (e = this
              .element.parents()
              .last(), t = `label[for='${this.element.attr("id")}']`, this
              .buttonElement = e.find(t), this.buttonElement.length || (e = e
              .length ? e.siblings() : this.element.siblings(), this
              .buttonElement = e.filter(t), this.buttonElement.length || (this
              .buttonElement = e.find(t))), this.element.addClass(
              "ui-helper-hidden-accessible"), i = this.element.is(":checked"),
            i && this.buttonElement.addClass("ui-state-active"), this
              .buttonElement.prop("aria-pressed", i)) : this.buttonElement = this
              .element
        },
        widget() {
            return this.buttonElement
        },
        _destroy() {
            this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement
              .removeClass(`${p} ui-state-active ${m}`)
              .removeAttr("role")
              .removeAttr("aria-pressed")
              .html(this.buttonElement.find(".ui-button-text")
                .html()), this.hasTitle || this.buttonElement.removeAttr("title")
        },
        _setOption(e, t) {
            return this._super(e, t), "disabled" === e ? (this.widget()
              .toggleClass("ui-state-disabled", !!t), this.element.prop("disabled",
              !!t), t && ("checkbox" === this.type || "radio" === this.type ?
              this.buttonElement.removeClass("ui-state-focus") : this
                .buttonElement.removeClass("ui-state-focus ui-state-active")),
              void 0) : (this._resetButton(), void 0)
        },
        refresh() {
            const t = this.element.is("input, button") ? this.element.is(":disabled") : this
              .element.hasClass("ui-button-disabled");
            t !== this.options.disabled && this._setOption("disabled", t), "radio" ===
            this.type ? _(this.element[0])
              .each(function () {
                  e(this)
                    .is(":checked") ? e(this)
                    .button("widget")
                    .addClass("ui-state-active")
                    .attr("aria-pressed", "true") : e(this)
                    .button("widget")
                    .removeClass("ui-state-active")
                    .attr("aria-pressed", "false")
              }) : "checkbox" === this.type && (this.element.is(":checked") ? this
              .buttonElement.addClass("ui-state-active")
              .attr("aria-pressed", "true") : this.buttonElement.removeClass(
              "ui-state-active")
              .attr("aria-pressed", "false"))
        },
        _resetButton() {
            if ("input" === this.type) return this.options.label && this.element.val(this
              .options.label), void 0;
            const t = this.buttonElement.removeClass(m);

            const i = e("<span></span>", this.document[0])
              .addClass("ui-button-text")
              .html(this.options.label)
              .appendTo(t.empty())
              .text();

            const n = this.options.icons;
            const o = n.primary && n.secondary;
            const s = [];
            n.primary || n.secondary ? (this.options.text && s.push(
              `ui-button-text-icon${o ? "s" : n.primary ? "-primary" :
"-secondary"}`), n.primary && t.prepend(
              `<span class='ui-button-icon-primary ui-icon ${n.primary}'></span>`), n.secondary && t.append(
              `<span class='ui-button-icon-secondary ui-icon ${n.secondary}'></span>`), this.options.text || (s.push(o ?
              "ui-button-icons-only" : "ui-button-icon-only"), this
              .hasTitle || t.attr("title", e.trim(i)))) : s.push(
              "ui-button-text-only"), t.addClass(s.join(" "))
        }
    }), e.widget("ui.buttonset", {
        version: "1.11.4",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },
        _create() {
            this.element.addClass("ui-buttonset")
        },
        _init() {
            this.refresh()
        },
        _setOption(e, t) {
            "disabled" === e && this.buttons.button("option", e, t), this._super(e, t)
        },
        refresh() {
            const t = "rtl" === this.element.css("direction");
            const i = this.element.find(this.options.items);
            const n = i.filter(":ui-button");
            i.not(":ui-button")
              .button(), n.button("refresh"), this.buttons = i.map(function () {
                return e(this)
                  .button("widget")[0]
            })
              .removeClass("ui-corner-all ui-corner-left ui-corner-right")
              .filter(":first")
              .addClass(t ? "ui-corner-right" : "ui-corner-left")
              .end()
              .filter(":last")
              .addClass(t ? "ui-corner-left" : "ui-corner-right")
              .end()
              .end()
        },
        _destroy() {
            this.element.removeClass("ui-buttonset"), this.buttons.map(function () {
                return e(this)
                  .button("widget")[0]
            })
              .removeClass("ui-corner-left ui-corner-right")
              .end()
              .button("destroy")
        }
    }), e.ui.button,
      /*!
           * jQuery UI Datepicker 1.11.4
           * http://jqueryui.com
           *
           * Copyright jQuery Foundation and other contributors
           * Released under the MIT license.
           * http://jquery.org/license
           *
           * http://api.jqueryui.com/datepicker/
           */
      e.extend(e.ui, {
          datepicker: {
              version: "1.11.4"
          }
      });
    var g;
    e.extend(o.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker() {
            return this.dpDiv
        },
        setDefaults(e) {
            return r(this._defaults, e || {}), this
        },
        _attachDatepicker(t, i) {
            let n;
            let o;
            let s;
            n = t.nodeName.toLowerCase(), o = "div" === n || "span" === n, t.id || (this
              .uuid += 1, t.id = `dp${this.uuid}`), s = this._newInst(e(t), o), s
              .settings = e.extend({}, i || {}), "input" === n ? this
              ._connectDatepicker(t, s) : o && this._inlineDatepicker(t, s)
        },
        _newInst(t, i) {
            const n = t[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: n,
                input: t,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: i,
                dpDiv: i ? s(e(`<div class='${this._inlineClass} ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>`
                )) : this.dpDiv
            };
        },
        _connectDatepicker(t, i) {
            const n = e(t);
            i.append = e([]), i.trigger = e([]), n.hasClass(this.markerClassName) || (this
              ._attachments(n, i), n.addClass(this.markerClassName)
              .keydown(this._doKeyDown)
              .keypress(this._doKeyPress)
              .keyup(this._doKeyUp), this._autoSize(i), e.data(t, "datepicker", i),
            i.settings.disabled && this._disableDatepicker(t))
        },
        _attachments(t, i) {
            let n;
            let o;
            let s;
            const a = this._get(i, "appendText");
            const r = this._get(i, "isRTL");
            i.append && i.append.remove(), a && (i.append = e(`<span class='${this
  ._appendClass}'>${a}</span>`), t[r ? "before" : "after"](i
              .append)), t.unbind("focus", this._showDatepicker), i.trigger && i
              .trigger.remove(), n = this._get(i, "showOn"), ("focus" === n ||
              "both" === n) && t.focus(this._showDatepicker), ("button" === n ||
              "both" === n) && (o = this._get(i, "buttonText"), s = this._get(i,
              "buttonImage"), i.trigger = e(this._get(i, "buttonImageOnly") ? e(
              "<img/>")
              .addClass(this._triggerClass)
              .attr({
                  src: s,
                  alt: o,
                  title: o
              }) : e("<button type='button'></button>")
              .addClass(this._triggerClass)
              .html(s ? e("<img/>")
                .attr({
                    src: s,
                    alt: o,
                    title: o
                }) : o)), t[r ? "before" : "after"](i.trigger), i.trigger
              .click(() => (e.datepicker._datepickerShowing && e.datepicker
              ._lastInput === t[0] ? e.datepicker._hideDatepicker() : e
              .datepicker._datepickerShowing && e.datepicker
              ._lastInput !== t[0] ? (e.datepicker._hideDatepicker(), e
              .datepicker._showDatepicker(t[0])) : e.datepicker
              ._showDatepicker(t[0]), !1)))
        },
        _autoSize(e) {
            if (this._get(e, "autoSize") && !e.inline) {
                let t;
                let i;
                let n;
                let o;
                const s = new Date(2009, 11, 20);
                const a = this._get(e, "dateFormat");
                a.match(/[DM]/) && (t = e => {
                    for (i = 0, n = 0, o = 0; o < e.length; o++) e[o].length >
                    i && (i = e[o].length, n = o);
                    return n
                }, s.setMonth(t(this._get(e, a.match(/MM/) ? "monthNames" :
                  "monthNamesShort"))), s.setDate(t(this._get(e, a.match(/DD/) ?
                  "dayNames" : "dayNamesShort")) + 20 - s.getDay())), e.input.attr(
                  "size", this._formatDate(e, s)
                    .length)
            }
        },
        _inlineDatepicker(t, i) {
            const n = e(t);
            n.hasClass(this.markerClassName) || (n.addClass(this.markerClassName)
              .append(i.dpDiv), e.data(t, "datepicker", i), this._setDate(i, this
              ._getDefaultDate(i), !0), this._updateDatepicker(i), this
              ._updateAlternate(i), i.settings.disabled && this._disableDatepicker(
              t), i.dpDiv.css("display", "block"))
        },
        _dialogDatepicker(t, i, n, o, s) {
            let a;
            let l;
            let c;
            let u;
            let d;
            let h = this._dialogInst;
            return h || (this.uuid += 1, a = `dp${this.uuid}`, this._dialogInput = e(
              `<input type='text' id='${a}' style='position: absolute; top: -100px; width: 0px;'/>`), this
              ._dialogInput.keydown(this._doKeyDown), e("body")
              .append(this._dialogInput), h = this._dialogInst = this._newInst(this
              ._dialogInput, !1), h.settings = {}, e.data(this._dialogInput[0],
              "datepicker", h)), r(h.settings, o || {}), i = i && i
              .constructor === Date ? this._formatDate(h, i) : i, this._dialogInput.val(
              i), this._pos = s ? s.length ? s : [s.pageX, s.pageY] : null, this
              ._pos || (l = document.documentElement.clientWidth, c = document
              .documentElement.clientHeight, u = document.documentElement
              .scrollLeft || document.body.scrollLeft, d = document.documentElement
              .scrollTop || document.body.scrollTop, this._pos = [l / 2 - 100 + u,
                c / 2 - 150 + d]), this._dialogInput.css("left", `${this._pos[0] +
  20}px`)
              .css("top", `${this._pos[1]}px`), h.settings.onSelect = n, this
              ._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this
              ._showDatepicker(this._dialogInput[0]), e.blockUI && e.blockUI(this
              .dpDiv), e.data(this._dialogInput[0], "datepicker", h), this;
        },
        _destroyDatepicker(t) {
            let i;
            const n = e(t);
            const o = e.data(t, "datepicker");
            n.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), e
              .removeData(t, "datepicker"), "input" === i ? (o.append.remove(), o
              .trigger.remove(), n.removeClass(this.markerClassName)
              .unbind("focus", this._showDatepicker)
              .unbind("keydown", this._doKeyDown)
              .unbind("keypress", this._doKeyPress)
              .unbind("keyup", this._doKeyUp)) : ("div" === i || "span" ===
              i) && n.removeClass(this.markerClassName)
              .empty(), g === o && (g = null))
        },
        _enableDatepicker(t) {
            let i;
            let n;
            const o = e(t);
            const s = e.data(t, "datepicker");
            o.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), "input" ===
            i ? (t.disabled = !1, s.trigger.filter("button")
              .each(function () {
                  this.disabled = !1
              })
              .end()
              .filter("img")
              .css({
                  opacity: "1.0",
                  cursor: ""
              })) : ("div" === i || "span" === i) && (n = o.children(`.${this
  ._inlineClass}`), n.children()
              .removeClass("ui-state-disabled"), n.find(
              "select.ui-datepicker-month, select.ui-datepicker-year")
              .prop("disabled", !1)), this._disabledInputs = e.map(this
                ._disabledInputs,
              e => e === t ? null : e))
        },
        _disableDatepicker(t) {
            let i;
            let n;
            const o = e(t);
            const s = e.data(t, "datepicker");
            o.hasClass(this.markerClassName) && (i = t.nodeName.toLowerCase(), "input" ===
            i ? (t.disabled = !0, s.trigger.filter("button")
              .each(function () {
                  this.disabled = !0
              })
              .end()
              .filter("img")
              .css({
                  opacity: "0.5",
                  cursor: "default"
              })) : ("div" === i || "span" === i) && (n = o.children(`.${this
  ._inlineClass}`), n.children()
              .addClass("ui-state-disabled"), n.find(
              "select.ui-datepicker-month, select.ui-datepicker-year")
              .prop("disabled", !0)), this._disabledInputs = e.map(this
                ._disabledInputs,
              e => e === t ? null : e), this._disabledInputs[this._disabledInputs.length] = t)
        },
        _isDisabledDatepicker(e) {
            if (!e) return !1;
            for (let t = 0; t < this._disabledInputs.length; t++)
                if (this._disabledInputs[t] === e) return !0;
            return !1
        },
        _getInst(t) {
            try {
                return e.data(t, "datepicker")
            } catch (i) {
                throw "Missing instance data for this datepicker"
            }
        },
        _optionDatepicker(t, i, n) {
            let o;
            let s;
            let a;
            let l;
            const c = this._getInst(t);
            return 2 === arguments.length && "string" == typeof i ? "defaults" === i ? e
              .extend({}, e.datepicker._defaults) : c ? "all" === i ? e.extend({}, c
              .settings) : this._get(c, i) : null : (o = i || {}, "string" ==
            typeof i && (o = {}, o[i] = n), c && (this._curInst === c && this
              ._hideDatepicker(), s = this._getDateDatepicker(t, !0), a = this
              ._getMinMaxDate(c, "min"), l = this._getMinMaxDate(c, "max"), r(c
              .settings, o), null !== a && void 0 !== o.dateFormat &&
            void 0 === o.minDate && (c.settings.minDate = this._formatDate(c,
              a)), null !== l && void 0 !== o.dateFormat && void 0 === o
              .maxDate && (c.settings.maxDate = this._formatDate(c, l)),
            "disabled" in o && (o.disabled ? this._disableDatepicker(t) : this
              ._enableDatepicker(t)), this._attachments(e(t), c), this
              ._autoSize(c), this._setDate(c, s), this._updateAlternate(c), this
              ._updateDatepicker(c)), void 0)
        },
        _changeDatepicker(e, t, i) {
            this._optionDatepicker(e, t, i)
        },
        _refreshDatepicker(e) {
            const t = this._getInst(e);
            t && this._updateDatepicker(t)
        },
        _setDateDatepicker(e, t) {
            const i = this._getInst(e);
            i && (this._setDate(i, t), this._updateDatepicker(i), this._updateAlternate(
              i))
        },
        _getDateDatepicker(e, t) {
            const i = this._getInst(e);
            return i && !i.inline && this._setDateFromField(i, t), i ? this._getDate(i) :
              null
        },
        _doKeyDown(t) {
            let i;
            let n;
            let o;
            const s = e.datepicker._getInst(t.target);
            let a = !0;
            const r = s.dpDiv.is(".ui-datepicker-rtl");
            if (s._keyEvent = !0, e.datepicker._datepickerShowing) switch (t.keyCode) {
                case 9:
                    e.datepicker._hideDatepicker(), a = !1;
                    break;
                case 13:
                    return o = e(`td.${e.datepicker._dayOverClass}:not(.${e
  .datepicker._currentClass})`, s.dpDiv), o[0] && e
                      .datepicker._selectDay(t.target, s.selectedMonth, s.selectedYear,
                        o[0]), i = e.datepicker._get(s, "onSelect"), i ? (n = e
                      .datepicker._formatDate(s), i.apply(s.input ? s.input[0] :
                      null, [n, s])) : e.datepicker._hideDatepicker(), !1;
                case 27:
                    e.datepicker._hideDatepicker();
                    break;
                case 33:
                    e.datepicker._adjustDate(t.target, t.ctrlKey ? -e.datepicker._get(s,
                      "stepBigMonths") : -e.datepicker._get(s, "stepMonths"),
                      "M");
                    break;
                case 34:
                    e.datepicker._adjustDate(t.target, t.ctrlKey ? +e.datepicker._get(s,
                      "stepBigMonths") : +e.datepicker._get(s, "stepMonths"),
                      "M");
                    break;
                case 35:
                    (t.ctrlKey || t.metaKey) && e.datepicker._clearDate(t.target), a = t
                      .ctrlKey || t.metaKey;
                    break;
                case 36:
                    (t.ctrlKey || t.metaKey) && e.datepicker._gotoToday(t.target), a = t
                      .ctrlKey || t.metaKey;
                    break;
                case 37:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, r ? 1 :
                      -1, "D"), a = t.ctrlKey || t.metaKey, t.originalEvent
                      .altKey && e.datepicker._adjustDate(t.target, t.ctrlKey ? -e
                      .datepicker._get(s, "stepBigMonths") : -e.datepicker._get(s,
                      "stepMonths"), "M");
                    break;
                case 38:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, -7,
                      "D"), a = t.ctrlKey || t.metaKey;
                    break;
                case 39:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, r ? -
                      1 : 1, "D"), a = t.ctrlKey || t.metaKey, t.originalEvent
                      .altKey && e.datepicker._adjustDate(t.target, t.ctrlKey ? +e
                      .datepicker._get(s, "stepBigMonths") : +e.datepicker._get(s,
                      "stepMonths"), "M");
                    break;
                case 40:
                    (t.ctrlKey || t.metaKey) && e.datepicker._adjustDate(t.target, 7,
                      "D"), a = t.ctrlKey || t.metaKey;
                    break;
                default:
                    a = !1
            } else 36 === t.keyCode && t.ctrlKey ? e.datepicker._showDatepicker(
              this) : a = !1;
            a && (t.preventDefault(), t.stopPropagation())
        },
        _doKeyPress(t) {
            let i;
            let n;
            const o = e.datepicker._getInst(t.target);
            return e.datepicker._get(o, "constrainInput") ? (i = e.datepicker
              ._possibleChars(e.datepicker._get(o, "dateFormat")), n = String
              .fromCharCode(null == t.charCode ? t.keyCode : t.charCode), t
              .ctrlKey || t.metaKey || " " > n || !i || i.includes(n)) : void 0;
        },
        _doKeyUp(t) {
            let i;
            const n = e.datepicker._getInst(t.target);
            if (n.input.val() !== n.lastVal) try {
                i = e.datepicker.parseDate(e.datepicker._get(n, "dateFormat"), n
                  .input ? n.input.val() : null, e.datepicker._getFormatConfig(
                  n)), i && (e.datepicker._setDateFromField(n), e.datepicker
                  ._updateAlternate(n), e.datepicker._updateDatepicker(n))
            } catch (o) {}
            return !0
        },
        _showDatepicker(t) {
            if (t = t.target || t, "input" !== t.nodeName.toLowerCase() && (t = e("input",
              t.parentNode)[0]), !e.datepicker._isDisabledDatepicker(t) && e
              .datepicker._lastInput !== t) {
                let i;
                let o;
                let s;
                let a;
                let l;
                let c;
                let u;
                i = e.datepicker._getInst(t), e.datepicker._curInst && e.datepicker
                  ._curInst !== i && (e.datepicker._curInst.dpDiv.stop(!0, !0), i && e
                  .datepicker._datepickerShowing && e.datepicker._hideDatepicker(e
                  .datepicker._curInst.input[0])), o = e.datepicker._get(i,
                  "beforeShow"), s = o ? o.apply(t, [t, i]) : {}, s !== !1 && (r(i
                  .settings, s), i.lastVal = null, e.datepicker._lastInput = t,
                  e.datepicker._setDateFromField(i), e.datepicker._inDialog && (t
                  .value = ""), e.datepicker._pos || (e.datepicker._pos = e
                  .datepicker._findPos(t), e.datepicker._pos[1] += t
                  .offsetHeight), a = !1, e(t)
                  .parents()
                  .each(function () {
                      return a |= "fixed" === e(this)
                        .css("position"), !a
                  }), l = {
                    left: e.datepicker._pos[0],
                    top: e.datepicker._pos[1]
                }, e.datepicker._pos = null, i.dpDiv.empty(), i.dpDiv.css({
                    position: "absolute",
                    display: "block",
                    top: "-1000px"
                }), e.datepicker._updateDatepicker(i), l = e.datepicker
                  ._checkOffset(i, l, a), i.dpDiv.css({
                    position: e.datepicker._inDialog && e.blockUI ? "static" :
                      a ? "fixed" : "absolute",
                    display: "none",
                    left: `${l.left}px`,
                    top: `${l.top}px`
                }), i.inline || (c = e.datepicker._get(i, "showAnim"), u = e
                  .datepicker._get(i, "duration"), i.dpDiv.css("z-index", n(e(
                  t)) + 1), e.datepicker._datepickerShowing = !0, e
                  .effects && e.effects.effect[c] ? i.dpDiv.show(c, e.datepicker
                  ._get(i, "showOptions"), u) : i.dpDiv[c || "show"](c ? u :
                  null), e.datepicker._shouldFocusInput(i) && i.input
                  .focus(), e.datepicker._curInst = i))
            }
        },
        _updateDatepicker(t) {
            this.maxRows = 4, g = t, t.dpDiv.empty()
              .append(this._generateHTML(t)), this._attachHandlers(t);
            let i;
            const n = this._getNumberOfMonths(t);
            const o = n[1];
            const s = 17;
            const r = t.dpDiv.find(`.${this._dayOverClass} a`);
            r.length > 0 && a.apply(r.get(0)), t.dpDiv.removeClass(
              "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4")
              .width(""), o > 1 && t.dpDiv.addClass(`ui-datepicker-multi-${o}`)
              .css("width", `${s * o}em`), t.dpDiv[`${1 !== n[0] || 1 !== n[1] ? "add" :
  "remove"}Class`]("ui-datepicker-multi"), t.dpDiv[`${this._get(t,
  "isRTL") ? "add" : "remove"}Class`]("ui-datepicker-rtl"), t === e
              .datepicker._curInst && e.datepicker._datepickerShowing && e.datepicker
              ._shouldFocusInput(t) && t.input.focus(), t.yearshtml && (i = t.yearshtml,
              setTimeout(() => {
                  i === t.yearshtml && t.yearshtml && t.dpDiv.find(
                    "select.ui-datepicker-year:first")
                    .replaceWith(t.yearshtml), i = t.yearshtml = null
              }, 0))
        },
        _shouldFocusInput({input}) {
            return input && input.is(":visible") && !input.is(":disabled") && !input.is(":focus");
        },
        _checkOffset(t, i, n) {
            const o = t.dpDiv.outerWidth();
            const s = t.dpDiv.outerHeight();
            const a = t.input ? t.input.outerWidth() : 0;
            const r = t.input ? t.input.outerHeight() : 0;

            const l = document.documentElement.clientWidth + (n ? 0 : e(document)
              .scrollLeft());

            const c = document.documentElement.clientHeight + (n ? 0 : e(document)
              .scrollTop());

            return i.left -= this._get(t, "isRTL") ? o - a : 0, i.left -= n && i.left ===
            t.input.offset()
              .left ? e(document)
              .scrollLeft() : 0, i.top -= n && i.top === t.input.offset()
              .top + r ? e(document)
              .scrollTop() : 0, i.left -= Math.min(i.left, i.left + o > l && l > o ?
              Math.abs(i.left + o - l) : 0), i.top -= Math.min(i.top, i.top + s >
            c && c > s ? Math.abs(s + r) : 0), i
        },
        _findPos(t) {
            for (var i, n = this._getInst(t), o = this._get(n, "isRTL"); t && (
              "hidden" === t.type || 1 !== t.nodeType || e.expr.filters.hidden(t));)
                t = t[o ? "previousSibling" : "nextSibling"];
            return i = e(t)
              .offset(), [i.left, i.top]
        },
        _hideDatepicker(t) {
            let i;
            let n;
            let o;
            let s;
            const a = this._curInst;
            !a || t && a !== e.data(t, "datepicker") || this._datepickerShowing && (i =
              this._get(a, "showAnim"), n = this._get(a, "duration"), o =
              () => {
                  e.datepicker._tidyDialog(a)
              }, e.effects && (e.effects.effect[i] || e.effects[i]) ? a.dpDiv.hide(
              i, e.datepicker._get(a, "showOptions"), n, o) : a.dpDiv[
              "slideDown" === i ? "slideUp" : "fadeIn" === i ? "fadeOut" :
                "hide"](i ? n : null, o), i || o(), this._datepickerShowing = !1,
              s = this._get(a, "onClose"), s && s.apply(a.input ? a.input[0] : null,
              [a.input ? a.input.val() : "", a]), this._lastInput = null, this
              ._inDialog && (this._dialogInput.css({
                position: "absolute",
                left: "0",
                top: "-100px"
            }), e.blockUI && (e.unblockUI(), e("body")
              .append(this.dpDiv))), this._inDialog = !1)
        },
        _tidyDialog({dpDiv}) {
            dpDiv.removeClass(this._dialogClass)
              .unbind(".ui-datepicker-calendar")
        },
        _checkExternalClick(t) {
            if (e.datepicker._curInst) {
                const i = e(t.target);
                const n = e.datepicker._getInst(i[0]);
                (i[0].id !== e.datepicker._mainDivId && 0 === i.parents(`#${e.datepicker
  ._mainDivId}`)
                  .length && !i.hasClass(e.datepicker.markerClassName) && !i.closest(
                  `.${e.datepicker._triggerClass}`)
                  .length && e.datepicker._datepickerShowing && (!e.datepicker
                  ._inDialog || !e.blockUI) || i.hasClass(e.datepicker
                  .markerClassName) && e.datepicker._curInst !== n) && e.datepicker
                  ._hideDatepicker()
            }
        },
        _adjustDate(t, i, n) {
            const o = e(t);
            const s = this._getInst(o[0]);
            this._isDisabledDatepicker(o[0]) || (this._adjustInstDate(s, i + ("M" === n ?
              this._get(s, "showCurrentAtPos") : 0), n), this._updateDatepicker(
              s))
        },
        _gotoToday(t) {
            let i;
            const n = e(t);
            const o = this._getInst(n[0]);
            this._get(o, "gotoCurrent") && o.currentDay ? (o.selectedDay = o.currentDay, o
              .drawMonth = o.selectedMonth = o.currentMonth, o.drawYear = o
              .selectedYear = o.currentYear) : (i = new Date, o.selectedDay = i
              .getDate(), o.drawMonth = o.selectedMonth = i.getMonth(), o.drawYear =
              o.selectedYear = i.getFullYear()), this._notifyChange(o), this
              ._adjustDate(n)
        },
        _selectMonthYear(t, {options, selectedIndex}, n) {
            const o = e(t);
            const s = this._getInst(o[0]);
            s[`selected${"M" === n ? "Month" : "Year"}`] = s[`draw${"M" === n ?
  "Month" : "Year"}`] = parseInt(options[selectedIndex].value, 10),
              this._notifyChange(s), this._adjustDate(o)
        },
        _selectDay(t, i, n, o) {
            let s;
            const a = e(t);
            e(o)
              .hasClass(this._unselectableClass) || this._isDisabledDatepicker(a[0]) ||
            (s = this._getInst(a[0]), s.selectedDay = s.currentDay = e("a", o)
              .html(), s.selectedMonth = s.currentMonth = i, s.selectedYear = s
              .currentYear = n, this._selectDate(t, this._formatDate(s, s
              .currentDay, s.currentMonth, s.currentYear)))
        },
        _clearDate(t) {
            const i = e(t);
            this._selectDate(i, "")
        },
        _selectDate(t, i) {
            let n;
            const o = e(t);
            const s = this._getInst(o[0]);
            i = null != i ? i : this._formatDate(s), s.input && s.input.val(i), this
              ._updateAlternate(s), n = this._get(s, "onSelect"), n ? n.apply(s.input ?
              s.input[0] : null, [i, s]) : s.input && s.input.trigger("change"), s
              .inline ? this._updateDatepicker(s) : (this._hideDatepicker(), this
              ._lastInput = s.input[0], "object" != typeof s.input[0] && s.input
              .focus(), this._lastInput = null)
        },
        _updateAlternate(t) {
            let i;
            let n;
            let o;
            const s = this._get(t, "altField");
            s && (i = this._get(t, "altFormat") || this._get(t, "dateFormat"), n = this
              ._getDate(t), o = this.formatDate(i, n, this._getFormatConfig(t)), e(
              s)
              .each(function () {
                  e(this)
                    .val(o)
              }))
        },
        noWeekends(e) {
            const t = e.getDay();
            return [t > 0 && 6 > t, ""]
        },
        iso8601Week(e) {
            let t;
            const i = new Date(e.getTime());
            return i.setDate(i.getDate() + 4 - (i.getDay() || 7)), t = i.getTime(), i
              .setMonth(0), i.setDate(1), Math.floor(Math.round((t - i) / 864e5) / 7) +
            1
        },
        parseDate(t, i, n) {
            if (null == t || null == i) throw "Invalid arguments";
            if (i = "object" == typeof i ? i.toString() : `${i}`, "" === i) return null;
            let o;
            let s;
            let a;
            let r;
            let l = 0;
            const c = (n ? n.shortYearCutoff : null) || this._defaults.shortYearCutoff;

            const u = "string" != typeof c ? c : (new Date)
              .getFullYear() % 100 + parseInt(c, 10);

            const d = (n ? n.dayNamesShort : null) || this._defaults.dayNamesShort;
            const h = (n ? n.dayNames : null) || this._defaults.dayNames;
            const p = (n ? n.monthNamesShort : null) || this._defaults.monthNamesShort;
            const m = (n ? n.monthNames : null) || this._defaults.monthNames;
            let f = -1;
            let _ = -1;
            let g = -1;
            let v = -1;
            let b = !1;

            const y = e => {
                const i = o + 1 < t.length && t.charAt(o + 1) === e;
                return i && o++, i
            };

            const w = e => {
                const t = y(e),
                      n = "@" === e ? 14 : "!" === e ? 20 : "y" === e && t ? 4 : "o" ===
                      e ? 3 : 2,
                      o = "y" === e ? n : 1,
                      s = new RegExp(`^\\d{${o},${n}}`),
                      a = i.substring(l)
                        .match(s);
                if (!a) throw `Missing number at position ${l}`;
                return l += a[0].length, parseInt(a[0], 10)
            };

            const k = (t, n, o) => {
                let s = -1;

                const a = e.map(y(t) ? o : n, (e, t) => [[t, e]])
                  .sort((e, t) => -(e[1].length - t[1].length));

                if (e.each(a, (e, t) => {
                    const n = t[1];
                    return i.substr(l, n.length)
                      .toLowerCase() === n.toLowerCase() ? (s = t[0], l += n
                      .length, !1) : void 0
                }), -1 !== s) return s + 1;
                throw `Unknown name at position ${l}`
            };

            const x = () => {
                if (i.charAt(l) !== t.charAt(o))
                    throw `Unexpected literal at position ${l}`;
                l++
            };

            for (o = 0; o < t.length; o++)
                if (b) "'" !== t.charAt(o) || y("'") ? x() : b = !1;
                else switch (t.charAt(o)) {
                    case "d":
                        g = w("d");
                        break;
                    case "D":
                        k("D", d, h);
                        break;
                    case "o":
                        v = w("o");
                        break;
                    case "m":
                        _ = w("m");
                        break;
                    case "M":
                        _ = k("M", p, m);
                        break;
                    case "y":
                        f = w("y");
                        break;
                    case "@":
                        r = new Date(w("@")), f = r.getFullYear(), _ = r.getMonth() + 1,
                          g = r.getDate();
                        break;
                    case "!":
                        r = new Date((w("!") - this._ticksTo1970) / 1e4), f = r
                          .getFullYear(), _ = r.getMonth() + 1, g = r.getDate();
                        break;
                    case "'":
                        y("'") ? x() : b = !0;
                        break;
                    default:
                        x()
                }
            if (l < i.length && (a = i.substr(l), !/^\s+/.test(a)))
                throw `Extra/unparsed characters found in date: ${a}`;
            if (-1 === f ? f = (new Date)
              .getFullYear() : 100 > f && (f += (new Date)
              .getFullYear() - (new Date)
              .getFullYear() % 100 + (u >= f ? 0 : -100)), v > -1)
                for (_ = 1, g = v;;) {
                    if (s = this._getDaysInMonth(f, _ - 1), s >= g) break;
                    _++, g -= s
                }
            if (r = this._daylightSavingAdjust(new Date(f, _ - 1, g)), r.getFullYear() !==
            f || r.getMonth() + 1 !== _ || r.getDate() !== g) throw "Invalid date";
            return r
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: 1e7 * 60 * 60 * 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) +
          Math.floor(4.925)),
        formatDate(e, t, i) {
            if (!t) return "";
            let n;
            const o = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort;
            const s = (i ? i.dayNames : null) || this._defaults.dayNames;
            const a = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort;
            const r = (i ? i.monthNames : null) || this._defaults.monthNames;

            const l = t => {
                const i = n + 1 < e.length && e.charAt(n + 1) === t;
                return i && n++, i
            };

            const c = (e, t, i) => {
                let n = `${t}`;
                if (l(e))
                    for (; n.length < i;) n = `0${n}`;
                return n
            };

            const u = (e, t, i, n) => l(e) ? n[t] : i[t];
            let d = "";
            let h = !1;
            if (t)
                for (n = 0; n < e.length; n++)
                    if (h) "'" !== e.charAt(n) || l("'") ? d += e.charAt(n) : h = !1;
                    else switch (e.charAt(n)) {
                        case "d":
                            d += c("d", t.getDate(), 2);
                            break;
                        case "D":
                            d += u("D", t.getDay(), o, s);
                            break;
                        case "o":
                            d += c("o", Math.round((new Date(t.getFullYear(), t
                              .getMonth(), t.getDate())
                              .getTime() - new Date(t.getFullYear(), 0, 0)
                              .getTime()) / 864e5), 3);
                            break;
                        case "m":
                            d += c("m", t.getMonth() + 1, 2);
                            break;
                        case "M":
                            d += u("M", t.getMonth(), a, r);
                            break;
                        case "y":
                            d += l("y") ? t.getFullYear() : (t.getYear() % 100 < 10 ?
                              "0" : "") + t.getYear() % 100;
                            break;
                        case "@":
                            d += t.getTime();
                            break;
                        case "!":
                            d += 1e4 * t.getTime() + this._ticksTo1970;
                            break;
                        case "'":
                            l("'") ? d += "'" : h = !0;
                            break;
                        default:
                            d += e.charAt(n)
                    }
            return d
        },
        _possibleChars(e) {
            let t;
            let i = "";
            let n = !1;

            const o = i => {
                const n = t + 1 < e.length && e.charAt(t + 1) === i;
                return n && t++, n
            };

            for (t = 0; t < e.length; t++)
                if (n) "'" !== e.charAt(t) || o("'") ? i += e.charAt(t) : n = !1;
                else switch (e.charAt(t)) {
                    case "d":
                    case "m":
                    case "y":
                    case "@":
                        i += "0123456789";
                        break;
                    case "D":
                    case "M":
                        return null;
                    case "'":
                        o("'") ? i += "'" : n = !0;
                        break;
                    default:
                        i += e.charAt(t)
                }
            return i
        },
        _get({settings}, t) {
            return void 0 !== settings[t] ? settings[t] : this._defaults[t];
        },
        _setDateFromField(e, t) {
            if (e.input.val() !== e.lastVal) {
                const i = this._get(e, "dateFormat");
                let n = e.lastVal = e.input ? e.input.val() : null;
                const o = this._getDefaultDate(e);
                let s = o;
                const a = this._getFormatConfig(e);
                try {
                    s = this.parseDate(i, n, a) || o
                } catch (r) {
                    n = t ? "" : n
                }
                e.selectedDay = s.getDate(), e.drawMonth = e.selectedMonth = s.getMonth(),
                  e.drawYear = e.selectedYear = s.getFullYear(), e.currentDay = n ? s
                  .getDate() : 0, e.currentMonth = n ? s.getMonth() : 0, e.currentYear =
                  n ? s.getFullYear() : 0, this._adjustInstDate(e)
            }
        },
        _getDefaultDate(e) {
            return this._restrictMinMax(e, this._determineDate(e, this._get(e,
              "defaultDate"), new Date))
        },
        _determineDate(t, i, n) {
            const o = e => {
                  const t = new Date;
                  return t.setDate(t.getDate() + e), t
              };

            const s = i => {
                try {
                    return e.datepicker.parseDate(e.datepicker._get(t, "dateFormat"),
                      i, e.datepicker._getFormatConfig(t))
                } catch (n) {}
                for (var o = (i.toLowerCase()
                    .match(/^c/) ? e.datepicker._getDate(t) : null) ||
                  new Date, s = o.getFullYear(), a = o.getMonth(), r = o
                  .getDate(), l = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, c = l
                  .exec(i); c;) {
                    switch (c[2] || "d") {
                        case "d":
                        case "D":
                            r += parseInt(c[1], 10);
                            break;
                        case "w":
                        case "W":
                            r += 7 * parseInt(c[1], 10);
                            break;
                        case "m":
                        case "M":
                            a += parseInt(c[1], 10), r = Math.min(r, e.datepicker
                              ._getDaysInMonth(s, a));
                            break;
                        case "y":
                        case "Y":
                            s += parseInt(c[1], 10), r = Math.min(r, e.datepicker
                              ._getDaysInMonth(s, a))
                    }
                    c = l.exec(i)
                }
                return new Date(s, a, r)
            };

            let a = null == i || "" === i ? n : "string" == typeof i ? s(i) : "number" ==
            typeof i ? isNaN(i) ? n : o(i) : new Date(i.getTime());

            return a = a && "Invalid Date" === a.toString() ? n : a, a && (a.setHours(0),
              a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)), this
              ._daylightSavingAdjust(a)
        },
        _daylightSavingAdjust(e) {
            return e ? (e.setHours(e.getHours() > 12 ? e.getHours() + 2 : 0), e) : null
        },
        _setDate(e, t, i) {
            const n = !t;
            const o = e.selectedMonth;
            const s = e.selectedYear;
            const a = this._restrictMinMax(e, this._determineDate(e, t, new Date));
            e.selectedDay = e.currentDay = a.getDate(), e.drawMonth = e.selectedMonth = e
              .currentMonth = a.getMonth(), e.drawYear = e.selectedYear = e
              .currentYear = a.getFullYear(), o === e.selectedMonth && s === e
              .selectedYear || i || this._notifyChange(e), this._adjustInstDate(e), e
              .input && e.input.val(n ? "" : this._formatDate(e))
        },
        _getDate({currentYear, input, currentMonth, currentDay}) {
            const t = !currentYear || input && "" === input.val() ? null : this
              ._daylightSavingAdjust(new Date(currentYear, currentMonth, currentDay));
            return t
        },
        _attachHandlers(t) {
            const i = this._get(t, "stepMonths");
            const n = `#${t.id.replace(/\\\\/g, "\\")}`;
            t.dpDiv.find("[data-handler]")
              .map(function () {
                  const t = {
                      prev() {
                          e.datepicker._adjustDate(n, -i, "M")
                      },
                      next() {
                          e.datepicker._adjustDate(n, +i, "M")
                      },
                      hide() {
                          e.datepicker._hideDatepicker()
                      },
                      today() {
                          e.datepicker._gotoToday(n)
                      },
                      selectDay() {
                          return e.datepicker._selectDay(n, +this
                            .getAttribute("data-month"), +this
                            .getAttribute("data-year"), this), !1
                      },
                      selectMonth() {
                          return e.datepicker._selectMonthYear(n, this,
                            "M"), !1
                      },
                      selectYear() {
                          return e.datepicker._selectMonthYear(n, this,
                            "Y"), !1
                      }
                  };
                  e(this)
                    .bind(this.getAttribute("data-event"), t[this.getAttribute(
                      "data-handler")])
              })
        },
        _generateHTML(e) {
            let t;
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            let f;
            let _;
            let g;
            let v;
            let b;
            let y;
            let w;
            let k;
            let x;
            let C;
            let z;
            let T;
            let S;
            let A;
            let E;
            let P;
            let I;
            let M;
            let j;
            let D;
            let N;
            let L;
            let O;
            let R;
            let $;
            const F = new Date;

            const B = this._daylightSavingAdjust(new Date(F.getFullYear(), F.getMonth(), F
              .getDate()));

            const H = this._get(e, "isRTL");
            const W = this._get(e, "showButtonPanel");
            const V = this._get(e, "hideIfNoPrevNext");
            const q = this._get(e, "navigationAsDateFormat");
            const U = this._getNumberOfMonths(e);
            const Z = this._get(e, "showCurrentAtPos");
            const G = this._get(e, "stepMonths");
            const K = 1 !== U[0] || 1 !== U[1];

            const Y = this._daylightSavingAdjust(e.currentDay ? new Date(e.currentYear, e
              .currentMonth, e.currentDay) : new Date(9999, 9, 9));

            const J = this._getMinMaxDate(e, "min");
            const Q = this._getMinMaxDate(e, "max");
            let X = e.drawMonth - Z;
            let et = e.drawYear;
            if (0 > X && (X += 12, et--), Q)
                for (t = this._daylightSavingAdjust(new Date(Q.getFullYear(), Q
                  .getMonth() - U[0] * U[1] + 1, Q.getDate())), t = J && J > t ? J :
                  t; this._daylightSavingAdjust(new Date(et, X, 1)) > t;) X--, 0 > X &&
                (X = 11, et--);
            for (e.drawMonth = X, e.drawYear = et, i = this._get(e, "prevText"), i = q ?
              this.formatDate(i, this._daylightSavingAdjust(new Date(et, X - G, 1)),
                this._getFormatConfig(e)) : i, n = this._canAdjustMonth(e, -1, et,
              X) ?
              `<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='${i}'><span class='ui-icon ui-icon-circle-triangle-${H ? "e" : "w"}'>${i}</span></a>` : V ? "" :
                `<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='${i}'><span class='ui-icon ui-icon-circle-triangle-${H ? "e" : "w"}'>${i}</span></a>`, o = this._get(e, "nextText"), o = q ? this
              .formatDate(o, this._daylightSavingAdjust(new Date(et, X + G, 1)), this
                ._getFormatConfig(e)) : o, s = this._canAdjustMonth(e, 1, et, X) ?
              `<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='${o}'><span class='ui-icon ui-icon-circle-triangle-${H ? "w" : "e"}'>${o}</span></a>` : V ? "" :
                `<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='${o}'><span class='ui-icon ui-icon-circle-triangle-${H ? "w" : "e"}'>${o}</span></a>`, a = this._get(e, "currentText"), r = this._get(
              e, "gotoCurrent") && e.currentDay ? Y : B, a = q ? this.formatDate(a,
              r, this._getFormatConfig(e)) : a, l = e.inline ? "" :
              `<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>${this._get(e, "closeText")}</button>`, c = W ?
              `<div class='ui-datepicker-buttonpane ui-widget-content'>${H ? l :
""}${this._isInRange(e, r) ?
`<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>${a}</button>` : ""}${H ? "" : l}</div>` : "", u = parseInt(
              this._get(e, "firstDay"), 10), u = isNaN(u) ? 0 : u, d = this._get(e,
              "showWeek"), h = this._get(e, "dayNames"), p = this._get(e,
              "dayNamesMin"), m = this._get(e, "monthNames"), f = this._get(e,
              "monthNamesShort"), _ = this._get(e, "beforeShowDay"), g = this._get(
              e, "showOtherMonths"), v = this._get(e, "selectOtherMonths"), b = this
              ._getDefaultDate(e), y = "", k = 0; k < U[0]; k++) {
                for (x = "", this.maxRows = 4, C = 0; C < U[1]; C++) {
                    if (z = this._daylightSavingAdjust(new Date(et, X, e.selectedDay)),
                      T = " ui-corner-all", S = "", K) {
                        if (S += "<div class='ui-datepicker-group", U[1] > 1) switch (C) {
                            case 0:
                                S += " ui-datepicker-group-first", T = ` ui-corner-${H ? "right" : "left"}`;
                                break;
                            case U[1] - 1:
                                S += " ui-datepicker-group-last", T = ` ui-corner-${H ?
  "left" : "right"}`;
                                break;
                            default:
                                S += " ui-datepicker-group-middle", T = ""
                        }
                        S += "'>"
                    }
                    for (S +=
                           `<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix${T}'>${/all|left/.test(T) && 0 === k ? H ? s : n : ""}${/all|right/.test(T) && 0 === k ? H ? n : s : ""}${this
  ._generateMonthYearHeader(e, X, et, J, Q, k > 0 || C > 0, m, f)}</div><table class='ui-datepicker-calendar'><thead><tr>`,
                           A = d ? `<th class='ui-datepicker-week-col'>${this._get(e,
  "weekHeader")}</th>` : "", w = 0; 7 > w; w++) E = (w + u) %
                      7, A += `<th scope='col'${(w + u + 6) % 7 >= 5 ?
  " class='ui-datepicker-week-end'" : ""}><span title='${h[E]}'>${p[E]}</span></th>`;
                    for (S += `${A}</tr></thead><tbody>`, P = this._getDaysInMonth(et, X),
                         et === e.selectedYear && X === e.selectedMonth && (e.selectedDay =
                           Math.min(e.selectedDay, P)), I = (this._getFirstDayOfMonth(et,
                      X) - u + 7) % 7, M = Math.ceil((I + P) / 7), j = K ? this
                      .maxRows > M ? this.maxRows : M : M, this.maxRows = j, D = this
                      ._daylightSavingAdjust(new Date(et, X, 1 - I)), N = 0; j > N; N++
                    ) {
                        for (S += "<tr>", L = d ? `<td class='ui-datepicker-week-col'>${this._get(e, "calculateWeek")(D)}</td>` : "", w = 0; 7 >
                             w; w++) O = _ ? _.apply(e.input ? e.input[0] : null, [D]) : [!
                          0, ""], R = D.getMonth() !== X, $ = R && !v || !O[0] ||
                          J && J > D || Q && D > Q, L += `<td class='${(w + u + 6) %
  7 >= 5 ? " ui-datepicker-week-end" : ""}${R ?
  " ui-datepicker-other-month" : ""}${D.getTime() === z
    .getTime() && X === e.selectedMonth && e._keyEvent || b
    .getTime() === D.getTime() && b.getTime() === z
    .getTime() ? ` ${this._dayOverClass}` : ""}${$ ? ` ${this
    ._unselectableClass} ui-state-disabled` : ""}${R && !
    g ? "" : ` ${O[1]}${D.getTime() === Y.getTime() ? ` ${this._currentClass}` : ""}${D.getTime() === B
    .getTime() ? " ui-datepicker-today" : ""}`}'${R && !
    g || !O[2] ? "" : ` title='${O[2].replace(/'/g,
  "&#39;")}'`}${$ ? "" :
  ` data-handler='selectDay' data-event='click' data-month='${D.getMonth()}' data-year='${D.getFullYear()}'`}>${R && !g ? "&#xa0;" : $ ?
    `<span class='ui-state-default'>${D.getDate()}</span>` : `<a class='ui-state-default${D
      .getTime() === B.getTime() ? " ui-state-highlight" : ""}${D.getTime() === Y.getTime() ? " ui-state-active" : ""}${R ? " ui-priority-secondary" : ""}' href='#'>${D
      .getDate()}</a>`}</td>`, D.setDate(D.getDate() +
                          1), D = this._daylightSavingAdjust(D);
                        S += `${L}</tr>`
                    }
                    X++, X > 11 && (X = 0, et++), S += `</tbody></table>${K ?
  `</div>${U[0] > 0 && C === U[1] - 1 ?
"<div class='ui-datepicker-row-break'></div>" : ""}` : ""}`,
                      x += S
                }
                y += x
            }
            return y += c, e._keyEvent = !1, y
        },
        _generateMonthYearHeader(e, t, i, n, o, s, a, r) {
            let l;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            let f;
            const _ = this._get(e, "changeMonth");
            const g = this._get(e, "changeYear");
            const v = this._get(e, "showMonthAfterYear");
            let b = "<div class='ui-datepicker-title'>";
            let y = "";
            if (s || !_) y += `<span class='ui-datepicker-month'>${a[t]}</span>`;
            else {
                for (l = n && n.getFullYear() === i, c = o && o.getFullYear() === i, y +=
                  "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",
                       u = 0; 12 > u; u++)(!l || u >= n.getMonth()) && (!c || u <= o
                  .getMonth()) && (y += `<option value='${u}'${u === t ?
  " selected='selected'" : ""}>${r[u]}</option>`);
                y += "</select>"
            }
            if (v || (b += y + (!s && _ && g ? "" : "&#xa0;")), !e.yearshtml)
                if (e.yearshtml = "", s || !g) b += `<span class='ui-datepicker-year'>${i}</span>`;
                else {
                    for (d = this._get(e, "yearRange")
                      .split(":"), h = (new Date)
                      .getFullYear(), p = e => {
                        const t = e.match(/c[+\-].*/) ? i + parseInt(e.substring(1),
                          10) : e.match(/[+\-].*/) ? h + parseInt(e, 10) : parseInt(
                          e, 10);
                        return isNaN(t) ? h : t
                    }, m = p(d[0]), f = Math.max(m, p(d[1] || "")), m = n ? Math.max(
                      m, n.getFullYear()) : m, f = o ? Math.min(f, o
                      .getFullYear()) : f, e.yearshtml +=
                      "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; f >=
                         m; m++) e.yearshtml += `<option value='${m}'${m === i ?
  " selected='selected'" : ""}>${m}</option>`;
                    e.yearshtml += "</select>", b += e.yearshtml, e.yearshtml = null
                }return b += this._get(e, "yearSuffix"), v && (b += (!s && _ && g ? "" :
                  "&#xa0;") + y), b += "</div>"
        },
        _adjustInstDate(e, t, i) {
            const n = e.drawYear + ("Y" === i ? t : 0);
            const o = e.drawMonth + ("M" === i ? t : 0);

            const s = Math.min(e.selectedDay, this._getDaysInMonth(n, o)) + ("D" === i ? t :
              0);

            const a = this._restrictMinMax(e, this._daylightSavingAdjust(new Date(n, o,
              s)));

            e.selectedDay = a.getDate(), e.drawMonth = e.selectedMonth = a.getMonth(), e
              .drawYear = e.selectedYear = a.getFullYear(), ("M" === i || "Y" === i) &&
            this._notifyChange(e)
        },
        _restrictMinMax(e, t) {
            const i = this._getMinMaxDate(e, "min");
            const n = this._getMinMaxDate(e, "max");
            const o = i && i > t ? i : t;
            return n && o > n ? n : o
        },
        _notifyChange(e) {
            const t = this._get(e, "onChangeMonthYear");
            t && t.apply(e.input ? e.input[0] : null, [e.selectedYear, e.selectedMonth +
            1, e])
        },
        _getNumberOfMonths(e) {
            const t = this._get(e, "numberOfMonths");
            return null == t ? [1, 1] : "number" == typeof t ? [1, t] : t
        },
        _getMinMaxDate(e, t) {
            return this._determineDate(e, this._get(e, `${t}Date`), null);
        },
        _getDaysInMonth(e, t) {
            return 32 - this._daylightSavingAdjust(new Date(e, t, 32))
              .getDate()
        },
        _getFirstDayOfMonth(e, t) {
            return new Date(e, t, 1)
              .getDay()
        },
        _canAdjustMonth(e, t, i, n) {
            const o = this._getNumberOfMonths(e);

            const s = this._daylightSavingAdjust(new Date(i, n + (0 > t ? t : o[0] * o[1]),
              1));

            return 0 > t && s.setDate(this._getDaysInMonth(s.getFullYear(), s
              .getMonth())), this._isInRange(e, s)
        },
        _isInRange(e, t) {
            let i;
            let n;
            const o = this._getMinMaxDate(e, "min");
            const s = this._getMinMaxDate(e, "max");
            let a = null;
            let r = null;
            const l = this._get(e, "yearRange");
            return l && (i = l.split(":"), n = (new Date)
              .getFullYear(), a = parseInt(i[0], 10), r = parseInt(i[1], 10), i[0]
              .match(/[+\-].*/) && (a += n), i[1].match(/[+\-].*/) && (r += n)), (!
              o || t.getTime() >= o.getTime()) && (!s || t.getTime() <= s
              .getTime()) && (!a || t.getFullYear() >= a) && (!r || t.getFullYear() <= r)
        },
        _getFormatConfig(e) {
            let t = this._get(e, "shortYearCutoff");
            return t = "string" != typeof t ? t : (new Date)
              .getFullYear() % 100 + parseInt(t, 10), {
                shortYearCutoff: t,
                dayNamesShort: this._get(e, "dayNamesShort"),
                dayNames: this._get(e, "dayNames"),
                monthNamesShort: this._get(e, "monthNamesShort"),
                monthNames: this._get(e, "monthNames")
            }
        },
        _formatDate(e, t, i, n) {
            t || (e.currentDay = e.selectedDay, e.currentMonth = e.selectedMonth, e
              .currentYear = e.selectedYear);
            const o = t ? "object" == typeof t ? t : this._daylightSavingAdjust(new Date(n,
              i, t)) : this._daylightSavingAdjust(new Date(e.currentYear, e
              .currentMonth, e.currentDay));
            return this.formatDate(this._get(e, "dateFormat"), o, this._getFormatConfig(
              e))
        }
    }), e.fn.datepicker = function (t) {
        if (!this.length) return this;
        e.datepicker.initialized || (e(document)
          .mousedown(e.datepicker._checkExternalClick), e.datepicker.initialized = !0),
        0 === e(`#${e.datepicker._mainDivId}`)
          .length && e("body")
          .append(e.datepicker.dpDiv);
        const i = Array.prototype.slice.call(arguments, 1);
        return "string" != typeof t || "isDisabled" !== t && "getDate" !== t && "widget" !== t ?
          "option" === t && 2 === arguments.length && "string" == typeof arguments[1] ? e
            .datepicker[`_${t}Datepicker`](...[this[0]].concat(i)) : this
            .each(function () {
                "string" == typeof t ? e.datepicker[`_${t}Datepicker`](...[this].concat(i)) : e.datepicker._attachDatepicker(this,
                  t)
            }) : e.datepicker[`_${t}Datepicker`](...[this[0]].concat(i));
    }, e.datepicker = new o, e.datepicker.initialized = !1, e.datepicker.uuid = (new Date)
      .getTime(), e.datepicker.version = "1.11.4", e.datepicker, e.widget("ui.dialog", {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoOpen: !0,
            buttons: [],
            closeOnEscape: !0,
            closeText: "Close",
            dialogClass: "",
            draggable: !0,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: !1,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                using(t) {
                    const i = e(this)
                      .css(t)
                      .offset()
                      .top;
                    0 > i && e(this)
                      .css("top", t.top - i)
                }
            },
            resizable: !0,
            show: null,
            title: null,
            width: 300,
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        sizeRelatedOptions: {
            buttons: !0,
            height: !0,
            maxHeight: !0,
            maxWidth: !0,
            minHeight: !0,
            minWidth: !0,
            width: !0
        },
        resizableRelatedOptions: {
            maxHeight: !0,
            maxWidth: !0,
            minHeight: !0,
            minWidth: !0
        },
        _create() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            }, this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent()
                  .children()
                  .index(this.element)
            }, this.originalTitle = this.element.attr("title"), this.options.title =
              this.options.title || this.originalTitle, this._createWrapper(), this
              .element.show()
              .removeAttr("title")
              .addClass("ui-dialog-content ui-widget-content")
              .appendTo(this.uiDialog), this._createTitlebar(), this
              ._createButtonPane(), this.options.draggable && e.fn.draggable && this
              ._makeDraggable(), this.options.resizable && e.fn.resizable && this
              ._makeResizable(), this._isOpen = !1, this._trackFocus()
        },
        _init() {
            this.options.autoOpen && this.open()
        },
        _appendTo() {
            const t = this.options.appendTo;
            return t && (t.jquery || t.nodeType) ? e(t) : this.document.find(t || "body")
              .eq(0)
        },
        _destroy() {
            let e;
            const t = this.originalPosition;
            this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId()
              .removeClass("ui-dialog-content ui-widget-content")
              .css(this.originalCss)
              .detach(), this.uiDialog.stop(!0, !0)
              .remove(), this.originalTitle && this.element.attr("title", this
              .originalTitle), e = t.parent.children()
              .eq(t.index), e.length && e[0] !== this.element[0] ? e.before(this
              .element) : t.parent.append(this.element)
        },
        widget() {
            return this.uiDialog
        },
        disable: e.noop,
        enable: e.noop,
        close(t) {
            let i;
            const n = this;
            if (this._isOpen && this._trigger("beforeClose", t) !== !1) {
                if (this._isOpen = !1, this._focusedElement = null, this
                  ._destroyOverlay(), this._untrackInstance(), !this.opener.filter(
                  ":focusable")
                  .focus()
                  .length) try {
                    i = this.document[0].activeElement, i && "body" !== i.nodeName
                      .toLowerCase() && e(i)
                      .blur()
                } catch (o) {}
                this._hide(this.uiDialog, this.options.hide, () => {
                    n._trigger("close", t)
                })
            }
        },
        isOpen() {
            return this._isOpen
        },
        moveToTop() {
            this._moveToTop()
        },
        _moveToTop(t, i) {
            let n = !1;

            const o = this.uiDialog.siblings(".ui-front:visible")
              .map(function () {
                  return +e(this)
                    .css("z-index")
              })
              .get();

            const s = Math.max.apply(null, o);
            return s >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", s +
              1), n = !0), n && !i && this._trigger("focus", t), n
        },
        open() {
            const t = this;
            return this._isOpen ? (this._moveToTop() && this._focusTabbable(), void 0) : (
              this._isOpen = !0, this.opener = e(this.document[0].activeElement),
                this._size(), this._position(), this._createOverlay(), this
                ._moveToTop(null, !0), this.overlay && this.overlay.css("z-index",
                this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this
                  .options.show,
                () => {
                    t._focusTabbable(), t._trigger("focus")
                }), this._makeFocusTarget(), this._trigger("open"), void 0);
        },
        _focusTabbable() {
            let e = this._focusedElement;
            e || (e = this.element.find("[autofocus]")), e.length || (e = this.element
              .find(":tabbable")), e.length || (e = this.uiDialogButtonPane.find(
              ":tabbable")), e.length || (e = this.uiDialogTitlebarClose.filter(
              ":tabbable")), e.length || (e = this.uiDialog), e.eq(0)
              .focus()
        },
        _keepFocus(t) {
            function i() {
                const t = this.document[0].activeElement;
                const i = this.uiDialog[0] === t || e.contains(this.uiDialog[0], t);
                i || this._focusTabbable()
            }
            t.preventDefault(), i.call(this), this._delay(i)
        },
        _createWrapper() {
            this.uiDialog = e("<div>")
              .addClass(
                `ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ${this
  .options.dialogClass}`)
              .hide()
              .attr({
                  tabIndex: -1,
                  role: "dialog"
              })
              .appendTo(this._appendTo()), this._on(this.uiDialog, {
                keydown(t) {
                    if (this.options.closeOnEscape && !t
                      .isDefaultPrevented() && t.keyCode && t.keyCode === e.ui
                      .keyCode.ESCAPE) return t.preventDefault(), this
                      .close(t), void 0;
                    if (t.keyCode === e.ui.keyCode.TAB && !t
                      .isDefaultPrevented()) {
                        const i = this.uiDialog.find(":tabbable");
                        const n = i.filter(":first");
                        const o = i.filter(":last");
                        t.target !== o[0] && t.target !== this.uiDialog[0] ||
                        t.shiftKey ? t.target !== n[0] && t.target !==
                          this.uiDialog[0] || !t.shiftKey || (this._delay(
                            () => {
                                o.focus()
                            }), t.preventDefault()) : (this._delay(
                          () => {
                              n.focus()
                          }), t.preventDefault())
                    }
                },
                mousedown(e) {
                    this._moveToTop(e) && this._focusTabbable()
                }
            }), this.element.find("[aria-describedby]")
              .length || this.uiDialog.attr({
                "aria-describedby": this.element.uniqueId()
                  .attr("id")
            })
        },
        _createTitlebar() {
            let t;
            this.uiDialogTitlebar = e("<div>")
              .addClass(
                "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix"
              )
              .prependTo(this.uiDialog), this._on(this.uiDialogTitlebar, {
                mousedown(t) {
                    e(t.target)
                      .closest(".ui-dialog-titlebar-close") || this.uiDialog
                      .focus()
                }
            }), this.uiDialogTitlebarClose = e("<button type='button'></button>")
              .button({
                  label: this.options.closeText,
                  icons: {
                      primary: "ui-icon-closethick"
                  },
                  text: !1
              })
              .addClass("ui-dialog-titlebar-close")
              .appendTo(this.uiDialogTitlebar), this._on(this.uiDialogTitlebarClose, {
                click(e) {
                    e.preventDefault(), this.close(e)
                }
            }), t = e("<span>")
              .uniqueId()
              .addClass("ui-dialog-title")
              .prependTo(this.uiDialogTitlebar), this._title(t), this.uiDialog.attr({
                "aria-labelledby": t.attr("id")
            })
        },
        _title(e) {
            this.options.title || e.html("&#160;"), e.text(this.options.title)
        },
        _createButtonPane() {
            this.uiDialogButtonPane = e("<div>")
              .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),
              this.uiButtonSet = e("<div>")
                .addClass("ui-dialog-buttonset")
                .appendTo(this.uiDialogButtonPane), this._createButtons()
        },
        _createButtons() {
            const t = this;
            const i = this.options.buttons;
            return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), e
              .isEmptyObject(i) || e.isArray(i) && !i.length ? (this.uiDialog
              .removeClass("ui-dialog-buttons"), void 0) : (e.each(i, (i, n) => {
                let o;
                let s;
                n = e.isFunction(n) ? {
                    click: n,
                    text: i
                } : n, n = e.extend({
                    type: "button"
                }, n), o = n.click, n.click = function(...args) {
                    o.apply(t.element[0], args)
                }, s = {
                    icons: n.icons,
                    text: n.showText
                }, delete n.icons, delete n.showText, e(
                  "<button></button>", n)
                  .button(s)
                  .appendTo(t.uiButtonSet)
            }), this.uiDialog.addClass("ui-dialog-buttons"), this
              .uiDialogButtonPane.appendTo(this.uiDialog), void 0);
        },
        _makeDraggable() {
            function t(e) {
                return {
                    position: e.position,
                    offset: e.offset
                }
            }
            const i = this;
            const n = this.options;
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start(n, o) {
                    e(this)
                      .addClass("ui-dialog-dragging"), i._blockFrames(), i
                      ._trigger("dragStart", n, t(o))
                },
                drag(e, n) {
                    i._trigger("drag", e, t(n))
                },
                stop(o, s) {
                    const a = s.offset.left - i.document.scrollLeft();
                    const r = s.offset.top - i.document.scrollTop();
                    n.position = {
                        my: "left top",
                        at: `left${a >= 0 ? "+" : ""}${a} top${r >= 0 ? "+" : ""}${r}`,
                        of: i.window
                    }, e(this)
                      .removeClass("ui-dialog-dragging"), i
                      ._unblockFrames(), i._trigger("dragStop", o, t(s))
                }
            })
        },
        _makeResizable() {
            function t(e) {
                return {
                    originalPosition: e.originalPosition,
                    originalSize: e.originalSize,
                    position: e.position,
                    size: e.size
                }
            }
            const i = this;
            const n = this.options;
            const o = n.resizable;
            const s = this.uiDialog.css("position");
            const a = "string" == typeof o ? o : "n,e,s,w,se,sw,ne,nw";
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: n.maxWidth,
                maxHeight: n.maxHeight,
                minWidth: n.minWidth,
                minHeight: this._minHeight(),
                handles: a,
                start(n, o) {
                    e(this)
                      .addClass("ui-dialog-resizing"), i._blockFrames(), i
                      ._trigger("resizeStart", n, t(o))
                },
                resize(e, n) {
                    i._trigger("resize", e, t(n))
                },
                stop(o, s) {
                    const a = i.uiDialog.offset();
                    const r = a.left - i.document.scrollLeft();
                    const l = a.top - i.document.scrollTop();
                    n.height = i.uiDialog.height(), n.width = i.uiDialog
                      .width(), n.position = {
                        my: "left top",
                        at: `left${r >= 0 ? "+" : ""}${r} top${l >= 0 ? "+" : ""}${l}`,
                        of: i.window
                    }, e(this)
                      .removeClass("ui-dialog-resizing"), i
                      ._unblockFrames(), i._trigger("resizeStop", o, t(s))
                }
            })
              .css("position", s)
        },
        _trackFocus() {
            this._on(this.widget(), {
                focusin(t) {
                    this._makeFocusTarget(), this._focusedElement = e(t
                      .target)
                }
            })
        },
        _makeFocusTarget() {
            this._untrackInstance(), this._trackingInstances()
              .unshift(this)
        },
        _untrackInstance() {
            const t = this._trackingInstances();
            const i = e.inArray(this, t);
            - 1 !== i && t.splice(i, 1)
        },
        _trackingInstances() {
            let e = this.document.data("ui-dialog-instances");
            return e || (e = [], this.document.data("ui-dialog-instances", e)), e
        },
        _minHeight() {
            const e = this.options;
            return "auto" === e.height ? e.minHeight : Math.min(e.minHeight, e.height)
        },
        _position() {
            const e = this.uiDialog.is(":visible");
            e || this.uiDialog.show(), this.uiDialog.position(this.options.position), e ||
            this.uiDialog.hide()
        },
        _setOptions(t) {
            const i = this;
            let n = !1;
            const o = {};
            e.each(t, (e, t) => {
                i._setOption(e, t), e in i.sizeRelatedOptions && (n = !0), e in i
                  .resizableRelatedOptions && (o[e] = t)
            }), n && (this._size(), this._position()), this.uiDialog.is(
              ":data(ui-resizable)") && this.uiDialog.resizable("option", o)
        },
        _setOption(e, t) {
            let i;
            let n;
            const o = this.uiDialog;
            "dialogClass" === e && o.removeClass(this.options.dialogClass)
              .addClass(t), "disabled" !== e && (this._super(e, t), "appendTo" === e &&
            this.uiDialog.appendTo(this._appendTo()), "buttons" === e && this
              ._createButtons(), "closeText" === e && this.uiDialogTitlebarClose
              .button({
                  label: `${t}`
              }), "draggable" === e && (i = o.is(":data(ui-draggable)"), i && !t &&
            o.draggable("destroy"), !i && t && this._makeDraggable()),
            "position" === e && this._position(), "resizable" === e && (n = o.is(
              ":data(ui-resizable)"), n && !t && o.resizable("destroy"),
            n && "string" == typeof t && o.resizable("option", "handles", t),
            n || t === !1 || this._makeResizable()), "title" === e && this
              ._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
        },
        _size() {
            let e;
            let t;
            let i;
            const n = this.options;
            this.element.show()
              .css({
                  width: "auto",
                  minHeight: 0,
                  maxHeight: "none",
                  height: 0
              }), n.minWidth > n.width && (n.width = n.minWidth), e = this.uiDialog
              .css({
                  height: "auto",
                  width: n.width
              })
              .outerHeight(), t = Math.max(0, n.minHeight - e), i = "number" == typeof n
              .maxHeight ? Math.max(0, n.maxHeight - e) : "none", "auto" === n.height ?
              this.element.css({
                  minHeight: t,
                  maxHeight: i,
                  height: "auto"
              }) : this.element.height(Math.max(0, n.height - e)), this.uiDialog.is(
              ":data(ui-resizable)") && this.uiDialog.resizable("option",
              "minHeight", this._minHeight())
        },
        _blockFrames() {
            this.iframeBlocks = this.document.find("iframe")
              .map(function () {
                  const t = e(this);
                  return e("<div>")
                    .css({
                        position: "absolute",
                        width: t.outerWidth(),
                        height: t.outerHeight()
                    })
                    .appendTo(t.parent())
                    .offset(t.offset())[0]
              })
        },
        _unblockFrames() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
        },
        _allowInteraction(t) {
            return e(t.target)
              .closest(".ui-dialog")
              .length ? !0 : !!e(t.target)
              .closest(".ui-datepicker")
              .length
        },
        _createOverlay() {
            if (this.options.modal) {
                let t = !0;
                this._delay(() => {
                    t = !1
                }), this.document.data("ui-dialog-overlays") || this._on(this
                  .document, {
                    focusin(e) {
                        t || this._allowInteraction(e) || (e.preventDefault(),
                          this._trackingInstances()[0]._focusTabbable())
                    }
                }), this.overlay = e("<div>")
                  .addClass("ui-widget-overlay ui-front")
                  .appendTo(this._appendTo()), this._on(this.overlay, {
                    mousedown: "_keepFocus"
                }), this.document.data("ui-dialog-overlays", (this.document.data(
                  "ui-dialog-overlays") || 0) + 1)
            }
        },
        _destroyOverlay() {
            if (this.options.modal && this.overlay) {
                const e = this.document.data("ui-dialog-overlays") - 1;
                e ? this.document.data("ui-dialog-overlays", e) : this.document.unbind(
                  "focusin")
                  .removeData("ui-dialog-overlays"), this.overlay.remove(), this
                  .overlay = null
            }
        }
    }), e.widget("ui.progressbar", {
        version: "1.11.4",
        options: {
            max: 100,
            value: 0,
            change: null,
            complete: null
        },
        min: 0,
        _create() {
            this.oldValue = this.options.value = this._constrainedValue(), this.element
              .addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
              .attr({
                  role: "progressbar",
                  "aria-valuemin": this.min
              }), this.valueDiv = e(
              "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>"
            )
              .appendTo(this.element), this._refreshValue()
        },
        _destroy() {
            this.element.removeClass(
              "ui-progressbar ui-widget ui-widget-content ui-corner-all")
              .removeAttr("role")
              .removeAttr("aria-valuemin")
              .removeAttr("aria-valuemax")
              .removeAttr("aria-valuenow"), this.valueDiv.remove()
        },
        value(e) {
            return void 0 === e ? this.options.value : (this.options.value = this
              ._constrainedValue(e), this._refreshValue(), void 0)
        },
        _constrainedValue(e) {
            return void 0 === e && (e = this.options.value), this.indeterminate = e === !
              1, "number" != typeof e && (e = 0), this.indeterminate ? !1 : Math.min(
              this.options.max, Math.max(this.min, e))
        },
        _setOptions(e) {
            const t = e.value;
            delete e.value, this._super(e), this.options.value = this._constrainedValue(
              t), this._refreshValue()
        },
        _setOption(e, t) {
            "max" === e && (t = Math.max(this.min, t)), "disabled" === e && this.element
              .toggleClass("ui-state-disabled", !!t)
              .attr("aria-disabled", t), this._super(e, t)
        },
        _percentage() {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (
              this.options.max - this.min)
        },
        _refreshValue() {
            const t = this.options.value;
            const i = this._percentage();
            this.valueDiv.toggle(this.indeterminate || t > this.min)
              .toggleClass("ui-corner-right", t === this.options.max)
              .width(`${i.toFixed(0)}%`), this.element.toggleClass(
              "ui-progressbar-indeterminate", this.indeterminate), this
              .indeterminate ? (this.element.removeAttr("aria-valuenow"), this
              .overlayDiv || (this.overlayDiv = e(
              "<div class='ui-progressbar-overlay'></div>")
              .appendTo(this.valueDiv))) : (this.element.attr({
                "aria-valuemax": this.options.max,
                "aria-valuenow": t
            }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv =
              null)), this.oldValue !== t && (this.oldValue = t, this._trigger(
              "change")), t === this.options.max && this._trigger("complete")
        }
    }), e.widget("ui.selectmenu", {
        version: "1.11.4",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
        _create() {
            const e = this.element.uniqueId()
              .attr("id");
            this.ids = {
                element: e,
                button: `${e}-button`,
                menu: `${e}-menu`
            }, this._drawButton(), this._drawMenu(), this.options.disabled && this
              .disable()
        },
        _drawButton() {
            const t = this;
            this.label = e(`label[for='${this.ids.element}']`)
              .attr("for", this.ids.button), this._on(this.label, {
                click(e) {
                    this.button.focus(), e.preventDefault()
                }
            }), this.element.hide(), this.button = e("<span>", {
                "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true"
            })
              .insertAfter(this.element), e("<span>", {
                "class": `ui-icon ${this.options.icons.button}`
            })
              .prependTo(this.button), this.buttonText = e("<span>", {
                "class": "ui-selectmenu-text"
            })
              .appendTo(this.button), this._setText(this.buttonText, this.element.find(
              "option:selected")
              .text()), this._resizeButton(), this._on(this.button, this
              ._buttonEvents), this.button.one("focusin", () => {
                t.menuItems || t._refreshMenu()
            }), this._hoverable(this.button), this._focusable(this.button)
        },
        _drawMenu() {
            const t = this;
            this.menu = e("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            }), this.menuWrap = e("<div>", {
                "class": "ui-selectmenu-menu ui-front"
            })
              .append(this.menu)
              .appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
                role: "listbox",
                select(e, {item}) {
                    e.preventDefault(), t._setSelection(), t._select(item
                      .data("ui-selectmenu-item"), e)
                },
                focus(e, {item}) {
                    const n = item.data("ui-selectmenu-item");
                    null != t.focusIndex && n.index !== t.focusIndex && (t
                      ._trigger("focus", e, {
                          item: n
                      }), t.isOpen || t._select(n, e)), t.focusIndex = n
                      .index, t.button.attr("aria-activedescendant", t
                      .menuItems.eq(n.index)
                      .attr("id"))
                }
            })
              .menu("instance"), this.menu.addClass("ui-corner-bottom")
              .removeClass("ui-corner-all"), this.menuInstance._off(this.menu,
              "mouseleave"), this.menuInstance._closeOnDocumentClick = () => !1, this.menuInstance._isDivider = () => !1
        },
        refresh() {
            this._refreshMenu(), this._setText(this.buttonText, this._getSelectedItem()
              .text()), this.options.width || this._resizeButton()
        },
        _refreshMenu() {
            this.menu.empty();
            let e;
            const t = this.element.find("option");
            t.length && (this._parseOptions(t), this._renderMenu(this.menu, this.items),
              this.menuInstance.refresh(), this.menuItems = this.menu.find("li")
              .not(".ui-selectmenu-optgroup"), e = this._getSelectedItem(), this
              .menuInstance.focus(null, e), this._setAria(e.data(
              "ui-selectmenu-item")), this._setOption("disabled", this.element
              .prop("disabled")))
        },
        open(e) {
            this.options.disabled || (this.menuItems ? (this.menu.find(".ui-state-focus")
              .removeClass("ui-state-focus"), this.menuInstance.focus(null, this
              ._getSelectedItem())) : this._refreshMenu(), this.isOpen = !0,
              this._toggleAttr(), this._resizeMenu(), this._position(), this._on(
              this.document, this._documentClick), this._trigger("open", e))
        },
        _position() {
            this.menuWrap.position(e.extend({
                of: this.button
            }, this.options.position))
        },
        close(e) {
            this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this
              ._off(this.document), this._trigger("close", e))
        },
        widget() {
            return this.button
        },
        menuWidget() {
            return this.menu
        },
        _renderMenu(t, i) {
            const n = this;
            let o = "";
            e.each(i, (i, s) => {
                s.optgroup !== o && (e("<li>", {
                    "class": `ui-selectmenu-optgroup ui-menu-divider${s.element.parent("optgroup")
    .prop("disabled") ? " ui-state-disabled" :
    ""}`,
                    text: s.optgroup
                })
                  .appendTo(t), o = s.optgroup), n._renderItemData(t, s)
            })
        },
        _renderItemData(e, t) {
            return this._renderItem(e, t)
              .data("ui-selectmenu-item", t)
        },
        _renderItem(t, {disabled, label}) {
            const n = e("<li>");
            return disabled && n.addClass("ui-state-disabled"), this._setText(n, label), n.appendTo(t);
        },
        _setText(e, t) {
            t ? e.text(t) : e.html("&#160;")
        },
        _move(e, t) {
            let i;
            let n;
            let o = ".ui-menu-item";
            this.isOpen ? i = this.menuItems.eq(this.focusIndex) : (i = this.menuItems.eq(
              this.element[0].selectedIndex), o += ":not(.ui-state-disabled)"), n =
              "first" === e || "last" === e ? i["first" === e ? "prevAll" : "nextAll"](
                o)
                .eq(-1) : i[`${e}All`](o)
                .eq(0), n.length && this.menuInstance.focus(t, n)
        },
        _getSelectedItem() {
            return this.menuItems.eq(this.element[0].selectedIndex)
        },
        _toggle(e) {
            this[this.isOpen ? "close" : "open"](e)
        },
        _setSelection() {
            let e;
            this.range && (window.getSelection ? (e = window.getSelection(), e
              .removeAllRanges(), e.addRange(this.range)) : this.range.select(),
              this.button.focus())
        },
        _documentClick: {
            mousedown(t) {
                this.isOpen && (e(t.target)
                  .closest(`.ui-selectmenu-menu, #${this.ids.button}`)
                  .length || this.close(t))
            }
        },
        _buttonEvents: {
            mousedown() {
                let e;
                window.getSelection ? (e = window.getSelection(), e.rangeCount && (this
                  .range = e.getRangeAt(0))) : this.range = document.selection
                  .createRange()
            },
            click(e) {
                this._setSelection(), this._toggle(e)
            },
            keydown(t) {
                let i = !0;
                switch (t.keyCode) {
                    case e.ui.keyCode.TAB:
                    case e.ui.keyCode.ESCAPE:
                        this.close(t), i = !1;
                        break;
                    case e.ui.keyCode.ENTER:
                        this.isOpen && this._selectFocusedItem(t);
                        break;
                    case e.ui.keyCode.UP:
                        t.altKey ? this._toggle(t) : this._move("prev", t);
                        break;
                    case e.ui.keyCode.DOWN:
                        t.altKey ? this._toggle(t) : this._move("next", t);
                        break;
                    case e.ui.keyCode.SPACE:
                        this.isOpen ? this._selectFocusedItem(t) : this._toggle(t);
                        break;
                    case e.ui.keyCode.LEFT:
                        this._move("prev", t);
                        break;
                    case e.ui.keyCode.RIGHT:
                        this._move("next", t);
                        break;
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.PAGE_UP:
                        this._move("first", t);
                        break;
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_DOWN:
                        this._move("last", t);
                        break;
                    default:
                        this.menu.trigger(t), i = !1
                }
                i && t.preventDefault()
            }
        },
        _selectFocusedItem(e) {
            const t = this.menuItems.eq(this.focusIndex);
            t.hasClass("ui-state-disabled") || this._select(t.data("ui-selectmenu-item"),
              e)
        },
        _select(e, t) {
            const i = this.element[0].selectedIndex;
            this.element[0].selectedIndex = e.index, this._setText(this.buttonText, e
              .label), this._setAria(e), this._trigger("select", t, {
                item: e
            }), e.index !== i && this._trigger("change", t, {
                item: e
            }), this.close(t)
        },
        _setAria(e) {
            const t = this.menuItems.eq(e.index)
              .attr("id");
            this.button.attr({
                "aria-labelledby": t,
                "aria-activedescendant": t
            }), this.menu.attr("aria-activedescendant", t)
        },
        _setOption(e, t) {
            "icons" === e && this.button.find("span.ui-icon")
              .removeClass(this.options.icons.button)
              .addClass(t.button), this._super(e, t), "appendTo" === e && this.menuWrap
              .appendTo(this._appendTo()), "disabled" === e && (this.menuInstance
              .option("disabled", t), this.button.toggleClass("ui-state-disabled",
              t)
              .attr("aria-disabled", t), this.element.prop("disabled", t), t ? (this
              .button.attr("tabindex", -1), this.close()) : this.button.attr(
              "tabindex", 0)), "width" === e && this._resizeButton()
        },
        _appendTo() {
            let t = this.options.appendTo;
            return t && (t = t.jquery || t.nodeType ? e(t) : this.document.find(t)
              .eq(0)), t && t[0] || (t = this.element.closest(".ui-front")), t
              .length || (t = this.document[0].body), t
        },
        _toggleAttr() {
            this.button.toggleClass("ui-corner-top", this.isOpen)
              .toggleClass("ui-corner-all", !this.isOpen)
              .attr("aria-expanded", this.isOpen), this.menuWrap.toggleClass(
              "ui-selectmenu-open", this.isOpen), this.menu.attr("aria-hidden", !
              this.isOpen)
        },
        _resizeButton() {
            let e = this.options.width;
            e || (e = this.element.show()
              .outerWidth(), this.element.hide()), this.button.outerWidth(e)
        },
        _resizeMenu() {
            this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("")
              .outerWidth() + 1))
        },
        _getCreateOptions() {
            return {
                disabled: this.element.prop("disabled")
            }
        },
        _parseOptions(t) {
            const i = [];
            t.each((t, n) => {
                const o = e(n);
                const s = o.parent("optgroup");
                i.push({
                    element: o,
                    index: t,
                    value: o.val(),
                    label: o.text(),
                    optgroup: s.attr("label") || "",
                    disabled: s.prop("disabled") || o.prop("disabled")
                })
            }), this.items = i
        },
        _destroy() {
            this.menuWrap.remove(), this.button.remove(), this.element.show(), this
              .element.removeUniqueId(), this.label.attr("for", this.ids.element)
        }
    }), e.widget("ui.slider", e.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "slide",
        options: {
            animate: !1,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: !1,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create() {
            this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this
              ._handleIndex = null, this._detectOrientation(), this._mouseInit(), this
              ._calculateNewMax(), this.element.addClass(`ui-slider ui-slider-${this
  .orientation} ui-widget ui-widget-content ui-corner-all`
            ), this._refresh(), this._setOption("disabled", this.options
              .disabled), this._animateOff = !1
        },
        _refresh() {
            this._createRange(), this._createHandles(), this._setupEvents(), this
              ._refreshValue()
        },
        _createHandles() {
            let t;
            let i;
            const n = this.options;

            let o = this.element.find(".ui-slider-handle")
              .addClass("ui-state-default ui-corner-all");

            const s =
              "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>";

            const a = [];
            for (i = n.values && n.values.length || 1, o.length > i && (o.slice(i)
              .remove(), o = o.slice(0, i)), t = o.length; i > t; t++) a.push(s);
            this.handles = o.add(e(a.join(""))
              .appendTo(this.element)), this.handle = this.handles.eq(0), this
              .handles.each(function (t) {
                  e(this)
                    .data("ui-slider-handle-index", t)
              })
        },
        _createRange() {
            const t = this.options;
            let i = "";
            t.range ? (t.range === !0 && (t.values ? t.values.length && 2 !== t.values
              .length ? t.values = [t.values[0], t.values[0]] : e.isArray(t
              .values) && (t.values = t.values.slice(0)) : t.values = [this
              ._valueMin(), this._valueMin()]), this.range && this.range
              .length ? this.range.removeClass(
              "ui-slider-range-min ui-slider-range-max")
              .css({
                  left: "",
                  bottom: ""
              }) : (this.range = e("<div></div>")
              .appendTo(this.element), i =
              "ui-slider-range ui-widget-header ui-corner-all"), this.range
              .addClass(i + ("min" === t.range || "max" === t.range ?
                ` ui-slider-range-${t.range}` : ""))) : (this.range && this.range
              .remove(), this.range = null)
        },
        _setupEvents() {
            this._off(this.handles), this._on(this.handles, this._handleEvents), this
              ._hoverable(this.handles), this._focusable(this.handles)
        },
        _destroy() {
            this.handles.remove(), this.range && this.range.remove(), this.element
              .removeClass(
                "ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"
              ), this._mouseDestroy()
        },
        _mouseCapture(t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            const u = this;
            const d = this.options;
            return d.disabled ? !1 : (this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            }, this.elementOffset = this.element.offset(), i = {
                x: t.pageX,
                y: t.pageY
            }, n = this._normValueFromMouse(i), o = this._valueMax() - this
              ._valueMin() + 1, this.handles.each(function (t) {
                const i = Math.abs(n - u.values(t));
                (o > i || o === i && (t === u._lastChangedValue || u.values(
                  t) === d.min)) && (o = i, s = e(this), a = t)
            }), r = this._start(t, a), r === !1 ? !1 : (this._mouseSliding = !0,
              this._handleIndex = a, s.addClass("ui-state-active")
              .focus(), l = s.offset(), c = !e(t.target)
              .parents()
              .addBack()
              .is(".ui-slider-handle"), this._clickOffset = c ? {
                left: 0,
                top: 0
            } : {
                left: t.pageX - l.left - s.width() / 2,
                top: t.pageY - l.top - s.height() / 2 - (parseInt(s.css(
                  "borderTopWidth"), 10) || 0) - (parseInt(s.css(
                  "borderBottomWidth"), 10) || 0) + (parseInt(s.css(
                  "marginTop"), 10) || 0)
            }, this.handles.hasClass("ui-state-hover") || this._slide(t, a,
              n), this._animateOff = !0, !0));
        },
        _mouseStart() {
            return !0
        },
        _mouseDrag(e) {
            const t = {
                  x: e.pageX,
                  y: e.pageY
              };

            const i = this._normValueFromMouse(t);
            return this._slide(e, this._handleIndex, i), !1
        },
        _mouseStop(e) {
            return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1,
              this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this
              ._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1
        },
        _detectOrientation() {
            this.orientation = "vertical" === this.options.orientation ? "vertical" :
              "horizontal"
        },
        _normValueFromMouse(e) {
            let t;
            let i;
            let n;
            let o;
            let s;
            return "horizontal" === this.orientation ? (t = this.elementSize.width, i = e
              .x - this.elementOffset.left - (this._clickOffset ? this._clickOffset
              .left : 0)) : (t = this.elementSize.height, i = e.y - this
              .elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)),
              n = i / t, n > 1 && (n = 1), 0 > n && (n = 0), "vertical" === this
              .orientation && (n = 1 - n), o = this._valueMax() - this._valueMin(), s =
              this._valueMin() + n * o, this._trimAlignValue(s)
        },
        _start(e, t) {
            const i = {
                handle: this.handles[t],
                value: this.value()
            };
            return this.options.values && this.options.values.length && (i.value = this
              .values(t), i.values = this.values()), this._trigger("start", e, i)
        },
        _slide(e, t, i) {
            let n;
            let o;
            let s;
            this.options.values && this.options.values.length ? (n = this.values(t ? 0 :
              1), 2 === this.options.values.length && this.options.range === !
                0 && (0 === t && i > n || 1 === t && n > i) && (i = n), i !== this
                .values(t) && (o = this.values(), o[t] = i, s = this._trigger("slide",
              e, {
                  handle: this.handles[t],
                  value: i,
                  values: o
              }), n = this.values(t ? 0 : 1), s !== !1 && this.values(t, i))) :
              i !== this.value() && (s = this._trigger("slide", e, {
                  handle: this.handles[t],
                  value: i
              }), s !== !1 && this.value(i))
        },
        _stop(e, t) {
            const i = {
                handle: this.handles[t],
                value: this.value()
            };
            this.options.values && this.options.values.length && (i.value = this.values(
              t), i.values = this.values()), this._trigger("stop", e, i)
        },
        _change(e, t) {
            if (!this._keySliding && !this._mouseSliding) {
                const i = {
                    handle: this.handles[t],
                    value: this.value()
                };
                this.options.values && this.options.values.length && (i.value = this
                  .values(t), i.values = this.values()), this._lastChangedValue = t,
                  this._trigger("change", e, i)
            }
        },
        value(e) {
            return arguments.length ? (this.options.value = this._trimAlignValue(e), this
              ._refreshValue(), this._change(null, 0), void 0) : this._value()
        },
        values(t, i) {
            let n;
            let o;
            let s;
            if (arguments.length > 1) return this.options.values[t] = this
              ._trimAlignValue(i), this._refreshValue(), this._change(null, t),
              void 0;
            if (!arguments.length) return this._values();
            if (!e.isArray(arguments[0])) return this.options.values && this.options
              .values.length ? this._values(t) : this.value();
            for (n = this.options.values, o = arguments[0], s = 0; s < n.length; s += 1)
                n[s] = this._trimAlignValue(o[s]), this._change(null, s);
            this._refreshValue()
        },
        _setOption(t, i) {
            let n;
            let o = 0;
            switch ("range" === t && this.options.range === !0 && ("min" === i ? (this
                .options.value = this._values(0), this.options.values = null) :
              "max" === i && (this.options.value = this._values(this.options.values
                .length - 1), this.options.values = null)), e.isArray(this.options
              .values) && (o = this.options.values.length), "disabled" === t && this
              .element.toggleClass("ui-state-disabled", !!i), this._super(t, i), t) {
                case "orientation":
                    this._detectOrientation(), this.element.removeClass(
                      "ui-slider-horizontal ui-slider-vertical")
                      .addClass(`ui-slider-${this.orientation}`), this._refreshValue(), this
                      .handles.css("horizontal" === i ? "bottom" : "left", "");
                    break;
                case "value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this
                      ._animateOff = !1;
                    break;
                case "values":
                    for (this._animateOff = !0, this._refreshValue(), n = 0; o > n; n += 1)
                        this._change(null, n);
                    this._animateOff = !1;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this
                      ._animateOff = !1;
                    break;
                case "range":
                    this._animateOff = !0, this._refresh(), this._animateOff = !1
            }
        },
        _value() {
            let e = this.options.value;
            return e = this._trimAlignValue(e)
        },
        _values(e) {
            let t;
            let i;
            let n;
            if (arguments.length) return t = this.options.values[e], t = this
              ._trimAlignValue(t);
            if (this.options.values && this.options.values.length) {
                for (i = this.options.values.slice(), n = 0; n < i.length; n += 1) i[n] =
                  this._trimAlignValue(i[n]);
                return i
            }
            return []
        },
        _trimAlignValue(e) {
            if (e <= this._valueMin()) return this._valueMin();
            if (e >= this._valueMax()) return this._valueMax();
            const t = this.options.step > 0 ? this.options.step : 1;
            const i = (e - this._valueMin()) % t;
            let n = e - i;
            return 2 * Math.abs(i) >= t && (n += i > 0 ? t : -t), parseFloat(n.toFixed(5))
        },
        _calculateNewMax() {
            let e = this.options.max;
            const t = this._valueMin();
            const i = this.options.step;

            const n = Math.floor(+(e - t)
              .toFixed(this._precision()) / i) * i;

            e = n + t, this.max = parseFloat(e.toFixed(this._precision()))
        },
        _precision() {
            let e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this
              .options.min))), e
        },
        _precisionOf(e) {
            const t = e.toString();
            const i = t.indexOf(".");
            return -1 === i ? 0 : t.length - i - 1
        },
        _valueMin() {
            return this.options.min
        },
        _valueMax() {
            return this.max
        },
        _refreshValue() {
            let t;
            let i;
            let n;
            let o;
            let s;
            const a = this.options.range;
            const r = this.options;
            const l = this;
            const c = this._animateOff ? !1 : r.animate;
            const u = {};
            this.options.values && this.options.values.length ? this.handles.each(
              function (n) {
                  i = 100 * ((l.values(n) - l._valueMin()) / (l._valueMax() - l
                    ._valueMin())), u["horizontal" === l.orientation ?
                    "left" : "bottom"] = `${i}%`, e(this)
                    .stop(1, 1)[c ? "animate" : "css"](u, r.animate), l.options
                    .range === !0 && ("horizontal" === l.orientation ? (0 === n &&
                  l.range.stop(1, 1)[c ? "animate" : "css"]({
                      left: `${i}%`
                  }, r.animate), 1 === n && l.range[c ? "animate" :
                    "css"]({
                      width: `${i - t}%`
                  }, {
                      queue: !1,
                      duration: r.animate
                  })) : (0 === n && l.range.stop(1, 1)[c ? "animate" :
                    "css"]({
                      bottom: `${i}%`
                  }, r.animate), 1 === n && l.range[c ? "animate" :
                    "css"]({
                      height: `${i - t}%`
                  }, {
                      queue: !1,
                      duration: r.animate
                  }))), t = i
              }) : (n = this.value(), o = this._valueMin(), s = this._valueMax(),
              i = s !== o ? 100 * ((n - o) / (s - o)) : 0, u["horizontal" === this
              .orientation ? "left" : "bottom"] = `${i}%`, this.handle.stop(1,
              1)[c ? "animate" : "css"](u, r.animate), "min" === a &&
            "horizontal" === this.orientation && this.range.stop(1, 1)[c ?
              "animate" : "css"]({
                width: `${i}%`
            }, r.animate), "max" === a && "horizontal" === this.orientation &&
            this.range[c ? "animate" : "css"]({
                width: `${100 - i}%`
            }, {
                queue: !1,
                duration: r.animate
            }), "min" === a && "vertical" === this.orientation && this.range.stop(
              1, 1)[c ? "animate" : "css"]({
                height: `${i}%`
            }, r.animate), "max" === a && "vertical" === this.orientation && this
              .range[c ? "animate" : "css"]({
                height: `${100 - i}%`
            }, {
                queue: !1,
                duration: r.animate
            }))
        },
        _handleEvents: {
            keydown(t) {
                let i;
                let n;
                let o;
                let s;

                const a = e(t.target)
                  .data("ui-slider-handle-index");

                switch (t.keyCode) {
                    case e.ui.keyCode.HOME:
                    case e.ui.keyCode.END:
                    case e.ui.keyCode.PAGE_UP:
                    case e.ui.keyCode.PAGE_DOWN:
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (t.preventDefault(), !this._keySliding && (this._keySliding = !0,
                            e(t.target)
                              .addClass("ui-state-active"), i = this._start(t, a), i === !1
                        )) return
                }
                switch (s = this.options.step, n = o = this.options.values && this.options
                  .values.length ? this.values(a) : this.value(), t.keyCode) {
                    case e.ui.keyCode.HOME:
                        o = this._valueMin();
                        break;
                    case e.ui.keyCode.END:
                        o = this._valueMax();
                        break;
                    case e.ui.keyCode.PAGE_UP:
                        o = this._trimAlignValue(n + (this._valueMax() - this._valueMin()) /
                          this.numPages);
                        break;
                    case e.ui.keyCode.PAGE_DOWN:
                        o = this._trimAlignValue(n - (this._valueMax() - this._valueMin()) /
                          this.numPages);
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.RIGHT:
                        if (n === this._valueMax()) return;
                        o = this._trimAlignValue(n + s);
                        break;
                    case e.ui.keyCode.DOWN:
                    case e.ui.keyCode.LEFT:
                        if (n === this._valueMin()) return;
                        o = this._trimAlignValue(n - s)
                }
                this._slide(t, a, o)
            },
            keyup(t) {
                const i = e(t.target)
                  .data("ui-slider-handle-index");
                this._keySliding && (this._keySliding = !1, this._stop(t, i), this
                  ._change(t, i), e(t.target)
                  .removeClass("ui-state-active"))
            }
        }
    }), e.widget("ui.spinner", {
        version: "1.11.4",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: !0,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create() {
            this._setOption("max", this.options.max), this._setOption("min", this.options
              .min), this._setOption("step", this.options.step), "" !== this
              .value() && this._value(this.element.val(), !0), this._draw(), this._on(this
              ._events), this._refresh(), this._on(this.window, {
                beforeunload() {
                    this.element.removeAttr("autocomplete")
                }
            })
        },
        _getCreateOptions() {
            const t = {};
            const i = this.element;
            return e.each(["min", "max", "step"], (e, n) => {
                const o = i.attr(n);
                void 0 !== o && o.length && (t[n] = o)
            }), t;
        },
        _events: {
            keydown(e) {
                this._start(e) && this._keydown(e) && e.preventDefault()
            },
            keyup: "_stop",
            focus() {
                this.previous = this.element.val()
            },
            blur(e) {
                return this.cancelBlur ? (delete this.cancelBlur, void 0) : (this._stop(),
                  this._refresh(), this.previous !== this.element.val() && this
                  ._trigger("change", e), void 0)
            },
            mousewheel(e, t) {
                if (t) {
                    if (!this.spinning && !this._start(e)) return !1;
                    this._spin((t > 0 ? 1 : -1) * this.options.step, e), clearTimeout(this
                      .mousewheelTimer), this.mousewheelTimer = this._delay(
                      function () {
                          this.spinning && this._stop(e)
                      }, 100), e.preventDefault()
                }
            },
            "mousedown .ui-spinner-button": function (t) {
                function i() {
                    const e = this.element[0] === this.document[0].activeElement;
                    e || (this.element.focus(), this.previous = n, this._delay(
                      function () {
                          this.previous = n
                      }))
                }
                var n;
                n = this.element[0] === this.document[0].activeElement ? this.previous :
                  this.element.val(), t.preventDefault(), i.call(this), this
                  .cancelBlur = !0, this._delay(function () {
                    delete this.cancelBlur, i.call(this)
                }), this._start(t) !== !1 && this._repeat(null, e(t.currentTarget)
                  .hasClass("ui-spinner-up") ? 1 : -1, t)
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function (t) {
                return e(t.currentTarget)
                  .hasClass("ui-state-active") ? this._start(t) === !1 ? !1 : (this
                  ._repeat(null, e(t.currentTarget)
                    .hasClass("ui-spinner-up") ? 1 : -1, t), void 0) : void 0
            },
            "mouseleave .ui-spinner-button": "_stop"
        },
        _draw() {
            const e = this.uiSpinner = this.element.addClass("ui-spinner-input")
              .attr("autocomplete", "off")
              .wrap(this._uiSpinnerHtml())
              .parent()
              .append(this._buttonHtml());
            this.element.attr("role", "spinbutton"), this.buttons = e.find(
              ".ui-spinner-button")
              .attr("tabIndex", -1)
              .button()
              .removeClass("ui-corner-all"), this.buttons.height() > Math.ceil(.5 * e
              .height()) && e.height() > 0 && e.height(e.height()), this.options
              .disabled && this.disable()
        },
        _keydown(t) {
            const i = this.options;
            const n = e.ui.keyCode;
            switch (t.keyCode) {
                case n.UP:
                    return this._repeat(null, 1, t), !0;
                case n.DOWN:
                    return this._repeat(null, -1, t), !0;
                case n.PAGE_UP:
                    return this._repeat(null, i.page, t), !0;
                case n.PAGE_DOWN:
                    return this._repeat(null, -i.page, t), !0
            }
            return !1
        },
        _uiSpinnerHtml() {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"
        },
        _buttonHtml() {
            return `<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon ${this.options.icons.up}'>&#9650;</span></a><a class='ui-spinner-button ui-spinner-down ui-corner-br'><span class='ui-icon ${this.options.icons.down}'>&#9660;</span></a>`;
        },
        _start(e) {
            return this.spinning || this._trigger("start", e) !== !1 ? (this.counter || (
              this.counter = 1), this.spinning = !0, !0) : !1
        },
        _repeat(e, t, i) {
            e = e || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
                this._repeat(40, t, i)
            }, e), this._spin(t * this.options.step, i)
        },
        _spin(e, t) {
            let i = this.value() || 0;
            this.counter || (this.counter = 1), i = this._adjustValue(i + e * this
              ._increment(this.counter)), this.spinning && this._trigger("spin",
              t, {
                  value: i
              }) === !1 || (this._value(i), this.counter++)
        },
        _increment(t) {
            const i = this.options.incremental;
            return i ? e.isFunction(i) ? i(t) : Math.floor(t * t * t / 5e4 - t * t / 500 +
              17 * t / 200 + 1) : 1
        },
        _precision() {
            let e = this._precisionOf(this.options.step);
            return null !== this.options.min && (e = Math.max(e, this._precisionOf(this
              .options.min))), e
        },
        _precisionOf(e) {
            const t = e.toString();
            const i = t.indexOf(".");
            return -1 === i ? 0 : t.length - i - 1
        },
        _adjustValue(e) {
            let t;
            let i;
            const n = this.options;
            return t = null !== n.min ? n.min : 0, i = e - t, i = Math.round(i / n.step) *
              n.step, e = t + i, e = parseFloat(e.toFixed(this._precision())), null !==
            n.max && e > n.max ? n.max : null !== n.min && e < n.min ? n.min : e
        },
        _stop(e) {
            this.spinning && (clearTimeout(this.timer), clearTimeout(this
              .mousewheelTimer), this.counter = 0, this.spinning = !1, this
              ._trigger("stop", e))
        },
        _setOption(e, t) {
            if ("culture" === e || "numberFormat" === e) {
                const i = this._parse(this.element.val());
                return this.options[e] = t, this.element.val(this._format(i)), void 0
            }("max" === e || "min" === e || "step" === e) && "string" == typeof t && (t =
              this._parse(t)), "icons" === e && (this.buttons.first()
              .find(".ui-icon")
              .removeClass(this.options.icons.up)
              .addClass(t.up), this.buttons.last()
              .find(".ui-icon")
              .removeClass(this.options.icons.down)
              .addClass(t.down)), this._super(e, t), "disabled" === e && (this
              .widget()
              .toggleClass("ui-state-disabled", !!t), this.element.prop("disabled",
              !!t), this.buttons.button(t ? "disable" : "enable"))
        },
        _setOptions: l(function (e) {
            this._super(e)
        }),
        _parse(e) {
            return "string" == typeof e && "" !== e && (e = window.Globalize && this
              .options.numberFormat ? Globalize.parseFloat(e, 10, this.options
              .culture) : +e), "" === e || isNaN(e) ? null : e
        },
        _format(e) {
            return "" === e ? "" : window.Globalize && this.options.numberFormat ?
              Globalize.format(e, this.options.numberFormat, this.options.culture) : e
        },
        _refresh() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            })
        },
        isValid() {
            const e = this.value();
            return null === e ? !1 : e === this._adjustValue(e)
        },
        _value(e, t) {
            let i;
            "" !== e && (i = this._parse(e), null !== i && (t || (i = this._adjustValue(
              i)), e = this._format(i))), this.element.val(e), this._refresh()
        },
        _destroy() {
            this.element.removeClass("ui-spinner-input")
              .prop("disabled", !1)
              .removeAttr("autocomplete")
              .removeAttr("role")
              .removeAttr("aria-valuemin")
              .removeAttr("aria-valuemax")
              .removeAttr("aria-valuenow"), this.uiSpinner.replaceWith(this.element)
        },
        stepUp: l(function (e) {
            this._stepUp(e)
        }),
        _stepUp(e) {
            this._start() && (this._spin((e || 1) * this.options.step), this._stop())
        },
        stepDown: l(function (e) {
            this._stepDown(e)
        }),
        _stepDown(e) {
            this._start() && (this._spin((e || 1) * -this.options.step), this._stop())
        },
        pageUp: l(function (e) {
            this._stepUp((e || 1) * this.options.page)
        }),
        pageDown: l(function (e) {
            this._stepDown((e || 1) * this.options.page)
        }),
        value(e) {
            return arguments.length ? (l(this._value)
              .call(this, e), void 0) : this._parse(this.element.val())
        },
        widget() {
            return this.uiSpinner
        }
    }), e.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: !1,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: (() => {
            const e = /#.*$/;
            return t => {
                let i;
                let n;
                t = t.cloneNode(!1), i = t.href.replace(e, ""), n = location.href
                  .replace(e, "");
                try {
                    i = decodeURIComponent(i)
                } catch (o) {}
                try {
                    n = decodeURIComponent(n)
                } catch (o) {}
                return t.hash.length > 1 && i === n
            };
        })(),
        _create() {
            const t = this;
            const i = this.options;
            this.running = !1, this.element.addClass(
              "ui-tabs ui-widget ui-widget-content ui-corner-all")
              .toggleClass("ui-tabs-collapsible", i.collapsible), this._processTabs(), i
              .active = this._initialActive(), e.isArray(i.disabled) && (i.disabled = e
              .unique(i.disabled.concat(e.map(this.tabs.filter(
                ".ui-state-disabled"),
                e => t.tabs.index(e))))
              .sort()), this.active = this.options.active !== !1 && this.anchors
              .length ? this._findActive(i.active) : e(), this._refresh(), this.active
              .length && this.load(i.active)
        },
        _initialActive() {
            let t = this.options.active;
            const i = this.options.collapsible;
            const n = location.hash.substring(1);
            return null === t && (n && this.tabs.each((i, o) => e(o)
              .attr("aria-controls") === n ? (t = i, !1) : void 0), null === t && (t = this.tabs.index(this.tabs.filter(
              ".ui-tabs-active"))), (null === t || -1 === t) && (t = this.tabs
              .length ? 0 : !1)), t !== !1 && (t = this.tabs.index(this.tabs.eq(t)),
            -1 === t && (t = i ? !1 : 0)), !i && t === !1 && this.anchors
              .length && (t = 0), t;
        },
        _getCreateEventData() {
            return {
                tab: this.active,
                panel: this.active.length ? this._getPanelForTab(this.active) : e()
            }
        },
        _tabKeydown(t) {
            const i = e(this.document[0].activeElement)
                .closest("li");

            let n = this.tabs.index(i);
            let o = !0;
            if (!this._handlePageNav(t)) {
                switch (t.keyCode) {
                    case e.ui.keyCode.RIGHT:
                    case e.ui.keyCode.DOWN:
                        n++;
                        break;
                    case e.ui.keyCode.UP:
                    case e.ui.keyCode.LEFT:
                        o = !1, n--;
                        break;
                    case e.ui.keyCode.END:
                        n = this.anchors.length - 1;
                        break;
                    case e.ui.keyCode.HOME:
                        n = 0;
                        break;
                    case e.ui.keyCode.SPACE:
                        return t.preventDefault(), clearTimeout(this.activating), this
                          ._activate(n), void 0;
                    case e.ui.keyCode.ENTER:
                        return t.preventDefault(), clearTimeout(this.activating), this
                          ._activate(n === this.options.active ? !1 : n), void 0;
                    default:
                        return
                }
                t.preventDefault(), clearTimeout(this.activating), n = this._focusNextTab(
                  n, o), t.ctrlKey || t.metaKey || (i.attr("aria-selected",
                  "false"), this.tabs.eq(n)
                  .attr("aria-selected", "true"), this.activating = this._delay(
                  function () {
                      this.option("active", n)
                  }, this.delay))
            }
        },
        _panelKeydown(t) {
            this._handlePageNav(t) || t.ctrlKey && t.keyCode === e.ui.keyCode.UP && (t
              .preventDefault(), this.active.focus())
        },
        _handlePageNav({altKey, keyCode}) {
            return altKey && keyCode === e.ui.keyCode.PAGE_UP ? (this._activate(this
              ._focusNextTab(this.options.active - 1, !1)), !0) : altKey && keyCode === e.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(
              this.options.active + 1, !0)), !0) : void 0;
        },
        _findNextTab(t, i) {
            function n() {
                return t > o && (t = 0), 0 > t && (t = o), t
            }
            for (var o = this.tabs.length - 1; - 1 !== e.inArray(n(), this.options
              .disabled);) t = i ? t + 1 : t - 1;
            return t
        },
        _focusNextTab(e, t) {
            return e = this._findNextTab(e, t), this.tabs.eq(e)
              .focus(), e
        },
        _setOption(e, t) {
            return "active" === e ? (this._activate(t), void 0) : "disabled" === e ? (this
              ._setupDisabled(t), void 0) : (this._super(e, t), "collapsible" ===
            e && (this.element.toggleClass("ui-tabs-collapsible", t), t || this
              .options.active !== !1 || this._activate(0)), "event" === e &&
            this._setupEvents(t), "heightStyle" === e && this._setupHeightStyle(
              t), void 0)
        },
        _sanitizeSelector(e) {
            return e ? e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
        },
        refresh() {
            const t = this.options;
            const i = this.tablist.children(":has(a[href])");
            t.disabled = e.map(i.filter(".ui-state-disabled"), e => i.index(e)), this._processTabs(), t.active !== !1 && this.anchors.length ? this
              .active.length && !e.contains(this.tablist[0], this.active[0]) ? this.tabs
              .length === t.disabled.length ? (t.active = !1, this.active = e()) : this
              ._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active =
              this.tabs.index(this.active) : (t.active = !1, this.active = e()), this
              ._refresh()
        },
        _refresh() {
            this._setupDisabled(this.options.disabled), this._setupEvents(this.options
              .event), this._setupHeightStyle(this.options.heightStyle), this.tabs
              .not(this.active)
              .attr({
                  "aria-selected": "false",
                  "aria-expanded": "false",
                  tabIndex: -1
              }), this.panels.not(this._getPanelForTab(this.active))
              .hide()
              .attr({
                  "aria-hidden": "true"
              }), this.active.length ? (this.active.addClass(
              "ui-tabs-active ui-state-active")
              .attr({
                  "aria-selected": "true",
                  "aria-expanded": "true",
                  tabIndex: 0
              }), this._getPanelForTab(this.active)
              .show()
              .attr({
                  "aria-hidden": "false"
              })) : this.tabs.eq(0)
              .attr("tabIndex", 0)
        },
        _processTabs() {
            const t = this;
            const i = this.tabs;
            const n = this.anchors;
            const o = this.panels;
            this.tablist = this._getList()
              .addClass(
                "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"
              )
              .attr("role", "tablist")
              .delegate("> li", `mousedown${this.eventNamespace}`, function (t) {
                  e(this)
                    .is(".ui-state-disabled") && t.preventDefault()
              })
              .delegate(".ui-tabs-anchor", `focus${this.eventNamespace}`, function () {
                  e(this)
                    .closest("li")
                    .is(".ui-state-disabled") && this.blur()
              }), this.tabs = this.tablist.find("> li:has(a[href])")
              .addClass("ui-state-default ui-corner-top")
              .attr({
                  role: "tab",
                  tabIndex: -1
              }), this.anchors = this.tabs.map(function () {
                return e("a", this)[0]
            })
              .addClass("ui-tabs-anchor")
              .attr({
                  role: "presentation",
                  tabIndex: -1
              }), this.panels = e(), this.anchors.each((i, n) => {
                let o;
                let s;
                let a;

                const r = e(n)
                    .uniqueId()
                    .attr("id");

                const l = e(n)
                  .closest("li");

                const c = l.attr("aria-controls");
                t._isLocal(n) ? (o = n.hash, a = o.substring(1), s = t.element
                  .find(t._sanitizeSelector(o))) : (a = l.attr(
                  "aria-controls") || e({})
                  .uniqueId()[0].id, o = `#${a}`, s = t.element.find(o), s
                  .length || (s = t._createPanel(a), s.insertAfter(t.panels[
                i - 1] || t.tablist)), s.attr("aria-live", "polite")),
                s.length && (t.panels = t.panels.add(s)), c && l.data(
                  "ui-tabs-aria-controls", c), l.attr({
                    "aria-controls": a,
                    "aria-labelledby": r
                }), s.attr("aria-labelledby", r)
            }), this.panels.addClass(
              "ui-tabs-panel ui-widget-content ui-corner-bottom")
              .attr("role", "tabpanel"), i && (this._off(i.not(this.tabs)), this._off(n
              .not(this.anchors)), this._off(o.not(this.panels)))
        },
        _getList() {
            return this.tablist || this.element.find("ol,ul")
              .eq(0)
        },
        _createPanel(t) {
            return e("<div>")
              .attr("id", t)
              .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
              .data("ui-tabs-destroy", !0)
        },
        _setupDisabled(t) {
            e.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) :
              t = !1);
            for (let i, n = 0; i = this.tabs[n]; n++) t === !0 || -1 !== e.inArray(n, t) ?
              e(i)
                .addClass("ui-state-disabled")
                .attr("aria-disabled", "true") : e(i)
                .removeClass("ui-state-disabled")
                .removeAttr("aria-disabled");
            this.options.disabled = t
        },
        _setupEvents(t) {
            const i = {};
            t && e.each(t.split(" "), (e, t) => {
                i[t] = "_eventHandler"
            }), this._off(this.anchors.add(this.tabs)
              .add(this.panels)), this._on(!0, this.anchors, {
                click(e) {
                    e.preventDefault()
                }
            }), this._on(this.anchors, i), this._on(this.tabs, {
                keydown: "_tabKeydown"
            }), this._on(this.panels, {
                keydown: "_panelKeydown"
            }), this._focusable(this.tabs), this._hoverable(this.tabs)
        },
        _setupHeightStyle(t) {
            let i;
            const n = this.element.parent();
            "fill" === t ? (i = n.height(), i -= this.element.outerHeight() - this.element
              .height(), this.element.siblings(":visible")
              .each(function () {
                const t = e(this);
                const n = t.css("position");
                "absolute" !== n && "fixed" !== n && (i -= t.outerHeight(!0))
            }), this.element.children()
              .not(this.panels)
              .each(function () {
                  i -= e(this)
                    .outerHeight(!0)
              }), this.panels.each(function () {
                e(this)
                  .height(Math.max(0, i - e(this)
                    .innerHeight() + e(this)
                    .height()))
            })
              .css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(
              function () {
                  i = Math.max(i, e(this)
                    .height("")
                    .height())
              })
              .height(i))
        },
        _eventHandler(t) {
            const i = this.options;
            const n = this.active;
            const o = e(t.currentTarget);
            const s = o.closest("li");
            const a = s[0] === n[0];
            const r = a && i.collapsible;
            const l = r ? e() : this._getPanelForTab(s);
            const c = n.length ? this._getPanelForTab(n) : e();

            const u = {
                oldTab: n,
                oldPanel: c,
                newTab: r ? e() : s,
                newPanel: l
            };

            t.preventDefault(), s.hasClass("ui-state-disabled") || s.hasClass(
              "ui-tabs-loading") || this.running || a && !i.collapsible || this
              ._trigger("beforeActivate", t, u) === !1 || (i.active = r ? !1 : this.tabs
              .index(s), this.active = a ? e() : s, this.xhr && this.xhr.abort(), c
              .length || l.length || e.error(
              "jQuery UI Tabs: Mismatching fragment identifier."), l.length &&
            this.load(this.tabs.index(s), t), this._toggle(t, u))
        },
        _toggle(t, i) {
            function n() {
                s.running = !1, s._trigger("activate", t, i)
            }

            function o() {
                i.newTab.closest("li")
                  .addClass("ui-tabs-active ui-state-active"), a.length && s.options
                  .show ? s._show(a, s.options.show, n) : (a.show(), n())
            }
            var s = this;
            var a = i.newPanel;
            const r = i.oldPanel;
            this.running = !0, r.length && this.options.hide ? this._hide(r, this.options
                .hide,
              () => {
                  i.oldTab.closest("li")
                    .removeClass("ui-tabs-active ui-state-active"), o()
              }) : (i.oldTab.closest("li")
              .removeClass("ui-tabs-active ui-state-active"), r.hide(), o()), r
              .attr("aria-hidden", "true"), i.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            }), a.length && r.length ? i.oldTab.attr("tabIndex", -1) : a.length &&
              this.tabs.filter(function () {
                  return 0 === e(this)
                    .attr("tabIndex")
              })
                .attr("tabIndex", -1), a.attr("aria-hidden", "false"), i.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            })
        },
        _activate(t) {
            let i;
            let n = this._findActive(t);
            n[0] !== this.active[0] && (n.length || (n = this.active), i = n.find(
              ".ui-tabs-anchor")[0], this._eventHandler({
                target: i,
                currentTarget: i,
                preventDefault: e.noop
            }))
        },
        _findActive(t) {
            return t === !1 ? e() : this.tabs.eq(t)
        },
        _getIndex(e) {
            return "string" == typeof e && (e = this.anchors.index(this.anchors.filter(
              `[href$='${e}']`))), e;
        },
        _destroy() {
            this.xhr && this.xhr.abort(), this.element.removeClass(
              "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"
            ), this.tablist.removeClass(
              "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"
            )
              .removeAttr("role"), this.anchors.removeClass("ui-tabs-anchor")
              .removeAttr("role")
              .removeAttr("tabIndex")
              .removeUniqueId(), this.tablist.unbind(this.eventNamespace), this.tabs
              .add(this.panels)
              .each(function () {
                  e.data(this, "ui-tabs-destroy") ? e(this)
                    .remove() : e(this)
                    .removeClass(
                      "ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel"
                    )
                    .removeAttr("tabIndex")
                    .removeAttr("aria-live")
                    .removeAttr("aria-busy")
                    .removeAttr("aria-selected")
                    .removeAttr("aria-labelledby")
                    .removeAttr("aria-hidden")
                    .removeAttr("aria-expanded")
                    .removeAttr("role")
              }), this.tabs.each(function () {
                const t = e(this);
                const i = t.data("ui-tabs-aria-controls");
                i ? t.attr("aria-controls", i)
                  .removeData("ui-tabs-aria-controls") : t.removeAttr(
                  "aria-controls")
            }), this.panels.show(), "content" !== this.options.heightStyle && this
              .panels.css("height", "")
        },
        enable(t) {
            let i = this.options.disabled;
            i !== !1 && (void 0 === t ? i = !1 : (t = this._getIndex(t), i = e.isArray(
              i) ? e.map(i, e => e !== t ? e : null) : e.map(this.tabs, (e, i) => i !== t ? i : null)), this._setupDisabled(i))
        },
        disable(t) {
            let i = this.options.disabled;
            if (i !== !0) {
                if (void 0 === t) i = !0;
                else {
                    if (t = this._getIndex(t), -1 !== e.inArray(t, i)) return;
                    i = e.isArray(i) ? e.merge([t], i)
                      .sort() : [t]
                }
                this._setupDisabled(i)
            }
        },
        load(t, i) {
            t = this._getIndex(t);
            const n = this;
            const o = this.tabs.eq(t);
            const s = o.find(".ui-tabs-anchor");
            const a = this._getPanelForTab(o);

            const r = {
                tab: o,
                panel: a
            };

            const l = (e, t) => {
                "abort" === t && n.panels.stop(!1, !0), o.removeClass(
                  "ui-tabs-loading"), a.removeAttr("aria-busy"), e === n.xhr &&
                delete n.xhr
            };

            this._isLocal(s[0]) || (this.xhr = e.ajax(this._ajaxSettings(s, i, r)), this
              .xhr && "canceled" !== this.xhr.statusText && (o.addClass(
              "ui-tabs-loading"), a.attr("aria-busy", "true"), this.xhr
              .done((e, t, o) => {
                  setTimeout(() => {
                      a.html(e), n._trigger("load", i, r), l(o, t)
                  }, 1)
              })
              .fail((e, t) => {
                  setTimeout(() => {
                      l(e, t)
                  }, 1)
              })))
        },
        _ajaxSettings(t, i, n) {
            const o = this;
            return {
                url: t.attr("href"),
                beforeSend(t, s) {
                    return o._trigger("beforeLoad", i, e.extend({
                        jqXHR: t,
                        ajaxSettings: s
                    }, n))
                }
            };
        },
        _getPanelForTab(t) {
            const i = e(t)
              .attr("aria-controls");
            return this.element.find(this._sanitizeSelector(`#${i}`));
        }
    }), e.widget("ui.tooltip", {
        version: "1.11.4",
        options: {
            content() {
                const t = e(this)
                  .attr("title") || "";
                return e("<a>")
                  .text(t)
                  .html()
            },
            hide: !0,
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: !0,
            tooltipClass: null,
            track: !1,
            close: null,
            open: null
        },
        _addDescribedBy(t, i) {
            const n = (t.attr("aria-describedby") || "")
              .split(/\s+/);
            n.push(i), t.data("ui-tooltip-id", i)
              .attr("aria-describedby", e.trim(n.join(" ")))
        },
        _removeDescribedBy(t) {
            const i = t.data("ui-tooltip-id");

            let n = (t.attr("aria-describedby") || "")
              .split(/\s+/);

            const o = e.inArray(i, n);
            - 1 !== o && n.splice(o, 1), t.removeData(
                  "ui-tooltip-id"), n = e.trim(n.join(" ")), n ? t.attr(
                  "aria-describedby", n) : t.removeAttr("aria-describedby")
        },
        _create() {
            this._on({
                mouseover: "open",
                focusin: "open"
            }), this.tooltips = {}, this.parents = {}, this.options.disabled && this
              ._disable(), this.liveRegion = e("<div>")
              .attr({
                  role: "log",
                  "aria-live": "assertive",
                  "aria-relevant": "additions"
              })
              .addClass("ui-helper-hidden-accessible")
              .appendTo(this.document[0].body)
        },
        _setOption(t, i) {
            const n = this;
            return "disabled" === t ? (this[i ? "_disable" : "_enable"](), this.options[
              t] = i, void 0) : (this._super(t, i), "content" === t && e.each(this
                .tooltips,
              (e, {element}) => {
                  n._updateContent(element)
              }), void 0);
        },
        _disable() {
            const t = this;
            e.each(this.tooltips, (i, {element}) => {
                const o = e.Event("blur");
                o.target = o.currentTarget = element[0], t.close(o, !0)
            }), this.element.find(this.options.items)
              .addBack()
              .each(function () {
                  const t = e(this);
                  t.is("[title]") && t.data("ui-tooltip-title", t.attr("title"))
                    .removeAttr("title")
              })
        },
        _enable() {
            this.element.find(this.options.items)
              .addBack()
              .each(function () {
                  const t = e(this);
                  t.data("ui-tooltip-title") && t.attr("title", t.data(
                    "ui-tooltip-title"))
              })
        },
        open(t) {
            const i = this;

            const n = e(t ? t.target : this.element)
              .closest(this.options.items);

            n.length && !n.data("ui-tooltip-id") && (n.attr("title") && n.data(
              "ui-tooltip-title", n.attr("title")), n.data("ui-tooltip-open", !
              0), t && "mouseover" === t.type && n.parents()
              .each(function () {
                let t;
                const n = e(this);
                n.data("ui-tooltip-open") && (t = e.Event("blur"), t.target =
                  t.currentTarget = this, i.close(t, !0)), n.attr(
                  "title") && (n.uniqueId(), i.parents[this.id] = {
                    element: this,
                    title: n.attr("title")
                }, n.attr("title", ""))
            }), this._registerCloseHandlers(t, n), this._updateContent(n, t))
        },
        _updateContent(e, t) {
            let i;
            const n = this.options.content;
            const o = this;
            const s = t ? t.type : null;
            return "string" == typeof n ? this._open(t, e, n) : (i = n.call(e[0],
              i => {
                  o._delay(function () {
                      e.data("ui-tooltip-open") && (t && (t.type = s),
                        this._open(t, e, i))
                  })
              }), i && this._open(t, e, i), void 0);
        },
        _open(t, i, n) {
            function o(e) {
                c.of = e, a.is(":hidden") || a.position(c)
            }
            let s;
            var a;
            let r;
            let l;
            var c = e.extend({}, this.options.position);
            if (n) {
                if (s = this._find(i)) return s.tooltip.find(".ui-tooltip-content")
                  .html(n), void 0;
                i.is("[title]") && (t && "mouseover" === t.type ? i.attr("title", "") : i
                  .removeAttr("title")), s = this._tooltip(i), a = s.tooltip, this
                  ._addDescribedBy(i, a.attr("id")), a.find(".ui-tooltip-content")
                  .html(n), this.liveRegion.children()
                  .hide(), n.clone ? (l = n.clone(), l.removeAttr("id")
                  .find("[id]")
                  .removeAttr("id")) : l = n, e("<div>")
                  .html(l)
                  .appendTo(this.liveRegion), this.options.track && t && /^mouse/.test(t
                  .type) ? (this._on(this.document, {
                    mousemove: o
                }), o(t)) : a.position(e.extend({
                    of: i
                }, this.options.position)), a.hide(), this._show(a, this.options
                  .show), this.options.show && this.options.show.delay && (r = this
                  .delayedShow = setInterval(() => {
                    a.is(":visible") && (o(c.of), clearInterval(r))
                }, e.fx.interval)), this._trigger("open", t, {
                    tooltip: a
                })
            }
        },
        _registerCloseHandlers(t, i) {
            const n = {
                keyup(t) {
                    if (t.keyCode === e.ui.keyCode.ESCAPE) {
                        const n = e.Event(t);
                        n.currentTarget = i[0], this.close(n, !0)
                    }
                }
            };
            i[0] !== this.element[0] && (n.remove = function () {
                this._removeTooltip(this._find(i)
                  .tooltip)
            }), t && "mouseover" !== t.type || (n.mouseleave = "close"), t &&
            "focusin" !== t.type || (n.focusout = "close"), this._on(!0, i, n)
        },
        close(t) {
            let i;
            const n = this;
            const o = e(t ? t.currentTarget : this.element);
            const s = this._find(o);
            return s ? (i = s.tooltip, s.closing || (clearInterval(this.delayedShow), o
              .data("ui-tooltip-title") && !o.attr("title") && o.attr("title", o
              .data("ui-tooltip-title")), this._removeDescribedBy(o), s
              .hiding = !0, i.stop(!0), this._hide(i, this.options.hide,
              function () {
                  n._removeTooltip(e(this))
              }), o.removeData("ui-tooltip-open"), this._off(o,
              "mouseleave focusout keyup"), o[0] !== this.element[0] && this
              ._off(o, "remove"), this._off(this.document, "mousemove"), t &&
            "mouseleave" === t.type && e.each(this.parents, (t, {element, title}) => {
                e(element)
                  .attr("title", title), delete n.parents[t]
            }), s.closing = !0, this._trigger("close", t, {
                tooltip: i
            }), s.hiding || (s.closing = !1)), void 0) : (o.removeData(
              "ui-tooltip-open"), void 0);
        },
        _tooltip(t) {
            const i = e("<div>")
                .attr("role", "tooltip")
                .addClass(`ui-tooltip ui-widget ui-corner-all ui-widget-content ${this
      .options.tooltipClass || ""}`);

            const n = i.uniqueId()
              .attr("id");

            return e("<div>")
              .addClass("ui-tooltip-content")
              .appendTo(i), i.appendTo(this.document[0].body), this.tooltips[n] = {
                element: t,
                tooltip: i
            }
        },
        _find(e) {
            const t = e.data("ui-tooltip-id");
            return t ? this.tooltips[t] : null
        },
        _removeTooltip(e) {
            e.remove(), delete this.tooltips[e.attr("id")]
        },
        _destroy() {
            const t = this;
            e.each(this.tooltips, (i, {element}) => {
                const o = e.Event("blur");
                const s = element;
                o.target = o.currentTarget = s[0], t.close(o, !0), e(`#${i}`)
                  .remove(), s.data("ui-tooltip-title") && (s.attr("title") || s
                  .attr("title", s.data("ui-tooltip-title")), s.removeData(
                  "ui-tooltip-title"))
            }), this.liveRegion.remove()
        }
    });

    /*!
       * jQuery UI Effects 1.11.4
       * http://jqueryui.com
       *
       * Copyright jQuery Foundation and other contributors
       * Released under the MIT license.
       * http://jquery.org/license
       *
       * http://api.jqueryui.com/category/effects-core/
       */
    const v = "ui-effects-";

    const b = e;
    e.effects = {
        effect: {}
    }, /*!
         * jQuery Color Animations v2.1.2
         * https://github.com/jquery/jquery-color
         *
         * Copyright 2014 jQuery Foundation and other contributors
         * Released under the MIT license.
         * http://jquery.org/license
         *
         * Date: Wed Jan 16 08:47:09 2013 -0600
         */
    ((e, t) => {
        function i(e, {type, def}, i) {
            const n = d[type] || {};
            return null == e ? i || !def ? null : def : (e = n.floor ? ~~e : parseFloat(e),
              isNaN(e) ? def : n.mod ? (e + n.mod) % n.mod : 0 > e ? 0 : n.max < e ? n
                .max : e);
        }

        function n(t) {
            const i = c();
            let n = i._rgba = [];
            return t = t.toLowerCase(), m(l, (e, o) => {
                let s;
                const a = o.re.exec(t);
                const r = a && o.parse(a);
                const l = o.space || "rgba";
                return r ? (s = i[l](r), i[u[l].cache] = s[u[l].cache], n = i._rgba = s
                  ._rgba, !1) : void 0
            }), n.length ? ("0,0,0,0" === n.join() && e.extend(n, s.transparent), i) : s[t];
        }

        function o(e, t, i) {
            return i = (i + 1) % 1, 1 > 6 * i ? e + 6 * (t - e) * i : 1 > 2 * i ? t : 2 > 3 * i ?
              e + 6 * (t - e) * (2 / 3 - i) : e
        }
        var s;

        const a =
            "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor";

        const r = /^([\-+])=\s*(\d+\.?\d*)/;

        var l = [{
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse(e) {
                return [e[1], e[2], e[3], e[4]]
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse(e) {
                return [2.55 * e[1], 2.55 * e[2], 2.55 * e[3], e[4]]
            }
        }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse(e) {
                return [parseInt(e[1], 16), parseInt(e[2], 16), parseInt(e[3], 16)]
            }
        }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse(e) {
                return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16),
                    parseInt(e[3] + e[3], 16)]
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse(e) {
                return [e[1], e[2] / 100, e[3] / 100, e[4]]
            }
        }];

        var c = e.Color = (t, i, n, o) => new e.Color.fn.parse(t, i, n, o);

        var u = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        };

        var d = {
            "byte": {
                floor: !0,
                max: 255
            },
            percent: {
                max: 1
            },
            degrees: {
                mod: 360,
                floor: !0
            }
        };

        const h = c.support = {};
        const p = e("<p>")[0];
        var m = e.each;
        p.style.cssText = "background-color:rgba(1,1,1,.5)", h.rgba = p.style.backgroundColor.includes("rgba"), m(u, (e, t) => {
            t.cache = `_${e}`, t.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            }
        }), c.fn = e.extend(c.prototype, {
            parse(o, a, r, l) {
                if (o === t) return this._rgba = [null, null, null, null], this;
                (o.jquery || o.nodeType) && (o = e(o)
                  .css(a), a = t);
                const d = this;
                let h = e.type(o);
                const p = this._rgba = [];
                return a !== t && (o = [o, a, r, l], h = "array"), "string" === h ?
                  this.parse(n(o) || s._default) : "array" === h ? (m(u.rgba.props,
                    (e, t) => {
                        p[t.idx] = i(o[t.idx], t)
                    }), this) : "object" === h ? (o instanceof c ? m(u, (e, {cache}) => {
                      o[cache] && (d[cache] = o[cache].slice())
                  }) : m(u, (t, n) => {
                      const s = n.cache;
                      m(n.props, (e, t) => {
                          if (!d[s] && n.to) {
                              if ("alpha" === e || null == o[e])
                                  return;
                              d[s] = n.to(d._rgba)
                          }
                          d[s][t.idx] = i(o[e], t, !0)
                      }), d[s] && e.inArray(null, d[s].slice(0, 3)) <
                      0 && (d[s][3] = 1, n.from && (d._rgba = n.from(d[
                        s])))
                  }), this) : void 0;
            },
            is(e) {
                const t = c(e);
                let i = !0;
                const n = this;
                return m(u, (e, o) => {
                    let s;
                    const a = t[o.cache];
                    return a && (s = n[o.cache] || o.to && o.to(n._rgba) ||
                      [], m(o.props, (e, t) => null != a[t.idx] ? i = a[t.idx] ===
                      s[t.idx] : void 0)), i;
                }), i;
            },
            _space() {
                const e = [];
                const t = this;
                return m(u, (i, {cache}) => {
                    t[cache] && e.push(i)
                }), e.pop();
            },
            transition(e, t) {
                let n = c(e);
                const o = n._space();
                const s = u[o];
                const a = 0 === this.alpha() ? c("transparent") : this;
                const r = a[s.cache] || s.to(a._rgba);
                const l = r.slice();
                return n = n[s.cache], m(s.props, (e, o) => {
                    const s = o.idx;
                    let a = r[s];
                    const c = n[s];
                    const u = d[o.type] || {};
                    null !== c && (null === a ? l[s] = c : (u.mod && (c - a >
                    u.mod / 2 ? a += u.mod : a - c > u.mod /
                      2 && (a -= u.mod)), l[s] = i((c - a) * t +
                      a, o)))
                }), this[o](l);
            },
            blend(t) {
                if (1 === this._rgba[3]) return this;
                const i = this._rgba.slice();
                const n = i.pop();

                const o = c(t)
                  ._rgba;

                return c(e.map(i, (e, t) => (1 - n) * o[t] + n * e));
            },
            toRgbaString() {
                let t = "rgba(";
                const i = e.map(this._rgba, (e, t) => null == e ? t > 2 ? 1 : 0 : e);
                return 1 === i[3] && (i.pop(), t = "rgb("), `${t + i.join()})`;
            },
            toHslaString() {
                let t = "hsla(";

                const i = e.map(this.hsla(), (e, t) => (null == e && (e = t > 2 ? 1 : 0), t && 3 > t && (
                  e = `${Math.round(100 * e)}%`), e));

                return 1 === i[3] && (i.pop(), t = "hsl("), `${t + i.join()})`;
            },
            toHexString(t) {
                const i = this._rgba.slice();
                const n = i.pop();
                return t && i.push(~~(255 * n)), `#${e.map(i, e => (e = (e || 0)
  .toString(16), 1 === e.length ? `0${e}` : e))
  .join("")}`;
            },
            toString() {
                return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
            }
        }), c.fn.parse.prototype = c.fn, u.hsla.to = e => {
            if (null == e[0] || null == e[1] || null == e[2]) return [null, null, null, e[3]];
            let t;
            let i;
            const n = e[0] / 255;
            const o = e[1] / 255;
            const s = e[2] / 255;
            const a = e[3];
            const r = Math.max(n, o, s);
            const l = Math.min(n, o, s);
            const c = r - l;
            const u = r + l;
            const d = .5 * u;
            return t = l === r ? 0 : n === r ? 60 * (o - s) / c + 360 : o === r ? 60 * (s -
              n) / c + 120 : 60 * (n - o) / c + 240, i = 0 === c ? 0 : .5 >= d ? c / u : c /
              (2 - u), [Math.round(t) % 360, i, d, null == a ? 1 : a]
        }, u.hsla.from = e => {
            if (null == e[0] || null == e[1] || null == e[2]) return [null, null, null, e[3]];
            const t = e[0] / 360;
            const i = e[1];
            const n = e[2];
            const s = e[3];
            const a = .5 >= n ? n * (1 + i) : n + i - n * i;
            const r = 2 * n - a;
            return [Math.round(255 * o(r, a, t + 1 / 3)), Math.round(255 * o(r, a, t)), Math
              .round(255 * o(r, a, t - 1 / 3)), s]
        }, m(u, (n, {props, cache, to, from}) => {
            const s = props;
            const a = cache;
            const l = to;
            const u = from;
            c.fn[n] = function (n) {
                if (l && !this[a] && (this[a] = l(this._rgba)), n === t) return this[
                  a].slice();
                let o;
                const r = e.type(n);
                const d = "array" === r || "object" === r ? n : arguments;
                const h = this[a].slice();
                return m(s, (e, t) => {
                    let n = d["object" === r ? e : t.idx];
                    null == n && (n = h[t.idx]), h[t.idx] = i(n, t)
                }), u ? (o = c(u(h)), o[a] = h, o) : c(h);
            }, m(s, (t, i) => {
                c.fn[t] || (c.fn[t] = function (o) {
                    let s;
                    let a = e.type(o);

                    const l = "alpha" === t ? this._hsla ? "hsla" : "rgba" :
                      n;

                    const c = this[l]();
                    const u = c[i.idx];
                    return "undefined" === a ? u : ("function" === a && (
                      o = o.call(this, u), a = e.type(o)),
                      null == o && i.empty ? this : ("string" ===
                      a && (s = r.exec(o), s && (o = u +
                        parseFloat(s[2]) * ("+" === s[1] ?
                          1 : -1))), c[i.idx] = o, this[l](
                        c)))
                })
            })
        }), c.hook = t => {
            const i = t.split(" ");
            m(i, (t, i) => {
                e.cssHooks[i] = {
                    set(t, o) {
                        let s;
                        let a;
                        let r = "";
                        if ("transparent" !== o && ("string" !== e.type(o) ||
                          (s = n(o)))) {
                            if (o = c(s || o), !h.rgba && 1 !== o._rgba[3]) {
                                for (a = "backgroundColor" === i ? t
                                  .parentNode : t;
                                     ("" === r || "transparent" === r) && a &&
                                     a.style;) try {
                                    r = e.css(a, "backgroundColor"), a = a
                                      .parentNode
                                } catch (l) {}
                                o = o.blend(r && "transparent" !== r ? r :
                                  "_default")
                            }
                            o = o.toRgbaString()
                        }
                        try {
                            t.style[i] = o
                        } catch (l) {}
                    }
                }, e.fx.step[i] = t => {
                    t.colorInit || (t.start = c(t.elem, i), t.end = c(t.end), t
                      .colorInit = !0), e.cssHooks[i].set(t.elem, t.start
                      .transition(t.end, t.pos))
                }
            })
        }, c.hook(a), e.cssHooks.borderColor = {
            expand(e) {
                const t = {};
                return m(["Top", "Right", "Bottom", "Left"], (i, n) => {
                    t[`border${n}Color`] = e
                }), t;
            }
        }, s = e.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [null, null, null, 0],
            _default: "#ffffff"
        }
    })(b), (() => {
        function t(t) {
            let i;
            let n;

            const o = t.ownerDocument.defaultView ? t.ownerDocument.defaultView
                .getComputedStyle(t, null) : t.currentStyle;

            const s = {};
            if (o && o.length && o[0] && o[o[0]])
                for (n = o.length; n--;) i = o[n], "string" == typeof o[i] && (s[e.camelCase(i)] =
                  o[i]);
            else
                for (i in o) "string" == typeof o[i] && (s[i] = o[i]);
            return s
        }

        function i(t, i) {
            let n;
            let s;
            const a = {};
            for (n in i) s = i[n], t[n] !== s && (o[n] || (e.fx.step[n] || !isNaN(parseFloat(
              s))) && (a[n] = s));
            return a
        }
        const n = ["add", "remove", "toggle"];

        var o = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };

        e.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"],
          (t, i) => {
              e.fx.step[i] = e => {
                  ("none" !== e.end && !e.setAttr || 1 === e.pos && !e.setAttr) && (b
                    .style(e.elem, i, e.end), e.setAttr = !0)
              }
          }), e.fn.addBack || (e.fn.addBack = function (e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }), e.effects.animateClass = function (o, s, a, r) {
            const l = e.speed(s, a, r);
            return this.queue(function () {
                let s;
                const a = e(this);
                const r = a.attr("class") || "";

                let c = l.children ? a.find("*")
                  .addBack() : a;

                c = c.map(function () {
                    const i = e(this);
                    return {
                        el: i,
                        start: t(this)
                    }
                }), s = () => {
                    e.each(n, (e, t) => {
                        o[t] && a[`${t}Class`](o[t])
                    })
                }, s(), c = c.map(function () {
                    return this.end = t(this.el[0]), this.diff = i(this.start,
                      this.end), this
                }), a.attr("class", r), c = c.map(function () {
                    const t = this;
                    const i = e.Deferred();

                    const n = e.extend({}, l, {
                        queue: !1,
                        complete() {
                            i.resolve(t)
                        }
                    });

                    return this.el.animate(this.diff, n), i.promise()
                }), e.when(...c.get())
                  .done(function(...args) {
                      s(), e.each(args, function () {
                          const t = this.el;
                          e.each(this.diff, e => {
                              t.css(e, "")
                          })
                      }), l.complete.call(a[0])
                  })
            });
        }, e.fn.extend({
            addClass: (t => (function(i, n, o, s) {
                return n ? e.effects.animateClass.call(this, {
                    add: i
                }, n, o, s) : t.apply(this, arguments)
            }))(e.fn.addClass),
            removeClass: (t => (function(i, n, o, s) {
                return arguments.length > 1 ? e.effects.animateClass.call(
                  this, {
                      remove: i
                  }, n, o, s) : t.apply(this, arguments)
            }))(e.fn.removeClass),
            toggleClass: (t => (function(i, n, o, s, a) {
                return "boolean" == typeof n || void 0 === n ? o ? e.effects
                  .animateClass.call(this, n ? {
                      add: i
                  } : {
                      remove: i
                  }, o, s, a) : t.apply(this, arguments) : e.effects
                  .animateClass.call(this, {
                      toggle: i
                  }, n, o, s)
            }))(e.fn.toggleClass),
            switchClass(t, i, n, o, s) {
                return e.effects.animateClass.call(this, {
                    add: i,
                    remove: t
                }, n, o, s)
            }
        })
    })(), (() => {
        function t(t, i, n, o) {
            return e.isPlainObject(t) && (i = t, t = t.effect), t = {
                effect: t
            }, null == i && (i = {}), e.isFunction(i) && (o = i, n = null, i = {}), (
              "number" == typeof i || e.fx.speeds[i]) && (o = n, n = i, i = {}), e
              .isFunction(n) && (o = n, n = null), i && e.extend(t, i), n = n || i.duration, t
              .duration = e.fx.off ? 0 : "number" == typeof n ? n : n in e.fx.speeds ? e.fx
              .speeds[n] : e.fx.speeds._default, t.complete = o || i.complete, t
        }

        function i(t) {
            return !t || "number" == typeof t || e.fx.speeds[t] ? !0 : "string" != typeof t || e
              .effects.effect[t] ? e.isFunction(t) ? !0 : "object" != typeof t || t.effect ? !
              1 : !0 : !0
        }
        e.extend(e.effects, {
            version: "1.11.4",
            save(e, t) {
                for (let i = 0; i < t.length; i++) null !== t[i] && e.data(v + t[i],
                  e[0].style[t[i]])
            },
            restore(e, t) {
                let i;
                let n;
                for (n = 0; n < t.length; n++) null !== t[n] && (i = e.data(v + t[n]),
                void 0 === i && (i = ""), e.css(t[n], i))
            },
            setMode(e, t) {
                return "toggle" === t && (t = e.is(":hidden") ? "show" : "hide"), t
            },
            getBaseline(e, {height, width}) {
                let i;
                let n;
                switch (e[0]) {
                    case "top":
                        i = 0;
                        break;
                    case "middle":
                        i = .5;
                        break;
                    case "bottom":
                        i = 1;
                        break;
                    default:
                        i = e[0] / height
                }
                switch (e[1]) {
                    case "left":
                        n = 0;
                        break;
                    case "center":
                        n = .5;
                        break;
                    case "right":
                        n = 1;
                        break;
                    default:
                        n = e[1] / width
                }
                return {
                    x: n,
                    y: i
                }
            },
            createWrapper(t) {
                if (t.parent()
                  .is(".ui-effects-wrapper")) return t.parent();

                const i = {
                      width: t.outerWidth(!0),
                      height: t.outerHeight(!0),
                      "float": t.css("float")
                  };

                let n = e("<div></div>")
                  .addClass("ui-effects-wrapper")
                  .css({
                      fontSize: "100%",
                      background: "transparent",
                      border: "none",
                      margin: 0,
                      padding: 0
                  });

                const o = {
                    width: t.width(),
                    height: t.height()
                };

                let s = document.activeElement;
                try {
                    s.id
                } catch (a) {
                    s = document.body
                }
                return t.wrap(n), (t[0] === s || e.contains(t[0], s)) && e(s)
                  .focus(), n = t.parent(), "static" === t.css("position") ? (n
                  .css({
                      position: "relative"
                  }), t.css({
                    position: "relative"
                })) : (e.extend(i, {
                    position: t.css("position"),
                    zIndex: t.css("z-index")
                }), e.each(["top", "left", "bottom", "right"], (e, n) => {
                    i[n] = t.css(n), isNaN(parseInt(i[n], 10)) && (i[n] =
                      "auto")
                }), t.css({
                    position: "relative",
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                })), t.css(o), n.css(i)
                  .show();
            },
            removeWrapper(t) {
                const i = document.activeElement;
                return t.parent()
                  .is(".ui-effects-wrapper") && (t.parent()
                  .replaceWith(t), (t[0] === i || e.contains(t[0], i)) && e(i)
                  .focus()), t
            },
            setTransition(t, i, n, o) {
                return o = o || {}, e.each(i, (e, i) => {
                    const s = t.cssUnit(i);
                    s[0] > 0 && (o[i] = s[0] * n + s[1])
                }), o;
            }
        }), e.fn.extend({
            effect(...args) {
                function i(t) {
                    function i() {
                        e.isFunction(s) && s.call(o[0]), e.isFunction(t) && t()
                    }
                    var o = e(this);
                    var s = n.complete;
                    const r = n.mode;
                    (o.is(":hidden") ? "hide" === r : "show" === r) ? (o[r](), i()) :
                      a.call(o[0], n, i)
                }
                var n = t.apply(this, args);
                const o = n.mode;
                const s = n.queue;
                var a = e.effects.effect[n.effect];
                return e.fx.off || !a ? o ? this[o](n.duration, n.complete) : this
                  .each(function () {
                      n.complete && n.complete.call(this)
                  }) : s === !1 ? this.each(i) : this.queue(s || "fx", i)
            },
            show: (e => (function(n) {
                if (i(n)) return e.apply(this, arguments);
                const o = t.apply(this, arguments);
                return o.mode = "show", this.effect.call(this, o)
            }))(e.fn.show),
            hide: (e => (function(n) {
                if (i(n)) return e.apply(this, arguments);
                const o = t.apply(this, arguments);
                return o.mode = "hide", this.effect.call(this, o)
            }))(e.fn.hide),
            toggle: (e => (function(n) {
                if (i(n) || "boolean" == typeof n) return e.apply(this,
                  arguments);
                const o = t.apply(this, arguments);
                return o.mode = "toggle", this.effect.call(this, o)
            }))(e.fn.toggle),
            cssUnit(t) {
                const i = this.css(t);
                let n = [];
                return e.each(["em", "px", "%", "pt"], (e, t) => {
                    i.indexOf(t) > 0 && (n = [parseFloat(i), t])
                }), n;
            }
        })
    })(), (() => {
        const t = {};
        e.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], (e, i) => {
            t[i] = t => t ** (e + 2)
        }), e.extend(t, {
            Sine(e) {
                return 1 - Math.cos(e * Math.PI / 2)
            },
            Circ(e) {
                return 1 - Math.sqrt(1 - e * e)
            },
            Elastic(e) {
                return 0 === e || 1 === e ? e : -(2 ** (8 * (e - 1))) * Math.sin((
                  80 * (e - 1) - 7.5) * Math.PI / 15);
            },
            Back(e) {
                return e * e * (3 * e - 2)
            },
            Bounce(e) {
                for (var t, i = 4; e < ((t = 2 ** --i) - 1) / 11;);
                return 1 / 4 ** (3 - i) - 7.5625 * ((3 * t - 2) / 22 - e) ** 2;
            }
        }), e.each(t, (t, i) => {
            e.easing[`easeIn${t}`] = i, e.easing[`easeOut${t}`] = e => 1 - i(1 - e), e.easing[`easeInOut${t}`] = e => .5 > e ? i(2 * e) / 2 : 1 - i(-2 * e + 2) / 2
        })
    })(), e.effects, e.effects.effect.blind = function({mode, direction, duration, easing}, i) {
        let n;
        let o;
        let s;
        const a = e(this);
        const r = /up|down|vertical/;
        const l = /up|left|vertical|horizontal/;
        const c = ["position", "top", "bottom", "left", "right", "height", "width"];
        const u = e.effects.setMode(a, mode || "hide");
        const d = direction || "up";
        const h = r.test(d);
        const p = h ? "height" : "width";
        const m = h ? "top" : "left";
        const f = l.test(d);
        const _ = {};
        const g = "show" === u;
        a.parent()
          .is(".ui-effects-wrapper") ? e.effects.save(a.parent(), c) : e.effects.save(a, c), a
          .show(), n = e.effects.createWrapper(a)
          .css({
              overflow: "hidden"
          }), o = n[p](), s = parseFloat(n.css(m)) || 0, _[p] = g ? o : 0, f || (a.css(h ?
          "bottom" : "right", 0)
          .css(h ? "top" : "left", "auto")
          .css({
              position: "absolute"
          }), _[m] = g ? s : o + s), g && (n.css(p, 0), f || n.css(m, s + o)), n.animate(
          _, {
              duration: duration,
              easing: easing,
              queue: !1,
              complete() {
                  "hide" === u && a.hide(), e.effects.restore(a, c), e.effects
                    .removeWrapper(a), i()
              }
          })
    }, e.effects.effect.bounce = function (t, i) {
        let n;
        let o;
        let s;
        const a = e(this);
        const r = ["position", "top", "bottom", "left", "right", "height", "width"];
        const l = e.effects.setMode(a, t.mode || "effect");
        const c = "hide" === l;
        const u = "show" === l;
        const d = t.direction || "up";
        let h = t.distance;
        const p = t.times || 5;
        const m = 2 * p + (u || c ? 1 : 0);
        const f = t.duration / m;
        const _ = t.easing;
        const g = "up" === d || "down" === d ? "top" : "left";
        const v = "up" === d || "left" === d;
        const b = a.queue();
        const y = b.length;
        for ((u || c) && r.push("opacity"), e.effects.save(a, r), a.show(), e.effects
          .createWrapper(a), h || (h = a["top" === g ? "outerHeight" : "outerWidth"]() / 3),
             u && (s = {
                 opacity: 1
             }, s[g] = 0, a.css("opacity", 0)
               .css(g, v ? 2 * -h : 2 * h)
               .animate(s, f, _)), c && (h /= 2 ** (p - 1)), s = {}, s[g] = 0, n = 0; p >
             n; n++) o = {}, o[g] = (v ? "-=" : "+=") + h, a.animate(o, f, _)
          .animate(s, f, _), h = c ? 2 * h : h / 2;
        c && (o = {
            opacity: 0
        }, o[g] = (v ? "-=" : "+=") + h, a.animate(o, f, _)), a.queue(() => {
            c && a.hide(), e.effects.restore(a, r), e.effects.removeWrapper(a), i()
        }), y > 1 && b.splice(...[1, 0].concat(b.splice(y, m + 1))), a.dequeue()
    }, e.effects.effect.clip = function({mode, direction, duration, easing}, i) {
        let n;
        let o;
        let s;
        const a = e(this);
        const r = ["position", "top", "bottom", "left", "right", "height", "width"];
        const l = e.effects.setMode(a, mode || "hide");
        const c = "show" === l;
        const u = direction || "vertical";
        const d = "vertical" === u;
        const h = d ? "height" : "width";
        const p = d ? "top" : "left";
        const m = {};
        e.effects.save(a, r), a.show(), n = e.effects.createWrapper(a)
          .css({
              overflow: "hidden"
          }), o = "IMG" === a[0].tagName ? n : a, s = o[h](), c && (o.css(h, 0), o.css(p, s /
          2)), m[h] = c ? s : 0, m[p] = c ? 0 : s / 2, o.animate(m, {
            queue: !1,
            duration: duration,
            easing: easing,
            complete() {
                c || a.hide(), e.effects.restore(a, r), e.effects.removeWrapper(a),
                  i()
            }
        })
    }, e.effects.effect.drop = function (t, i) {
        let n;
        const o = e(this);
        const s = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"];
        const a = e.effects.setMode(o, t.mode || "hide");
        const r = "show" === a;
        const l = t.direction || "left";
        const c = "up" === l || "down" === l ? "top" : "left";
        const u = "up" === l || "left" === l ? "pos" : "neg";

        const d = {
            opacity: r ? 1 : 0
        };

        e.effects.save(o, s), o.show(), e.effects.createWrapper(o), n = t.distance || o["top" ===
        c ? "outerHeight" : "outerWidth"](!0) / 2, r && o.css("opacity", 0)
          .css(c, "pos" === u ? -n : n), d[c] = (r ? "pos" === u ? "+=" : "-=" : "pos" === u ?
          "-=" : "+=") + n, o.animate(d, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete() {
                "hide" === a && o.hide(), e.effects.restore(o, s), e.effects
                  .removeWrapper(o), i()
            }
        })
    }, e.effects.effect.explode = function({pieces, mode, duration, easing}, i) {
        function n() {
            b.push(this), b.length === d * h && o()
        }

        function o() {
            p.css({
                visibility: "visible"
            }), e(b)
              .remove(), f || p.hide(), i()
        }
        let s;
        let a;
        let r;
        let l;
        let c;
        let u;
        var d = pieces ? Math.round(Math.sqrt(pieces)) : 3;
        var h = d;
        var p = e(this);
        const m = e.effects.setMode(p, mode || "hide");
        var f = "show" === m;

        const _ = p.show()
          .css("visibility", "hidden")
          .offset();

        const g = Math.ceil(p.outerWidth() / h);
        const v = Math.ceil(p.outerHeight() / d);
        var b = [];
        for (s = 0; d > s; s++)
            for (l = _.top + s * v, u = s - (d - 1) / 2, a = 0; h > a; a++) r = _.left + a * g,
              c = a - (h - 1) / 2, p.clone()
              .appendTo("body")
              .wrap("<div></div>")
              .css({
                  position: "absolute",
                  visibility: "visible",
                  left: -a * g,
                  top: -s * v
              })
              .parent()
              .addClass("ui-effects-explode")
              .css({
                  position: "absolute",
                  overflow: "hidden",
                  width: g,
                  height: v,
                  left: r + (f ? c * g : 0),
                  top: l + (f ? u * v : 0),
                  opacity: f ? 0 : 1
              })
              .animate({
                  left: r + (f ? 0 : c * g),
                  top: l + (f ? 0 : u * v),
                  opacity: f ? 1 : 0
              }, duration || 500, easing, n)
    }, e.effects.effect.fade = function({mode, duration, easing}, i) {
        const n = e(this);
        const o = e.effects.setMode(n, mode || "toggle");
        n.animate({
            opacity: o
        }, {
            queue: !1,
            duration: duration,
            easing: easing,
            complete: i
        })
    }, e.effects.effect.fold = function (t, i) {
        let n;
        let o;
        const s = e(this);
        const a = ["position", "top", "bottom", "left", "right", "height", "width"];
        const r = e.effects.setMode(s, t.mode || "hide");
        const l = "show" === r;
        const c = "hide" === r;
        let u = t.size || 15;
        const d = /([0-9]+)%/.exec(u);
        const h = !!t.horizFirst;
        const p = l !== h;
        const m = p ? ["width", "height"] : ["height", "width"];
        const f = t.duration / 2;
        const _ = {};
        const g = {};
        e.effects.save(s, a), s.show(), n = e.effects.createWrapper(s)
          .css({
              overflow: "hidden"
          }), o = p ? [n.width(), n.height()] : [n.height(), n.width()], d && (u = parseInt(d[
          1], 10) / 100 * o[c ? 0 : 1]), l && n.css(h ? {
            height: 0,
            width: u
        } : {
            height: u,
            width: 0
        }), _[m[0]] = l ? o[0] : u, g[m[1]] = l ? o[1] : 0, n.animate(_, f, t.easing)
          .animate(g, f, t.easing, () => {
              c && s.hide(), e.effects.restore(s, a), e.effects.removeWrapper(s), i()
          })
    }, e.effects.effect.highlight = function({mode, color, duration, easing}, i) {
        const n = e(this);
        const o = ["backgroundImage", "backgroundColor", "opacity"];
        const s = e.effects.setMode(n, mode || "show");

        const a = {
            backgroundColor: n.css("backgroundColor")
        };

        "hide" === s && (a.opacity = 0), e.effects.save(n, o), n.show()
          .css({
              backgroundImage: "none",
              backgroundColor: color || "#ffff99"
          })
          .animate(a, {
              queue: !1,
              duration: duration,
              easing: easing,
              complete() {
                  "hide" === s && n.hide(), e.effects.restore(n, o), i()
              }
          })
    }, e.effects.effect.size = function (t, i) {
        let n;
        let o;
        let s;
        const a = e(this);

        const r = ["position", "top", "bottom", "left", "right", "width", "height", "overflow",
            "opacity"];

        const l = ["position", "top", "bottom", "left", "right", "overflow", "opacity"];
        let c = ["width", "height", "overflow"];
        const u = ["fontSize"];
        let d = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
        let h = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"];
        const p = e.effects.setMode(a, t.mode || "effect");
        const m = t.restore || "effect" !== p;
        const f = t.scale || "both";
        const _ = t.origin || ["middle", "center"];
        const g = a.css("position");
        let v = m ? r : l;

        const b = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        };

        "show" === p && a.show(), n = {
            height: a.height(),
            width: a.width(),
            outerHeight: a.outerHeight(),
            outerWidth: a.outerWidth()
        }, "toggle" === t.mode && "show" === p ? (a.from = t.to || b, a.to = t.from || n) : (a
          .from = t.from || ("show" === p ? b : n), a.to = t.to || ("hide" === p ? b : n)),
          s = {
              from: {
                  y: a.from.height / n.height,
                  x: a.from.width / n.width
              },
              to: {
                  y: a.to.height / n.height,
                  x: a.to.width / n.width
              }
          }, ("box" === f || "both" === f) && (s.from.y !== s.to.y && (v = v.concat(d), a.from =
          e.effects.setTransition(a, d, s.from.y, a.from), a.to = e.effects
          .setTransition(a, d, s.to.y, a.to)), s.from.x !== s.to.x && (v = v.concat(h),
          a.from = e.effects.setTransition(a, h, s.from.x, a.from), a.to = e.effects
          .setTransition(a, h, s.to.x, a.to))), ("content" === f || "both" === f) && s.from
          .y !== s.to.y && (v = v.concat(u)
          .concat(c), a.from = e.effects.setTransition(a, u, s.from.y, a.from), a.to = e
          .effects.setTransition(a, u, s.to.y, a.to)), e.effects.save(a, v), a.show(), e
          .effects.createWrapper(a), a.css("overflow", "hidden")
          .css(a.from), _ && (o = e.effects.getBaseline(_, n), a.from.top = (n.outerHeight - a
          .outerHeight()) * o.y, a.from.left = (n.outerWidth - a.outerWidth()) * o.x, a
          .to.top = (n.outerHeight - a.to.outerHeight) * o.y, a.to.left = (n.outerWidth - a
          .to.outerWidth) * o.x), a.css(a.from), ("content" === f || "both" === f) && (
          d = d.concat(["marginTop", "marginBottom"])
            .concat(u), h = h.concat(["marginLeft", "marginRight"]), c = r.concat(d)
            .concat(h), a.find("*[width]")
            .each(function () {
              const i = e(this);

              const n = {
                  height: i.height(),
                  width: i.width(),
                  outerHeight: i.outerHeight(),
                  outerWidth: i.outerWidth()
              };

              m && e.effects.save(i, c), i.from = {
                  height: n.height * s.from.y,
                  width: n.width * s.from.x,
                  outerHeight: n.outerHeight * s.from.y,
                  outerWidth: n.outerWidth * s.from.x
              }, i.to = {
                  height: n.height * s.to.y,
                  width: n.width * s.to.x,
                  outerHeight: n.height * s.to.y,
                  outerWidth: n.width * s.to.x
              }, s.from.y !== s.to.y && (i.from = e.effects.setTransition(i, d, s
                .from.y, i.from), i.to = e.effects.setTransition(i, d, s.to.y,
                i.to)), s.from.x !== s.to.x && (i.from = e.effects.setTransition(
                i, h, s.from.x, i.from), i.to = e.effects.setTransition(i, h,
                s.to.x, i.to)), i.css(i.from), i.animate(i.to, t.duration, t
                  .easing,
                () => {
                    m && e.effects.restore(i, c)
                })
          })), a.animate(a.to, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete() {
                0 === a.to.opacity && a.css("opacity", a.from.opacity), "hide" ===
                p && a.hide(), e.effects.restore(a, v), m || ("static" === g ? a
                  .css({
                      position: "relative",
                      top: a.to.top,
                      left: a.to.left
                  }) : e.each(["top", "left"], (e, t) => {
                    a.css(t, (t, i) => {
                        const n = parseInt(i, 10);
                        const o = e ? a.to.left : a.to.top;
                        return "auto" === i ? `${o}px` : `${n + o}px`;
                    })
                })), e.effects.removeWrapper(a), i()
            }
        })
    }, e.effects.effect.scale = function (t, i) {
        const n = e(this);
        const o = e.extend(!0, {}, t);
        const s = e.effects.setMode(n, t.mode || "effect");

        const a = parseInt(t.percent, 10) || (0 === parseInt(t.percent, 10) ? 0 : "hide" === s ? 0 :
          100);

        const r = t.direction || "both";
        const l = t.origin;

        const c = {
            height: n.height(),
            width: n.width(),
            outerHeight: n.outerHeight(),
            outerWidth: n.outerWidth()
        };

        const u = {
            y: "horizontal" !== r ? a / 100 : 1,
            x: "vertical" !== r ? a / 100 : 1
        };

        o.effect = "size", o.queue = !1, o.complete = i, "effect" !== s && (o.origin = l || [
            "middle", "center"], o.restore = !0), o.from = t.from || ("show" === s ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : c), o.to = {
            height: c.height * u.y,
            width: c.width * u.x,
            outerHeight: c.outerHeight * u.y,
            outerWidth: c.outerWidth * u.x
        }, o.fade && ("show" === s && (o.from.opacity = 0, o.to.opacity = 1), "hide" === s &&
        (o.from.opacity = 1, o.to.opacity = 0)), n.effect(o)
    }, e.effects.effect.puff = function (t, i) {
        const n = e(this);
        const o = e.effects.setMode(n, t.mode || "hide");
        const s = "hide" === o;
        const a = parseInt(t.percent, 10) || 150;
        const r = a / 100;

        const l = {
            height: n.height(),
            width: n.width(),
            outerHeight: n.outerHeight(),
            outerWidth: n.outerWidth()
        };

        e.extend(t, {
            effect: "scale",
            queue: !1,
            fade: !0,
            mode: o,
            complete: i,
            percent: s ? a : 100,
            from: s ? l : {
                height: l.height * r,
                width: l.width * r,
                outerHeight: l.outerHeight * r,
                outerWidth: l.outerWidth * r
            }
        }), n.effect(t)
    }, e.effects.effect.pulsate = function({mode, times, duration, easing}, i) {
        let n;
        const o = e(this);
        const s = e.effects.setMode(o, mode || "show");
        const a = "show" === s;
        const r = "hide" === s;
        const l = a || "hide" === s;
        const c = 2 * (times || 5) + (l ? 1 : 0);
        const u = duration / c;
        let d = 0;
        const h = o.queue();
        const p = h.length;
        for ((a || !o.is(":visible")) && (o.css("opacity", 0)
          .show(), d = 1), n = 1; c > n; n++) o.animate({
            opacity: d
        }, u, easing), d = 1 - d;
        o.animate({
            opacity: d
        }, u, easing), o.queue(() => {
            r && o.hide(), i()
        }), p > 1 && h.splice(...[1, 0].concat(h.splice(p, c + 1))), o.dequeue()
    }, e.effects.effect.shake = function (t, i) {
        let n;
        const o = e(this);
        const s = ["position", "top", "bottom", "left", "right", "height", "width"];
        const a = e.effects.setMode(o, t.mode || "effect");
        const r = t.direction || "left";
        const l = t.distance || 20;
        const c = t.times || 3;
        const u = 2 * c + 1;
        const d = Math.round(t.duration / u);
        const h = "up" === r || "down" === r ? "top" : "left";
        const p = "up" === r || "left" === r;
        const m = {};
        const f = {};
        const _ = {};
        const g = o.queue();
        const v = g.length;
        for (e.effects.save(o, s), o.show(), e.effects.createWrapper(o), m[h] = (p ? "-=" :
          "+=") + l, f[h] = (p ? "+=" : "-=") + 2 * l, _[h] = (p ? "-=" : "+=") + 2 * l, o
          .animate(m, d, t.easing), n = 1; c > n; n++) o.animate(f, d, t.easing)
          .animate(_, d, t.easing);
        o.animate(f, d, t.easing)
          .animate(m, d / 2, t.easing)
          .queue(() => {
              "hide" === a && o.hide(), e.effects.restore(o, s), e.effects.removeWrapper(o),
                i()
          }), v > 1 && g.splice(...[1, 0].concat(g.splice(v, u + 1))), o.dequeue()
    }, e.effects.effect.slide = function (t, i) {
        let n;
        const o = e(this);
        const s = ["position", "top", "bottom", "left", "right", "width", "height"];
        const a = e.effects.setMode(o, t.mode || "show");
        const r = "show" === a;
        const l = t.direction || "left";
        const c = "up" === l || "down" === l ? "top" : "left";
        const u = "up" === l || "left" === l;
        const d = {};
        e.effects.save(o, s), o.show(), n = t.distance || o["top" === c ? "outerHeight" :
          "outerWidth"](!0), e.effects.createWrapper(o)
          .css({
              overflow: "hidden"
          }), r && o.css(c, u ? isNaN(n) ? `-${n}` : -n : n), d[c] = (r ? u ? "+=" : "-=" : u ?
          "-=" : "+=") + n, o.animate(d, {
            queue: !1,
            duration: t.duration,
            easing: t.easing,
            complete() {
                "hide" === a && o.hide(), e.effects.restore(o, s), e.effects
                  .removeWrapper(o), i()
            }
        })
    }, e.effects.effect.transfer = function({to, className, duration, easing}, i) {
        const n = e(this);
        const o = e(to);
        const s = "fixed" === o.css("position");
        const a = e("body");
        const r = s ? a.scrollTop() : 0;
        const l = s ? a.scrollLeft() : 0;
        const c = o.offset();

        const u = {
            top: c.top - r,
            left: c.left - l,
            height: o.innerHeight(),
            width: o.innerWidth()
        };

        const d = n.offset();

        const h = e("<div class='ui-effects-transfer'></div>")
          .appendTo(document.body)
          .addClass(className)
          .css({
              top: d.top - r,
              left: d.left - l,
              height: n.innerHeight(),
              width: n.innerWidth(),
              position: s ? "fixed" : "absolute"
          })
          .animate(u, duration, easing, () => {
              h.remove(), i()
          });
    }
}), ((e, t) => {
    e.rails !== t && e.error("jquery-ujs has already been loaded!");
    let i;
    e.rails = i = {
        linkClickSelector: "a[data-confirm], a[data-method], a[data-remote], a[data-disable-with]",
        buttonClickSelector: "button[data-remote]",
        inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
        formSubmitSelector: "form",
        formInputClickSelector: "form input[type=submit], form input[type=image], form button[type=submit], form button:not([type])",
        disableSelector: "input[data-disable-with], button[data-disable-with], textarea[data-disable-with]",
        enableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled",
        requiredInputSelector: "input[name][required]:not([disabled]),textarea[name][required]:not([disabled])",
        fileInputSelector: "input[type=file]",
        linkDisableSelector: "a[data-disable-with]",
        CSRFProtection(t) {
            const i = e('meta[name="csrf-token"]')
              .attr("content");
            i && t.setRequestHeader("X-CSRF-Token", i)
        },
        fire(t, i, n) {
            const o = e.Event(i);
            return t.trigger(o, n), o.result !== !1
        },
        confirm(e) {
            return confirm(e)
        },
        ajax(t) {
            return e.ajax(t)
        },
        href(e) {
            return e.attr("href")
        },
        handleRemote(n) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            if (i.fire(n, "ajax:before")) {
                if (r = n.data("cross-domain"), l = r === t ? null : r, c = n.data(
                  "with-credentials") || null, u = n.data("type") || e.ajaxSettings && e
                  .ajaxSettings.dataType, n.is("form")) {
                    o = n.attr("method"), s = n.attr("action"), a = n.serializeArray();
                    const h = n.data("ujs:submit-button");
                    h && (a.push(h), n.data("ujs:submit-button", null))
                } else n.is(i.inputChangeSelector) ? (o = n.data("method"), s = n.data("url"), a =
                  n.serialize(), n.data("params") && (a = `${a}&${n.data("params")}`)) : n
                  .is(i.buttonClickSelector) ? (o = n.data("method") || "get", s = n.data(
                  "url"), a = n.serialize(), n.data("params") && (a = `${a}&${n.data(
  "params")}`)) : (o = n.data("method"), s = i.href(n), a = n.data(
                  "params") || null);
                d = {
                    type: o || "GET",
                    data: a,
                    dataType: u,
                    beforeSend(e, o) {
                        return o.dataType === t && e.setRequestHeader("accept",
                          `*/*;q=0.5, ${o.accepts.script}`), i.fire(n,
                          "ajax:beforeSend", [e, o]);
                    },
                    success(e, t, i) {
                        n.trigger("ajax:success", [e, t, i])
                    },
                    complete(e, t) {
                        n.trigger("ajax:complete", [e, t])
                    },
                    error(e, t, i) {
                        n.trigger("ajax:error", [e, t, i])
                    },
                    crossDomain: l
                }, c && (d.xhrFields = {
                    withCredentials: c
                }), s && (d.url = s);
                const p = i.ajax(d);
                return n.trigger("ajax:send", p), p
            }
            return !1
        },
        handleMethod(n) {
            const o = i.href(n);
            const s = n.data("method");
            const a = n.attr("target");

            const r = e("meta[name=csrf-token]")
              .attr("content");

            const l = e("meta[name=csrf-param]")
              .attr("content");

            const c = e(`<form method="post" action="${o}"></form>`);
            let u = `<input name="_method" value="${s}" type="hidden" />`;
            l !== t && r !== t && (u += `<input name="${l}" value="${r}" type="hidden" />`), a && c.attr("target", a), c.hide()
              .append(u)
              .appendTo("body"), c.submit()
        },
        disableFormElements(t) {
            t.find(i.disableSelector)
              .each(function () {
                const t = e(this);
                const i = t.is("button") ? "html" : "val";
                t.data("ujs:enable-with", t[i]()), t[i](t.data("disable-with")), t.prop(
                  "disabled", !0)
            })
        },
        enableFormElements(t) {
            t.find(i.enableSelector)
              .each(function () {
                const t = e(this);
                const i = t.is("button") ? "html" : "val";
                t.data("ujs:enable-with") && t[i](t.data("ujs:enable-with")), t.prop(
                  "disabled", !1)
            })
        },
        allowAction(e) {
            let t;
            const n = e.data("confirm");
            let o = !1;
            return n ? (i.fire(e, "confirm") && (o = i.confirm(n), t = i.fire(e,
              "confirm:complete", [o])), o && t) : !0
        },
        blankInputs(t, i, n) {
            let o;
            let s;
            let a = e();
            const r = i || "input,textarea";
            const l = t.find(r);
            return l.each(function () {
                if (o = e(this), s = o.is("input[type=checkbox],input[type=radio]") ? o
                  .is(":checked") : o.val(), !s == !n) {
                    if (o.is("input[type=radio]") && l.filter(
                      `input[type=radio]:checked[name="${o.attr("name")}"]`)
                      .length) return !0;
                    a = a.add(o)
                }
            }), a.length ? a : !1;
        },
        nonBlankInputs(e, t) {
            return i.blankInputs(e, t, !0)
        },
        stopEverything(t) {
            return e(t.target)
              .trigger("ujs:everythingStopped"), t.stopImmediatePropagation(), !1
        },
        disableElement(e) {
            e.data("ujs:enable-with", e.html()), e.html(e.data("disable-with")), e.bind(
              "click.railsDisable",
              e => i.stopEverything(e))
        },
        enableElement(e) {
            e.data("ujs:enable-with") !== t && (e.html(e.data("ujs:enable-with")), e.removeData(
              "ujs:enable-with")), e.unbind("click.railsDisable")
        }
    }, i.fire(e(document), "rails:attachBindings") && (e.ajaxPrefilter(({crossDomain}, t, n) => {
        crossDomain || i.CSRFProtection(n)
    }), e(document)
      .delegate(i.linkDisableSelector, "ajax:complete", function () {
          i.enableElement(e(this))
      }), e(document)
      .delegate(i.linkClickSelector, "click.rails", function (n) {
        const o = e(this);
        const s = o.data("method");
        const a = o.data("params");
        if (!i.allowAction(o)) return i.stopEverything(n);
        if (o.is(i.linkDisableSelector) && i.disableElement(o), o.data("remote") !== t) {
            if (!(!n.metaKey && !n.ctrlKey || s && "GET" !== s || a)) return !0;
            const r = i.handleRemote(o);
            return r === !1 ? i.enableElement(o) : r.error(() => {
                i.enableElement(o)
            }), !1;
        }
        return o.data("method") ? (i.handleMethod(o), !1) : void 0
    }), e(document)
      .delegate(i.buttonClickSelector, "click.rails", function (t) {
          const n = e(this);
          return i.allowAction(n) ? (i.handleRemote(n), !1) : i.stopEverything(t)
      }), e(document)
      .delegate(i.inputChangeSelector, "change.rails", function (t) {
          const n = e(this);
          return i.allowAction(n) ? (i.handleRemote(n), !1) : i.stopEverything(t)
      }), e(document)
      .delegate(i.formSubmitSelector, "submit.rails", function (n) {
        const o = e(this);
        const s = o.data("remote") !== t;
        const a = i.blankInputs(o, i.requiredInputSelector);
        const r = i.nonBlankInputs(o, i.fileInputSelector);
        if (!i.allowAction(o)) return i.stopEverything(n);
        if (a && o.attr("novalidate") == t && i.fire(o, "ajax:aborted:required", [a]))
            return i.stopEverything(n);
        if (s) {
            if (r) {
                setTimeout(() => {
                    i.disableFormElements(o)
                }, 13);
                const l = i.fire(o, "ajax:aborted:file", [r]);
                return l || setTimeout(() => {
                    i.enableFormElements(o)
                }, 13), l;
            }
            return i.handleRemote(o), !1
        }
        setTimeout(() => {
            i.disableFormElements(o)
        }, 13)
    }), e(document)
      .delegate(i.formInputClickSelector, "click.rails", function (t) {
        const n = e(this);
        if (!i.allowAction(n)) return i.stopEverything(t);
        const o = n.attr("name");

        const s = o ? {
            name: o,
            value: n.val()
        } : null;

        n.closest("form")
          .data("ujs:submit-button", s)
    }), e(document)
      .delegate(i.formSubmitSelector, "ajax:beforeSend.rails", function (t) {
          this == t.target && i.disableFormElements(e(this))
      }), e(document)
      .delegate(i.formSubmitSelector, "ajax:complete.rails", function (t) {
          this == t.target && i.enableFormElements(e(this))
      }), e(() => {
        const t = e("meta[name=csrf-token]")
            .attr("content");

        const i = e("meta[name=csrf-param]")
          .attr("content");

        e(`form input[name="${i}"]`)
          .val(t)
    }))
})(jQuery), /**!
 * TableSorter 2.15.14 - Client-side table sorting with ease!
 * @requires jQuery v1.2.6+
 *
 * Copyright (c) 2007 Christian Bach
 * Examples and docs at: http://tablesorter.com
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * @type jQuery
 * @name tablesorter
 * @cat Plugins/Tablesorter
 * @author Christian Bach/christian.bach@polyester.se
 * @contributor Rob Garrison/https://github.com/Mottie/tablesorter
 */
!(e => {
    e.extend({
        tablesorter: new (function() {
            function t(...args) {
                const e = args[0];
                const t = args.length > 1 ? Array.prototype.slice.call(args) : e;
                "undefined" != typeof console && "undefined" != typeof console.log ? console[
                    /error/i.test(e) ? "error" : /warn/i.test(e) ? "warn" : "log"](t) :
                  alert(t)
            }

            function i(e, i) {
                t(`${e} (${(new Date)
  .getTime() - i.getTime()}ms)`)
            }

            function n(e) {
                for (const t in e) return !1;
                return !0
            }

            function o(t, i, n) {
                if (!i) return "";
                const o = t.config;
                const s = o.textExtraction;
                let a = "";
                return a = "simple" === s ? o.supportsTextContent ? i.textContent : e(i)
                  .text() : "function" == typeof s ? s(i, t, n) : "object" == typeof s && s
                  .hasOwnProperty(n) ? s[n](i, t, n) : o.supportsTextContent ? i
                  .textContent : e(i)
                  .text(), e.trim(a)
            }

            function s(e, i, n, s) {
                for (var a, r = x.parsers.length, l = !1, c = "", u = !0;
                     "" === c && u;) n++, i[n] ? (l = i[n].cells[s], c = o(e, l, s), e.config
                  .debug && t(`Checking if value was empty on row ${n}, column: ${s}: "${c}"`)) : u = !1;
                for (; --r >= 0;)
                    if (a = x.parsers[r], a && "text" !== a.id && a.is && a.is(c, e, l))
                        return a;
                return x.getParserById("text")
            }

            function a(e) {
                let n;
                let o;
                let a;
                let r;
                let l;
                let c;
                let u;
                let d;
                const h = e.config;
                const p = h.$tbodies = h.$table.children(`tbody:not(.${h.cssInfoBlock})`);
                let m = "";
                if (0 === p.length) return h.debug ? t(
                  "Warning: *Empty table!* Not building a parser cache") : "";
                if (h.debug && (d = new Date, t("Detecting parsers for each column")), n = p[
                  0].rows, n[0])
                    for (o = [], a = n[0].cells.length, r = 0; a > r; r++) l = h.$headers
                      .filter(":not([colspan])"), l = l.add(h.$headers.filter(
                      '[colspan="1"]'))
                      .filter(`[data-column="${r}"]:last`), c = h.headers[r], u = x
                      .getParserById(x.getData(l, c, "sorter")), h.empties[r] = x.getData(l,
                      c, "empty") || h.emptyTo || (h.emptyToBottom ? "bottom" : "top"),
                      h.strings[r] = x.getData(l, c, "string") || h.stringTo || "max", u ||
                    (u = s(e, n, -1, r)), h.debug && (m += `column:${r}; parser:${u
    .id}; string:${h.strings[r]}; empty: ${h.empties[r]}\n`), o.push(u);
                h.debug && (t(m), i("Completed detecting parsers", d)), h.parsers = o
            }

            function r(n) {
                let s;
                let a;
                let r;
                let l;
                let c;
                let u;
                let d;
                let h;
                let p;
                let m;
                const f = n.tBodies;
                const _ = n.config;
                const g = _.parsers;
                const v = [];
                if (_.cache = {}, !g) return _.debug ? t(
                  "Warning: *Empty table!* Not building a cache") : "";
                for (_.debug && (m = new Date), _.showProcessing && x.isProcessing(n, !0), d =
                  0; d < f.length; d++)
                    if (_.cache[d] = {
                        row: [],
                        normalized: []
                    }, !e(f[d])
                      .hasClass(_.cssInfoBlock)) {
                        for (s = f[d] && f[d].rows.length || 0, a = f[d].rows[0] && f[d].rows[
                          0].cells.length || 0, c = 0; s > c; ++c)
                            if (h = e(f[d].rows[c]), p = [], h.hasClass(_.cssChildRow) &&
                            0 !== c) _.cache[d].row[_.cache[d].row.length - 1] = _.cache[
                              d].row[_.cache[d].row.length - 1].add(h), h.prev()
                              .hasClass(_.cssChildRow) || h.prev()
                              .addClass(x.css.cssHasChild);
                            else {
                                for (_.cache[d].row.push(h), u = 0; a > u; ++u) "undefined" !=
                                typeof g[u] ? (r = o(n, h[0].cells[u], u), l = g[u]
                                  .format(r, n, h[0].cells[u], u), p.push(l),
                                "numeric" === (g[u].type || "")
                                  .toLowerCase() && (v[u] = Math.max(Math.abs(l) || 0,
                                  v[u] || 0))) : _.debug && t(
                                  "No parser found for cell:", h[0].cells[u],
                                  "does it have a header?");
                                p.push(_.cache[d].normalized.length), _.cache[d].normalized
                                  .push(p)
                            } _.cache[d].colMax = v
                    }_.showProcessing && x.isProcessing(n), _.debug && i(
                      `Building cache for ${s} rows`, m)
            }

            function l(t, o) {
                let s;
                let a;
                let r;
                let l;
                let c;
                let u;
                let d;
                let h;
                let p;
                let m;
                let f;
                let _;
                const g = t.config;
                const v = g.widgetOptions;
                const b = t.tBodies;
                const y = [];
                const w = g.cache;
                if (n(w)) return g.appender ? g.appender(t, y) : t.isUpdating ? g.$table
                  .trigger("updateComplete", t) : "";
                for (g.debug && (_ = new Date), p = 0; p < b.length; p++)
                    if (c = e(b[p]), c.length && !c.hasClass(g.cssInfoBlock)) {
                        for (u = x.processTbody(t, c, !0), s = w[p].row, a = w[p].normalized,
                               r = a.length, l = r ? a[0].length - 1 : 0, d = 0; r > d; d++)
                            if (f = a[d][l], y.push(s[f]), !g.appender || g.pager && (!g.pager
                              .removeRows || !v.pager_removeRows) && !g.pager.ajax)
                                for (m = s[f].length, h = 0; m > h; h++) u.append(s[f][h]);
                        x.processTbody(t, u, !1)
                    }g.appender && g.appender(t, y), g.debug && i("Rebuilt table", _), o || g
                      .appender || x.applyWidget(t), t.isUpdating && g.$table.trigger(
                      "updateComplete", t)
            }

            function c(t) {
                let i;
                let n;
                let o;
                let s;
                let a;
                let r;
                let l;
                let c;
                let u;
                let d;
                let h;
                let p;
                const m = [];
                const f = {};
                let _ = 0;

                const g = e(t)
                  .children("thead, tfoot")
                  .children("tr");

                for (i = 0; i < g.length; i++)
                    for (r = g[i].cells, n = 0; n < r.length; n++) {
                        for (a = r[n], l = a.parentNode.rowIndex, c = `${l}-${e(a)
  .index()}`, u = a.rowSpan || 1, d = a.colSpan || 1, "undefined" ==
                        typeof m[l] && (m[l] = []), o = 0; o < m[l].length + 1; o++)
                            if ("undefined" == typeof m[l][o]) {
                                h = o;
                                break
                            } for (f[c] = h, _ = Math.max(h, _), e(a)
                          .attr({
                              "data-column": h
                          }), o = l; l + u > o; o++)
                            for ("undefined" == typeof m[o] && (m[o] = []), p = m[o], s =
                              h; h + d > s; s++) p[s] = "x"
                    }
                t.config.columns = _ + 1
            }

            function u(e) {
                return /^d/i.test(e) || 1 === e
            }

            function d(n) {
                let o;
                let s;
                let a;
                let r;
                let l;
                let d;
                let h;
                const m = n.config;
                m.headerList = [], m.headerContent = [], m.debug && (h = new Date), c(n), r =
                  m.cssIcon ? `<i class="${m.cssIcon === x.css.icon ? x.css.icon : `${m
  .cssIcon} ${x.css.icon}`}"></i>` : "", m.$headers = e(n)
                  .find(m.selectorHeaders)
                  .each(function (t) {
                      s = e(this), o = m.headers[t], m.headerContent[t] = e(this)
                        .html(), l = m.headerTemplate.replace(/\{content\}/g, e(this)
                        .html())
                        .replace(/\{icon\}/g, r), m.onRenderTemplate && (a = m
                        .onRenderTemplate.apply(s, [t, l]), a && "string" ==
                      typeof a && (l = a)), e(this)
                        .html(`<div class="${x.css.headerIn}">${l}</div>`),
                      m.onRenderHeader && m.onRenderHeader.apply(s, [t]), this
                        .column = parseInt(e(this)
                        .attr("data-column"), 10), this.order = u(x.getData(s, o,
                        "sortInitialOrder") || m.sortInitialOrder) ? [1, 0, 2] : [
                          0, 1, 2], this.count = -1, this.lockedOrder = !1, d = x
                        .getData(s, o, "lockedOrder") || !1, "undefined" !=
                      typeof d && d !== !1 && (this.order = this.lockedOrder = u(
                        d) ? [1, 1, 1] : [0, 0, 0]), s.addClass(`${x.css.header} ${m.cssHeader}`), m.headerList[t] = this, s.parent()
                        .addClass(`${x.css.headerRow} ${m.cssHeaderRow}`)
                        .attr("role", "row"), m.tabIndex && s.attr("tabindex", 0)
                  })
                  .attr({
                      scope: "col",
                      role: "columnheader"
                  }), p(n), m.debug && (i("Built headers:", h), t(m.$headers))
            }

            function h(e, t, i) {
                const n = e.config;
                n.$table.find(n.selectorRemove)
                  .remove(), a(e), r(e), w(n.$table, t, i)
            }

            function p({config, id}) {
                let i;
                let n;
                const o = config;
                o.$headers.each((s, a) => {
                    n = e(a), i = "false" === x.getData(a, o.headers[s], "sorter"), a
                      .sortDisabled = i, n[i ? "addClass" : "removeClass"](
                      "sorter-false")
                      .attr("aria-disabled", `${i}`), id && (i ? n.removeAttr(
                      "aria-controls") : n.attr("aria-controls", id))
                })
            }

            function m(t) {
                let i;
                let n;
                let o;
                let s;
                const a = t.config;
                const r = a.sortList;
                const l = `${x.css.sortNone} ${a.cssNone}`;
                const c = [`${x.css.sortAsc} ${a.cssAsc}`, `${x.css.sortDesc} ${a.cssDesc}`];
                const u = ["ascending", "descending"];

                const d = e(t)
                  .find("tfoot tr")
                  .children()
                  .removeClass(c.join(" "));

                for (a.$headers.removeClass(c.join(" "))
                       .addClass(l)
                       .attr("aria-sort", "none"), s = r.length, n = 0; s > n; n++)
                    if (2 !== r[n][1] && (i = a.$headers.not(".sorter-false")
                      .filter(`[data-column="${r[n][0]}"]${1 === s ? ":last" :
    ""}`), i.length))
                        for (o = 0; o < i.length; o++) i[o].sortDisabled || (i.eq(o)
                          .removeClass(l)
                          .addClass(c[r[n][1]])
                          .attr("aria-sort", u[r[n][1]]), d.length && d.filter(
                          `[data-column="${r[n][0]}"]`)
                          .eq(o)
                          .addClass(c[r[n][1]]));
                a.$headers.not(".sorter-false")
                  .each(function () {
                    const t = e(this);
                    const i = this.order[(this.count + 1) % (a.sortReset ? 3 : 2)];

                    const n = `${t.text()}: ${x.language[t.hasClass(x.css.sortAsc) ?
  "sortAsc" : t.hasClass(x.css.sortDesc) ? "sortDesc" :
    "sortNone"]}${x.language[0 === i ? "nextAsc" : 1 === i ?
  "nextDesc" : "nextNone"]}`;

                    t.attr("aria-label", n)
                })
            }

            function f(t) {
                if (t.config.widthFixed && 0 === e(t)
                  .find("colgroup")
                  .length) {
                    const i = e("<colgroup>");

                    const n = e(t)
                      .width();

                    e(t.tBodies[0])
                      .find("tr:first")
                      .children("td:visible")
                      .each(function () {
                          i.append(e("<col>")
                            .css("width", `${parseInt(1e3 * (e(this)
    .width() / n), 10) / 10}%`))
                      }), e(t)
                      .prepend(i)
                }
            }

            function _({config}, i) {
                let n;
                let o;
                let s;
                const a = config;
                const r = i || a.sortList;
                a.sortList = [], e.each(r, (t, i) => {
                    n = [parseInt(i[0], 10), parseInt(i[1], 10)], s = a.$headers[n[
                      0]], s && (a.sortList.push(n), o = e.inArray(n[1], s.order), s
                      .count = o >= 0 ? o : n[1] % (a.sortReset ? 3 : 2))
                })
            }

            function g(e, t) {
                return e && e[t] ? e[t].type || "" : ""
            }

            function v(t, i, n) {
                let o;
                let s;
                let a;
                let r;
                let c;
                const u = t.config;
                const d = !n[u.sortMultiSortKey];
                const h = u.$table;
                if (h.trigger("sortStart", t), i.count = n[u.sortResetKey] ? 2 : (i.count +
                  1) % (u.sortReset ? 3 : 2), u.sortRestart && (s = i, u.$headers.each(
                  function () {
                      this === s || !d && e(this)
                        .is(`.${x.css.sortDesc},.${x.css.sortAsc}`) || (this
                        .count = -1)
                  })), s = i.column, d) {
                    if (u.sortList = [], null !== u.sortForce)
                        for (o = u.sortForce, a = 0; a < o.length; a++) o[a][0] !== s && u
                          .sortList.push(o[a]);
                    if (r = i.order[i.count], 2 > r && (u.sortList.push([s, r]), i.colSpan >
                    1))
                        for (a = 1; a < i.colSpan; a++) u.sortList.push([s + a, r])
                } else {
                    if (u.sortAppend && u.sortList.length > 1)
                        for (a = 0; a < u.sortAppend.length; a++) c = x.isValueInArray(u
                          .sortAppend[a][0], u.sortList), c >= 0 && u.sortList.splice(c,
                          1);
                    if (x.isValueInArray(s, u.sortList) >= 0)
                        for (a = 0; a < u.sortList.length; a++) c = u.sortList[a], r = u
                          .$headers[c[0]], c[0] === s && (c[1] = r.order[i.count], 2 === c[
                          1] && (u.sortList.splice(a, 1), r.count = -1));
                    else if (r = i.order[i.count], 2 > r && (u.sortList.push([s, r]), i
                      .colSpan > 1))
                        for (a = 1; a < i.colSpan; a++) u.sortList.push([s + a, r])
                }
                if (null !== u.sortAppend)
                    for (o = u.sortAppend, a = 0; a < o.length; a++) o[a][0] !== s && u
                      .sortList.push(o[a]);
                h.trigger("sortBegin", t), setTimeout(() => {
                    m(t), b(t), l(t), h.trigger("sortEnd", t)
                }, 1)
            }

            function b(e) {
                let t;
                let o;
                let s;
                let a;
                let r;
                let l;
                let c;
                let u;
                let d;
                let h;
                let p;
                let m;
                let f;
                let _ = 0;
                const v = e.config;
                const b = v.textSorter || "";
                const y = v.sortList;
                const w = y.length;
                const k = e.tBodies.length;
                if (!v.serverSideSorting && !n(v.cache)) {
                    for (v.debug && (h = new Date), o = 0; k > o; o++) r = v.cache[o].colMax,
                      l = v.cache[o].normalized, c = l.length, d = l && l[0] ? l[0].length -
                      1 : 0, l.sort((i, n) => {
                        for (t = 0; w > t; t++) {
                            if (a = y[t][0], u = y[t][1], _ = 0 === u, v.sortStable &&
                            i[a] === n[a] && 1 === w) return i[d] - n[d];
                            if (s = /n/i.test(g(v.parsers, a)), s && v.strings[a] ? (
                                s = "boolean" == typeof v.string[v.strings[a]] ? (
                                  _ ? 1 : -1) * (v.string[v.strings[a]] ? -1 :
                                  1) : v.strings[a] ? v.string[v.strings[a]] ||
                                  0 : 0, p = v.numberSorter ? v.numberSorter(i[a],
                                  n[a], _, r[a], e) : x[`sortNumeric${_ ?
  "Asc" : "Desc"}`](i[a], n[a], s, r[a], a, e)) :
                              (m = _ ? i : n, f = _ ? n : i, p = "function" ==
                              typeof b ? b(m[a], f[a], _, a, e) : "object" ==
                              typeof b && b.hasOwnProperty(a) ? b[a](m[a], f[a],
                                _, a, e) : x[`sortNatural${_ ? "Asc" :
    "Desc"}`](i[a], n[a], a, e, v)), p) return p
                        }
                        return i[d] - n[d]
                    });
                    v.debug && i(`Sorting on ${y.toString()} and dir ${u} time`, h)
                }
            }

            function y(e, t) {
                const i = e[0];
                i.isUpdating && e.trigger("updateComplete"), "function" == typeof t && t(e[0])
            }

            function w(e, t, i) {
                const n = e[0].config.sortList;
                t !== !1 && !e[0].isProcessing && n.length ? e.trigger("sorton", [n,
                    () => {
                        y(e, i)
                    }, !0]) : (e.trigger("applyWidgets"), y(e, i))
            }

            function k(t) {
                const i = t.config;
                const s = i.$table;
                s.unbind(
                  "sortReset update updateRows updateCell updateAll addRows updateComplete sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup mouseleave "
                    .split(" ")
                    .join(`${i.namespace} `))
                  .bind(`sortReset${i.namespace}`, e => {
                      e.stopPropagation(), i.sortList = [], m(t), b(t), l(t)
                  })
                  .bind(`updateAll${i.namespace}`, (e, n, o) => {
                      e.stopPropagation(), t.isUpdating = !0, x.refreshWidgets(t, !0, !
                        0), x.restoreHeaders(t), d(t), x.bindEvents(t, i
                        .$headers), k(t), h(t, n, o)
                  })
                  .bind(`update${i.namespace} updateRows${i.namespace}`, (e, i, n) => {
                      e.stopPropagation(), t.isUpdating = !0, p(t), h(t, i, n)
                  })
                  .bind(`updateCell${i.namespace}`, (n, a, r, l) => {
                    n.stopPropagation(), t.isUpdating = !0, s.find(i.selectorRemove)
                      .remove();
                    let c;
                    let u;
                    let d;
                    const h = s.find("tbody");

                    const p = h.index(e(a)
                      .parents("tbody")
                      .filter(":first"));

                    const m = e(a)
                      .parents("tr")
                      .filter(":first");

                    a = e(a)[0], h.length && p >= 0 && (u = h.eq(p)
                      .find("tr")
                      .index(m), d = e(a)
                      .index(), c = i.cache[p].normalized[u].length - 1, i
                      .cache[p].row[i.cache[p].normalized[u][c]] = m, i.cache[p]
                      .normalized[u][d] = i.parsers[d].format(o(t, a, d), t, a,
                      d), w(s, r, l))
                })
                  .bind(`addRows${i.namespace}`, (e, r, l, c) => {
                      if (e.stopPropagation(), t.isUpdating = !0, n(i.cache)) p(t), h(t,
                        l, c);
                      else {
                          let u;
                          let d;

                          const m = r.filter("tr")
                              .length;

                          let f = [];
                          const _ = r[0].cells.length;

                          const g = s.find("tbody")
                            .index(r.parents("tbody")
                              .filter(":first"));

                          for (i.parsers || a(t), u = 0; m > u; u++) {
                              for (d = 0; _ > d; d++) f[d] = i.parsers[d].format(o(t, r[
                                u].cells[d], d), t, r[u].cells[d], d);
                              f.push(i.cache[g].row.length), i.cache[g].row.push([r[
                                u]]), i.cache[g].normalized.push(f), f = []
                          }
                          w(s, l, c)
                      }
                  })
                  .bind(`updateComplete${i.namespace}`, () => {
                      t.isUpdating = !1
                  })
                  .bind(`sorton${i.namespace}`, function (e, i, o, a) {
                      const c = t.config;
                      e.stopPropagation(), s.trigger("sortStart", this), _(t, i), m(t),
                      c.delayInit && n(c.cache) && r(t), s.trigger("sortBegin",
                        this), b(t), l(t, a), s.trigger("sortEnd", this)
                        .trigger("applyWidgets"), "function" == typeof o && o(t)
                  })
                  .bind(`appendCache${i.namespace}`, (e, i, n) => {
                      e.stopPropagation(), l(t, n), "function" == typeof i && i(t)
                  })
                  .bind(`updateCache${i.namespace}`, (e, n) => {
                      i.parsers || a(t), r(t), "function" == typeof n && n(t)
                  })
                  .bind(`applyWidgetId${i.namespace}`, (e, n) => {
                      e.stopPropagation(), x.getWidgetById(n)
                        .format(t, i, i.widgetOptions)
                  })
                  .bind(`applyWidgets${i.namespace}`, (e, i) => {
                      e.stopPropagation(), x.applyWidget(t, i)
                  })
                  .bind(`refreshWidgets${i.namespace}`, (e, i, n) => {
                      e.stopPropagation(), x.refreshWidgets(t, i, n)
                  })
                  .bind(`destroy${i.namespace}`, (e, i, n) => {
                      e.stopPropagation(), x.destroy(t, i, n)
                  })
            }
            var x = this;
            x.version = "2.15.14", x.parsers = [], x.widgets = [], x.defaults = {
                theme: "default",
                widthFixed: !1,
                showProcessing: !1,
                headerTemplate: "{content}",
                onRenderTemplate: null,
                onRenderHeader: null,
                cancelSelection: !0,
                tabIndex: !0,
                dateFormat: "mmddyyyy",
                sortMultiSortKey: "shiftKey",
                sortResetKey: "ctrlKey",
                usNumberFormat: !0,
                delayInit: !1,
                serverSideSorting: !1,
                headers: {},
                ignoreCase: !0,
                sortForce: null,
                sortList: [],
                sortAppend: null,
                sortStable: !1,
                sortInitialOrder: "asc",
                sortLocaleCompare: !1,
                sortReset: !1,
                sortRestart: !1,
                emptyTo: "bottom",
                stringTo: "max",
                textExtraction: "simple",
                textSorter: null,
                numberSorter: null,
                widgets: [],
                widgetOptions: {
                    zebra: ["even", "odd"]
                },
                initWidgets: !0,
                initialized: null,
                tableClass: "",
                cssAsc: "",
                cssDesc: "",
                cssNone: "",
                cssHeader: "",
                cssHeaderRow: "",
                cssProcessing: "",
                cssChildRow: "tablesorter-childRow",
                cssIcon: "tablesorter-icon",
                cssInfoBlock: "tablesorter-infoOnly",
                selectorHeaders: "> thead th, > thead td",
                selectorSort: "th, td",
                selectorRemove: ".remove-me",
                debug: !1,
                headerList: [],
                empties: {},
                strings: {},
                parsers: []
            }, x.css = {
                table: "tablesorter",
                cssHasChild: "tablesorter-hasChildRow",
                childRow: "tablesorter-childRow",
                header: "tablesorter-header",
                headerRow: "tablesorter-headerRow",
                headerIn: "tablesorter-header-inner",
                icon: "tablesorter-icon",
                info: "tablesorter-infoOnly",
                processing: "tablesorter-processing",
                sortAsc: "tablesorter-headerAsc",
                sortDesc: "tablesorter-headerDesc",
                sortNone: "tablesorter-headerUnSorted"
            }, x.language = {
                sortAsc: "Ascending sort applied, ",
                sortDesc: "Descending sort applied, ",
                sortNone: "No sort applied, ",
                nextAsc: "activate to apply an ascending sort",
                nextDesc: "activate to apply a descending sort",
                nextNone: "activate to remove the sort"
            }, x.log = t, x.benchmark = i, x.construct = function (t) {
                return this.each(function () {
                    const i = this;
                    const n = e.extend(!0, {}, x.defaults, t);
                    !i.hasInitialized && x.buildTable && "TABLE" !== this
                      .tagName ? x.buildTable(i, n) : x.setup(i, n)
                });
            }, x.setup = (i, n) => {
                if (!i || !i.tHead || 0 === i.tBodies.length || i.hasInitialized === !0)
                    return n.debug ? t(
                      "ERROR: stopping initialization! No table, thead, tbody or tablesorter has already been initialized"
                    ) : "";
                let o = "";
                const s = e(i);
                const l = e.metadata;
                i.hasInitialized = !1, i.isProcessing = !0, i.config = n, e.data(i,
                  "tablesorter", n), n.debug && e.data(i, "startoveralltimer",
                  new Date), n.supportsTextContent = "x" === e("<span>x</span>")[0]
                  .textContent, n.supportsDataObject = (e => (e[0] = parseInt(e[0], 10), e[0] > 1 || 1 === e[0] &&
                parseInt(e[1], 10) >= 4))(e.fn.jquery.split(".")), n.string = {
                    max: 1,
                    min: -1,
                    "max+": 1,
                    "max-": -1,
                    zero: 0,
                    none: 0,
                    "null": 0,
                    top: !0,
                    bottom: !1
                }, /tablesorter\-/.test(s.attr("class")) || (o = "" !== n.theme ?
                  ` tablesorter-${n.theme}` : ""), n.$table = s.addClass(`${x.css
  .table} ${n.tableClass}${o}`)
                  .attr({
                      role: "grid"
                  }), n.namespace = n.namespace ? `.${n.namespace.replace(/\W/g, "")}` :
                  `.tablesorter${Math.random()
  .toString(16)
  .slice(2)}`, n.$tbodies = s.children(`tbody:not(.${n.cssInfoBlock})`)
                  .attr({
                      "aria-live": "polite",
                      "aria-relevant": "all"
                  }), n.$table.find("caption")
                  .length && n.$table.attr("aria-labelledby", "theCaption"), n
                  .widgetInit = {}, d(i), f(i), a(i), n.delayInit || r(i), x.bindEvents(
                  i, n.$headers), k(i), n.supportsDataObject && "undefined" !=
                typeof s.data()
                  .sortlist ? n.sortList = s.data()
                  .sortlist : l && s.metadata() && s.metadata()
                  .sortlist && (n.sortList = s.metadata()
                  .sortlist), x.applyWidget(i, !0), n.sortList.length > 0 ? s
                  .trigger("sorton", [n.sortList, {}, !n.initWidgets, !0]) : (m(i), n
                  .initWidgets && x.applyWidget(i)), n.showProcessing && s.unbind(
                  `sortBegin${n.namespace} sortEnd${n.namespace}`)
                  .bind(`sortBegin${n.namespace} sortEnd${n.namespace}`, ({type}) => {
                      x.isProcessing(i, "sortBegin" === type)
                  }), i.hasInitialized = !0, i.isProcessing = !1, n.debug && x
                  .benchmark("Overall initialization time", e.data(i,
                    "startoveralltimer")), s.trigger("tablesorter-initialized", i),
                "function" == typeof n.initialized && n.initialized(i)
            }, x.isProcessing = (t, i, n) => {
                t = e(t);
                const o = t[0].config;
                let s = n || t.find(`.${x.css.header}`);
                i ? ("undefined" != typeof n && o.sortList.length > 0 && (s = s.filter(
                  function () {
                      return this.sortDisabled ? !1 : x.isValueInArray(
                        parseFloat(e(this)
                          .attr("data-column")), o.sortList) >= 0
                  })), s.addClass(`${x.css.processing} ${o.cssProcessing}`)) : s
                  .removeClass(`${x.css.processing} ${o.cssProcessing}`)
            }, x.processTbody = (t, i, n) => {
                t = e(t)[0];
                let o;
                return n ? (t.isProcessing = !0, i.before(
                  '<span class="tablesorter-savemyplace"/>'), o = e.fn.detach ?
                  i.detach() : i.remove()) : (o = e(t)
                  .find("span.tablesorter-savemyplace"), i.insertAfter(o), o
                  .remove(), t.isProcessing = !1, void 0)
            }, x.clearTableBody = t => {
                e(t)[0].config.$tbodies.empty()
            }, x.bindEvents = (t, i) => {
                t = e(t)[0];
                let o;
                const s = t.config;
                i.find(s.selectorSort)
                  .add(i.filter(s.selectorSort))
                  .unbind("mousedown mouseup sort keyup ".split(" ")
                    .join(`${s.namespace} `))
                  .bind("mousedown mouseup sort keyup ".split(" ")
                      .join(`${s.namespace} `),
                    function (a, l) {
                        let c;
                        const u = a.type;
                        if (!(1 !== (a.which || a.button) && !/sort|keyup/.test(u) ||
                          "keyup" === u && 13 !== a.which || "mouseup" === u &&
                          l !== !0 && (new Date)
                            .getTime() - o > 250)) {
                            if ("mousedown" === u) return o = (new Date)
                              .getTime(), "INPUT" === a.target.tagName ? "" : !s
                              .cancelSelection;
                            s.delayInit && n(s.cache) && r(t), c = /TH|TD/.test(this
                              .tagName) ? this : e(this)
                              .parents("th, td")[0], c = s.$headers[i.index(c)], c
                              .sortDisabled || v(t, c, a)
                        }
                    }), s.cancelSelection && i.attr("unselectable", "on")
                  .bind("selectstart", !1)
                  .css({
                      "user-select": "none",
                      MozUserSelect: "none"
                  })
            }, x.restoreHeaders = t => {
                const i = e(t)[0].config;
                i.$table.find(i.selectorHeaders)
                  .each(function (t) {
                      e(this)
                        .find(`.${x.css.headerIn}`)
                        .length && e(this)
                        .html(i.headerContent[t])
                  })
            }, x.destroy = (t, i, n) => {
                if (t = e(t)[0], t.hasInitialized) {
                    x.refreshWidgets(t, !0, !0);
                    const o = e(t);
                    const s = t.config;
                    const a = o.find("thead:first");

                    const r = a.find(`tr.${x.css.headerRow}`)
                      .removeClass(`${x.css.headerRow} ${s.cssHeaderRow}`);

                    const l = o.find("tfoot:first > tr")
                      .children("th, td");

                    i === !1 && e.inArray("uitheme", s.widgets) >= 0 && (o.trigger(
                      "applyWidgetId", ["uitheme"]), o.trigger("applyWidgetId",
                      ["zebra"])), a.find("tr")
                      .not(r)
                      .remove(), o.removeData("tablesorter")
                      .unbind(
                        "sortReset update updateAll updateRows updateCell addRows updateComplete sorton appendCache updateCache applyWidgetId applyWidgets refreshWidgets destroy mouseup mouseleave keypress sortBegin sortEnd "
                          .split(" ")
                          .join(`${s.namespace} `)), s.$headers.add(l)
                      .removeClass([x.css.header, s.cssHeader, s.cssAsc, s.cssDesc, x
                        .css.sortAsc, x.css.sortDesc, x.css.sortNone].join(" "))
                      .removeAttr("data-column")
                      .removeAttr("aria-label")
                      .attr("aria-disabled", "true"), r.find(s.selectorSort)
                      .unbind("mousedown mouseup keypress ".split(" ")
                        .join(`${s.namespace} `)), x.restoreHeaders(t), o.toggleClass(
                      `${x.css.table} ${s.tableClass} tablesorter-${s.theme}`,
                      i === !1), t.hasInitialized = !1, "function" == typeof n && n(
                      t)
                }
            }, x.regex = {
                chunk: /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
                chunks: /(^\\0|\\0$)/,
                hex: /^0x[0-9a-f]+$/i
            }, x.sortNatural = (e, t) => {
                if (e === t) return 0;
                let i;
                let n;
                let o;
                let s;
                let a;
                let r;
                let l;
                let c;
                const u = x.regex;
                if (u.hex.test(t)) {
                    if (n = parseInt(e.match(u.hex), 16), s = parseInt(t.match(u.hex),
                      16), s > n) return -1;
                    if (n > s) return 1
                }
                for (i = e.replace(u.chunk, "\\0$1\\0")
                  .replace(u.chunks, "")
                  .split("\\0"), o = t.replace(u.chunk, "\\0$1\\0")
                  .replace(u.chunks, "")
                  .split("\\0"), c = Math.max(i.length, o.length), l = 0; c > l; l++) {
                    if (a = isNaN(i[l]) ? i[l] || 0 : parseFloat(i[l]) || 0, r = isNaN(o[
                      l]) ? o[l] || 0 : parseFloat(o[l]) || 0, isNaN(a) !== isNaN(
                      r)) return isNaN(a) ? 1 : -1;
                    if (typeof a != typeof r && (a += "", r += ""), r > a) return -1;
                    if (a > r) return 1
                }
                return 0
            }, x.sortNaturalAsc = (e, t, i, n, {string, empties, emptyTo}) => {
                if (e === t) return 0;
                const s = string[empties[i] || emptyTo];
                return "" === e && 0 !== s ? "boolean" == typeof s ? s ? -1 : 1 : -s || -
                  1 : "" === t && 0 !== s ? "boolean" == typeof s ? s ? 1 : -1 : s ||
                  1 : x.sortNatural(e, t)
            }, x.sortNaturalDesc = (e, t, i, n, {string, empties, emptyTo}) => {
                if (e === t) return 0;
                const s = string[empties[i] || emptyTo];
                return "" === e && 0 !== s ? "boolean" == typeof s ? s ? -1 : 1 : s || 1 :
                  "" === t && 0 !== s ? "boolean" == typeof s ? s ? 1 : -1 : -s || -1 :
                    x.sortNatural(t, e)
            }, x.sortText = (e, t) => e > t ? 1 : t > e ? -1 : 0, x.getTextValue = (e, t, i) => {
                if (i) {
                    let n;
                    const o = e ? e.length : 0;
                    let s = i + t;
                    for (n = 0; o > n; n++) s += e.charCodeAt(n);
                    return t * s
                }
                return 0
            }, x.sortNumericAsc = (e, t, i, n, o, {config}) => {
                if (e === t) return 0;
                const a = config;
                const r = a.string[a.empties[o] || a.emptyTo];
                return "" === e && 0 !== r ? "boolean" == typeof r ? r ? -1 : 1 : -r || -
                  1 : "" === t && 0 !== r ? "boolean" == typeof r ? r ? 1 : -1 : r ||
                  1 : (isNaN(e) && (e = x.getTextValue(e, i, n)), isNaN(t) && (t = x
                  .getTextValue(t, i, n)), e - t)
            }, x.sortNumericDesc = (e, t, i, n, o, {config}) => {
                if (e === t) return 0;
                const a = config;
                const r = a.string[a.empties[o] || a.emptyTo];
                return "" === e && 0 !== r ? "boolean" == typeof r ? r ? -1 : 1 : r || 1 :
                  "" === t && 0 !== r ? "boolean" == typeof r ? r ? 1 : -1 : -r || -1 :
                    (isNaN(e) && (e = x.getTextValue(e, i, n)), isNaN(t) && (t = x
                      .getTextValue(t, i, n)), t - e)
            }, x.sortNumeric = (e, t) => e - t, x.characterEquivalents = {
                a: "áàâãäąå",
                A: "ÁÀÂÃÄĄÅ",
                c: "çćč",
                C: "ÇĆČ",
                e: "éèêëěę",
                E: "ÉÈÊËĚĘ",
                i: "íìİîïı",
                I: "ÍÌİÎÏ",
                o: "óòôõö",
                O: "ÓÒÔÕÖ",
                ss: "ß",
                SS: "ẞ",
                u: "úùûüů",
                U: "ÚÙÛÜŮ"
            }, x.replaceAccents = e => {
                let t;
                let i = "[";
                const n = x.characterEquivalents;
                if (!x.characterRegex) {
                    x.characterRegexArray = {};
                    for (t in n) "string" == typeof t && (i += n[t], x
                      .characterRegexArray[t] = new RegExp(`[${n[t]}]`, "g"));
                    x.characterRegex = new RegExp(`${i}]`)
                }
                if (x.characterRegex.test(e))
                    for (t in n) "string" == typeof t && (e = e.replace(x
                      .characterRegexArray[t], t));
                return e
            }, x.isValueInArray = (e, t) => {
                let i;
                const n = t.length;
                for (i = 0; n > i; i++)
                    if (t[i][0] === e) return i;
                return -1
            }, x.addParser = e => {
                let t;
                const i = x.parsers.length;
                let n = !0;
                for (t = 0; i > t; t++) x.parsers[t].id.toLowerCase() === e.id
                  .toLowerCase() && (n = !1);
                n && x.parsers.push(e)
            }, x.getParserById = e => {
                let t;
                const i = x.parsers.length;
                for (t = 0; i > t; t++)
                    if (x.parsers[t].id.toLowerCase() === e.toString()
                      .toLowerCase()) return x.parsers[t];
                return !1
            }, x.addWidget = e => {
                x.widgets.push(e)
            }, x.getWidgetById = e => {
                let t;
                let i;
                const n = x.widgets.length;
                for (t = 0; n > t; t++)
                    if (i = x.widgets[t], i && i.hasOwnProperty("id") && i.id
                      .toLowerCase() === e.toLowerCase()) return i
            }, x.applyWidget = (t, n) => {
                t = e(t)[0];
                let o;
                let s;
                let a;
                const r = t.config;
                let l = r.widgetOptions;
                const c = [];
                r.debug && (o = new Date), r.widgets.length && (r.widgets = e.grep(r
                    .widgets,
                  (t, i) => e.inArray(t, r.widgets) === i), e.each(r.widgets || [], (e, t) => {
                    a = x.getWidgetById(t), a && a.id && (a.priority || (a
                      .priority = 10), c[e] = a)
                }), c.sort(({priority}, {priority}) => priority < priority ? -1 : priority === priority ? 0 : 1), e.each(c, (i, o) => {
                    o && ((n || !r.widgetInit[o.id]) && (o.hasOwnProperty(
                        "options") && (l = t.config
                        .widgetOptions = e.extend(!0, {}, o
                        .options, l)), o.hasOwnProperty(
                        "init") && o.init(t, o, r, l), r
                        .widgetInit[o.id] = !0), !n && o
                        .hasOwnProperty("format") && o.format(t, r, l, !1)
                    )
                })), r.debug && (s = r.widgets.length, i(`Completed ${n === !0 ?
  "initializing " : "applying "}${s} widget${1 !==
s ? "s" : ""}`, o))
            }, x.refreshWidgets = (i, n, o) => {
                i = e(i)[0];
                let s;
                const a = i.config;
                const r = a.widgets;
                const l = x.widgets;
                const c = l.length;
                for (s = 0; c > s; s++) l[s] && l[s].id && (n || e.inArray(l[s].id, r) <
                  0) && (a.debug && t(`Refeshing widgets: Removing "${l[s].id}"`), l[s].hasOwnProperty("remove") && a.widgetInit[l[s]
                  .id] && (l[s].remove(i, a, a.widgetOptions), a.widgetInit[l[s]
                  .id] = !1));
                o !== !0 && x.applyWidget(i, n)
            }, x.getData = (t, i, n) => {
                let o;
                let s;
                let a = "";
                const r = e(t);
                return r.length ? (o = e.metadata ? r.metadata() : !1, s = ` ${r.attr(
  "class") || ""}`, "undefined" != typeof r.data(n) ||
                "undefined" != typeof r.data(n.toLowerCase()) ? a += r.data(n) ||
                  r.data(n.toLowerCase()) : o && "undefined" != typeof o[n] ? a +=
                  o[n] : i && "undefined" != typeof i[n] ? a += i[n] : " " !== s &&
                  s.match(` ${n}-`) && (a = s.match(new RegExp(`\\s${n}-([\\w-]+)`))[1] || ""), e.trim(a)) : "";
            }, x.formatFloat = (t, i) => {
                if ("string" != typeof t || "" === t) return t;
                let n;

                const o = i && i.config ? i.config.usNumberFormat !== !1 : "undefined" !=
                typeof i ? i : !0;

                return t = o ? t.replace(/,/g, "") : t.replace(/[\s|\.]/g, "")
                  .replace(/,/g, "."), /^\s*\([.\d]+\)/.test(t) && (t = t.replace(
                  /^\s*\(([.\d]+)\)/, "-$1")), n = parseFloat(t), isNaN(n) ? e.trim(
                  t) : n
            }, x.isDigit = e => isNaN(e) ? /^[\-+(]?\d+[)]?$/.test(e.toString()
              .replace(/[,.'"\s]/g, "")) : !0
        })
    });
    const t = e.tablesorter;
    e.fn.extend({
        tablesorter: t.construct
    }), t.addParser({
        id: "text",
        is() {
            return !0
        },
        format(i, {config}) {
            const o = config;
            return i && (i = e.trim(o.ignoreCase ? i.toLocaleLowerCase() : i), i = o
              .sortLocaleCompare ? t.replaceAccents(i) : i), i
        },
        type: "text"
    }), t.addParser({
        id: "digit",
        is(e) {
            return t.isDigit(e)
        },
        format(i, n) {
            const o = t.formatFloat((i || "")
              .replace(/[^\w,. \-()]/g, ""), n);
            return i && "number" == typeof o ? o : i ? e.trim(i && n.config.ignoreCase ? i
              .toLocaleLowerCase() : i) : i
        },
        type: "numeric"
    }), t.addParser({
        id: "currency",
        is(e) {
            return /^\(?\d+[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]|[\u00a3$\u20ac\u00a4\u00a5\u00a2?.]\d+\)?$/
              .test((e || "")
                .replace(/[+\-,. ]/g, ""))
        },
        format(i, n) {
            const o = t.formatFloat((i || "")
              .replace(/[^\w,. \-()]/g, ""), n);
            return i && "number" == typeof o ? o : i ? e.trim(i && n.config.ignoreCase ? i
              .toLocaleLowerCase() : i) : i
        },
        type: "numeric"
    }), t.addParser({
        id: "ipAddress",
        is(e) {
            return /^\d{1,3}[\.]\d{1,3}[\.]\d{1,3}[\.]\d{1,3}$/.test(e)
        },
        format(e, i) {
            let n;
            const o = e ? e.split(".") : "";
            let s = "";
            const a = o.length;
            for (n = 0; a > n; n++) s += (`00${o[n]}`)
              .slice(-3);
            return e ? t.formatFloat(s, i) : e
        },
        type: "numeric"
    }), t.addParser({
        id: "url",
        is(e) {
            return /^(https?|ftp|file):\/\//.test(e)
        },
        format(t) {
            return t ? e.trim(t.replace(/(https?|ftp|file):\/\//, "")) : t
        },
        type: "text"
    }), t.addParser({
        id: "isoDate",
        is(e) {
            return /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/.test(e)
        },
        format(e, i) {
            return e ? t.formatFloat("" !== e ? new Date(e.replace(/-/g, "/"))
              .getTime() || e : "", i) : e
        },
        type: "numeric"
    }), t.addParser({
        id: "percent",
        is(e) {
            return /(\d\s*?%|%\s*?\d)/.test(e) && e.length < 15
        },
        format(e, i) {
            return e ? t.formatFloat(e.replace(/%/g, ""), i) : e
        },
        type: "numeric"
    }), t.addParser({
        id: "usLongDate",
        is(e) {
            return /^[A-Z]{3,10}\.?\s+\d{1,2},?\s+(\d{4})(\s+\d{1,2}:\d{2}(:\d{2})?(\s+[AP]M)?)?$/i
              .test(e) || /^\d{1,2}\s+[A-Z]{3,10}\s+\d{4}/i.test(e)
        },
        format(e, i) {
            return e ? t.formatFloat(new Date(e.replace(/(\S)([AP]M)$/i, "$1 $2"))
              .getTime() || e, i) : e
        },
        type: "numeric"
    }), t.addParser({
        id: "shortDate",
        is(e) {
            return /(^\d{1,2}[\/\s]\d{1,2}[\/\s]\d{4})|(^\d{4}[\/\s]\d{1,2}[\/\s]\d{1,2})/
              .test((e || "")
                .replace(/\s+/g, " ")
                .replace(/[\-.,]/g, "/"))
        },
        format(e, i, n, o) {
            if (e) {
                const s = i.config;
                const a = s.$headers.filter(`[data-column=${o}]:last`);

                const r = a.length && a[0].dateFormat || t.getData(a, s.headers[o],
                  "dateFormat") || s.dateFormat;

                e = e.replace(/\s+/g, " ")
                  .replace(/[\-.,]/g, "/"), "mmddyyyy" === r ? e = e.replace(
                  /(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/, "$3/$1/$2") : "ddmmyyyy" ===
                r ? e = e.replace(/(\d{1,2})[\/\s](\d{1,2})[\/\s](\d{4})/, "$3/$2/$1") :
                  "yyyymmdd" === r && (e = e.replace(
                  /(\d{4})[\/\s](\d{1,2})[\/\s](\d{1,2})/, "$1/$2/$3"))
            }
            return e ? t.formatFloat(new Date(e)
              .getTime() || e, i) : e
        },
        type: "numeric"
    }), t.addParser({
        id: "time",
        is(e) {
            return /^(([0-2]?\d:[0-5]\d)|([0-1]?\d:[0-5]\d\s?([AP]M)))$/i.test(e)
        },
        format(e, i) {
            return e ? t.formatFloat(new Date(`2000/01/01 ${e.replace(/(\S)([AP]M)$/i,
  "$1 $2")}`)
              .getTime() || e, i) : e;
        },
        type: "numeric"
    }), t.addParser({
        id: "metadata",
        is() {
            return !1
        },
        format(t, {config}, n) {
            const o = config;
            const s = o.parserMetadataName ? o.parserMetadataName : "sortValue";
            return e(n)
              .metadata()[s]
        },
        type: "numeric"
    }), t.addWidget({
        id: "zebra",
        priority: 90,
        format(i, {cssChildRow, $tbodies, debug, selectorRemove}, {zebra}) {
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            const p = new RegExp(cssChildRow, "i");
            const m = $tbodies;
            for (debug && (u = new Date), d = 0; d < m.length; d++) s = m.eq(d), h = s
              .children("tr")
              .length, h > 1 && (l = 0, a = s.children("tr:visible")
              .not(selectorRemove), a.each(function () {
                r = e(this), p.test(this.className) || l++, c = 0 === l % 2, r
                  .removeClass(zebra[c ? 1 : 0])
                  .addClass(zebra[c ? 0 : 1])
            }));
            debug && t.benchmark("Applying Zebra widget", u)
        },
        remove(t, {$tbodies}, {zebra}) {
            let o;
            let s;
            const a = $tbodies;

            const r = (zebra || ["even", "odd"])
              .join(" ");

            for (o = 0; o < a.length; o++) s = e.tablesorter.processTbody(t, a.eq(o), !0), s
              .children()
              .removeClass(r), e.tablesorter.processTbody(t, s, !1)
        }
    })
})(jQuery), (e => {
    /**
     * Copyright 2012, Digital Fusion
     * Licensed under the MIT license.
     * http://teamdf.com/jquery-plugins/license/
     *
     * @author Sam Sehnert
     * @desc A small plugin that checks whether elements are within
     *       the user visible viewport of a web browser.
     *       only accounts for vertical position, not horizontal.
     */
    const t = e(window);
    e.fn.visible = function (i, n, o, s) {
        if (!(this.length < 1)) {
            o = o || "both";
            const a = this.length > 1 ? this.eq(0) : this;
            const r = "undefined" != typeof s && null !== s;
            const l = r ? e(s) : t;
            const c = r ? l.position() : 0;
            const u = a.get(0);
            const d = l.outerWidth();
            const h = l.outerHeight();
            const p = n === !0 ? u.offsetWidth * u.offsetHeight : !0;
            if ("function" == typeof u.getBoundingClientRect) {
                const m = u.getBoundingClientRect();
                const f = r ? m.top - c.top >= 0 && m.top < h + c.top : m.top >= 0 && m.top < h;

                const _ = r ? m.bottom - c.top > 0 && m.bottom <= h + c.top : m.bottom > 0 && m
                  .bottom <= h;

                const g = r ? m.left - c.left >= 0 && m.left < d + c.left : m.left >= 0 && m.left < d;

                const v = r ? m.right - c.left > 0 && m.right < d + c.left : m.right > 0 && m.right <=
                  d;

                var b = i ? f || _ : f && _;
                var y = i ? g || v : g && v;
                var b = m.top < 0 && m.bottom > h ? !0 : b;
                var y = m.left < 0 && m.right > d ? !0 : y;
                if ("both" === o) return p && b && y;
                if ("vertical" === o) return p && b;
                if ("horizontal" === o) return p && y
            } else {
                const w = r ? 0 : c;
                const k = w + h;
                const x = l.scrollLeft();
                const C = x + d;
                const z = a.position();
                const T = z.top;
                const S = T + a.height();
                const A = z.left;
                const E = A + a.width();
                const P = i === !0 ? S : T;
                const I = i === !0 ? T : S;
                const M = i === !0 ? E : A;
                const j = i === !0 ? A : E;
                if ("both" === o) return !!p && k >= I && P >= w && C >= j && M >= x;
                if ("vertical" === o) return !!p && k >= I && P >= w;
                if ("horizontal" === o) return !!p && C >= j && M >= x
            }
        }
    }
})(jQuery), /*
   * jQuery Hotkeys Plugin
   * Copyright 2010, John Resig
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   * Based upon the plugin by Tzury Bar Yochay:
   * https://github.com/tzuryby/jquery.hotkeys
   *
   * Original idea by:
   * Binny V A, http://www.openjs.com/scripts/events/keyboard_shortcuts/
   */
(e => {
    function t(t) {
        if ("string" == typeof t.data && (t.data = {
            keys: t.data
        }), t.data && t.data.keys && "string" == typeof t.data.keys) {
            const i = t.handler;

            const n = t.data.keys.toLowerCase()
              .split(" ");

            t.handler = function (t) {
                if (this === t.target || !(e.hotkeys.options.filterInputAcceptingElements && e.hotkeys
                  .textInputTypes.test(t.target.nodeName) || e.hotkeys.options
                  .filterContentEditable && e(t.target)
                  .attr("contenteditable") || e.hotkeys.options.filterTextInputs && e.inArray(t
                  .target.type, e.hotkeys.textAcceptingInputTypes) > -1)) {
                    const o = "keypress" !== t.type && e.hotkeys.specialKeys[t.which];

                    const s = String.fromCharCode(t.which)
                      .toLowerCase();

                    let a = "";
                    const r = {};
                    e.each(["alt", "ctrl", "shift"], (e, i) => {
                        t[`${i}Key`] && o !== i && (a += `${i}+`)
                    }), t.metaKey && !t.ctrlKey && "meta" !== o && (a += "meta+"), t.metaKey &&
                    "meta" !== o && a.includes("alt+ctrl+shift+") && (a = a.replace(
                      "alt+ctrl+shift+", "hyper+")), o ? r[a + o] = !0 : (r[a + s] = !0, r[a + e
                      .hotkeys.shiftNums[s]] = !0, "shift+" === a && (r[e.hotkeys.shiftNums[
                      s]] = !0));
                    for (let l = 0, c = n.length; c > l; l++)
                        if (r[n[l]]) return i.apply(this, arguments)
                }
            }
        }
    }
    e.hotkeys = {
        version: "0.2.0",
        specialKeys: {
            8: "backspace",
            9: "tab",
            10: "return",
            13: "return",
            16: "shift",
            17: "ctrl",
            18: "alt",
            19: "pause",
            20: "capslock",
            27: "esc",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            45: "insert",
            46: "del",
            59: ";",
            61: "=",
            96: "0",
            97: "1",
            98: "2",
            99: "3",
            100: "4",
            101: "5",
            102: "6",
            103: "7",
            104: "8",
            105: "9",
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            112: "f1",
            113: "f2",
            114: "f3",
            115: "f4",
            116: "f5",
            117: "f6",
            118: "f7",
            119: "f8",
            120: "f9",
            121: "f10",
            122: "f11",
            123: "f12",
            144: "numlock",
            145: "scroll",
            173: "-",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
        },
        shiftNums: {
            "`": "~",
            1: "!",
            2: "@",
            3: "#",
            4: "$",
            5: "%",
            6: "^",
            7: "&",
            8: "*",
            9: "(",
            0: ")",
            "-": "_",
            "=": "+",
            ";": ": ",
            "'": '"',
            ",": "<",
            ".": ">",
            "/": "?",
            "\\": "|"
        },
        textAcceptingInputTypes: ["text", "password", "number", "email", "url", "range", "date",
            "month", "week", "time", "datetime", "datetime-local", "search", "color", "tel"],
        textInputTypes: /textarea|input|select/i,
        options: {
            filterInputAcceptingElements: !0,
            filterTextInputs: !0,
            filterContentEditable: !0
        }
    }, e.each(["keydown", "keyup", "keypress"], function () {
        e.event.special[this] = {
            add: t
        }
    })
})(jQuery || this.jQuery || window.jQuery), jQuery.expr[":"].regex = (e, t, i) => {
    const n = i[3].split(",");
    const o = /^(data|css):/;

    const s = {
        method: n[0].match(o) ? n[0].split(":")[0] : "attr",
        property: n.shift()
          .replace(o, "")
    };

    const a = "ig";

    const r = new RegExp(n.join("")
      .replace(/^\s+|\s+$/g, ""), a);

    return r.test(jQuery(e)[s.method](s.property))
}, (e => {
    e(document)
      .ready(() => {
          e("body")
            .on("click", 'a[data-colorbox="true"]', function (t) {
                t.preventDefault(), e.colorbox({
                    height: e(this)
                      .data("colorbox-height") || !1,
                    width: e(this)
                      .data("colorbox-width") || !1,
                    iframe: e(this)
                      .data("colorbox-iframe") || !1,
                    photo: e(this)
                      .data("colorbox-photo") || !1,
                    innerHeight: e(this)
                      .data("colorbox-innerheight") || !1,
                    innerWidth: e(this)
                      .data("colorbox-innerwidth") || !1,
                    href: e(this)
                      .attr("href"),
                    opacity: .5
                })
            })
      })
})(jQuery), !(() => {
    const Faye = {
        VERSION: "1.1.0",
        BAYEUX_VERSION: "1.0",
        ID_LENGTH: 160,
        JSONP_CALLBACK: "jsonpcallback",
        CONNECTION_TYPES: ["long-polling", "cross-origin-long-polling", "callback-polling",
            "websocket", "eventsource", "in-process"],
        MANDATORY_CONNECTION_TYPES: ["long-polling", "callback-polling", "in-process"],
        ENV: "undefined" != typeof window ? window : global,
        extend(e, t, i) {
            if (!t) return e;
            for (const n in t) t.hasOwnProperty(n) && (e.hasOwnProperty(n) && i === !1 || e[n] !==
              t[n] && (e[n] = t[n]));
            return e
        },
        random(e = this.ID_LENGTH) {
            for (var t = Math.ceil(e * Math.log(2) / Math.log(36)), i = csprng(e, 36); i.length <
            t;) i = `0${i}`;
            return i
        },
        validateOptions(e, t) {
            for (const i in e)
                if (this.indexOf(t, i) < 0) throw Error(`Unrecognized option: ${i}`)
        },
        clientIdFromMessages(e) {
            const t = this.filter([].concat(e), ({channel}) => "/meta/connect" === channel);
            return t[0] && t[0].clientId
        },
        copyObject(e) {
            let t;
            let i;
            let n;
            if (e instanceof Array) {
                for (t = [], i = e.length; i--;) t[i] = Faye.copyObject(e[i]);
                return t
            }
            if ("object" == typeof e) {
                t = null === e ? null : {};
                for (n in e) t[n] = Faye.copyObject(e[n]);
                return t
            }
            return e
        },
        commonElement(e, t) {
            for (let i = 0, n = e.length; n > i; i++)
                if (-1 !== this.indexOf(t, e[i])) return e[i];
            return null
        },
        indexOf(e, t) {
            if (e.indexOf) return e.indexOf(t);
            for (let i = 0, n = e.length; n > i; i++)
                if (e[i] === t) return i;
            return -1
        },
        map(e, t, i) {
            if (e.map) return e.map(t, i);
            const n = [];
            if (e instanceof Array)
                for (let o = 0, s = e.length; s > o; o++) n.push(t.call(i || null, e[o], o));
            else
                for (const a in e) e.hasOwnProperty(a) && n.push(t.call(i || null, a, e[a]));
            return n
        },
        filter(e, t, i) {
            if (e.filter) return e.filter(t, i);
            for (var n = [], o = 0, s = e.length; s > o; o++) t.call(i || null, e[o], o) && n
              .push(e[o]);
            return n
        },
        asyncEach(e, t, i, n) {
            const o = e.length;
            let s = -1;
            let a = 0;
            let r = !1;
            const l = () => (a -= 1, s += 1, s === o ? i && i.call(n) : void t(e[s], u));

            const c = () => {
                if (!r) {
                    for (r = !0; a > 0;) l();
                    r = !1
                }
            };

            var u = () => {
                a += 1, c()
            };

            u()
        },
        toJSON(e) {
            return this.stringify ? this.stringify(e, function (e, t) {
                return this[e] instanceof Array ? this[e] : t
            }) : JSON.stringify(e)
        }
    };
    "undefined" != typeof module ? module.exports = Faye : "undefined" != typeof window && (window.Faye =
      Faye), Faye.Class = (e, t) => {
        "function" != typeof e && (t = e, e = Object);

        const i = function(...args) {
              return this.initialize ? this.initialize(...args) || this : this;
          };

        const n = () => {};
        return n.prototype = e.prototype, i.prototype = new n, Faye.extend(i.prototype, t), i
    }, (() => {
        function e(e, t) {
            if (e.indexOf) return e.indexOf(t);
            for (let i = 0; i < e.length; i++)
                if (t === e[i]) return i;
            return -1
        }
        const t = Faye.EventEmitter = () => {};
        const i = "function" == typeof Array.isArray ? Array.isArray : e => "[object Array]" === Object.prototype.toString.call(e);
        t.prototype.emit = function (e) {
            if ("error" === e && (!this._events || !this._events.error || i(this._events.error) &&
              !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[
              1] : Error("Uncaught, unspecified 'error' event.");
            if (!this._events) return !1;
            const t = this._events[e];
            if (!t) return !1;
            if ("function" == typeof t) {
                switch (arguments.length) {
                    case 1:
                        t.call(this);
                        break;
                    case 2:
                        t.call(this, arguments[1]);
                        break;
                    case 3:
                        t.call(this, arguments[1], arguments[2]);
                        break;
                    default:
                        var n = Array.prototype.slice.call(arguments, 1);
                        t.apply(this, n)
                }
                return !0
            }
            if (i(t)) {
                for (let n = Array.prototype.slice.call(arguments, 1),
                    o = t.slice(),
                    s = 0,
                    a = o
                      .length; a > s; s++) o[s].apply(this, n);
                return !0
            }
            return !1
        }, t.prototype.addListener = function (e, t) {
            if ("function" != typeof t) throw Error(
              "addListener only takes instances of Function");
            return this._events || (this._events = {}), this.emit("newListener", e, t), this
              ._events[e] ? i(this._events[e]) ? this._events[e].push(t) : this._events[e] = [
                this._events[e], t] : this._events[e] = t, this
        }, t.prototype.on = t.prototype.addListener, t.prototype.once = function (e, t) {
            const i = this;
            return i.on(e, function n() {
                i.removeListener(e, n), t.apply(this, arguments)
            }), this
        }, t.prototype.removeListener = function (t, n) {
            if ("function" != typeof n) throw Error(
              "removeListener only takes instances of Function");
            if (!this._events || !this._events[t]) return this;
            const o = this._events[t];
            if (i(o)) {
                const s = e(o, n);
                if (0 > s) return this;
                o.splice(s, 1), 0 == o.length && delete this._events[t]
            } else this._events[t] === n && delete this._events[t];
            return this
        }, t.prototype.removeAllListeners = function (e) {
            return 0 === arguments.length ? (this._events = {}, this) : (e && this._events && this
              ._events[e] && (this._events[e] = null), this)
        }, t.prototype.listeners = function (e) {
            return this._events || (this._events = {}), this._events[e] || (this._events[e] = []),
            i(this._events[e]) || (this._events[e] = [this._events[e]]), this._events[e]
        }
    })(), Faye.Namespace = Faye.Class({
        initialize() {
            this._used = {}
        },
        exists(e) {
            return this._used.hasOwnProperty(e)
        },
        generate() {
            for (var e = Faye.random(); this._used.hasOwnProperty(e);) e = Faye.random();
            return this._used[e] = e
        },
        release(e) {
            delete this._used[e]
        }
    }), (() => {
        let e;
        const t = setTimeout;
        e = "function" == typeof setImmediate ? e => {
            setImmediate(e)
        } : "object" == typeof process && process.nextTick ? e => {
            process.nextTick(e)
        } : e => {
            t(e, 0)
        };
        const i = 0;
        const n = 1;
        const o = 2;
        const s = e => e;

        const a = e => {
            throw e
        };

        const r = function (e) {
            if (this._state = i, this._onFulfilled = [], this._onRejected = [], "function" ==
            typeof e) {
                const t = this;
                e(e => {
                    h(t, e)
                }, e => {
                    m(t, e)
                })
            }
        };

        r.prototype.then = function (e, t) {
            const i = new r;
            return l(this, e, i), c(this, t, i), i
        };

        var l = ({_state, _onFulfilled, _value}, t, o) => {
              "function" != typeof t && (t = s);
              const a = e => {
                  u(t, e, o)
              };
              _state === i ? _onFulfilled.push(a) : _state === n && a(_value)
          };

        var c = ({_state, _onRejected, _reason}, t, n) => {
            "function" != typeof t && (t = a);
            const s = e => {
                u(t, e, n)
            };
            _state === i ? _onRejected.push(s) : _state === o && s(_reason)
        };

        var u = (t, i, n) => {
            e(() => {
                d(t, i, n)
            })
        };

        var d = (e, t, i) => {
            let n;
            try {
                n = e(t)
            } catch (o) {
                return m(i, o)
            }
            n === i ? m(i, new TypeError("Recursive promise chain detected")) : h(i, n)
        };

        var h = r.fulfill = r.resolve = (e, t) => {
            let i, n, o = !1;
            try {
                if (i = typeof t, n = null !== t && ("function" === i || "object" === i) && t
                  .then, "function" != typeof n) return p(e, t);
                n.call(t, t => {
                    o ^ (o = !0) && h(e, t)
                }, t => {
                    o ^ (o = !0) && m(e, t)
                })
            } catch (s) {
                if (!(o ^ (o = !0))) return;
                m(e, s)
            }
        };

        var p = (e, t) => {
            if (e._state === i) {
                e._state = n, e._value = t, e._onRejected = [];
                for (let o, s = e._onFulfilled; o = s.shift();) o(t)
            }
        };

        var m = r.reject = (e, t) => {
            if (e._state === i) {
                e._state = o, e._reason = t, e._onFulfilled = [];
                for (let n, s = e._onRejected; n = s.shift();) n(t)
            }
        };

        r.all = e => new r((t, i) => {
            let n;
            const o = [];
            let s = e.length;
            if (0 === s) return t(o);
            for (n = 0; s > n; n++) !((e, n) => {
                r.fulfilled(e)
                  .then(e => {
                      o[n] = e, 0 === --s && t(o)
                  }, i)
            })(e[n], n)
        }), r.defer = e, r.deferred = r.pending = () => {
            const e = {};
            return e.promise = new r((t, i) => {
                e.fulfill = e.resolve = t, e.reject = i
            }), e;
        }, r.fulfilled = r.resolved = e => new r(t => {
            t(e)
        }), r.rejected = e => new r((t, i) => {
            i(e)
        }), void 0 === Faye ? module.exports = r : Faye.Promise = r
    })(), Faye.Set = Faye.Class({
        initialize() {
            this._index = {}
        },
        add(e) {
            const t = void 0 !== e.id ? e.id : e;
            return this._index.hasOwnProperty(t) ? !1 : (this._index[t] = e, !0)
        },
        forEach(e, t) {
            for (const i in this._index) this._index.hasOwnProperty(i) && e.call(t, this._index[
              i])
        },
        isEmpty() {
            for (const e in this._index)
                if (this._index.hasOwnProperty(e)) return !1;
            return !0
        },
        member(e) {
            for (const t in this._index)
                if (this._index[t] === e) return !0;
            return !1
        },
        remove(e) {
            const t = void 0 !== e.id ? e.id : e;
            const i = this._index[t];
            return delete this._index[t], i
        },
        toArray() {
            const e = [];
            return this.forEach(t => {
                e.push(t)
            }), e;
        }
    }), Faye.URI = {
        isURI(e) {
            return e && e.protocol && e.host && e.path
        },
        isSameOrigin({protocol, hostname, port}) {
            const t = Faye.ENV.location;
            return protocol === t.protocol && hostname === t.hostname && port === t.port;
        },
        parse(e) {
            if ("string" != typeof e) return e;
            let t;
            let i;
            let n;
            let o;
            let s;
            let a;
            const r = {};

            const l = (t, i) => {
                e = e.replace(i, e => (r[t] = e, "")), r[t] = r[t] || ""
            };

            for (l("protocol", /^[a-z]+\:/i), l("host", /^\/\/[^\/\?#]+/), /^\//.test(e) || r
              .host || (e = Faye.ENV.location.pathname.replace(/[^\/]*$/, "") + e), l(
              "pathname", /^[^\?#]*/), l("search", /^\?[^#]*/), l("hash", /^#.*/), r
              .protocol = r.protocol || Faye.ENV.location.protocol, r.host ? (r.host = r.host
              .substr(2), t = r.host.split(":"), r.hostname = t[0], r.port = t[1] || "") : (
              r.host = Faye.ENV.location.host, r.hostname = Faye.ENV.location.hostname, r
                .port = Faye.ENV.location.port), r.pathname = r.pathname || "/", r.path = r
              .pathname + r.search, i = r.search.replace(/^\?/, ""), n = i ? i.split("&") : [],
                   a = {}, o = 0, s = n.length; s > o; o++) t = n[o].split("="), a[
              decodeURIComponent(t[0] || "")] = decodeURIComponent(t[1] || "");
            return r.query = a, r.href = this.stringify(r), r
        },
        stringify(e) {
            let t = `${e.protocol}//${e.hostname}`;
            return e.port && (t += `:${e.port}`), t += e.pathname + this.queryString(e.query) + (e
              .hash || "");
        },
        queryString(e) {
            const t = [];
            for (const i in e) e.hasOwnProperty(i) && t.push(`${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`);
            return 0 === t.length ? "" : `?${t.join("&")}`;
        }
    }, Faye.Error = Faye.Class({
        initialize(e, t, i) {
            this.code = e, this.params = Array.prototype.slice.call(t), this.message = i
        },
        toString() {
            return `${this.code}:${this.params.join(",")}:${this.message}`;
        }
    }), Faye.Error.parse = function (e) {
        if (e = e || "", !Faye.Grammar.ERROR.test(e)) return new this(null, [], e);
        const t = e.split(":");
        const i = parseInt(t[0]);
        const n = t[1].split(",");
        var e = t[2];
        return new this(i, n, e)
    }, Faye.Error.versionMismatch = function(...args) {
        return `${new this(300, args, "Version mismatch")}`;
    }, Faye.Error.conntypeMismatch = function(...args) {
        return `${new this(301, args, "Connection types not supported")}`;
    }, Faye.Error.extMismatch = function(...args) {
        return `${new this(302, args, "Extension mismatch")}`;
    }, Faye.Error.badRequest = function(...args) {
        return `${new this(400, args, "Bad request")}`;
    }, Faye.Error.clientUnknown = function(...args) {
        return `${new this(401, args, "Unknown client")}`;
    }, Faye.Error.parameterMissing = function(...args) {
        return `${new this(402, args, "Missing required parameter")}`;
    }, Faye.Error.channelForbidden = function(...args) {
        return `${new this(403, args, "Forbidden channel")}`;
    }, Faye.Error.channelUnknown = function(...args) {
        return `${new this(404, args, "Unknown channel")}`;
    }, Faye.Error.channelInvalid = function(...args) {
        return `${new this(405, args, "Invalid channel")}`;
    }, Faye.Error.extUnknown = function(...args) {
        return `${new this(406, args, "Unknown extension")}`;
    }, Faye.Error.publishFailed = function(...args) {
        return `${new this(407, args, "Failed to publish")}`;
    }, Faye.Error.serverError = function(...args) {
        return `${new this(500, args, "Internal server error")}`;
    }, Faye.Deferrable = {
        then(e, t) {
            const i = this;
            return this._promise || (this._promise = new Faye.Promise((e, t) => {
                i._fulfill = e, i._reject = t
            })), 0 === arguments.length ? this._promise : this._promise.then(e, t);
        },
        callback(e, t) {
            return this.then(i => {
                e.call(t, i)
            });
        },
        errback(e, t) {
            return this.then(null, i => {
                e.call(t, i)
            });
        },
        timeout(e, t) {
            this.then();
            const i = this;
            this._timer = Faye.ENV.setTimeout(() => {
                i._reject(t)
            }, 1e3 * e)
        },
        setDeferredStatus(e, t) {
            this._timer && Faye.ENV.clearTimeout(this._timer), this.then(), "succeeded" === e ?
              this._fulfill(t) : "failed" === e ? this._reject(t) : delete this._promise
        }
    }, Faye.Publisher = {
        countListeners(e) {
            return this.listeners(e)
              .length
        },
        bind(e, t, i) {
            const n = Array.prototype.slice;

            const o = function(...args) {
                t.apply(i, n.call(args))
            };

            return this._listeners = this._listeners || [], this._listeners.push([e, t, i, o]),
              this.on(e, o)
        },
        unbind(e, t, i) {
            this._listeners = this._listeners || [];
            for (let n, o = this._listeners.length; o--;) n = this._listeners[o], n[0] === e && (!
              t || n[1] === t && n[2] === i) && (this._listeners.splice(o, 1), this
              .removeListener(e, n[3]))
        }
    }, Faye.extend(Faye.Publisher, Faye.EventEmitter.prototype), Faye.Publisher.trigger = Faye
      .Publisher.emit, Faye.Timeouts = {
        addTimeout(e, t, i, n) {
            if (this._timeouts = this._timeouts || {}, !this._timeouts.hasOwnProperty(e)) {
                const o = this;
                this._timeouts[e] = Faye.ENV.setTimeout(() => {
                    delete o._timeouts[e], i.call(n)
                }, 1e3 * t)
            }
        },
        removeTimeout(e) {
            this._timeouts = this._timeouts || {};
            const t = this._timeouts[e];
            t && (Faye.ENV.clearTimeout(t), delete this._timeouts[e])
        },
        removeAllTimeouts() {
            this._timeouts = this._timeouts || {};
            for (const e in this._timeouts) this.removeTimeout(e)
        }
    }, Faye.Logging = {
        LOG_LEVELS: {
            fatal: 4,
            error: 3,
            warn: 2,
            info: 1,
            debug: 0
        },
        writeLog(e, t) {
            if (Faye.logger) {
                const i = Array.prototype.slice.apply(e);
                let n = "[Faye";
                let o = this.className;

                const s = i.shift()
                  .replace(/\?/g, () => {
                      try {
                          return Faye.toJSON(i.shift())
                      } catch (e) {
                          return "[Object]"
                      }
                  });

                for (const a in Faye) o || "function" == typeof Faye[a] && this instanceof Faye[
                  a] && (o = a);
                o && (n += `.${o}`), n += "] ", "function" == typeof Faye.logger[t] ? Faye.logger[
                  t](n + s) : "function" == typeof Faye.logger && Faye.logger(n + s)
            }
        }
    }, (() => {
        for (const e in Faye.Logging.LOG_LEVELS) !(e => {
            Faye.Logging[e] = function(...args) {
                this.writeLog(args, e)
            }
        })(e)
    })(), Faye.Grammar = {
        CHANNEL_NAME: /^\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,
        CHANNEL_PATTERN: /^(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*\/\*{1,2}$/,
        ERROR: /^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)$/,
        VERSION: /^([0-9])+(\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*)*$/
    }, Faye.Extensible = {
        addExtension(e) {
            this._extensions = this._extensions || [], this._extensions.push(e), e.added && e
              .added(this)
        },
        removeExtension(e) {
            if (this._extensions)
                for (let t = this._extensions.length; t--;) this._extensions[t] === e && (this
                  ._extensions.splice(t, 1), e.removed && e.removed(this))
        },
        pipeThroughExtensions(e, t, i, n, o) {
            if (this.debug("Passing through ? extensions: ?", e, t), !this._extensions) return n
              .call(o, t);
            const s = this._extensions.slice();

            const a = t => {
                if (!t) return n.call(o, t);
                const r = s.shift();
                if (!r) return n.call(o, t);
                const l = r[e];
                return l ? void(l.length >= 3 ? r[e](t, i, a) : r[e](t, a)) : a(t)
            };

            a(t)
        }
    }, Faye.extend(Faye.Extensible, Faye.Logging), Faye.Channel = Faye.Class({
        initialize(e) {
            this.id = this.name = e
        },
        push(e) {
            this.trigger("message", e)
        },
        isUnused() {
            return 0 === this.countListeners("message")
        }
    }), Faye.extend(Faye.Channel.prototype, Faye.Publisher), Faye.extend(Faye.Channel, {
        HANDSHAKE: "/meta/handshake",
        CONNECT: "/meta/connect",
        SUBSCRIBE: "/meta/subscribe",
        UNSUBSCRIBE: "/meta/unsubscribe",
        DISCONNECT: "/meta/disconnect",
        META: "meta",
        SERVICE: "service",
        expand(e) {
            const t = this.parse(e);
            const i = ["/**", e];
            let n = t.slice();
            n[n.length - 1] = "*", i.push(this.unparse(n));
            for (let o = 1, s = t.length; s > o; o++) n = t.slice(0, o), n.push("**"), i.push(
              this.unparse(n));
            return i
        },
        isValid(e) {
            return Faye.Grammar.CHANNEL_NAME.test(e) || Faye.Grammar.CHANNEL_PATTERN.test(e)
        },
        parse(e) {
            return this.isValid(e) ? e.split("/")
              .slice(1) : null
        },
        unparse(e) {
            return `/${e.join("/")}`;
        },
        isMeta(e) {
            const t = this.parse(e);
            return t ? t[0] === this.META : null
        },
        isService(e) {
            const t = this.parse(e);
            return t ? t[0] === this.SERVICE : null
        },
        isSubscribable(e) {
            return this.isValid(e) ? !this.isMeta(e) && !this.isService(e) : null
        },
        Set: Faye.Class({
            initialize() {
                this._channels = {}
            },
            getKeys() {
                const e = [];
                for (const t in this._channels) e.push(t);
                return e
            },
            remove(e) {
                delete this._channels[e]
            },
            hasSubscription(e) {
                return this._channels.hasOwnProperty(e)
            },
            subscribe(e, t, i) {
                for (let n, o = 0, s = e.length; s > o; o++) {
                    n = e[o];
                    const a = this._channels[n] = this._channels[n] || new Faye.Channel(
                      n);
                    t && a.bind("message", t, i)
                }
            },
            unsubscribe(e, t, i) {
                const n = this._channels[e];
                return n ? (n.unbind("message", t, i), n.isUnused() ? (this.remove(e),
                  !0) : !1) : !1
            },
            distributeMessage(e) {
                for (let t = Faye.Channel.expand(e.channel), i = 0, n = t.length; n >
                i; i++) {
                    const o = this._channels[t[i]];
                    o && o.trigger("message", e.data)
                }
            }
        })
    }), Faye.Publication = Faye.Class(Faye.Deferrable), Faye.Subscription = Faye.Class({
        initialize(e, t, i, n) {
            this._client = e, this._channels = t, this._callback = i, this._context = n, this
              ._cancelled = !1
        },
        cancel() {
            this._cancelled || (this._client.unsubscribe(this._channels, this._callback, this
              ._context), this._cancelled = !0)
        },
        unsubscribe() {
            this.cancel()
        }
    }), Faye.extend(Faye.Subscription.prototype, Faye.Deferrable), Faye.Client = Faye.Class({
        UNCONNECTED: 1,
        CONNECTING: 2,
        CONNECTED: 3,
        DISCONNECTED: 4,
        HANDSHAKE: "handshake",
        RETRY: "retry",
        NONE: "none",
        CONNECTION_TIMEOUT: 60,
        DEFAULT_ENDPOINT: "/bayeux",
        INTERVAL: 0,
        initialize(e, t) {
            this.info("New client created for ?", e), t = t || {}, Faye.validateOptions(t, [
                "interval", "timeout", "endpoints", "proxy", "retry", "scheduler",
                "websocketExtensions", "tls", "ca"]), this._endpoint = e || this
              .DEFAULT_ENDPOINT, this._channels = new Faye.Channel.Set, this._dispatcher =
              new Faye.Dispatcher(this, this._endpoint, t), this._messageId = 0, this
              ._state = this.UNCONNECTED, this._responseCallbacks = {}, this._advice = {
                reconnect: this.RETRY,
                interval: 1e3 * (t.interval || this.INTERVAL),
                timeout: 1e3 * (t.timeout || this.CONNECTION_TIMEOUT)
            }, this._dispatcher.timeout = this._advice.timeout / 1e3, this._dispatcher
              .bind("message", this._receiveMessage, this), Faye.Event && void 0 !== Faye
              .ENV.onbeforeunload && Faye.Event.on(Faye.ENV, "beforeunload", function () {
                Faye.indexOf(this._dispatcher._disabled, "autodisconnect") < 0 && this
                  .disconnect()
            }, this)
        },
        addWebsocketExtension(e) {
            return this._dispatcher.addWebsocketExtension(e)
        },
        disable(e) {
            return this._dispatcher.disable(e)
        },
        setHeader(e, t) {
            return this._dispatcher.setHeader(e, t)
        },
        handshake(e, t) {
            if (this._advice.reconnect !== this.NONE && this._state === this.UNCONNECTED) {
                this._state = this.CONNECTING;
                const i = this;
                this.info("Initiating handshake with ?", Faye.URI.stringify(this._endpoint)),
                  this._dispatcher.selectTransport(Faye.MANDATORY_CONNECTION_TYPES), this
                  ._sendMessage({
                      channel: Faye.Channel.HANDSHAKE,
                      version: Faye.BAYEUX_VERSION,
                      supportedConnectionTypes: this._dispatcher.getConnectionTypes()
                  }, {}, function({successful, clientId, supportedConnectionTypes}) {
                      successful ? (this._state = this.CONNECTED, this._dispatcher
                        .clientId = clientId, this._dispatcher.selectTransport(supportedConnectionTypes), this.info(
                        "Handshake successful: ?", this._dispatcher.clientId),
                        this.subscribe(this._channels.getKeys(), !0), e && Faye
                        .Promise.defer(() => {
                            e.call(t)
                        })) : (this.info("Handshake unsuccessful"), Faye.ENV
                        .setTimeout(() => {
                            i.handshake(e, t)
                        }, 1e3 * this._dispatcher.retry), this._state = this
                        .UNCONNECTED)
                  }, this)
            }
        },
        connect(e, t) {
            if (this._advice.reconnect !== this.NONE && this._state !== this.DISCONNECTED) {
                if (this._state === this.UNCONNECTED) return this.handshake(function () {
                    this.connect(e, t)
                }, this);
                this.callback(e, t), this._state === this.CONNECTED && (this.info(
                  "Calling deferred actions for ?", this._dispatcher.clientId), this
                  .setDeferredStatus("succeeded"), this.setDeferredStatus("unknown"),
                this._connectRequest || (this._connectRequest = !0, this.info(
                  "Initiating connection for ?", this._dispatcher.clientId),
                  this._sendMessage({
                      channel: Faye.Channel.CONNECT,
                      clientId: this._dispatcher.clientId,
                      connectionType: this._dispatcher.connectionType
                  }, {}, this._cycleConnection, this)))
            }
        },
        disconnect() {
            if (this._state === this.CONNECTED) {
                this._state = this.DISCONNECTED, this.info("Disconnecting ?", this._dispatcher
                  .clientId);
                const e = new Faye.Publication;
                return this._sendMessage({
                    channel: Faye.Channel.DISCONNECT,
                    clientId: this._dispatcher.clientId
                }, {}, function({successful, error}) {
                    successful ? (this._dispatcher.close(), e.setDeferredStatus(
                      "succeeded")) : e.setDeferredStatus("failed", Faye.Error
                      .parse(error))
                }, this), this.info("Clearing channel listeners for ?", this._dispatcher
                  .clientId), this._channels = new Faye.Channel.Set, e;
            }
        },
        subscribe(e, t, i) {
            if (e instanceof Array) return Faye.map(e, function (e) {
                return this.subscribe(e, t, i)
            }, this);
            const n = new Faye.Subscription(this, e, t, i);
            const o = t === !0;
            const s = this._channels.hasSubscription(e);
            return s && !o ? (this._channels.subscribe([e], t, i), n.setDeferredStatus(
              "succeeded"), n) : (this.connect(function () {
                this.info("Client ? attempting to subscribe to ?", this
                  ._dispatcher.clientId, e), o || this._channels.subscribe([
                    e], t, i), this._sendMessage({
                    channel: Faye.Channel.SUBSCRIBE,
                    clientId: this._dispatcher.clientId,
                    subscription: e
                }, {}, function({successful, error, subscription}) {
                    if (!successful) return n.setDeferredStatus(
                      "failed", Faye.Error.parse(error)), this
                      ._channels.unsubscribe(e, t, i);
                    const s = [].concat(subscription);
                    this.info("Subscription acknowledged for ? to ?", this
                      ._dispatcher.clientId, s), n
                      .setDeferredStatus("succeeded")
                }, this)
            }, this), n);
        },
        unsubscribe(e, t, i) {
            if (e instanceof Array) return Faye.map(e, function (e) {
                return this.unsubscribe(e, t, i)
            }, this);
            const n = this._channels.unsubscribe(e, t, i);
            n && this.connect(function () {
                this.info("Client ? attempting to unsubscribe from ?", this
                  ._dispatcher.clientId, e), this._sendMessage({
                    channel: Faye.Channel.UNSUBSCRIBE,
                    clientId: this._dispatcher.clientId,
                    subscription: e
                }, {}, function({successful, subscription}) {
                    if (successful) {
                        const t = [].concat(subscription);
                        this.info("Unsubscription acknowledged for ? from ?",
                          this._dispatcher.clientId, t)
                    }
                }, this)
            }, this)
        },
        publish(e, t, i) {
            Faye.validateOptions(i || {}, ["attempts", "deadline"]);
            const n = new Faye.Publication;
            return this.connect(function () {
                this.info("Client ? queueing published message to ?: ?", this
                  ._dispatcher.clientId, e, t), this._sendMessage({
                    channel: e,
                    data: t,
                    clientId: this._dispatcher.clientId
                }, i, ({successful, error}) => {
                    successful ? n.setDeferredStatus("succeeded") : n
                      .setDeferredStatus("failed", Faye.Error.parse(error))
                }, this)
            }, this), n;
        },
        _sendMessage(e, t, i, n) {
            e.id = this._generateMessageId();
            const o = this._advice.timeout ? 1.2 * this._advice.timeout / 1e3 : 1.2 * this
              ._dispatcher.retry;
            this.pipeThroughExtensions("outgoing", e, null, function (e) {
                e && (i && (this._responseCallbacks[e.id] = [i, n]), this._dispatcher
                  .sendMessage(e, o, t || {}))
            }, this)
        },
        _generateMessageId() {
            return this._messageId += 1, this._messageId >= 2 ** 32 && (this
              ._messageId = 0), this._messageId.toString(36);
        },
        _receiveMessage(e) {
            let t;
            const i = e.id;
            void 0 !== e.successful && (t = this._responseCallbacks[i], delete this
              ._responseCallbacks[i]), this.pipeThroughExtensions("incoming", e, null,
              function (e) {
                  e && (e.advice && this._handleAdvice(e.advice), this._deliverMessage(
                    e), t && t[0].call(t[1], e))
              }, this)
        },
        _handleAdvice(e) {
            Faye.extend(this._advice, e), this._dispatcher.timeout = this._advice.timeout /
              1e3, this._advice.reconnect === this.HANDSHAKE && this._state !== this
              .DISCONNECTED && (this._state = this.UNCONNECTED, this._dispatcher.clientId =
              null, this._cycleConnection())
        },
        _deliverMessage(e) {
            e.channel && void 0 !== e.data && (this.info(
              "Client ? calling listeners for ? with ?", this._dispatcher.clientId,
              e.channel, e.data), this._channels.distributeMessage(e))
        },
        _cycleConnection() {
            this._connectRequest && (this._connectRequest = null, this.info(
              "Closed connection for ?", this._dispatcher.clientId));
            const e = this;
            Faye.ENV.setTimeout(() => {
                e.connect()
            }, this._advice.interval)
        }
    }), Faye.extend(Faye.Client.prototype, Faye.Deferrable), Faye.extend(Faye.Client.prototype, Faye
      .Publisher), Faye.extend(Faye.Client.prototype, Faye.Logging), Faye.extend(Faye.Client
      .prototype, Faye.Extensible), Faye.Dispatcher = Faye.Class({
        MAX_REQUEST_SIZE: 2048,
        DEFAULT_RETRY: 5,
        UP: 1,
        DOWN: 2,
        initialize(e, t, i) {
            this._client = e, this.endpoint = Faye.URI.parse(t), this._alternates = i
              .endpoints || {}, this.cookies = Faye.Cookies && new Faye.Cookies.CookieJar,
              this._disabled = [], this._envelopes = {}, this.headers = {}, this.retry = i
              .retry || this.DEFAULT_RETRY, this._scheduler = i.scheduler || Faye.Scheduler,
              this._state = 0, this.transports = {}, this.wsExtensions = [], this.proxy = i
              .proxy || {}, "string" == typeof this._proxy && (this._proxy = {
                origin: this._proxy
            });
            let n = i.websocketExtensions;
            if (n) {
                n = [].concat(n);
                for (let o = 0, s = n.length; s > o; o++) this.addWebsocketExtension(n[o])
            }
            this.tls = i.tls || {}, this.tls.ca = this.tls.ca || i.ca;
            for (const a in this._alternates) this._alternates[a] = Faye.URI.parse(this
              ._alternates[a]);
            this.maxRequestSize = this.MAX_REQUEST_SIZE
        },
        endpointFor(e) {
            return this._alternates[e] || this.endpoint
        },
        addWebsocketExtension(e) {
            this.wsExtensions.push(e)
        },
        disable(e) {
            this._disabled.push(e)
        },
        setHeader(e, t) {
            this.headers[e] = t
        },
        close() {
            const e = this._transport;
            delete this._transport, e && e.close()
        },
        getConnectionTypes() {
            return Faye.Transport.getConnectionTypes()
        },
        selectTransport(e) {
            Faye.Transport.get(this, e, this._disabled, function (e) {
                this.debug("Selected ? transport for ?", e.connectionType, Faye.URI
                  .stringify(e.endpoint)), e !== this._transport && (this
                  ._transport && this._transport.close(), this._transport = e,
                  this.connectionType = e.connectionType)
            }, this)
        },
        sendMessage(e, t, i) {
            if (this._transport) {
                i = i || {};
                let n;
                const o = e.id;
                const s = i.attempts;

                const a = i.deadline && (new Date)
                  .getTime() + 1e3 * i.deadline;

                let r = this._envelopes[o];
                r || (n = new this._scheduler(e, {
                    timeout: t,
                    interval: this.retry,
                    attempts: s,
                    deadline: a
                }), r = this._envelopes[o] = {
                    message: e,
                    scheduler: n
                }), this._sendEnvelope(r)
            }
        },
        _sendEnvelope(e) {
            if (!e.request && !e.timer) {
                const t = e.message;
                const i = e.scheduler;
                const n = this;
                if (!i.isDeliverable()) return i.abort(), void delete this._envelopes[t.id];
                e.timer = Faye.ENV.setTimeout(() => {
                    n.handleError(t)
                }, 1e3 * i.getTimeout()), i.send(), e.request = this._transport
                  .sendMessage(t)
            }
        },
        handleResponse(e) {
            const t = this._envelopes[e.id];
            void 0 !== e.successful && t && (t.scheduler.succeed(), delete this._envelopes[e
              .id], Faye.ENV.clearTimeout(t.timer)), this.trigger("message", e), this
              ._state !== this.UP && (this._state = this.UP, this._client.trigger(
              "transport:up"))
        },
        handleError({id}, t) {
            const i = this._envelopes[id];
            const n = i && i.request;
            const o = this;
            if (n) {
                n.then(e => {
                    e && e.abort && e.abort()
                });
                const s = i.scheduler;
                s.fail(), Faye.ENV.clearTimeout(i.timer), i.request = i.timer = null, t ? this
                  ._sendEnvelope(i) : i.timer = Faye.ENV.setTimeout(() => {
                    i.timer = null, o._sendEnvelope(i)
                }, 1e3 * s.getInterval()), this._state !== this.DOWN && (this._state =
                  this.DOWN, this._client.trigger("transport:down"))
            }
        }
    }), Faye.extend(Faye.Dispatcher.prototype, Faye.Publisher), Faye.extend(Faye.Dispatcher.prototype,
      Faye.Logging), Faye.Scheduler = function (e, t) {
        this.message = e, this.options = t, this.attempts = 0
    }, Faye.extend(Faye.Scheduler.prototype, {
        getTimeout() {
            return this.options.timeout
        },
        getInterval() {
            return this.options.interval
        },
        isDeliverable() {
            const e = this.options.attempts;
            const t = this.attempts;
            const i = this.options.deadline;

            const n = (new Date)
              .getTime();

            return void 0 !== e && t >= e ? !1 : void 0 !== i && n > i ? !1 : !0
        },
        send() {
            this.attempts += 1
        },
        succeed() {},
        fail() {},
        abort() {}
    }), Faye.Transport = Faye.extend(Faye.Class({
        DEFAULT_PORTS: {
            "http:": 80,
            "https:": 443,
            "ws:": 80,
            "wss:": 443
        },
        SECURE_PROTOCOLS: ["https:", "wss:"],
        MAX_DELAY: 0,
        batching: !0,
        initialize(e, t) {
            this._dispatcher = e, this.endpoint = t, this._outbox = [], this._proxy = Faye
              .extend({}, this._dispatcher.proxy), !this._proxy.origin && Faye
              .NodeAdapter && (this._proxy.origin = Faye.indexOf(this.SECURE_PROTOCOLS,
              this.endpoint.protocol) >= 0 ? process.env.HTTPS_PROXY || process
              .env.https_proxy : process.env.HTTP_PROXY || process.env.http_proxy)
        },
        close() {},
        encode() {
            return ""
        },
        sendMessage(e) {
            return this.debug("Client ? sending message to ?: ?", this._dispatcher
              .clientId, Faye.URI.stringify(this.endpoint), e), this.batching ? (
              this._outbox.push(e), this._flushLargeBatch(), this._promise = this
                ._promise || new Faye.Promise, e.channel === Faye.Channel.HANDSHAKE ?
                (this.addTimeout("publish", .01, this._flush, this), this._promise) :
                (e.channel === Faye.Channel.CONNECT && (this._connectMessage = e),
                  this.addTimeout("publish", this.MAX_DELAY, this._flush, this),
                  this._promise)) : Faye.Promise.fulfilled(this.request([e]))
        },
        _flush() {
            this.removeTimeout("publish"), this._outbox.length > 1 && this
              ._connectMessage && (this._connectMessage.advice = {
                timeout: 0
            }), Faye.Promise.fulfill(this._promise, this.request(this._outbox)),
              delete this._promise, this._connectMessage = null, this._outbox = []
        },
        _flushLargeBatch() {
            const e = this.encode(this._outbox);
            if (!(e.length < this._dispatcher.maxRequestSize)) {
                const t = this._outbox.pop();
                this._flush(), t && this._outbox.push(t)
            }
        },
        _receive(e) {
            e = [].concat(e), this.debug("Client ? received from ? via ?: ?", this
              ._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this
              .connectionType, e);
            for (let t = 0, i = e.length; i > t; t++) this._dispatcher.handleResponse(e[
              t])
        },
        _handleError(e) {
            e = [].concat(e), this.debug("Client ? failed to send to ? via ?: ?", this
              ._dispatcher.clientId, Faye.URI.stringify(this.endpoint), this
              .connectionType, e);
            for (let t = 0, i = e.length; i > t; t++) this._dispatcher.handleError(e[t])
        },
        _getCookies() {
            const e = this._dispatcher.cookies;
            const t = Faye.URI.stringify(this.endpoint);
            return e ? Faye.map(e.getCookiesSync(t), e => e.cookieString())
              .join("; ") : "";
        },
        _storeCookies(e) {
            let t;
            const i = this._dispatcher.cookies;
            const n = Faye.URI.stringify(this.endpoint);
            if (e && i) {
                e = [].concat(e);
                for (let o = 0, s = e.length; s > o; o++) t = Faye.Cookies.Cookie.parse(e[
                  o]), i.setCookieSync(t, n)
            }
        }
    }), {
        get(e, t, i, n, o) {
            const s = e.endpoint;
            Faye.asyncEach(this._transports, (s, a) => {
                const r = s[0];
                const l = s[1];
                const c = e.endpointFor(r);
                return Faye.indexOf(i, r) >= 0 ? a() : Faye.indexOf(t, r) < 0 ? (l
                  .isUsable(e, c, () => {}), a()) : void l.isUsable(e, c,
                  t => {
                      if (!t) return a();
                      const i = l.hasOwnProperty("create") ? l.create(e, c) :
                        new l(e, c);
                      n.call(o, i)
                  });
            }, () => {
                throw Error(`Could not find a usable connection type for ${Faye.URI
  .stringify(s)}`)
            })
        },
        register(e, t) {
            this._transports.push([e, t]), t.prototype.connectionType = e
        },
        getConnectionTypes() {
            return Faye.map(this._transports, e => e[0]);
        },
        _transports: []
    }), Faye.extend(Faye.Transport.prototype, Faye.Logging), Faye.extend(Faye.Transport.prototype,
      Faye.Timeouts), Faye.Event = {
        _registry: [],
        on(e, t, i, n) {
            const o = () => {
                i.call(n)
            };
            e.addEventListener ? e.addEventListener(t, o, !1) : e.attachEvent(`on${t}`, o), this
              ._registry.push({
                  _element: e,
                  _type: t,
                  _callback: i,
                  _context: n,
                  _handler: o
              })
        },
        detach(e, t, i, n) {
            for (let o, s = this._registry.length; s--;) o = this._registry[s], e && e !== o
              ._element || t && t !== o._type || i && i !== o._callback || n && n !== o
              ._context || (o._element.removeEventListener ? o._element.removeEventListener(o
              ._type, o._handler, !1) : o._element.detachEvent(`on${o._type}`, o
              ._handler), this._registry.splice(s, 1), o = null)
        }
    }, void 0 !== Faye.ENV.onunload && Faye.Event.on(Faye.ENV, "unload", Faye.Event.detach, Faye
      .Event), "object" != typeof JSON && (JSON = {}), (() => {
        function f(e) {
            return 10 > e ? `0${e}` : e;
        }

        function quote(e) {
            return escapable.lastIndex = 0, escapable.test(e) ? `"${e.replace(escapable, e => {
    const t = meta[e];
    return "string" == typeof t ? t : `\\u${(`0000${e.charCodeAt(0)
  .toString(16)}`)
  .slice(-4)}`;
})}"` : `"${e}"`;
        }

        function str(e, t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            const r = gap;
            let l = t[e];
            switch (l && "object" == typeof l && "function" == typeof l.toJSON && (l = l.toJSON(e)),
            "function" == typeof rep && (l = rep.call(t, e, l)), typeof l) {
                case "string":
                    return quote(l);
                case "number":
                    return isFinite(l) ? `${l}` : "null";
                case "boolean":
                case "null":
                    return `${l}`;
                case "object":
                    if (!l) return "null";
                    if (gap += indent, a = [], "[object Array]" === Object.prototype.toString.apply(l)) {
                        for (s = l.length, i = 0; s > i; i += 1) a[i] = str(i, l) || "null";
                        return o = 0 === a.length ? "[]" : gap ? `[\n${gap}${a.join(`,\n${gap}`)}\n${r}]` : `[${a.join(",")}]`, gap = r, o;
                    }
                    if (rep && "object" == typeof rep)
                        for (s = rep.length, i = 0; s > i; i += 1) "string" == typeof rep[i] && (n = rep[
                          i], o = str(n, l), o && a.push(quote(n) + (gap ? ": " : ":") + o));
                    else
                        for (n in l) Object.prototype.hasOwnProperty.call(l, n) && (o = str(n, l), o && a
                          .push(quote(n) + (gap ? ": " : ":") + o));
                    return o = 0 === a.length ? "{}" : gap ? `{\n${gap}${a.join(`,\n${gap}`)}\n${r}}` : `{${a.join(",")}}`, gap = r, o;
            }
        }
        "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function () {
            return isFinite(this.valueOf()) ? `${this.getUTCFullYear()}-${f(this
  .getUTCMonth() + 1)}-${f(this.getUTCDate())}T${f(this
  .getUTCHours())}:${f(this.getUTCMinutes())}:${f(this
  .getUTCSeconds())}Z` : null;
        }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON =
          function () {
              return this.valueOf()
          });

        const cx =
            /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

        var escapable =
          /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

        var gap;
        var indent;

        var meta = {
              "\b": "\\b",
              "	": "\\t",
              "\n": "\\n",
              "\f": "\\f",
              "\r": "\\r",
              '"': '\\"',
              "\\": "\\\\"
          };

        var rep;
        Faye.stringify = (e, t, i) => {
            let n;
            if (gap = "", indent = "", "number" == typeof i)
                for (n = 0; i > n; n += 1) indent += " ";
            else "string" == typeof i && (indent = i);
            if (rep = t, t && "function" != typeof t && ("object" != typeof t || "number" !=
              typeof t.length)) throw Error("JSON.stringify");
            return str("", {
                "": e
            })
        }, "function" != typeof JSON.stringify && (JSON.stringify = Faye.stringify), "function" !=
        typeof JSON.parse && (JSON.parse = (text, reviver) => {
            function walk(e, t) {
                let i;
                let n;
                const o = e[t];
                if (o && "object" == typeof o)
                    for (i in o) Object.prototype.hasOwnProperty.call(o, i) && (n = walk(o,
                      i), void 0 !== n ? o[i] = n : delete o[i]);
                return reviver.call(e, t, o)
            }
            let j;
            if (text += "", cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx,
              e => `\\u${(`0000${e.charCodeAt(0)
  .toString(16)}`)
  .slice(-4)}`)), /^[\],:{}\s]*$/.test(text.replace(
              /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@")
              .replace(
                /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                "]")
              .replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval(`(${text})`),
              "function" == typeof reviver ? walk({
                  "": j
              }, "") : j;
            throw new SyntaxError("JSON.parse")
        })
    })(), Faye.Transport.WebSocket = Faye.extend(Faye.Class(Faye.Transport, {
        UNCONNECTED: 1,
        CONNECTING: 2,
        CONNECTED: 3,
        batching: !1,
        isUsable(e, t) {
            this.callback(() => {
                e.call(t, !0)
            }), this.errback(() => {
                e.call(t, !1)
            }), this.connect()
        },
        request(e) {
            this._pending = this._pending || new Faye.Set;
            for (let t = 0, i = e.length; i > t; t++) this._pending.add(e[t]);
            const n = new Faye.Promise;
            return this.callback(t => {
                t && (t.send(Faye.toJSON(e)), Faye.Promise.fulfill(n, t))
            }, this), this.connect(), {
                abort() {
                    n.then(e => {
                        e.close()
                    })
                }
            };
        },
        connect() {
            if (!Faye.Transport.WebSocket._unloaded && (this._state = this._state || this
              .UNCONNECTED, this._state === this.UNCONNECTED)) {
                this._state = this.CONNECTING;
                const e = this._createSocket();
                if (!e) return this.setDeferredStatus("failed");
                const t = this;
                e.onopen = () => {
                    e.headers && t._storeCookies(e.headers["set-cookie"]), t._socket =
                      e, t._state = t.CONNECTED, t._everConnected = !0, t._ping(), t
                      .setDeferredStatus("succeeded", e)
                };
                let i = !1;
                e.onclose = e.onerror = () => {
                    if (!i) {
                        i = !0;
                        const n = t._state === t.CONNECTED;
                        e.onopen = e.onclose = e.onerror = e.onmessage = null,
                          delete t._socket, t._state = t.UNCONNECTED, t
                          .removeTimeout("ping"), t.setDeferredStatus("unknown");
                        const o = t._pending ? t._pending.toArray() : [];
                        delete t._pending, n ? t._handleError(o, !0) : t
                          ._everConnected ? t._handleError(o) : t.setDeferredStatus(
                          "failed")
                    }
                }, e.onmessage = e => {
                    let i = JSON.parse(e.data);
                    if (i) {
                        i = [].concat(i);
                        for (let n = 0, o = i.length; o > n; n++) void 0 !== i[n]
                          .successful && t._pending.remove(i[n]);
                        t._receive(i)
                    }
                }
            }
        },
        close() {
            this._socket && this._socket.close()
        },
        _createSocket() {
            const e = Faye.Transport.WebSocket.getSocketUrl(this.endpoint);
            const t = this._dispatcher.headers;
            const i = this._dispatcher.wsExtensions;
            const n = this._getCookies();
            const o = this._dispatcher.tls;

            const s = {
                extensions: i,
                headers: t,
                proxy: this._proxy,
                tls: o
            };

            return "" !== n && (s.headers.Cookie = n), Faye.WebSocket ? new Faye.WebSocket
              .Client(e, [], s) : Faye.ENV.MozWebSocket ? new MozWebSocket(e) : Faye.ENV
              .WebSocket ? new WebSocket(e) : void 0
        },
        _ping() {
            this._socket && (this._socket.send("[]"), this.addTimeout("ping", this
              ._dispatcher.timeout / 2, this._ping, this))
        }
    }), {
        PROTOCOLS: {
            "http:": "ws:",
            "https:": "wss:"
        },
        create(e, t) {
            const i = e.transports.websocket = e.transports.websocket || {};
            return i[t.href] = i[t.href] || new this(e, t), i[t.href]
        },
        getSocketUrl(e) {
            return e = Faye.copyObject(e), e.protocol = this.PROTOCOLS[e.protocol], Faye.URI
              .stringify(e)
        },
        isUsable(e, t, i, n) {
            this.create(e, t)
              .isUsable(i, n)
        }
    }), Faye.extend(Faye.Transport.WebSocket.prototype, Faye.Deferrable), Faye.Transport.register(
      "websocket", Faye.Transport.WebSocket), Faye.Event && void 0 !== Faye.ENV.onbeforeunload &&
    Faye.Event.on(Faye.ENV, "beforeunload", () => {
        Faye.Transport.WebSocket._unloaded = !0
    }), Faye.Transport.EventSource = Faye.extend(Faye.Class(Faye.Transport, {
        initialize(e, t) {
            if (Faye.Transport.prototype.initialize.call(this, e, t), !Faye.ENV
              .EventSource) return this.setDeferredStatus("failed");
            this._xhr = new Faye.Transport.XHR(e, t), t = Faye.copyObject(t), t
              .pathname += `/${e.clientId}`;
            const i = new EventSource(Faye.URI.stringify(t));
            const n = this;
            i.onopen = () => {
                n._everConnected = !0, n.setDeferredStatus("succeeded")
            }, i.onerror = () => {
                n._everConnected ? n._handleError([]) : (n.setDeferredStatus(
                  "failed"), i.close())
            }, i.onmessage = e => {
                n._receive(JSON.parse(e.data))
            }, this._socket = i
        },
        close() {
            this._socket && (this._socket.onopen = this._socket.onerror = this._socket
              .onmessage = null, this._socket.close(), delete this._socket)
        },
        isUsable(e, t) {
            this.callback(() => {
                e.call(t, !0)
            }), this.errback(() => {
                e.call(t, !1)
            })
        },
        encode(e) {
            return this._xhr.encode(e)
        },
        request(e) {
            return this._xhr.request(e)
        }
    }), {
        isUsable(e, t, i, n) {
            const o = e.clientId;
            return o ? void Faye.Transport.XHR.isUsable(e, t, function (o) {
                return o ? void this.create(e, t)
                  .isUsable(i, n) : i.call(n, !1)
            }, this) : i.call(n, !1)
        },
        create(e, t) {
            const i = e.transports.eventsource = e.transports.eventsource || {};
            const n = e.clientId;
            t = Faye.copyObject(t), t.pathname += `/${n || ""}`;
            const o = Faye.URI.stringify(t);
            return i[o] = i[o] || new this(e, t), i[o]
        }
    }), Faye.extend(Faye.Transport.EventSource.prototype, Faye.Deferrable), Faye.Transport.register(
      "eventsource", Faye.Transport.EventSource), Faye.Transport.XHR = Faye.extend(Faye.Class(Faye
      .Transport, {
        encode(e) {
            return Faye.toJSON(e)
        },
        request(e) {
            const t = this.endpoint.href;

            let i = Faye.ENV.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") :
              new XMLHttpRequest;

            const n = this;
            i.open("POST", t, !0), i.setRequestHeader("Content-Type", "application/json"),
              i.setRequestHeader("Pragma", "no-cache"), i.setRequestHeader(
              "X-Requested-With", "XMLHttpRequest");
            const o = this._dispatcher.headers;
            for (const s in o) o.hasOwnProperty(s) && i.setRequestHeader(s, o[s]);
            const a = () => {
                i.abort()
            };
            return void 0 !== Faye.ENV.onbeforeunload && Faye.Event.on(Faye.ENV,
              "beforeunload", a), i.onreadystatechange = () => {
                if (i && 4 === i.readyState) {
                    let t = null;
                    const o = i.status;
                    const s = i.responseText;
                    const r = o >= 200 && 300 > o || 304 === o || 1223 === o;
                    if (void 0 !== Faye.ENV.onbeforeunload && Faye.Event.detach(Faye
                      .ENV, "beforeunload", a), i.onreadystatechange =
                      () => {}, i = null, !r) return n._handleError(e);
                    try {
                        t = JSON.parse(s)
                    } catch (l) {}
                    t ? n._receive(t) : n._handleError(e)
                }
            }, i.send(this.encode(e)), i;
        }
    }), {
        isUsable(e, t, i, n) {
            i.call(n, Faye.URI.isSameOrigin(t))
        }
    }), Faye.Transport.register("long-polling", Faye.Transport.XHR), Faye.Transport.CORS = Faye
      .extend(Faye.Class(Faye.Transport, {
          encode(e) {
              return `message=${encodeURIComponent(Faye.toJSON(e))}`;
          },
          request(e) {
              let t;
              const i = Faye.ENV.XDomainRequest ? XDomainRequest : XMLHttpRequest;
              let n = new i;
              const o = this._dispatcher.headers;
              const s = this;
              if (n.open("POST", Faye.URI.stringify(this.endpoint), !0), n
                .setRequestHeader) {
                  n.setRequestHeader("Pragma", "no-cache");
                  for (t in o) o.hasOwnProperty(t) && n.setRequestHeader(t, o[t])
              }
              const a = () => n ? (n.onload = n.onerror = n.ontimeout = n.onprogress = null,
                void(n = null)) : !1;
              return n.onload = () => {
                  let t = null;
                  try {
                      t = JSON.parse(n.responseText)
                  } catch (i) {}
                  a(), t ? s._receive(t) : s._handleError(e)
              }, n.onerror = n.ontimeout = () => {
                  a(), s._handleError(e)
              }, n.onprogress = () => {}, n.send(this.encode(e)), n;
          }
      }), {
          isUsable(e, t, i, n) {
              if (Faye.URI.isSameOrigin(t)) return i.call(n, !1);
              if (Faye.ENV.XDomainRequest) return i.call(n, t.protocol === Faye.ENV.location
                .protocol);
              if (Faye.ENV.XMLHttpRequest) {
                  const o = new Faye.ENV.XMLHttpRequest;
                  return i.call(n, void 0 !== o.withCredentials)
              }
              return i.call(n, !1)
          }
      }), Faye.Transport.register("cross-origin-long-polling", Faye.Transport.CORS), Faye.Transport
      .JSONP = Faye.extend(Faye.Class(Faye.Transport, {
        encode(e) {
            const t = Faye.copyObject(this.endpoint);
            return t.query.message = Faye.toJSON(e), t.query.jsonp = `__jsonp${Faye
  .Transport.JSONP._cbCount}__`, Faye.URI.stringify(t);
        },
        request(e) {
            const t = document.getElementsByTagName("head")[0];
            const i = document.createElement("script");
            const n = Faye.Transport.JSONP.getCallbackName();
            const o = Faye.copyObject(this.endpoint);
            const s = this;
            o.query.message = Faye.toJSON(e), o.query.jsonp = n;
            const a = () => {
                if (!Faye.ENV[n]) return !1;
                Faye.ENV[n] = void 0;
                try {
                    delete Faye.ENV[n]
                } catch (e) {}
                i.parentNode.removeChild(i)
            };
            return Faye.ENV[n] = e => {
                a(), s._receive(e)
            }, i.type = "text/javascript", i.src = Faye.URI.stringify(o), t
              .appendChild(i), i.onerror = () => {
                a(), s._handleError(e)
            }, {
                abort: a
            };
        }
    }), {
        _cbCount: 0,
        getCallbackName() {
            return this._cbCount += 1, `__jsonp${this._cbCount}__`;
        },
        isUsable(e, t, i, n) {
            i.call(n, !0)
        }
    }), Faye.Transport.register("callback-polling", Faye.Transport.JSONP)
})(), !((e, t) => {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" ==
    typeof define && define.amd ? define(["exports"], t) : t(e.L = {})
})(this, e => {
    function t(e) {
        let t;
        let i;
        let n;
        let o;
        for (i = 1, n = arguments.length; n > i; i++) {
            o = arguments[i];
            for (t in o) e[t] = o[t]
        }
        return e
    }

    function i(e, t) {
        const i = Array.prototype.slice;
        if (e.bind) return e.bind(...i.call(arguments, 1));
        const n = i.call(arguments, 2);
        return function(...args) {
            return e.apply(t, n.length ? n.concat(i.call(args)) : args);
        };
    }

    function n(e) {
        return e._leaflet_id = e._leaflet_id || ++ii, e._leaflet_id
    }

    function o(e, t, i) {
        let n;
        let o;
        let s;
        let a;
        return a = () => {
            n = !1, o && (s.apply(i, o), o = !1)
        }, s = function(...args) {
            n ? o = args : (e.apply(i, args), setTimeout(a, t), n = !0)
        };
    }

    function s(e, t, i) {
        const n = t[1];
        const o = t[0];
        const s = n - o;
        return e === n && i ? e : ((e - o) % s + s) % s + o
    }

    function a() {
        return !1
    }

    function r(e, t) {
        const i = 10 ** (void 0 === t ? 6 : t);
        return Math.round(e * i) / i
    }

    function l(e) {
        return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
    }

    function c(e) {
        return l(e)
          .split(/\s+/)
    }

    function u(e, t) {
        e.hasOwnProperty("options") || (e.options = e.options ? ti(e.options) : {});
        for (const i in t) e.options[i] = t[i];
        return e.options
    }

    function d(e, t, i) {
        const n = [];
        for (const o in e) n.push(`${encodeURIComponent(i ? o.toUpperCase() : o)}=${encodeURIComponent(e[o])}`);
        return (t && t.includes("?") ? "&" : "?") + n.join("&");
    }

    function h(e, t) {
        return e.replace(ni, (e, i) => {
            let n = t[i];
            if (void 0 === n) throw new Error(`No value provided for variable ${e}`);
            return "function" == typeof n && (n = n(t)), n
        });
    }

    function p(e, t) {
        for (let i = 0; i < e.length; i++)
            if (e[i] === t) return i;
        return -1
    }

    function m(e) {
        return window[`webkit${e}`] || window[`moz${e}`] || window[`ms${e}`];
    }

    function f(e) {
        const t = +new Date;
        const i = Math.max(0, 16 - (t - ai));
        return ai = t + i, window.setTimeout(e, i)
    }

    function _(e, t, n) {
        return n && ri === f ? (e.call(t), void 0) : ri.call(window, i(e, t))
    }

    function g(e) {
        e && li.call(window, e)
    }

    function v() {}

    function b(e) {
        if ("undefined" != typeof L && L && L.Mixin) {
            e = oi(e) ? e : [e];
            for (let t = 0; t < e.length; t++) e[t] === L.Mixin.Events && console.warn(
              "Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",
              (new Error)
                .stack)
        }
    }

    function y(e, t, i) {
        this.x = i ? Math.round(e) : e, this.y = i ? Math.round(t) : t
    }

    function w(e, t, i) {
        return e instanceof y ? e : oi(e) ? new y(e[0], e[1]) : void 0 === e || null === e ? e :
          "object" == typeof e && "x" in e && "y" in e ? new y(e.x, e.y) : new y(e, t, i)
    }

    function k(e, t) {
        if (e)
            for (let i = t ? [e, t] : e, n = 0, o = i.length; o > n; n++) this.extend(i[n])
    }

    function x(e, t) {
        return !e || e instanceof k ? e : new k(e, t)
    }

    function C(e, t) {
        if (e)
            for (let i = t ? [e, t] : e, n = 0, o = i.length; o > n; n++) this.extend(i[n])
    }

    function z(e, t) {
        return e instanceof C ? e : new C(e, t)
    }

    function T(e, t, i) {
        if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LatLng object: (${e}, ${t})`);
        this.lat = +e, this.lng = +t, void 0 !== i && (this.alt = +i)
    }

    function S(e, t, i) {
        return e instanceof T ? e : oi(e) && "object" != typeof e[0] ? 3 === e.length ? new T(e[0], e[
          1], e[2]) : 2 === e.length ? new T(e[0], e[1]) : null : void 0 === e || null === e ?
          e : "object" == typeof e && "lat" in e ? new T(e.lat, "lng" in e ? e.lng : e.lon, e.alt) :
            void 0 === t ? null : new T(e, t, i)
    }

    function A(e, t, i, n) {
        return oi(e) ? (this._a = e[0], this._b = e[1], this._c = e[2], void(this._d = e[3])) : (this
          ._a = e, this._b = t, this._c = i, this._d = n, void 0)
    }

    function E(e, t, i, n) {
        return new A(e, t, i, n)
    }

    function P(e) {
        return document.createElementNS("http://www.w3.org/2000/svg", e)
    }

    function I(e, t) {
        let i;
        let n;
        let o;
        let s;
        let a;
        let r;
        let l = "";
        for (i = 0, o = e.length; o > i; i++) {
            for (n = 0, s = (a = e[i])
              .length; s > n; n++) r = a[n], l += `${(n ? "L" : "M") + r.x} ${r.y}`;
            l += t ? Ji ? "z" : "x" : ""
        }
        return l || "M0 0"
    }

    function M(e) {
        return navigator.userAgent.toLowerCase().includes(e);
    }

    function j(e, t, i, n) {
        return "touchstart" === t ? N(e, i, n) : "touchmove" === t ? B(e, i, n) : "touchend" === t &&
          H(e, i, n), this
    }

    function D(e, t, i) {
        const n = e[`_leaflet_${t}${i}`];
        return "touchstart" === t ? e.removeEventListener(en, n, !1) : "touchmove" === t ? e
          .removeEventListener(tn, n, !1) : "touchend" === t && (e.removeEventListener(nn, n, !1), e
          .removeEventListener(on, n, !1)), this
    }

    function N(e, t, n) {
        const o = i(e => {
            if ("mouse" !== e.pointerType && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e
              .MSPOINTER_TYPE_MOUSE) {
                if (!(!sn.includes(e.target.tagName))) return;
                kt(e)
            }
            F(e, t)
        });
        e[`_leaflet_touchstart${n}`] = o, e.addEventListener(en, o, !1), rn || (document
          .documentElement.addEventListener(en, O, !0), document.documentElement
          .addEventListener(tn, R, !0), document.documentElement.addEventListener(nn, $, !0),
          document.documentElement.addEventListener(on, $, !0), rn = !0)
    }

    function O(e) {
        an[e.pointerId] = e, ln++
    }

    function R(e) {
        an[e.pointerId] && (an[e.pointerId] = e)
    }

    function $({pointerId}) {
        delete an[pointerId], ln--
    }

    function F(e, t) {
        e.touches = [];
        for (const i in an) e.touches.push(an[i]);
        e.changedTouches = [e], t(e)
    }

    function B(e, t, i) {
        const n = e => {
            (e.pointerType !== e.MSPOINTER_TYPE_MOUSE && "mouse" !== e.pointerType || 0 !== e
              .buttons) && F(e, t)
        };
        e[`_leaflet_touchmove${i}`] = n, e.addEventListener(tn, n, !1)
    }

    function H(e, t, i) {
        const n = e => {
            F(e, t)
        };
        e[`_leaflet_touchend${i}`] = n, e.addEventListener(nn, n, !1), e.addEventListener(on, n, !1)
    }

    function W(e, t, i) {
        function n(e) {
            let t;
            if (qi) {
                if (!Ci || "mouse" === e.pointerType) return;
                t = ln
            } else t = e.touches.length;
            if (!(t > 1)) {
                const i = Date.now();
                const n = i - (s || i);
                a = e.touches ? e.touches[0] : e, r = n > 0 && l >= n, s = i
            }
        }

        function o({pointerType}) {
            if (r && !a.cancelBubble) {
                if (qi) {
                    if (!Ci || "mouse" === pointerType) return;
                    let i;
                    let n;
                    const o = {};
                    for (n in a) i = a[n], o[n] = i && i.bind ? i.bind(a) : i;
                    a = o
                }
                a.type = "dblclick", t(a), s = null
            }
        }
        var s;
        var a;
        var r = !1;
        var l = 250;
        return e[dn + cn + i] = n, e[dn + un + i] = o, e[`${dn}dblclick${i}`] = t, e.addEventListener(
          cn, n, !1), e.addEventListener(un, o, !1), e.addEventListener("dblclick", t, !1), this;
    }

    function V(e, t) {
        const i = e[dn + cn + t];
        const n = e[dn + un + t];
        const o = e[`${dn}dblclick${t}`];
        return e.removeEventListener(cn, i, !1), e.removeEventListener(un, n, !1), Ci || e
          .removeEventListener("dblclick", o, !1), this
    }

    function q(e) {
        return "string" == typeof e ? document.getElementById(e) : e
    }

    function U(e, t) {
        let i = e.style[t] || e.currentStyle && e.currentStyle[t];
        if ((!i || "auto" === i) && document.defaultView) {
            const n = document.defaultView.getComputedStyle(e, null);
            i = n ? n[t] : null
        }
        return "auto" === i ? null : i
    }

    function Z(e, t, i) {
        const n = document.createElement(e);
        return n.className = t || "", i && i.appendChild(n), n
    }

    function G(e) {
        const t = e.parentNode;
        t && t.removeChild(e)
    }

    function K(e) {
        for (; e.firstChild;) e.removeChild(e.firstChild)
    }

    function Y(e) {
        const t = e.parentNode;
        t && t.lastChild !== e && t.appendChild(e)
    }

    function J(e) {
        const t = e.parentNode;
        t && t.firstChild !== e && t.insertBefore(e, t.firstChild)
    }

    function Q(e, t) {
        if (void 0 !== e.classList) return e.classList.contains(t);
        const i = it(e);
        return i.length > 0 && new RegExp(`(^|\\s)${t}(\\s|$)`)
          .test(i);
    }

    function X(e, t) {
        if (void 0 !== e.classList)
            for (let i = c(t), n = 0, o = i.length; o > n; n++) e.classList.add(i[n]);
        else if (!Q(e, t)) {
            const s = it(e);
            tt(e, (s ? `${s} ` : "") + t)
        }
    }

    function et(e, t) {
        void 0 !== e.classList ? e.classList.remove(t) : tt(e, l((` ${it(e)} `)
          .replace(` ${t} `, " ")))
    }

    function tt(e, t) {
        void 0 === e.className.baseVal ? e.className = t : e.className.baseVal = t
    }

    function it(e) {
        return e.correspondingElement && (e = e.correspondingElement), void 0 === e.className
          .baseVal ? e.className : e.className.baseVal
    }

    function nt(e, t) {
        "opacity" in e.style ? e.style.opacity = t : "filter" in e.style && ot(e, t)
    }

    function ot({filters, style}, t) {
        let i = !1;
        const n = "DXImageTransform.Microsoft.Alpha";
        try {
            i = filters.item(n)
        } catch (e) {
            if (1 === t) return
        }
        t = Math.round(100 * t), i ? (i.Enabled = 100 !== t, i.Opacity = t) : style.filter +=
          ` progid:${n}(opacity=${t})`
    }

    function st(e) {
        for (let t = document.documentElement.style, i = 0; i < e.length; i++)
            if (e[i] in t) return e[i];
        return !1
    }

    function at({style}, t, i) {
        const n = t || new y(0, 0);
        style[hn] = (Oi ? `translate(${n.x}px,${n.y}px)` : `translate3d(${n.x}px,${n.y}px,0)`) + (i ? ` scale(${i})` : "")
    }

    function rt(e, t) {
        e._leaflet_pos = t, Fi ? at(e, t) : (e.style.left = `${t.x}px`, e.style.top = `${t.y}px`)
    }

    function lt({_leaflet_pos}) {
        return _leaflet_pos || new y(0, 0);
    }

    function ct() {
        ft(window, "dragstart", kt)
    }

    function ut() {
        _t(window, "dragstart", kt)
    }

    function dt(e) {
        for (; - 1 === e.tabIndex;) e = e.parentNode;
        e.style && (ht(), _n = e, gn = e.style.outline, e.style.outline = "none", ft(window,
          "keydown", ht))
    }

    function ht() {
        _n && (_n.style.outline = gn, _n = void 0, gn = void 0, _t(window, "keydown", ht))
    }

    function pt(e) {
        do e = e.parentNode; while (!(e.offsetWidth && e.offsetHeight || e === document.body));
        return e
    }

    function mt(e) {
        const t = e.getBoundingClientRect();
        return {
            x: t.width / e.offsetWidth || 1,
            y: t.height / e.offsetHeight || 1,
            boundingClientRect: t
        }
    }

    function ft(e, t, i, n) {
        if ("object" == typeof t)
            for (const o in t) gt(e, o, t[o], i);
        else
            for (let s = 0,
                a = (t = c(t))
                  .length; a > s; s++) gt(e, t[s], i, n);
        return this
    }

    function _t(e, t, i, n) {
        if ("object" == typeof t)
            for (const o in t) vt(e, o, t[o], i);
        else if (t)
            for (let s = 0,
                a = (t = c(t))
                  .length; a > s; s++) vt(e, t[s], i, n);
        else {
            for (const r in e[yn]) vt(e, r, e[yn][r]);
            delete e[yn]
        }
        return this
    }

    function gt(e, t, i, o) {
        const s = t + n(i) + (o ? `_${n(o)}` : "");
        if (e[yn] && e[yn][s]) return this;
        let a = t => i.call(o || e, t || window.event);
        const r = a;
        qi && 0 === t.indexOf("touch") ? j(e, t, a, s) : !Ui || "dblclick" !== t || !W || qi && Ii ?
          "addEventListener" in e ? "mousewheel" === t ? e.addEventListener("onwheel" in e ?
            "wheel" : "mousewheel", a, !1) : "mouseenter" === t || "mouseleave" === t ? (a =
            t => {
                t = t || window.event, At(e, t) && r(t)
            }, e.addEventListener("mouseenter" === t ? "mouseover" : "mouseout", a, !1)) : (
            "click" === t && Ti && (a = e => {
                Et(e, r)
            }), e.addEventListener(t, a, !1)) : "attachEvent" in e && e.attachEvent(`on${t}`, a) :
          W(e, a, s), e[yn] = e[yn] || {}, e[yn][s] = a
    }

    function vt(e, t, i, o) {
        const s = t + n(i) + (o ? `_${n(o)}` : "");
        const a = e[yn] && e[yn][s];
        return a ? (qi && 0 === t.indexOf("touch") ? D(e, t, s) : !Ui || "dblclick" !== t || !V ||
          qi && Ii ? "removeEventListener" in e ? "mousewheel" === t ? e.removeEventListener(
          "onwheel" in e ? "wheel" : "mousewheel", a, !1) : e.removeEventListener(
          "mouseenter" === t ? "mouseover" : "mouseleave" === t ? "mouseout" : t, a, !1) :
          "detachEvent" in e && e.detachEvent(`on${t}`, a) : V(e, s), e[yn][s] = null, void 0) :
          this;
    }

    function bt(e) {
        return e.stopPropagation ? e.stopPropagation() : e.originalEvent ? e.originalEvent
          ._stopped = !0 : e.cancelBubble = !0, St(e), this
    }

    function yt(e) {
        return gt(e, "mousewheel", bt), this
    }

    function wt(e) {
        return ft(e, "mousedown touchstart dblclick", bt), gt(e, "click", Tt), this
    }

    function kt(e) {
        return e.preventDefault ? e.preventDefault() : e.returnValue = !1, this
    }

    function xt(e) {
        return kt(e), bt(e), this
    }

    function Ct({clientX, clientY}, t) {
        if (!t) return new y(clientX, clientY);
        const i = mt(t);
        const n = i.boundingClientRect;
        return new y((clientX - n.left) / i.x - t.clientLeft, (clientY - n.top) / i.y - t
          .clientTop);
    }

    function zt(e) {
        return Ci ? e.wheelDeltaY / 2 : e.deltaY && 0 === e.deltaMode ? -e.deltaY / wn : e.deltaY &&
        1 === e.deltaMode ? 20 * -e.deltaY : e.deltaY && 2 === e.deltaMode ? 60 * -e.deltaY : e
          .deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail &&
        Math.abs(e.detail) < 32765 ? 20 * -e.detail : e.detail ? 60 * (e.detail / -32765) : 0
    }

    function Tt({type}) {
        kn[type] = !0
    }

    function St({type}) {
        const t = kn[type];
        return kn[type] = !1, t;
    }

    function At(e, {relatedTarget}) {
        let i = relatedTarget;
        if (!i) return !0;
        try {
            for (; i && i !== e;) i = i.parentNode
        } catch (e) {
            return !1
        }
        return i !== e
    }

    function Et(e, t) {
        const i = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp;
        const n = vn && i - vn;
        n && n > 100 && 500 > n || e.target._simulatedClick && !e._simulated ? xt(e) : (vn = i, t(e))
    }

    function Pt(e, t) {
        if (!t || !e.length) return e.slice();
        const i = t * t;
        return e = Dt(e, i), e = Mt(e, i)
    }

    function It(e, t, i) {
        return Math.sqrt($t(e, t, i, !0))
    }

    function Mt(e, t) {
        const i = e.length;
        const n = new(typeof Uint8Array != `${void 0}` ? Uint8Array : Array)(i);
        n[0] = n[i - 1] = 1, jt(e, n, t, 0, i - 1);
        let o;
        const s = [];
        for (o = 0; i > o; o++) n[o] && s.push(e[o]);
        return s
    }

    function jt(e, t, i, n, o) {
        let s;
        let a;
        let r;
        let l = 0;
        for (a = n + 1; o - 1 >= a; a++)(r = $t(e[a], e[n], e[o], !0)) > l && (s = a, l = r);
        l > i && (t[s] = 1, jt(e, t, i, n, s), jt(e, t, i, s, o))
    }

    function Dt(e, t) {
        for (var i = [e[0]], n = 1, o = 0, s = e.length; s > n; n++) Rt(e[n], e[o]) > t && (i.push(e[
          n]), o = n);
        return s - 1 > o && i.push(e[s - 1]), i
    }

    function Nt(e, t, i, n, o) {
        let s;
        let a;
        let r;
        let l = n ? jn : Ot(e, i);
        let c = Ot(t, i);
        for (jn = c;;) {
            if (!(l | c)) return [e, t];
            if (l & c) return !1;
            r = Ot(a = Lt(e, t, s = l || c, i, o), i), s === l ? (e = a, l = r) : (t = a, c = r)
        }
    }

    function Lt(e, t, i, {min, max}, o) {
        let s;
        let a;
        const r = t.x - e.x;
        const l = t.y - e.y;
        const c = min;
        const u = max;
        return 8 & i ? (s = e.x + r * (u.y - e.y) / l, a = u.y) : 4 & i ? (s = e.x + r * (c.y - e.y) /
          l, a = c.y) : 2 & i ? (s = u.x, a = e.y + l * (u.x - e.x) / r) : 1 & i && (s = c.x,
          a = e.y + l * (c.x - e.x) / r), new y(s, a, o)
    }

    function Ot(e, {min, max}) {
        let i = 0;
        return e.x < min.x ? i |= 1 : e.x > max.x && (i |= 2), e.y < min.y ? i |= 4 : e.y > max.y && (i |= 8), i;
    }

    function Rt(e, t) {
        const i = t.x - e.x;
        const n = t.y - e.y;
        return i * i + n * n
    }

    function $t(e, t, i, n) {
        let o;
        let s = t.x;
        let a = t.y;
        let r = i.x - s;
        let l = i.y - a;
        const c = r * r + l * l;
        return c > 0 && ((o = ((e.x - s) * r + (e.y - a) * l) / c) > 1 ? (s = i.x, a = i.y) : o > 0 &&
          (s += r * o, a += l * o)), r = e.x - s, l = e.y - a, n ? r * r + l * l : new y(s, a)
    }

    function Ft(e) {
        return !oi(e[0]) || "object" != typeof e[0][0] && void 0 !== e[0][0]
    }

    function Bt(e) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), Ft(e)
    }

    function Ht(e, t, i) {
        let n;
        let o;
        let s;
        let a;
        let r;
        let l;
        let c;
        let u;
        let d;
        const h = [1, 4, 2, 8];
        for (o = 0, c = e.length; c > o; o++) e[o]._code = Ot(e[o], t);
        for (a = 0; 4 > a; a++) {
            for (u = h[a], n = [], o = 0, s = (c = e.length) - 1; c > o; s = o++) r = e[o], l = e[s],
              r._code & u ? l._code & u || ((d = Lt(l, r, u, t, i))
                ._code = Ot(d, t), n.push(d)) : (l._code & u && ((d = Lt(l, r, u, t, i))
                ._code = Ot(d, t), n.push(d)), n.push(r));
            e = n
        }
        return e
    }

    function Wt(e, t) {
        let i;
        let n;
        let o;
        let s;
        const a = "Feature" === e.type ? e.geometry : e;
        const r = a ? a.coordinates : null;
        const l = [];
        const c = t && t.pointToLayer;
        const u = t && t.coordsToLatLng || Vt;
        if (!r && !a) return null;
        switch (a.type) {
            case "Point":
                return i = u(r), c ? c(e, i) : new Xn(i);
            case "MultiPoint":
                for (o = 0, s = r.length; s > o; o++) i = u(r[o]), l.push(c ? c(e, i) : new Xn(i));
                return new Kn(l);
            case "LineString":
            case "MultiLineString":
                return n = qt(r, "LineString" === a.type ? 0 : 1, u), new no(n, t);
            case "Polygon":
            case "MultiPolygon":
                return n = qt(r, "Polygon" === a.type ? 1 : 2, u), new oo(n, t);
            case "GeometryCollection":
                for (o = 0, s = a.geometries.length; s > o; o++) {
                    const d = Wt({
                        geometry: a.geometries[o],
                        type: "Feature",
                        properties: e.properties
                    }, t);
                    d && l.push(d)
                }
                return new Kn(l);
            default:
                throw new Error("Invalid GeoJSON object.")
        }
    }

    function Vt(e) {
        return new T(e[1], e[0], e[2])
    }

    function qt(e, t, i) {
        for (var n, o = [], s = 0, a = e.length; a > s; s++) n = t ? qt(e[s], t - 1, i) : (i || Vt)(e[
          s]), o.push(n);
        return o
    }

    function Ut({alt, lng, lat}, t) {
        return t = "number" == typeof t ? t : 6, void 0 !== alt ? [r(lng, t), r(lat, t), r(alt, t)] : [r(lng, t), r(lat, t)];
    }

    function Zt(e, t, i, n) {
        for (var o = [], s = 0, a = e.length; a > s; s++) o.push(t ? Zt(e[s], t - 1, i, n) : Ut(e[s],
          n));
        return !t && i && o.push(o[0]), o
    }

    function Gt({feature}, i) {
        return feature ? t({}, feature, {
            geometry: i
        }) : Kt(i);
    }

    function Kt(e) {
        return "Feature" === e.type || "FeatureCollection" === e.type ? e : {
            type: "Feature",
            properties: {},
            geometry: e
        }
    }

    function Yt(e, t) {
        return new so(e, t)
    }

    function Jt(e, t) {
        return new _o(e, t)
    }

    function Qt(e) {
        return Yi ? new bo(e) : null
    }

    function Xt(e) {
        return Ji || Qi ? new xo(e) : null
    }
    const ei = Object.freeze;
    Object.freeze = e => e;

    var ti = Object.create || (() => {
          function e() {}
          return t => (e.prototype = t, new e);
      })();

    var ii = 0;
    var ni = /\{ *([\w_-]+) *\}/g;
    var oi = Array.isArray || (e => "[object Array]" === Object.prototype.toString.call(e));
    const si = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
    var ai = 0;
    var ri = window.requestAnimationFrame || m("RequestAnimationFrame") || f;

    var li = window.cancelAnimationFrame || m("CancelAnimationFrame") || m(
      "CancelRequestAnimationFrame") || (e => {
        window.clearTimeout(e)
    });

    const ci = (Object.freeze || Object)({
        freeze: ei,
        extend: t,
        create: ti,
        bind: i,
        lastId: ii,
        stamp: n,
        throttle: o,
        wrapNum: s,
        falseFn: a,
        formatNum: r,
        trim: l,
        splitWords: c,
        setOptions: u,
        getParamString: d,
        template: h,
        isArray: oi,
        indexOf: p,
        emptyImageUrl: si,
        requestFn: ri,
        cancelFn: li,
        requestAnimFrame: _,
        cancelAnimFrame: g
    });

    v.extend = function (e) {
        const i = function(...args) {
              this.initialize && this.initialize(...args), this.callInitHooks()
          };

        const n = i.__super__ = this.prototype;
        const o = ti(n);
        o.constructor = i, i.prototype = o;
        for (const s in this) this.hasOwnProperty(s) && "prototype" !== s && "__super__" !== s && (
          i[s] = this[s]);
        return e.statics && (t(i, e.statics), delete e.statics), e.includes && (b(e.includes), t(...[o].concat(e.includes)), delete e.includes), o.options && (e
          .options = t(ti(o.options), e.options)), t(o, e), o._initHooks = [], o
          .callInitHooks = function () {
            if (!this._initHooksCalled) {
                n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0;
                for (let e = 0, t = o._initHooks.length; t > e; e++) o._initHooks[e].call(
                  this)
            }
        }, i;
    }, v.include = function (e) {
        return t(this.prototype, e), this
    }, v.mergeOptions = function (e) {
        return t(this.prototype.options, e), this
    }, v.addInitHook = function (e) {
        const t = Array.prototype.slice.call(arguments, 1);

        const i = "function" == typeof e ? e : function () {
            this[e](...t)
        };

        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype
          ._initHooks.push(i), this
    };
    const ui = {
        on(e, t, i) {
            if ("object" == typeof e)
                for (const n in e) this._on(n, e[n], t);
            else
                for (let o = 0,
                    s = (e = c(e))
                      .length; s > o; o++) this._on(e[o], t, i);
            return this
        },
        off(e, t, i) {
            if (e)
                if ("object" == typeof e)
                    for (const n in e) this._off(n, e[n], t);
                else
                    for (let o = 0,
                        s = (e = c(e))
                          .length; s > o; o++) this._off(e[o], t, i);
            else delete this._events;
            return this
        },
        _on(e, t, i) {
            this._events = this._events || {};
            let n = this._events[e];
            n || (n = [], this._events[e] = n), i === this && (i = void 0);
            for (var o = {
                fn: t,
                ctx: i
            }, s = n, a = 0, r = s.length; r > a; a++)
                if (s[a].fn === t && s[a].ctx === i) return;
            s.push(o)
        },
        _off(e, t, i) {
            let n;
            let o;
            let s;
            if (this._events && (n = this._events[e]))
                if (t) {
                    if (i === this && (i = void 0), n)
                        for (o = 0, s = n.length; s > o; o++) {
                            const r = n[o];
                            if (r.ctx === i && r.fn === t) return r.fn = a, this
                              ._firingCount && (this._events[e] = n = n.slice()), void n
                              .splice(o, 1)
                        }
                } else {
                    for (o = 0, s = n.length; s > o; o++) n[o].fn = a;
                    delete this._events[e]
                }
        },
        fire(e, i, n) {
            if (!this.listens(e, n)) return this;
            const o = t({}, i, {
                type: e,
                target: this,
                sourceTarget: i && i.sourceTarget || this
            });
            if (this._events) {
                const s = this._events[e];
                if (s) {
                    this._firingCount = this._firingCount + 1 || 1;
                    for (let a = 0, r = s.length; r > a; a++) {
                        const l = s[a];
                        l.fn.call(l.ctx || this, o)
                    }
                    this._firingCount--
                }
            }
            return n && this._propagateEvent(o), this
        },
        listens(e, t) {
            const i = this._events && this._events[e];
            if (i && i.length) return !0;
            if (t)
                for (const n in this._eventParents)
                    if (this._eventParents[n].listens(e, t)) return !0;
            return !1
        },
        once(e, t, n) {
            if ("object" == typeof e) {
                for (const o in e) this.once(o, e[o], t);
                return this
            }
            const s = i(function () {
                this.off(e, t, n)
                  .off(e, s, n)
            }, this);
            return this.on(e, t, n)
              .on(e, s, n)
        },
        addEventParent(e) {
            return this._eventParents = this._eventParents || {}, this._eventParents[n(e)] =
              e, this
        },
        removeEventParent(e) {
            return this._eventParents && delete this._eventParents[n(e)], this
        },
        _propagateEvent(e) {
            for (const i in this._eventParents) this._eventParents[i].fire(e.type, t({
                layer: e.target,
                propagatedFrom: e.target
            }, e), !0)
        }
    };
    ui.addEventListener = ui.on, ui.removeEventListener = ui.clearAllEventListeners = ui.off, ui
      .addOneTimeEventListener = ui.once, ui.fireEvent = ui.fire, ui.hasEventListeners = ui.listens;
    const di = v.extend(ui);
    const hi = Math.trunc || (e => e > 0 ? Math.floor(e) : Math.ceil(e));
    y.prototype = {
        clone() {
            return new y(this.x, this.y)
        },
        add(e) {
            return this.clone()
              ._add(w(e))
        },
        _add(e) {
            return this.x += e.x, this.y += e.y, this
        },
        subtract(e) {
            return this.clone()
              ._subtract(w(e))
        },
        _subtract(e) {
            return this.x -= e.x, this.y -= e.y, this
        },
        divideBy(e) {
            return this.clone()
              ._divideBy(e)
        },
        _divideBy(e) {
            return this.x /= e, this.y /= e, this
        },
        multiplyBy(e) {
            return this.clone()
              ._multiplyBy(e)
        },
        _multiplyBy(e) {
            return this.x *= e, this.y *= e, this
        },
        scaleBy(e) {
            return new y(this.x * e.x, this.y * e.y)
        },
        unscaleBy(e) {
            return new y(this.x / e.x, this.y / e.y)
        },
        round() {
            return this.clone()
              ._round()
        },
        _round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        },
        floor() {
            return this.clone()
              ._floor()
        },
        _floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        },
        ceil() {
            return this.clone()
              ._ceil()
        },
        _ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        },
        trunc() {
            return this.clone()
              ._trunc()
        },
        _trunc() {
            return this.x = hi(this.x), this.y = hi(this.y), this
        },
        distanceTo(e) {
            const t = (e = w(e))
                .x - this.x;

            const i = e.y - this.y;
            return Math.sqrt(t * t + i * i)
        },
        equals(e) {
            return (e = w(e))
              .x === this.x && e.y === this.y
        },
        contains(e) {
            return e = w(e), Math.abs(e.x) <= Math.abs(this.x) && Math.abs(e.y) <= Math.abs(
              this.y)
        },
        toString() {
            return `Point(${r(this.x)}, ${r(this.y)})`;
        }
    }, k.prototype = {
        extend(e) {
            return e = w(e), this.min || this.max ? (this.min.x = Math.min(e.x, this.min.x),
              this.max.x = Math.max(e.x, this.max.x), this.min.y = Math.min(e.y, this
              .min.y), this.max.y = Math.max(e.y, this.max.y)) : (this.min = e
              .clone(), this.max = e.clone()), this
        },
        getCenter(e) {
            return new y((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, e)
        },
        getBottomLeft() {
            return new y(this.min.x, this.max.y)
        },
        getTopRight() {
            return new y(this.max.x, this.min.y)
        },
        getTopLeft() {
            return this.min
        },
        getBottomRight() {
            return this.max
        },
        getSize() {
            return this.max.subtract(this.min)
        },
        contains(e) {
            let t;
            let i;
            return (e = "number" == typeof e[0] || e instanceof y ? w(e) : x(
              e)) instanceof k ? (t = e.min, i = e.max) : t = i = e, t.x >= this.min.x && i
              .x <= this.max.x && t.y >= this.min.y && i.y <= this.max.y
        },
        intersects(e) {
            e = x(e);
            const t = this.min;
            const i = this.max;
            const n = e.min;
            const o = e.max;
            const s = o.x >= t.x && n.x <= i.x;
            const a = o.y >= t.y && n.y <= i.y;
            return s && a
        },
        overlaps(e) {
            e = x(e);
            const t = this.min;
            const i = this.max;
            const n = e.min;
            const o = e.max;
            const s = o.x > t.x && n.x < i.x;
            const a = o.y > t.y && n.y < i.y;
            return s && a
        },
        isValid() {
            return !(!this.min || !this.max)
        }
    }, C.prototype = {
        extend(e) {
            let t;
            let i;
            const n = this._southWest;
            const o = this._northEast;
            if (e instanceof T) t = e, i = e;
            else {
                if (!(e instanceof C)) return e ? this.extend(S(e) || z(e)) : this;
                if (t = e._southWest, i = e._northEast, !t || !i) return this
            }
            return n || o ? (n.lat = Math.min(t.lat, n.lat), n.lng = Math.min(t.lng, n.lng), o
              .lat = Math.max(i.lat, o.lat), o.lng = Math.max(i.lng, o.lng)) : (this
              ._southWest = new T(t.lat, t.lng), this._northEast = new T(i.lat, i.lng)),
              this
        },
        pad(e) {
            const t = this._southWest;
            const i = this._northEast;
            const n = Math.abs(t.lat - i.lat) * e;
            const o = Math.abs(t.lng - i.lng) * e;
            return new C(new T(t.lat - n, t.lng - o), new T(i.lat + n, i.lng + o))
        },
        getCenter() {
            return new T((this._southWest.lat + this._northEast.lat) / 2, (this._southWest
              .lng + this._northEast.lng) / 2)
        },
        getSouthWest() {
            return this._southWest
        },
        getNorthEast() {
            return this._northEast
        },
        getNorthWest() {
            return new T(this.getNorth(), this.getWest())
        },
        getSouthEast() {
            return new T(this.getSouth(), this.getEast())
        },
        getWest() {
            return this._southWest.lng
        },
        getSouth() {
            return this._southWest.lat
        },
        getEast() {
            return this._northEast.lng
        },
        getNorth() {
            return this._northEast.lat
        },
        contains(e) {
            e = "number" == typeof e[0] || e instanceof T || "lat" in e ? S(e) : z(e);
            let t;
            let i;
            const n = this._southWest;
            const o = this._northEast;
            return e instanceof C ? (t = e.getSouthWest(), i = e.getNorthEast()) : t = i = e,
            t.lat >= n.lat && i.lat <= o.lat && t.lng >= n.lng && i.lng <= o.lng
        },
        intersects(e) {
            e = z(e);
            const t = this._southWest;
            const i = this._northEast;
            const n = e.getSouthWest();
            const o = e.getNorthEast();
            const s = o.lat >= t.lat && n.lat <= i.lat;
            const a = o.lng >= t.lng && n.lng <= i.lng;
            return s && a
        },
        overlaps(e) {
            e = z(e);
            const t = this._southWest;
            const i = this._northEast;
            const n = e.getSouthWest();
            const o = e.getNorthEast();
            const s = o.lat > t.lat && n.lat < i.lat;
            const a = o.lng > t.lng && n.lng < i.lng;
            return s && a
        },
        toBBoxString() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(
              ",")
        },
        equals(e, t) {
            return !!e && (e = z(e), this._southWest.equals(e.getSouthWest(), t) && this
              ._northEast.equals(e.getNorthEast(), t))
        },
        isValid() {
            return !(!this._southWest || !this._northEast)
        }
    }, T.prototype = {
        equals(e, t) {
            return !!e && (e = S(e), Math.max(Math.abs(this.lat - e.lat), Math.abs(this.lng -
              e.lng)) <= (void 0 === t ? 1e-9 : t))
        },
        toString(e) {
            return `LatLng(${r(this.lat, e)}, ${r(this.lng, e)})`;
        },
        distanceTo(e) {
            return mi.distance(this, S(e))
        },
        wrap() {
            return mi.wrapLatLng(this)
        },
        toBounds(e) {
            const t = 180 * e / 40075017;
            const i = t / Math.cos(Math.PI / 180 * this.lat);
            return z([this.lat - t, this.lng - i], [this.lat + t, this.lng + i])
        },
        clone() {
            return new T(this.lat, this.lng, this.alt)
        }
    };

    const pi = {
          latLngToPoint(e, t) {
              const i = this.projection.project(e), n = this.scale(t);
              return this.transformation._transform(i, n)
          },
          pointToLatLng(e, t) {
              const i = this.scale(t), n = this.transformation.untransform(e, i);
              return this.projection.unproject(n)
          },
          project(e) {
              return this.projection.project(e)
          },
          unproject(e) {
              return this.projection.unproject(e)
          },
          scale(e) {
              return 256 * 2 ** e;
          },
          zoom(e) {
              return Math.log(e / 256) / Math.LN2
          },
          getProjectedBounds(e) {
              if (this.infinite) return null;
              const t = this.projection.bounds, i = this.scale(e);
              return new k(this.transformation.transform(t.min, i), this.transformation
                .transform(t.max, i))
          },
          infinite: !1,
          wrapLatLng({lng, lat, alt}) {
              const t = this.wrapLng ? s(lng, this.wrapLng, !0) : lng;
              return new T(this.wrapLat ? s(lat, this.wrapLat, !0) : lat, t, alt);
          },
          wrapLatLngBounds(e) {
              const t = e.getCenter(), i = this.wrapLatLng(t), n = t.lat - i.lat, o = t.lng - i.lng;
              if (0 === n && 0 === o) return e;
              const s = e.getSouthWest(), a = e.getNorthEast();
              return new C(new T(s.lat - n, s.lng - o), new T(a.lat - n, a.lng - o))
          }
      };

    var mi = t({}, pi, {
        wrapLng: [-180, 180],
        R: 6371e3,
        distance({lat, lng}, {lat, lng}) {
            const i = Math.PI / 180, n = lat * i, o = lat * i, s = Math.sin((lat - lat) * i / 2), a = Math.sin((lng - lng) * i / 2), r = s * s + Math.cos(n) * Math.cos(o) * a * a, l = 2 * Math.atan2(Math.sqrt(r), Math.sqrt(1 - r));
            return this.R * l
        }
    });

    const fi = {
        R: 6378137,
        MAX_LATITUDE: 85.0511287798,
        project({lat, lng}) {
            const t = Math.PI / 180, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, lat), -i), o = Math.sin(n * t);
            return new y(this.R * lng * t, this.R * Math.log((1 + o) / (1 - o)) / 2);
        },
        unproject(e) {
            const t = 180 / Math.PI;
            return new T((2 * Math.atan(Math.exp(e.y / this.R)) - Math.PI / 2) * t, e.x * t /
              this.R)
        },
        bounds: (() => {
            const e = 6378137 * Math.PI;
            return new k([-e, -e], [e, e])
        })()
    };

    A.prototype = {
        transform(e, t) {
            return this._transform(e.clone(), t)
        },
        _transform(e, t) {
            return t = t || 1, e.x = t * (this._a * e.x + this._b), e.y = t * (this._c * e.y +
              this._d), e
        },
        untransform(e, t) {
            return t = t || 1, new y((e.x / t - this._b) / this._a, (e.y / t - this._d) / this
              ._c)
        }
    };
    let _i;
    let gi;
    let vi;

    const bi = t({}, mi, {
          code: "EPSG:3857",
          projection: fi,
          transformation: (() => {
              const e = .5 / (Math.PI * fi.R);
              return E(e, .5, -e, .5)
          })()
      });

    const yi = t({}, bi, {
        code: "EPSG:900913"
    });

    const wi = document.documentElement.style;
    const ki = "ActiveXObject" in window;
    const xi = ki && !document.addEventListener;
    var Ci = "msLaunchUri" in navigator && !("documentMode" in document);
    const zi = M("webkit");
    var Ti = M("android");
    const Si = M("android 2") || M("android 3");
    const Ai = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
    const Ei = Ti && M("Google") && 537 > Ai && !("AudioNode" in window);
    const Pi = !!window.opera;
    var Ii = M("chrome");
    const Mi = M("gecko") && !zi && !Pi && !ki;
    const ji = !Ii && M("safari");
    const Di = M("phantom");
    const Ni = "OTransition" in wi;
    const Li = 0 === navigator.platform.indexOf("Win");
    var Oi = ki && "transition" in wi;
    const Ri = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !Si;
    const $i = "MozPerspective" in wi;
    var Fi = !window.L_DISABLE_3D && (Oi || Ri || $i) && !Ni && !Di;
    const Bi = "undefined" != typeof orientation || M("mobile");
    const Hi = Bi && zi;
    const Wi = Bi && Ri;
    const Vi = !window.PointerEvent && window.MSPointerEvent;
    var qi = !(!window.PointerEvent && !Vi);

    var Ui = !window.L_NO_TOUCH && (qi || "ontouchstart" in window || window.DocumentTouch &&
      document instanceof window.DocumentTouch);

    const Zi = Bi && Pi;
    const Gi = Bi && Mi;
    const Ki = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

    var Yi = !!document.createElement("canvas")
      .getContext;

    var Ji = !(!document.createElementNS || !P("svg")
      .createSVGRect);

    var Qi = !Ji && (() => {
        try {
            var e = document.createElement("div");
            e.innerHTML = '<v:shape adj="1"/>';
            const t = e.firstChild;
            return t.style.behavior = "url(#default#VML)", t && "object" == typeof t.adj
        } catch (e) {
            return !1
        }
    })();

    const Xi = (Object.freeze || Object)({
        ie: ki,
        ielt9: xi,
        edge: Ci,
        webkit: zi,
        android: Ti,
        android23: Si,
        androidStock: Ei,
        opera: Pi,
        chrome: Ii,
        gecko: Mi,
        safari: ji,
        phantom: Di,
        opera12: Ni,
        win: Li,
        ie3d: Oi,
        webkit3d: Ri,
        gecko3d: $i,
        any3d: Fi,
        mobile: Bi,
        mobileWebkit: Hi,
        mobileWebkit3d: Wi,
        msPointer: Vi,
        pointer: qi,
        touch: Ui,
        mobileOpera: Zi,
        mobileGecko: Gi,
        retina: Ki,
        canvas: Yi,
        svg: Ji,
        vml: Qi
    });

    var en = Vi ? "MSPointerDown" : "pointerdown";
    var tn = Vi ? "MSPointerMove" : "pointermove";
    var nn = Vi ? "MSPointerUp" : "pointerup";
    var on = Vi ? "MSPointerCancel" : "pointercancel";
    var sn = ["INPUT", "SELECT", "OPTION"];
    var an = {};
    var rn = !1;
    var ln = 0;
    var cn = Vi ? "MSPointerDown" : qi ? "pointerdown" : "touchstart";
    var un = Vi ? "MSPointerUp" : qi ? "pointerup" : "touchend";
    var dn = "_leaflet_";
    var hn = st(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
    const pn = st(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    const mn = "webkitTransition" === pn || "OTransition" === pn ? `${pn}End` : "transitionend";
    if ("onselectstart" in document) _i = () => {
        ft(window, "selectstart", kt)
    }, gi = () => {
        _t(window, "selectstart", kt)
    };
    else {
        const fn = st(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect",
            "msUserSelect"]);
        _i = () => {
            if (fn) {
                const e = document.documentElement.style;
                vi = e[fn], e[fn] = "none"
            }
        }, gi = () => {
            fn && (document.documentElement.style[fn] = vi, vi = void 0)
        }
    }
    var _n;
    var gn;
    var vn;

    const bn = (Object.freeze || Object)({
          TRANSFORM: hn,
          TRANSITION: pn,
          TRANSITION_END: mn,
          get: q,
          getStyle: U,
          create: Z,
          remove: G,
          empty: K,
          toFront: Y,
          toBack: J,
          hasClass: Q,
          addClass: X,
          removeClass: et,
          setClass: tt,
          getClass: it,
          setOpacity: nt,
          testProp: st,
          setTransform: at,
          setPosition: rt,
          getPosition: lt,
          disableTextSelection: _i,
          enableTextSelection: gi,
          disableImageDrag: ct,
          enableImageDrag: ut,
          preventOutline: dt,
          restoreOutline: ht,
          getSizedParentNode: pt,
          getScale: mt
      });

    var yn = "_leaflet_events";
    var wn = Li && Ii ? 2 * window.devicePixelRatio : Mi ? window.devicePixelRatio : 1;
    var kn = {};

    const xn = (Object.freeze || Object)({
        on: ft,
        off: _t,
        stopPropagation: bt,
        disableScrollPropagation: yt,
        disableClickPropagation: wt,
        preventDefault: kt,
        stop: xt,
        getMousePosition: Ct,
        getWheelDelta: zt,
        fakeStop: Tt,
        skipped: St,
        isExternalTarget: At,
        addListener: ft,
        removeListener: _t
    });

    const Cn = di.extend({
        run(e, t, i, n) {
            this.stop(), this._el = e, this._inProgress = !0, this._duration = i || .25,
              this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = lt(e),
              this._offset = t.subtract(this._startPos), this._startTime = +new Date,
              this.fire("start"), this._animate()
        },
        stop() {
            this._inProgress && (this._step(!0), this._complete())
        },
        _animate() {
            this._animId = _(this._animate, this), this._step()
        },
        _step(e) {
            const t = +new Date - this._startTime, i = 1e3 * this._duration;
            i > t ? this._runFrame(this._easeOut(t / i), e) : (this._runFrame(1), this
              ._complete())
        },
        _runFrame(e, t) {
            const i = this._startPos.add(this._offset.multiplyBy(e));
            t && i._round(), rt(this._el, i), this.fire("step")
        },
        _complete() {
            g(this._animId), this._inProgress = !1, this.fire("end")
        },
        _easeOut(e) {
            return 1 - (1 - e) ** this._easeOutPower;
        }
    });

    const zn = di.extend({
        options: {
            crs: bi,
            center: void 0,
            zoom: void 0,
            minZoom: void 0,
            maxZoom: void 0,
            layers: [],
            maxBounds: void 0,
            renderer: void 0,
            zoomAnimation: !0,
            zoomAnimationThreshold: 4,
            fadeAnimation: !0,
            markerZoomAnimation: !0,
            transform3DLimit: 8388608,
            zoomSnap: 1,
            zoomDelta: 1,
            trackResize: !0
        },
        initialize(e, t) {
            t = u(this, t), this._handlers = [], this._layers = {}, this
              ._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(e),
              this._initLayout(), this._onResize = i(this._onResize, this), this
              ._initEvents(), t.maxBounds && this.setMaxBounds(t.maxBounds), void 0 !==
            t.zoom && (this._zoom = this._limitZoom(t.zoom)), t.center && void 0 !== t
              .zoom && this.setView(S(t.center), t.zoom, {
                reset: !0
            }), this.callInitHooks(), this._zoomAnimated = pn && Fi && !Zi && this
              .options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(),
              ft(this._proxy, mn, this._catchTransitionEnd, this)), this._addLayers(
              this.options.layers)
        },
        setView(e, i, n) {
            return i = void 0 === i ? this._zoom : this._limitZoom(i), e = this
              ._limitCenter(S(e), i, this.options.maxBounds), n = n || {}, this._stop(),
              this._loaded && !n.reset && !0 !== n && (void 0 !== n.animate && (n.zoom =
                t({
                    animate: n.animate
                }, n.zoom), n.pan = t({
                  animate: n.animate,
                  duration: n.duration
              }, n.pan)), this._zoom !== i ? this._tryAnimatedZoom && this
                ._tryAnimatedZoom(e, i, n.zoom) : this._tryAnimatedPan(e, n.pan)) ? (
                clearTimeout(this._sizeTimer), this) : (this._resetView(e, i), this)
        },
        setZoom(e, t) {
            return this._loaded ? this.setView(this.getCenter(), e, {
                zoom: t
            }) : (this._zoom = e, this)
        },
        zoomIn(e, t) {
            return e = e || (Fi ? this.options.zoomDelta : 1), this.setZoom(this._zoom +
              e, t)
        },
        zoomOut(e, t) {
            return e = e || (Fi ? this.options.zoomDelta : 1), this.setZoom(this._zoom -
              e, t)
        },
        setZoomAround(e, t, i) {
            const n = this.getZoomScale(t),
                  o = this.getSize()
                    .divideBy(2),
                  s = (e instanceof y ? e : this.latLngToContainerPoint(e))
                    .subtract(o)
                    .multiplyBy(1 - 1 / n),
                  a = this.containerPointToLatLng(o.add(s));
            return this.setView(a, t, {
                zoom: i
            })
        },
        _getBoundsCenterZoom(e, t) {
            t = t || {}, e = e.getBounds ? e.getBounds() : z(e);
            const i = w(t.paddingTopLeft || t.padding || [0, 0]);
            const n = w(t.paddingBottomRight || t.padding || [0, 0]);
            let o = this.getBoundsZoom(e, !1, i.add(n));
            if ((o = "number" == typeof t.maxZoom ? Math.min(t.maxZoom, o) : o) === 1 / 0)
                return {
                    center: e.getCenter(),
                    zoom: o
                };
            const s = n.subtract(i)
                      .divideBy(2),
                  a = this.project(e.getSouthWest(), o),
                  r = this.project(e.getNorthEast(), o);
            return {
                center: this.unproject(a.add(r)
                  .divideBy(2)
                  .add(s), o),
                zoom: o
            }
        },
        fitBounds(e, t) {
            if (!(e = z(e))
              .isValid()) throw new Error("Bounds are not valid.");
            const i = this._getBoundsCenterZoom(e, t);
            return this.setView(i.center, i.zoom, t)
        },
        fitWorld(e) {
            return this.fitBounds([[-90, -180], [90, 180]], e)
        },
        panTo(e, t) {
            return this.setView(e, this._zoom, {
                pan: t
            })
        },
        panBy(e, t) {
            if (e = w(e)
              .round(), t = t || {}, !e.x && !e.y) return this.fire("moveend");
            if (!0 !== t.animate && !this.getSize()
              .contains(e)) return this._resetView(this.unproject(this.project(this
              .getCenter())
              .add(e)), this.getZoom()), this;
            if (this._panAnim || (this._panAnim = new Cn, this._panAnim.on({
                step: this._onPanTransitionStep,
                end: this._onPanTransitionEnd
            }, this)), t.noMoveStart || this.fire("movestart"), !1 !== t.animate) {
                X(this._mapPane, "leaflet-pan-anim");
                const i = this._getMapPanePos()
                  .subtract(e)
                  .round();
                this._panAnim.run(this._mapPane, i, t.duration || .25, t.easeLinearity)
            } else this._rawPanBy(e), this.fire("move")
              .fire("moveend");
            return this
        },
        flyTo(e, t, i) {
            function n(e) {
                const t = (g * g - f * f + (e ? -1 : 1) * y * y * v * v) / (2 * (e ? g :
                        f) * y * v),
                      i = Math.sqrt(t * t + 1) - t;
                return 1e-9 > i ? -18 : Math.log(i)
            }

            function o(e) {
                return (Math.exp(e) - Math.exp(-e)) / 2
            }

            function s(e) {
                return (Math.exp(e) + Math.exp(-e)) / 2
            }

            function a(e) {
                return o(e) / s(e)
            }

            function r(e) {
                return f * (s(w) / s(w + b * e))
            }

            function l(e) {
                return f * (s(w) * a(w + b * e) - o(w)) / y
            }

            function c(e) {
                return 1 - (1 - e) ** 1.5;
            }

            function u() {
                const i = (Date.now() - k) / C, n = c(i) * x;
                1 >= i ? (this._flyToFrame = _(u, this), this._move(this.unproject(d.add(h
                  .subtract(d)
                  .multiplyBy(l(n) / v)), m), this.getScaleZoom(f / r(n),
                  m), {
                    flyTo: !0
                })) : this._move(e, t)
                  ._moveEnd(!0)
            }
            if (!1 === (i = i || {})
              .animate || !Fi) return this.setView(e, t, i);
            this._stop();
            var d = this.project(this.getCenter());
            var h = this.project(e);
            const p = this.getSize();
            var m = this._zoom;
            e = S(e), t = void 0 === t ? m : t;
            var f = Math.max(p.x, p.y),
              g = f * this.getZoomScale(m, t),
              v = h.distanceTo(d) || 1,
              b = 1.42,
              y = b * b,
              w = n(0),
              k = Date.now(),
              x = (n(1) - w) / b,
              C = i.duration ? 1e3 * i.duration : .8 * 1e3 * x;
            return this._moveStart(!0, i.noMoveStart), u.call(this), this
        },
        flyToBounds(e, t) {
            const i = this._getBoundsCenterZoom(e, t);
            return this.flyTo(i.center, i.zoom, t)
        },
        setMaxBounds(e) {
            return (e = z(e))
              .isValid() ? (this.options.maxBounds && this.off("moveend", this
              ._panInsideMaxBounds), this.options.maxBounds = e, this._loaded &&
            this._panInsideMaxBounds(), this.on("moveend", this
              ._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off(
              "moveend", this._panInsideMaxBounds))
        },
        setMinZoom(e) {
            const t = this.options.minZoom;
            return this.options.minZoom = e, this._loaded && t !== e && (this.fire(
              "zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this
              .setZoom(e) : this
        },
        setMaxZoom(e) {
            const t = this.options.maxZoom;
            return this.options.maxZoom = e, this._loaded && t !== e && (this.fire(
              "zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this
              .setZoom(e) : this
        },
        panInsideBounds(e, t) {
            this._enforcingBounds = !0;
            const i = this.getCenter(), n = this._limitCenter(i, this._zoom, z(e));
            return i.equals(n) || this.panTo(n, t), this._enforcingBounds = !1, this
        },
        panInside(e, t) {
            const i = w((t = t || {})
                      .paddingTopLeft || t.padding || [0, 0]),
                  n = w(t.paddingBottomRight || t.padding || [0, 0]),
                  o = this.getCenter(),
                  s = this.project(o),
                  a = this.project(e),
                  r = this.getPixelBounds(),
                  l = r.getSize()
                    .divideBy(2),
                  c = x([r.min.add(i), r.max.subtract(n)]);
            if (!c.contains(a)) {
                this._enforcingBounds = !0;
                const u = s.subtract(a), d = w(a.x + u.x, a.y + u.y);
                (a.x < c.min.x || a.x > c.max.x) && (d.x = s.x - u.x, u.x > 0 ? d.x += l
                  .x - i.x : d.x -= l.x - n.x), (a.y < c.min.y || a.y > c.max.y) && (d
                  .y = s.y - u.y, u.y > 0 ? d.y += l.y - i.y : d.y -= l.y - n.y), this
                  .panTo(this.unproject(d), t), this._enforcingBounds = !1
            }
            return this
        },
        invalidateSize(e) {
            if (!this._loaded) return this;
            e = t({
                animate: !1,
                pan: !0
            }, !0 === e ? {
                animate: !0
            } : e);
            const n = this.getSize();
            this._sizeChanged = !0, this._lastCenter = null;
            const o = this.getSize(),
                  s = n.divideBy(2)
                    .round(),
                  a = o.divideBy(2)
                    .round(),
                  r = s.subtract(a);
            return r.x || r.y ? (e.animate && e.pan ? this.panBy(r) : (e.pan && this
                ._rawPanBy(r), this.fire("move"), e.debounceMoveend ? (
                clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(i(
                  this.fire, this, "moveend"), 200)) : this.fire("moveend")
            ), this.fire("resize", {
                oldSize: n,
                newSize: o
            })) : this
        },
        stop() {
            return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap ||
            this.fire("viewreset"), this._stop()
        },
        locate(e) {
            if (e = this._locateOptions = t({
                timeout: 1e4,
                watch: !1
            }, e), !("geolocation" in navigator)) return this
              ._handleGeolocationError({
                  code: 0,
                  message: "Geolocation not supported."
              }), this;
            const n = i(this._handleGeolocationResponse, this), o = i(this._handleGeolocationError, this);
            return e.watch ? this._locationWatchId = navigator.geolocation.watchPosition(
              n, o, e) : navigator.geolocation.getCurrentPosition(n, o, e), this
        },
        stopLocate() {
            return navigator.geolocation && navigator.geolocation.clearWatch && navigator
              .geolocation.clearWatch(this._locationWatchId), this._locateOptions && (
              this._locateOptions.setView = !1), this
        },
        _handleGeolocationError(e) {
            const t = e.code,
                  i = e.message || (1 === t ? "permission denied" : 2 === t ?
                    "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire(
              "locationerror", {
                  code: t,
                  message: `Geolocation error: ${i}.`
              })
        },
        _handleGeolocationResponse({coords, timestamp}) {
            const t = new T(coords.latitude, coords.longitude), i = t.toBounds(2 * coords.accuracy), n = this._locateOptions;
            if (n.setView) {
                const o = this.getBoundsZoom(i);
                this.setView(t, n.maxZoom ? Math.min(o, n.maxZoom) : o)
            }
            const s = {
                latlng: t,
                bounds: i,
                timestamp: timestamp
            };
            for (const a in coords) "number" == typeof coords[a] && (s[a] = coords[
              a]);
            this.fire("locationfound", s)
        },
        addHandler(e, t) {
            if (!t) return this;
            const i = this[e] = new t(this);
            return this._handlers.push(i), this.options[e] && i.enable(), this
        },
        remove() {
            if (this._initEvents(!0), this._containerId !== this._container._leaflet_id)
                throw new Error("Map container is being reused by another instance");
            try {
                delete this._container._leaflet_id, delete this._containerId
            } catch (e) {
                this._container._leaflet_id = void 0, this._containerId = void 0
            }
            void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), G(this
              ._mapPane), this._clearControlPos && this._clearControlPos(), this
              ._resizeRequest && (g(this._resizeRequest), this._resizeRequest = null),
              this._clearHandlers(), this._loaded && this.fire("unload");
            var e;
            for (e in this._layers) this._layers[e].remove();
            for (e in this._panes) G(this._panes[e]);
            return this._layers = [], this._panes = [], delete this._mapPane, delete this
              ._renderer, this
        },
        createPane(e, t) {
            const i = Z("div", `leaflet-pane${e ? ` leaflet-${e.replace("Pane", "")}-pane` : ""}`, t || this._mapPane);
            return e && (this._panes[e] = i), i
        },
        getCenter() {
            return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this
              ._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom() {
            return this._zoom
        },
        getBounds() {
            const e = this.getPixelBounds();
            return new C(this.unproject(e.getBottomLeft()), this.unproject(e
              .getTopRight()))
        },
        getMinZoom() {
            return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this
              .options.minZoom
        },
        getMaxZoom() {
            return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 /
              0 : this._layersMaxZoom : this.options.maxZoom
        },
        getBoundsZoom(e, t, i) {
            e = z(e), i = w(i || [0, 0]);
            let n = this.getZoom() || 0;
            const o = this.getMinZoom();
            const s = this.getMaxZoom();
            const a = e.getNorthWest();
            const r = e.getSouthEast();

            const l = this.getSize()
              .subtract(i);

            const c = x(this.project(r, n), this.project(a, n))
              .getSize();

            const u = Fi ? this.options.zoomSnap : 1;
            const d = l.x / c.x;
            const h = l.y / c.y;
            const p = t ? Math.max(d, h) : Math.min(d, h);
            return n = this.getScaleZoom(p, n), u && (n = Math.round(n / (u / 100)) * (u /
              100), n = t ? Math.ceil(n / u) * u : Math.floor(n / u) * u), Math.max(
              o, Math.min(s, n))
        },
        getSize() {
            return this._size && !this._sizeChanged || (this._size = new y(this._container
              .clientWidth || 0, this._container.clientHeight || 0), this
              ._sizeChanged = !1), this._size.clone()
        },
        getPixelBounds(e, t) {
            const i = this._getTopLeftPoint(e, t);
            return new k(i, i.add(this.getSize()))
        },
        getPixelOrigin() {
            return this._checkIfLoaded(), this._pixelOrigin
        },
        getPixelWorldBounds(e) {
            return this.options.crs.getProjectedBounds(void 0 === e ? this.getZoom() : e)
        },
        getPane(e) {
            return "string" == typeof e ? this._panes[e] : e
        },
        getPanes() {
            return this._panes
        },
        getContainer() {
            return this._container
        },
        getZoomScale(e, t) {
            const i = this.options.crs;
            return t = void 0 === t ? this._zoom : t, i.scale(e) / i.scale(t)
        },
        getScaleZoom(e, t) {
            const i = this.options.crs;
            t = void 0 === t ? this._zoom : t;
            const n = i.zoom(e * i.scale(t));
            return isNaN(n) ? 1 / 0 : n
        },
        project(e, t) {
            return t = void 0 === t ? this._zoom : t, this.options.crs.latLngToPoint(S(e),
              t)
        },
        unproject(e, t) {
            return t = void 0 === t ? this._zoom : t, this.options.crs.pointToLatLng(w(e),
              t)
        },
        layerPointToLatLng(e) {
            const t = w(e)
              .add(this.getPixelOrigin());
            return this.unproject(t)
        },
        latLngToLayerPoint(e) {
            return this.project(S(e))
              ._round()
              ._subtract(this.getPixelOrigin())
        },
        wrapLatLng(e) {
            return this.options.crs.wrapLatLng(S(e))
        },
        wrapLatLngBounds(e) {
            return this.options.crs.wrapLatLngBounds(z(e))
        },
        distance(e, t) {
            return this.options.crs.distance(S(e), S(t))
        },
        containerPointToLayerPoint(e) {
            return w(e)
              .subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint(e) {
            return w(e)
              .add(this._getMapPanePos())
        },
        containerPointToLatLng(e) {
            const t = this.containerPointToLayerPoint(w(e));
            return this.layerPointToLatLng(t)
        },
        latLngToContainerPoint(e) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(S(e)))
        },
        mouseEventToContainerPoint(e) {
            return Ct(e, this._container)
        },
        mouseEventToLayerPoint(e) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e))
        },
        mouseEventToLatLng(e) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(e))
        },
        _initContainer(e) {
            const t = this._container = q(e);
            if (!t) throw new Error("Map container not found.");
            if (t._leaflet_id) throw new Error("Map container is already initialized.");
            ft(t, "scroll", this._onScroll, this), this._containerId = n(t)
        },
        _initLayout() {
            const e = this._container;
            this._fadeAnimated = this.options.fadeAnimation && Fi, X(e,
              `leaflet-container${Ui ? " leaflet-touch" : ""}${Ki ?
" leaflet-retina" : ""}${xi ? " leaflet-oldie" : ""}${ji ?
" leaflet-safari" : ""}${this._fadeAnimated ?
" leaflet-fade-anim" : ""}`);
            const t = U(e, "position");
            "absolute" !== t && "relative" !== t && "fixed" !== t && (e.style.position =
              "relative"), this._initPanes(), this._initControlPos && this
              ._initControlPos()
        },
        _initPanes() {
            const e = this._panes = {};
            this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this
              ._container), rt(this._mapPane, new y(0, 0)), this.createPane(
              "tilePane"), this.createPane("shadowPane"), this.createPane(
              "overlayPane"), this.createPane("markerPane"), this.createPane(
              "tooltipPane"), this.createPane("popupPane"), this.options
              .markerZoomAnimation || (X(e.markerPane, "leaflet-zoom-hide"), X(e
              .shadowPane, "leaflet-zoom-hide"))
        },
        _resetView(e, t) {
            rt(this._mapPane, new y(0, 0));
            const i = !this._loaded;
            this._loaded = !0, t = this._limitZoom(t), this.fire("viewprereset");
            const n = this._zoom !== t;
            this._moveStart(n, !1)
              ._move(e, t)
              ._moveEnd(n), this.fire("viewreset"), i && this.fire("load")
        },
        _moveStart(e, t) {
            return e && this.fire("zoomstart"), t || this.fire("movestart"), this
        },
        _move(e, t, i) {
            void 0 === t && (t = this._zoom);
            const n = this._zoom !== t;
            return this._zoom = t, this._lastCenter = e, this._pixelOrigin = this
              ._getNewPixelOrigin(e), (n || i && i.pinch) && this.fire("zoom", i), this
              .fire("move", i)
        },
        _moveEnd(e) {
            return e && this.fire("zoomend"), this.fire("moveend")
        },
        _stop() {
            return g(this._flyToFrame), this._panAnim && this._panAnim.stop(), this
        },
        _rawPanBy(e) {
            rt(this._mapPane, this._getMapPanePos()
              .subtract(e))
        },
        _getZoomSpan() {
            return this.getMaxZoom() - this.getMinZoom()
        },
        _panInsideMaxBounds() {
            this._enforcingBounds || this.panInsideBounds(this.options.maxBounds)
        },
        _checkIfLoaded() {
            if (!this._loaded) throw new Error("Set map center and zoom first.")
        },
        _initEvents(e) {
            this._targets = {}, this._targets[n(this._container)] = this;
            const t = e ? _t : ft;
            t(this._container,
              "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress",
              this._handleDOMEvent, this), this.options.trackResize && t(window,
              "resize", this._onResize, this), Fi && this.options
              .transform3DLimit && (e ? this.off : this.on)
              .call(this, "moveend", this._onMoveEnd)
        },
        _onResize() {
            g(this._resizeRequest), this._resizeRequest = _(function () {
                this.invalidateSize({
                    debounceMoveend: !0
                })
            }, this)
        },
        _onScroll() {
            this._container.scrollTop = 0, this._container.scrollLeft = 0
        },
        _onMoveEnd() {
            const e = this._getMapPanePos();
            Math.max(Math.abs(e.x), Math.abs(e.y)) >= this.options.transform3DLimit &&
            this._resetView(this.getCenter(), this.getZoom())
        },
        _findEventTargets(e, t) {
            for (var i, o = [], s = "mouseout" === t || "mouseover" === t, a = e.target ||
              e.srcElement, r = !1; a;) {
                if ((i = this._targets[n(a)]) && ("click" === t || "preclick" === t) && !e
                  ._simulated && this._draggableMoved(i)) {
                    r = !0;
                    break
                }
                if (i && i.listens(t, !0)) {
                    if (s && !At(a, e)) break;
                    if (o.push(i), s) break
                }
                if (a === this._container) break;
                a = a.parentNode
            }
            return o.length || r || s || !At(a, e) || (o = [this]), o
        },
        _handleDOMEvent(e) {
            if (this._loaded && !St(e)) {
                const t = e.type;
                "mousedown" !== t && "keypress" !== t || dt(e.target || e.srcElement),
                  this._fireDOMEvent(e, t)
            }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent(e, i, n) {
            if ("click" === e.type) {
                const o = t({}, e);
                o.type = "preclick", this._fireDOMEvent(o, o.type, n)
            }
            if (!e._stopped && (n = (n || [])
              .concat(this._findEventTargets(e, i)))
              .length) {
                const s = n[0];
                "contextmenu" === i && s.listens(i, !0) && kt(e);
                const a = {
                    originalEvent: e
                };
                if ("keypress" !== e.type) {
                    const r = s.getLatLng && (!s._radius || s._radius <= 10);
                    a.containerPoint = r ? this.latLngToContainerPoint(s.getLatLng()) :
                      this.mouseEventToContainerPoint(e), a.layerPoint = this
                      .containerPointToLayerPoint(a.containerPoint), a.latlng = r ? s
                      .getLatLng() : this.layerPointToLatLng(a.layerPoint)
                }
                for (let l = 0; l < n.length; l++)
                    if (n[l].fire(i, a, !0), a.originalEvent._stopped || !1 === n[l]
                      .options.bubblingMouseEvents && -1 !== p(this._mouseEvents, i))
                        return
            }
        },
        _draggableMoved(e) {
            return (e = e.dragging && e.dragging.enabled() ? e : this)
              .dragging && e.dragging.moved() || this.boxZoom && this.boxZoom.moved()
        },
        _clearHandlers() {
            for (let e = 0, t = this._handlers.length; t > e; e++) this._handlers[e]
              .disable()
        },
        whenReady(e, t) {
            return this._loaded ? e.call(t || this, {
                target: this
            }) : this.on("load", e, t), this
        },
        _getMapPanePos() {
            return lt(this._mapPane) || new y(0, 0)
        },
        _moved() {
            const e = this._getMapPanePos();
            return e && !e.equals([0, 0])
        },
        _getTopLeftPoint(e, t) {
            return (e && void 0 !== t ? this._getNewPixelOrigin(e, t) : this
              .getPixelOrigin())
              .subtract(this._getMapPanePos())
        },
        _getNewPixelOrigin(e, t) {
            const i = this.getSize()
              ._divideBy(2);
            return this.project(e, t)
              ._subtract(i)
              ._add(this._getMapPanePos())
              ._round()
        },
        _latLngToNewLayerPoint(e, t, i) {
            const n = this._getNewPixelOrigin(i, t);
            return this.project(e, t)
              ._subtract(n)
        },
        _latLngBoundsToNewLayerBounds(e, t, i) {
            const n = this._getNewPixelOrigin(i, t);
            return x([this.project(e.getSouthWest(), t)
              ._subtract(n), this.project(e.getNorthWest(), t)
              ._subtract(n), this.project(e.getSouthEast(), t)
              ._subtract(n), this.project(e.getNorthEast(), t)
              ._subtract(n)])
        },
        _getCenterLayerPoint() {
            return this.containerPointToLayerPoint(this.getSize()
              ._divideBy(2))
        },
        _getCenterOffset(e) {
            return this.latLngToLayerPoint(e)
              .subtract(this._getCenterLayerPoint())
        },
        _limitCenter(e, t, i) {
            if (!i) return e;
            const n = this.project(e, t),
                  o = this.getSize()
                    .divideBy(2),
                  s = new k(n.subtract(o), n.add(o)),
                  a = this._getBoundsOffset(s, i, t);
            return a.round()
              .equals([0, 0]) ? e : this.unproject(n.add(a), t)
        },
        _limitOffset(e, t) {
            if (!t) return e;
            const i = this.getPixelBounds(), n = new k(i.min.add(e), i.max.add(e));
            return e.add(this._getBoundsOffset(n, t))
        },
        _getBoundsOffset({min, max}, t, i) {
            const n = x(this.project(t.getNorthEast(), i), this.project(t.getSouthWest(),
                    i)),
                  o = n.min.subtract(min),
                  s = n.max.subtract(max);
            return new y(this._rebound(o.x, -s.x), this._rebound(o.y, -s.y))
        },
        _rebound(e, t) {
            return e + t > 0 ? Math.round(e - t) / 2 : Math.max(0, Math.ceil(e)) - Math
              .max(0, Math.floor(t))
        },
        _limitZoom(e) {
            const t = this.getMinZoom(), i = this.getMaxZoom(), n = Fi ? this.options.zoomSnap : 1;
            return n && (e = Math.round(e / n) * n), Math.max(t, Math.min(i, e))
        },
        _onPanTransitionStep() {
            this.fire("move")
        },
        _onPanTransitionEnd() {
            et(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
        },
        _tryAnimatedPan(e, t) {
            const i = this._getCenterOffset(e)
              ._trunc();
            return !(!0 !== (t && t.animate) && !this.getSize()
              .contains(i) || (this.panBy(i, t), 0))
        },
        _createAnimProxy() {
            const e = this._proxy = Z("div", "leaflet-proxy leaflet-zoom-animated");
            this._panes.mapPane.appendChild(e), this.on("zoomanim", function({center, zoom}) {
                const t = hn, i = this._proxy.style[t];
                at(this._proxy, this.project(center, zoom), this.getZoomScale(
                  zoom, 1)), i === this._proxy.style[t] && this
                  ._animatingZoom && this._onZoomTransitionEnd()
            }, this), this.on("load moveend", function () {
                const e = this.getCenter(), t = this.getZoom();
                at(this._proxy, this.project(e, t), this.getZoomScale(t, 1))
            }, this), this._on("unload", this._destroyAnimProxy, this)
        },
        _destroyAnimProxy() {
            G(this._proxy), delete this._proxy
        },
        _catchTransitionEnd({propertyName}) {
            this._animatingZoom && propertyName.includes("transform") && this
              ._onZoomTransitionEnd()
        },
        _nothingToAnimate() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated")
              .length
        },
        _tryAnimatedZoom(e, t, i) {
            if (this._animatingZoom) return !0;
            if (i = i || {}, !this._zoomAnimated || !1 === i.animate || this
              ._nothingToAnimate() || Math.abs(t - this._zoom) > this.options
              .zoomAnimationThreshold) return !1;
            const n = this.getZoomScale(t),
                  o = this._getCenterOffset(e)
                    ._divideBy(1 - 1 / n);
            return !(!0 !== i.animate && !this.getSize()
              .contains(o) || (_(function () {
                this._moveStart(!0, !1)
                  ._animateZoom(e, t, !0)
            }, this), 0))
        },
        _animateZoom(e, t, n, o) {
            this._mapPane && (n && (this._animatingZoom = !0, this._animateToCenter = e,
              this._animateToZoom = t, X(this._mapPane, "leaflet-zoom-anim")),
              this.fire("zoomanim", {
                  center: e,
                  zoom: t,
                  noUpdate: o
              }), setTimeout(i(this._onZoomTransitionEnd, this), 250))
        },
        _onZoomTransitionEnd() {
            this._animatingZoom && (this._mapPane && et(this._mapPane,
              "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this
              ._animateToCenter, this._animateToZoom), _(function () {
                this._moveEnd(!0)
            }, this))
        }
    });

    const Tn = v.extend({
        options: {
            position: "topright"
        },
        initialize(e) {
            u(this, e)
        },
        getPosition() {
            return this.options.position
        },
        setPosition(e) {
            const t = this._map;
            return t && t.removeControl(this), this.options.position = e, t && t
              .addControl(this), this
        },
        getContainer() {
            return this._container
        },
        addTo(e) {
            this.remove(), this._map = e;
            const t = this._container = this.onAdd(e), i = this.getPosition(), n = e._controlCorners[i];
            return X(t, "leaflet-control"), i.includes("bottom") ? n.insertBefore(t,
              n.firstChild) : n.appendChild(t), this;
        },
        remove() {
            return this._map ? (G(this._container), this.onRemove && this.onRemove(this
              ._map), this._map = null, this) : this
        },
        _refocusOnMap(e) {
            this._map && e && e.screenX > 0 && e.screenY > 0 && this._map.getContainer()
              .focus()
        }
    });

    const Sn = e => new Tn(e);
    zn.include({
        addControl(e) {
            return e.addTo(this), this
        },
        removeControl(e) {
            return e.remove(), this
        },
        _initControlPos() {
            function e(e, o) {
                const s = `${i + e} ${i}${o}`;
                t[e + o] = Z("div", s, n)
            }
            var t = this._controlCorners = {};
            var i = "leaflet-";

            var n = this._controlContainer = Z("div", `${i}control-container`, this
              ._container);

            e("top", "left"), e("top", "right"), e("bottom", "left"), e("bottom", "right")
        },
        _clearControlPos() {
            for (const e in this._controlCorners) G(this._controlCorners[e]);
            G(this._controlContainer), delete this._controlCorners, delete this
              ._controlContainer
        }
    });

    const An = Tn.extend({
          options: {
              collapsed: !0,
              position: "topright",
              autoZIndex: !0,
              hideSingleBase: !1,
              sortLayers: !1,
              sortFunction(e, t, i, n) {
                  return n > i ? -1 : i > n ? 1 : 0
              }
          },
          initialize(e, t, i) {
              u(this, i), this._layerControlInputs = [], this._layers = [], this
                ._lastZIndex = 0, this._handlingClick = !1;
              for (var n in e) this._addLayer(e[n], n);
              for (n in t) this._addLayer(t[n], n, !0)
          },
          onAdd(e) {
              this._initLayout(), this._update(), this._map = e, e.on("zoomend", this
                ._checkDisabledLayers, this);
              for (let t = 0; t < this._layers.length; t++) this._layers[t].layer.on(
                "add remove", this._onLayerChange, this);
              return this._container
          },
          addTo(e) {
              return Tn.prototype.addTo.call(this, e), this._expandIfNotCollapsed()
          },
          onRemove() {
              this._map.off("zoomend", this._checkDisabledLayers, this);
              for (let e = 0; e < this._layers.length; e++) this._layers[e].layer.off(
                "add remove", this._onLayerChange, this)
          },
          addBaseLayer(e, t) {
              return this._addLayer(e, t), this._map ? this._update() : this
          },
          addOverlay(e, t) {
              return this._addLayer(e, t, !0), this._map ? this._update() : this
          },
          removeLayer(e) {
              e.off("add remove", this._onLayerChange, this);
              const t = this._getLayer(n(e));
              return t && this._layers.splice(this._layers.indexOf(t), 1), this._map ? this
                ._update() : this
          },
          expand() {
              X(this._container, "leaflet-control-layers-expanded"), this._section.style
                .height = null;
              const e = this._map.getSize()
                .y - (this._container.offsetTop + 50);
              return e < this._section.clientHeight ? (X(this._section,
                "leaflet-control-layers-scrollbar"), this._section.style.height =
                `${e}px`) : et(this._section, "leaflet-control-layers-scrollbar"),
                this._checkDisabledLayers(), this;
          },
          collapse() {
              return et(this._container, "leaflet-control-layers-expanded"), this
          },
          _initLayout() {
              const e = "leaflet-control-layers", t = this._container = Z("div", e), i = this.options.collapsed;
              t.setAttribute("aria-haspopup", !0), wt(t), yt(t);
              const n = this._section = Z("section", `${e}-list`);
              i && (this._map.on("click", this.collapse, this), Ti || ft(t, {
                  mouseenter: this.expand,
                  mouseleave: this.collapse
              }, this));
              const o = this._layersLink = Z("a", `${e}-toggle`, t);
              o.href = "#", o.title = "Layers", Ui ? (ft(o, "click", xt), ft(o, "click",
                this.expand, this)) : ft(o, "focus", this.expand, this), i || this
                .expand(), this._baseLayersList = Z("div", `${e}-base`, n), this
                ._separator = Z("div", `${e}-separator`, n), this._overlaysList = Z("div",
                `${e}-overlays`, n), t.appendChild(n)
          },
          _getLayer(e) {
              for (let t = 0; t < this._layers.length; t++)
                  if (this._layers[t] && n(this._layers[t].layer) === e) return this
                    ._layers[t]
          },
          _addLayer(e, t, n) {
              this._map && e.on("add remove", this._onLayerChange, this), this._layers
                .push({
                    layer: e,
                    name: t,
                    overlay: n
                }), this.options.sortLayers && this._layers.sort(i(function({layer, name}, {layer, name}) {
                  return this.options.sortFunction(layer, layer, name, name);
              }, this)), this.options.autoZIndex && e.setZIndex && (this._lastZIndex++,
                e.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed()
          },
          _update() {
              if (!this._container) return this;
              K(this._baseLayersList), K(this._overlaysList), this._layerControlInputs = [];
              let e, t, i, n, o = 0;
              for (i = 0; i < this._layers.length; i++) n = this._layers[i], this._addItem(
                n), t = t || n.overlay, e = e || !n.overlay, o += n.overlay ? 0 : 1;
              return this.options.hideSingleBase && (e = e && o > 1, this._baseLayersList
                .style.display = e ? "" : "none"), this._separator.style.display =
                t && e ? "" : "none", this
          },
          _onLayerChange(e) {
              this._handlingClick || this._update();
              const t = this._getLayer(n(e.target)),
                    i = t.overlay ? "add" === e.type ? "overlayadd" : "overlayremove" :
                      "add" === e.type ? "baselayerchange" : null;
              i && this._map.fire(i, t)
          },
          _createRadioElement(e, t) {
              const i = `<input type="radio" class="leaflet-control-layers-selector" name="${e}"${t ? ' checked="checked"' : ""}/>`, n = document.createElement("div");
              return n.innerHTML = i, n.firstChild
          },
          _addItem({layer, overlay, name}) {
              let t;
              const i = document.createElement("label");
              const o = this._map.hasLayer(layer);
              overlay ? ((t = document.createElement("input"))
                .type = "checkbox", t.className = "leaflet-control-layers-selector", t
                .defaultChecked = o) : t = this._createRadioElement(
                "leaflet-base-layers", o), this._layerControlInputs.push(t), t
                .layerId = n(layer), ft(t, "click", this._onInputClick, this);
              const s = document.createElement("span");
              s.innerHTML = ` ${name}`;
              const a = document.createElement("div");
              return i.appendChild(a), a.appendChild(t), a.appendChild(s), (overlay ? this
                ._overlaysList : this._baseLayersList)
                .appendChild(i), this._checkDisabledLayers(), i;
          },
          _onInputClick() {
              let e;
              let t;
              const i = this._layerControlInputs;
              const n = [];
              const o = [];
              this._handlingClick = !0;
              for (var s = i.length - 1; s >= 0; s--) e = i[s], t = this._getLayer(e
                .layerId)
                .layer, e.checked ? n.push(t) : e.checked || o.push(t);
              for (s = 0; s < o.length; s++) this._map.hasLayer(o[s]) && this._map
                .removeLayer(o[s]);
              for (s = 0; s < n.length; s++) this._map.hasLayer(n[s]) || this._map.addLayer(
                n[s]);
              this._handlingClick = !1, this._refocusOnMap()
          },
          _checkDisabledLayers() {
              for (let e,
                  t,
                  i = this._layerControlInputs,
                  n = this._map.getZoom(),
                  o = i
                    .length - 1; o >= 0; o--) e = i[o], t = this._getLayer(e.layerId)
                .layer, e.disabled = void 0 !== t.options.minZoom && n < t.options
                .minZoom || void 0 !== t.options.maxZoom && n > t.options.maxZoom
          },
          _expandIfNotCollapsed() {
              return this._map && !this.options.collapsed && this.expand(), this
          },
          _expand() {
              return this.expand()
          },
          _collapse() {
              return this.collapse()
          }
      });

    const En = Tn.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "&#x2212;",
            zoomOutTitle: "Zoom out"
        },
        onAdd(e) {
            const t = "leaflet-control-zoom", i = Z("div", `${t} leaflet-bar`), n = this.options;
            return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle,
              `${t}-in`, i, this._zoomIn), this._zoomOutButton = this._createButton(
              n.zoomOutText, n.zoomOutTitle, `${t}-out`, i, this._zoomOut), this
              ._updateDisabled(), e.on("zoomend zoomlevelschange", this._updateDisabled,
              this), i;
        },
        onRemove(e) {
            e.off("zoomend zoomlevelschange", this._updateDisabled, this)
        },
        disable() {
            return this._disabled = !0, this._updateDisabled(), this
        },
        enable() {
            return this._disabled = !1, this._updateDisabled(), this
        },
        _zoomIn({shiftKey}) {
            !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map
              .zoomIn(this._map.options.zoomDelta * (shiftKey ? 3 : 1))
        },
        _zoomOut({shiftKey}) {
            !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map
              .zoomOut(this._map.options.zoomDelta * (shiftKey ? 3 : 1))
        },
        _createButton(e, t, i, n, o) {
            const s = Z("a", i, n);
            return s.innerHTML = e, s.href = "#", s.title = t, s.setAttribute("role",
              "button"), s.setAttribute("aria-label", t), wt(s), ft(s, "click", xt),
              ft(s, "click", o, this), ft(s, "click", this._refocusOnMap, this), s
        },
        _updateDisabled() {
            const e = this._map, t = "leaflet-disabled";
            et(this._zoomInButton, t), et(this._zoomOutButton, t), (this._disabled || e
              ._zoom === e.getMinZoom()) && X(this._zoomOutButton, t), (this
              ._disabled || e._zoom === e.getMaxZoom()) && X(this._zoomInButton, t)
        }
    });

    zn.mergeOptions({
        zoomControl: !0
    }), zn.addInitHook(function () {
        this.options.zoomControl && (this.zoomControl = new En, this.addControl(this
          .zoomControl))
    });

    const Pn = Tn.extend({
          options: {
              position: "bottomleft",
              maxWidth: 100,
              metric: !0,
              imperial: !0
          },
          onAdd(e) {
              const t = Z("div", "leaflet-control-scale"), i = this.options;
              return this._addScales(i, "leaflet-control-scale-line", t), e.on(i
                .updateWhenIdle ? "moveend" : "move", this._update, this), e
                .whenReady(this._update, this), t
          },
          onRemove(e) {
              e.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
          },
          _addScales({metric, imperial}, t, i) {
              metric && (this._mScale = Z("div", t, i)), imperial && (this._iScale = Z(
                "div", t, i))
          },
          _update() {
              const e = this._map,
                    t = e.getSize()
                      .y / 2,
                    i = e.distance(e.containerPointToLatLng([0, t]), e.containerPointToLatLng(
                      [this.options.maxWidth, t]));
              this._updateScales(i)
          },
          _updateScales(e) {
              this.options.metric && e && this._updateMetric(e), this.options.imperial &&
              e && this._updateImperial(e)
          },
          _updateMetric(e) {
              const t = this._getRoundNum(e), i = 1e3 > t ? `${t} m` : `${t / 1e3} km`;
              this._updateScale(this._mScale, i, t / e)
          },
          _updateImperial(e) {
              let t;
              let i;
              let n;
              const o = 3.2808399 * e;
              o > 5280 ? (t = o / 5280, i = this._getRoundNum(t), this._updateScale(this
                ._iScale, `${i} mi`, i / t)) : (n = this._getRoundNum(o), this
                ._updateScale(this._iScale, `${n} ft`, n / o))
          },
          _updateScale(e, t, i) {
              e.style.width = `${Math.round(this.options.maxWidth * i)}px`, e.innerHTML = t
          },
          _getRoundNum(e) {
              const t = 10 ** ((`${Math.floor(e)}`)
                  .length - 1);

              let i = e / t;
              return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, t * i
          }
      });

    const In = Tn.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize(e) {
            u(this, e), this._attributions = {}
        },
        onAdd(e) {
            e.attributionControl = this, this._container = Z("div",
              "leaflet-control-attribution"), wt(this._container);
            for (const t in e._layers) e._layers[t].getAttribution && this.addAttribution(e
              ._layers[t].getAttribution());
            return this._update(), this._container
        },
        setPrefix(e) {
            return this.options.prefix = e, this._update(), this
        },
        addAttribution(e) {
            return e ? (this._attributions[e] || (this._attributions[e] = 0), this
              ._attributions[e]++, this._update(), this) : this
        },
        removeAttribution(e) {
            return e ? (this._attributions[e] && (this._attributions[e]--, this
              ._update()), this) : this
        },
        _update() {
            if (this._map) {
                const e = [];
                for (const t in this._attributions) this._attributions[t] && e.push(t);
                const i = [];
                this.options.prefix && i.push(this.options.prefix), e.length && i.push(e
                  .join(", ")), this._container.innerHTML = i.join(" | ")
            }
        }
    });

    zn.mergeOptions({
        attributionControl: !0
    }), zn.addInitHook(function () {
        this.options.attributionControl && (new In)
          .addTo(this)
    }), Tn.Layers = An, Tn.Zoom = En, Tn.Scale = Pn, Tn.Attribution = In, Sn.layers = (e, t, i) => new An(e, t, i), Sn.zoom = e => new En(e), Sn.scale = e => new Pn(e), Sn.attribution = e => new In(e);
    const Mn = v.extend({
        initialize(e) {
            this._map = e
        },
        enable() {
            return this._enabled ? this : (this._enabled = !0, this.addHooks(), this)
        },
        disable() {
            return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this
        },
        enabled() {
            return !!this._enabled
        }
    });
    Mn.addTo = function (e, t) {
        return e.addHandler(t, this), this
    };
    var jn;

    const Dn = {
          Events: ui
      };

    const Nn = Ui ? "touchstart mousedown" : "mousedown";

    const Ln = {
        mousedown: "mouseup",
        touchstart: "touchend",
        pointerdown: "touchend",
        MSPointerDown: "touchend"
    };

    const On = {
        mousedown: "mousemove",
        touchstart: "touchmove",
        pointerdown: "touchmove",
        MSPointerDown: "touchmove"
    };

    const Rn = di.extend({
        options: {
            clickTolerance: 3
        },
        initialize(e, t, i, n) {
            u(this, n), this._element = e, this._dragStartTarget = t || e, this
              ._preventOutline = i
        },
        enable() {
            this._enabled || (ft(this._dragStartTarget, Nn, this._onDown, this), this
              ._enabled = !0)
        },
        disable() {
            this._enabled && (Rn._dragging === this && this.finishDrag(), _t(this
              ._dragStartTarget, Nn, this._onDown, this), this._enabled = !1,
              this._moved = !1)
        },
        _onDown(e) {
            if (!e._simulated && this._enabled && (this._moved = !1, !(Q(this._element,
              "leaflet-zoom-anim") || Rn._dragging || e.shiftKey || 1 !== e
              .which && 1 !== e.button && !e.touches || (Rn._dragging = this,
            this._preventOutline && dt(this._element), ct(), _i(), this
              ._moving)))) {
                this.fire("down");
                const t = e.touches ? e.touches[0] : e, i = pt(this._element);
                this._startPoint = new y(t.clientX, t.clientY), this._parentScale = mt(i),
                  ft(document, On[e.type], this._onMove, this), ft(document, Ln[e.type],
                  this._onUp, this)
            }
        },
        _onMove(e) {
            if (!e._simulated && this._enabled)
                if (e.touches && e.touches.length > 1) this._moved = !0;
                else {
                    const t = e.touches && 1 === e.touches.length ? e.touches[0] : e,
                          i = new y(t.clientX, t.clientY)
                            ._subtract(this._startPoint);
                    (i.x || i.y) && (Math.abs(i.x) + Math.abs(i.y) < this.options
                      .clickTolerance || (i.x /= this._parentScale.x, i.y /= this
                      ._parentScale.y, kt(e), this._moved || (this.fire(
                      "dragstart"), this._moved = !0, this._startPos = lt(this
                      ._element)
                      .subtract(i), X(document.body, "leaflet-dragging"), this
                      ._lastTarget = e.target || e.srcElement, window
                      .SVGElementInstance && this
                      ._lastTarget instanceof SVGElementInstance && (this
                      ._lastTarget = this._lastTarget
                      .correspondingUseElement), X(this._lastTarget,
                      "leaflet-drag-target")), this._newPos = this._startPos
                      .add(i), this._moving = !0, g(this._animRequest), this
                      ._lastEvent = e, this._animRequest = _(this._updatePosition,
                      this, !0)))
                }
        },
        _updatePosition() {
            const e = {
                originalEvent: this._lastEvent
            };
            this.fire("predrag", e), rt(this._element, this._newPos), this.fire("drag", e)
        },
        _onUp({_simulated}) {
            !_simulated && this._enabled && this.finishDrag()
        },
        finishDrag() {
            et(document.body, "leaflet-dragging"), this._lastTarget && (et(this
              ._lastTarget, "leaflet-drag-target"), this._lastTarget = null);
            for (const e in On) _t(document, On[e], this._onMove, this), _t(document, Ln[e],
              this._onUp, this);
            ut(), gi(), this._moved && this._moving && (g(this._animRequest), this.fire(
              "dragend", {
                  distance: this._newPos.distanceTo(this._startPos)
              })), this._moving = !1, Rn._dragging = !1
        }
    });

    const $n = (Object.freeze || Object)({
        simplify: Pt,
        pointToSegmentDistance: It,
        closestPointOnSegment(e, t, i) {
            return $t(e, t, i)
        },
        clipSegment: Nt,
        _getEdgeIntersection: Lt,
        _getBitCode: Ot,
        _sqClosestPointOnSegment: $t,
        isFlat: Ft,
        _flat: Bt
    });

    const Fn = (Object.freeze || Object)({
        clipPolygon: Ht
    });

    const Bn = {
        project({lng, lat}) {
            return new y(lng, lat);
        },
        unproject(e) {
            return new T(e.y, e.x)
        },
        bounds: new k([-180, -90], [180, 90])
    };

    const Hn = {
        R: 6378137,
        R_MINOR: 6356752.314245179,
        bounds: new k([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
        project({lat, lng}) {
            const t = Math.PI / 180;
            const i = this.R;
            let n = lat * t;
            const o = this.R_MINOR / i;
            const s = Math.sqrt(1 - o * o);
            const a = s * Math.sin(n);
            const r = Math.tan(Math.PI / 4 - n / 2) / ((1 - a) / (1 + a)) ** (s / 2);
            return n = -i * Math.log(Math.max(r, 1e-10)), new y(lng * t * i, n);
        },
        unproject(e) {
            for (var t, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 -
              o * o), a = Math.exp(-e.y / n), r = Math.PI / 2 - 2 * Math.atan(a),
                   l = 0, c = .1; 15 > l && Math.abs(c) > 1e-7; l++) t = s * Math.sin(r), t =
              ((1 - t) / (1 + t)) ** (s / 2), r += c = Math.PI / 2 - 2 * Math.atan(a *
              t) - r;
            return new T(r * i, e.x * i / n)
        }
    };

    const Wn = (Object.freeze || Object)({
        LonLat: Bn,
        Mercator: Hn,
        SphericalMercator: fi
    });

    const Vn = t({}, mi, {
        code: "EPSG:3395",
        projection: Hn,
        transformation: (() => {
            const e = .5 / (Math.PI * Hn.R);
            return E(e, .5, -e, .5)
        })()
    });

    const qn = t({}, mi, {
        code: "EPSG:4326",
        projection: Bn,
        transformation: E(1 / 180, 1, -1 / 180, .5)
    });

    const Un = t({}, pi, {
        projection: Bn,
        transformation: E(1, 0, -1, 0),
        scale(e) {
            return 2 ** e;
        },
        zoom(e) {
            return Math.log(e) / Math.LN2
        },
        distance({lng, lat}, {lng, lat}) {
            const i = lng - lng, n = lat - lat;
            return Math.sqrt(i * i + n * n)
        },
        infinite: !0
    });

    pi.Earth = mi, pi.EPSG3395 = Vn, pi.EPSG3857 = bi, pi.EPSG900913 = yi, pi.EPSG4326 = qn, pi
      .Simple = Un;
    const Zn = di.extend({
        options: {
            pane: "overlayPane",
            attribution: null,
            bubblingMouseEvents: !0
        },
        addTo(e) {
            return e.addLayer(this), this
        },
        remove() {
            return this.removeFrom(this._map || this._mapToAdd)
        },
        removeFrom(e) {
            return e && e.removeLayer(this), this
        },
        getPane(e) {
            return this._map.getPane(e ? this.options[e] || e : this.options.pane)
        },
        addInteractiveTarget(e) {
            return this._map._targets[n(e)] = this, this
        },
        removeInteractiveTarget(e) {
            return delete this._map._targets[n(e)], this
        },
        getAttribution() {
            return this.options.attribution
        },
        _layerAdd(e) {
            const t = e.target;
            if (t.hasLayer(this)) {
                if (this._map = t, this._zoomAnimated = t._zoomAnimated, this.getEvents) {
                    const i = this.getEvents();
                    t.on(i, this), this.once("remove", function () {
                        t.off(i, this)
                    }, this)
                }
                this.onAdd(t), this.getAttribution && t.attributionControl && t
                  .attributionControl.addAttribution(this.getAttribution()), this.fire(
                  "add"), t.fire("layeradd", {
                    layer: this
                })
            }
        }
    });
    zn.include({
        addLayer(e) {
            if (!e._layerAdd) throw new Error("The provided object is not a Layer.");
            const t = n(e);
            return this._layers[t] ? this : (this._layers[t] = e, e._mapToAdd = this, e
              .beforeAdd && e.beforeAdd(this), this.whenReady(e._layerAdd, e), this)
        },
        removeLayer(e) {
            const t = n(e);
            return this._layers[t] ? (this._loaded && e.onRemove(this), e
              .getAttribution && this.attributionControl && this.attributionControl
              .removeAttribution(e.getAttribution()), delete this._layers[t], this
              ._loaded && (this.fire("layerremove", {
                layer: e
            }), e.fire("remove")), e._map = e._mapToAdd = null, this) : this
        },
        hasLayer(e) {
            return !!e && n(e) in this._layers
        },
        eachLayer(e, t) {
            for (const i in this._layers) e.call(t, this._layers[i]);
            return this
        },
        _addLayers(e) {
            for (let t = 0,
                i = (e = e ? oi(e) ? e : [e] : [])
                  .length; i > t; t++) this.addLayer(e[t])
        },
        _addZoomLimit(e) {
            !isNaN(e.options.maxZoom) && isNaN(e.options.minZoom) || (this
              ._zoomBoundLayers[n(e)] = e, this._updateZoomLevels())
        },
        _removeZoomLimit(e) {
            const t = n(e);
            this._zoomBoundLayers[t] && (delete this._zoomBoundLayers[t], this
              ._updateZoomLevels())
        },
        _updateZoomLevels() {
            let e = 1 / 0;
            let t = -1 / 0;
            const i = this._getZoomSpan();
            for (const n in this._zoomBoundLayers) {
                const o = this._zoomBoundLayers[n].options;
                e = void 0 === o.minZoom ? e : Math.min(e, o.minZoom), t = void 0 === o
                  .maxZoom ? t : Math.max(t, o.maxZoom)
            }
            this._layersMaxZoom = t === -1 / 0 ? void 0 : t, this._layersMinZoom = e ===
            1 / 0 ? void 0 : e, i !== this._getZoomSpan() && this.fire(
              "zoomlevelschange"), void 0 === this.options.maxZoom && this
              ._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(
              this._layersMaxZoom), void 0 === this.options.minZoom && this
              ._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(
              this._layersMinZoom)
        }
    });

    const Gn = Zn.extend({
          initialize(e, t) {
              u(this, t), this._layers = {};
              let i, n;
              if (e)
                  for (i = 0, n = e.length; n > i; i++) this.addLayer(e[i])
          },
          addLayer(e) {
              const t = this.getLayerId(e);
              return this._layers[t] = e, this._map && this._map.addLayer(e), this
          },
          removeLayer(e) {
              const t = e in this._layers ? e : this.getLayerId(e);
              return this._map && this._layers[t] && this._map.removeLayer(this._layers[t]),
                delete this._layers[t], this
          },
          hasLayer(e) {
              return !!e && (e in this._layers || this.getLayerId(e) in this._layers)
          },
          clearLayers() {
              return this.eachLayer(this.removeLayer, this)
          },
          invoke(e) {
              let t;
              let i;
              const n = Array.prototype.slice.call(arguments, 1);
              for (t in this._layers)(i = this._layers[t])[e] && i[e](...n);
              return this
          },
          onAdd(e) {
              this.eachLayer(e.addLayer, e)
          },
          onRemove(e) {
              this.eachLayer(e.removeLayer, e)
          },
          eachLayer(e, t) {
              for (const i in this._layers) e.call(t, this._layers[i]);
              return this
          },
          getLayer(e) {
              return this._layers[e]
          },
          getLayers() {
              const e = [];
              return this.eachLayer(e.push, e), e
          },
          setZIndex(e) {
              return this.invoke("setZIndex", e)
          },
          getLayerId(e) {
              return n(e)
          }
      });

    var Kn = Gn.extend({
        addLayer(e) {
            return this.hasLayer(e) ? this : (e.addEventParent(this), Gn.prototype
              .addLayer.call(this, e), this.fire("layeradd", {
                layer: e
            }))
        },
        removeLayer(e) {
            return this.hasLayer(e) ? (e in this._layers && (e = this._layers[e]), e
              .removeEventParent(this), Gn.prototype.removeLayer.call(this, e), this
              .fire("layerremove", {
                  layer: e
              })) : this
        },
        setStyle(e) {
            return this.invoke("setStyle", e)
        },
        bringToFront() {
            return this.invoke("bringToFront")
        },
        bringToBack() {
            return this.invoke("bringToBack")
        },
        getBounds() {
            const e = new C;
            for (const t in this._layers) {
                const i = this._layers[t];
                e.extend(i.getBounds ? i.getBounds() : i.getLatLng())
            }
            return e
        }
    });

    const Yn = v.extend({
        options: {
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 0]
        },
        initialize(e) {
            u(this, e)
        },
        createIcon(e) {
            return this._createIcon("icon", e)
        },
        createShadow(e) {
            return this._createIcon("shadow", e)
        },
        _createIcon(e, t) {
            const i = this._getIconUrl(e);
            if (!i) {
                if ("icon" === e) throw new Error(
                  "iconUrl not set in Icon options (see the docs).");
                return null
            }
            const n = this._createImg(i, t && "IMG" === t.tagName ? t : null);
            return this._setIconStyles(n, e), n
        },
        _setIconStyles(e, t) {
            const i = this.options;
            let n = i[`${t}Size`];
            "number" == typeof n && (n = [n, n]);
            const o = w(n),
                  s = w("shadow" === t && i.shadowAnchor || i.iconAnchor || o && o.divideBy(
                    2, !0));
            e.className = `leaflet-marker-${t} ${i.className || ""}`, s && (e.style
              .marginLeft = `${-s.x}px`, e.style.marginTop = `${-s.y}px`), o && (e
              .style.width = `${o.x}px`, e.style.height = `${o.y}px`)
        },
        _createImg(e, t) {
            return t = t || document.createElement("img"), t.src = e, t
        },
        _getIconUrl(e) {
            return Ki && this.options[`${e}RetinaUrl`] || this.options[`${e}Url`];
        }
    });

    const Jn = Yn.extend({
        options: {
            iconUrl: "marker-icon.png",
            iconRetinaUrl: "marker-icon-2x.png",
            shadowUrl: "marker-shadow.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            tooltipAnchor: [16, -28],
            shadowSize: [41, 41]
        },
        _getIconUrl(e) {
            return Jn.imagePath || (Jn.imagePath = this._detectIconPath()), (this.options
              .imagePath || Jn.imagePath) + Yn.prototype._getIconUrl.call(this, e)
        },
        _detectIconPath() {
            const e = Z("div", "leaflet-default-icon-path", document.body);
            let t = U(e, "background-image") || U(e, "backgroundImage");
            return document.body.removeChild(e), t = null === t || 0 !== t.indexOf(
              "url") ? "" : t.replace(/^url\(["']?/, "")
              .replace(/marker-icon\.png["']?\)$/, "")
        }
    });

    const Qn = Mn.extend({
        initialize(e) {
            this._marker = e
        },
        addHooks() {
            const e = this._marker._icon;
            this._draggable || (this._draggable = new Rn(e, e, !0)), this._draggable.on({
                dragstart: this._onDragStart,
                predrag: this._onPreDrag,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this)
              .enable(), X(e, "leaflet-marker-draggable")
        },
        removeHooks() {
            this._draggable.off({
                dragstart: this._onDragStart,
                predrag: this._onPreDrag,
                drag: this._onDrag,
                dragend: this._onDragEnd
            }, this)
              .disable(), this._marker._icon && et(this._marker._icon,
              "leaflet-marker-draggable")
        },
        moved() {
            return this._draggable && this._draggable._moved
        },
        _adjustPan(e) {
            const t = this._marker,
                  i = t._map,
                  n = this._marker.options.autoPanSpeed,
                  o = this._marker.options.autoPanPadding,
                  s = lt(t._icon),
                  a = i.getPixelBounds(),
                  r = i.getPixelOrigin(),
                  l = x(a.min._subtract(r)
                    .add(o), a.max._subtract(r)
                    .subtract(o));
            if (!l.contains(s)) {
                const c = w((Math.max(l.max.x, s.x) - l.max.x) / (a.max.x - l.max.x) - (Math
                  .min(l.min.x, s.x) - l.min.x) / (a.min.x - l.min.x), (Math
                  .max(l.max.y, s.y) - l.max.y) / (a.max.y - l.max.y) - (Math
                  .min(l.min.y, s.y) - l.min.y) / (a.min.y - l.min.y))
                  .multiplyBy(n);
                i.panBy(c, {
                    animate: !1
                }), this._draggable._newPos._add(c), this._draggable._startPos._add(
                  c), rt(t._icon, this._draggable._newPos), this._onDrag(e), this
                  ._panRequest = _(this._adjustPan.bind(this, e))
            }
        },
        _onDragStart() {
            this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup()
              .fire("movestart")
              .fire("dragstart")
        },
        _onPreDrag(e) {
            this._marker.options.autoPan && (g(this._panRequest), this._panRequest = _(
              this._adjustPan.bind(this, e)))
        },
        _onDrag(e) {
            const t = this._marker, i = t._shadow, n = lt(t._icon), o = t._map.layerPointToLatLng(n);
            i && rt(i, n), t._latlng = o, e.latlng = o, e.oldLatLng = this._oldLatLng, t
              .fire("move", e)
              .fire("drag", e)
        },
        _onDragEnd(e) {
            g(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend")
              .fire("dragend", e)
        }
    });

    var Xn = Zn.extend({
        options: {
            icon: new Jn,
            interactive: !0,
            keyboard: !0,
            title: "",
            alt: "",
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250,
            pane: "markerPane",
            bubblingMouseEvents: !1,
            draggable: !1,
            autoPan: !1,
            autoPanPadding: [50, 50],
            autoPanSpeed: 10
        },
        initialize(e, t) {
            u(this, t), this._latlng = S(e)
        },
        onAdd(e) {
            this._zoomAnimated = this._zoomAnimated && e.options.markerZoomAnimation, this
              ._zoomAnimated && e.on("zoomanim", this._animateZoom, this), this
              ._initIcon(), this.update()
        },
        onRemove(e) {
            this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this
              .dragging.removeHooks()), delete this.dragging, this._zoomAnimated &&
            e.off("zoomanim", this._animateZoom, this), this._removeIcon(), this
              ._removeShadow()
        },
        getEvents() {
            return {
                zoom: this.update,
                viewreset: this.update
            }
        },
        getLatLng() {
            return this._latlng
        },
        setLatLng(e) {
            const t = this._latlng;
            return this._latlng = S(e), this.update(), this.fire("move", {
                oldLatLng: t,
                latlng: this._latlng
            })
        },
        setZIndexOffset(e) {
            return this.options.zIndexOffset = e, this.update()
        },
        setIcon(e) {
            return this.options.icon = e, this._map && (this._initIcon(), this.update()),
            this._popup && this.bindPopup(this._popup, this._popup.options), this
        },
        getElement() {
            return this._icon
        },
        update() {
            if (this._icon && this._map) {
                const e = this._map.latLngToLayerPoint(this._latlng)
                  .round();
                this._setPos(e)
            }
            return this
        },
        _initIcon() {
            const e = this.options;
            const t = `leaflet-zoom-${this._zoomAnimated ? "animated" : "hide"}`;
            const i = e.icon.createIcon(this._icon);
            let n = !1;
            i !== this._icon && (this._icon && this._removeIcon(), n = !0, e.title && (i
              .title = e.title), "IMG" === i.tagName && (i.alt = e.alt || "")), X(i,
              t), e.keyboard && (i.tabIndex = "0"), this._icon = i, e.riseOnHover &&
            this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
            });
            const o = e.icon.createShadow(this._shadow);
            let s = !1;
            o !== this._shadow && (this._removeShadow(), s = !0), o && (X(o, t), o.alt =
              ""), this._shadow = o, e.opacity < 1 && this._updateOpacity(), n &&
            this.getPane()
              .appendChild(this._icon), this._initInteraction(), o && s && this.getPane(
              "shadowPane")
              .appendChild(this._shadow)
        },
        _removeIcon() {
            this.options.riseOnHover && this.off({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
            }), G(this._icon), this.removeInteractiveTarget(this._icon), this._icon =
              null
        },
        _removeShadow() {
            this._shadow && G(this._shadow), this._shadow = null
        },
        _setPos(e) {
            rt(this._icon, e), this._shadow && rt(this._shadow, e), this._zIndex = e.y +
              this.options.zIndexOffset, this._resetZIndex()
        },
        _updateZIndex(e) {
            this._icon.style.zIndex = this._zIndex + e
        },
        _animateZoom({zoom, center}) {
            const t = this._map._latLngToNewLayerPoint(this._latlng, zoom, center)
              .round();
            this._setPos(t)
        },
        _initInteraction() {
            if (this.options.interactive && (X(this._icon, "leaflet-interactive"), this
              .addInteractiveTarget(this._icon), Qn)) {
                let e = this.options.draggable;
                this.dragging && (e = this.dragging.enabled(), this.dragging.disable()),
                  this.dragging = new Qn(this), e && this.dragging.enable()
            }
        },
        setOpacity(e) {
            return this.options.opacity = e, this._map && this._updateOpacity(), this
        },
        _updateOpacity() {
            const e = this.options.opacity;
            nt(this._icon, e), this._shadow && nt(this._shadow, e)
        },
        _bringToFront() {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex() {
            this._updateZIndex(0)
        },
        _getPopupAnchor() {
            return this.options.icon.options.popupAnchor
        },
        _getTooltipAnchor() {
            return this.options.icon.options.tooltipAnchor
        }
    });

    const eo = Zn.extend({
        options: {
            stroke: !0,
            color: "#3388ff",
            weight: 3,
            opacity: 1,
            lineCap: "round",
            lineJoin: "round",
            dashArray: null,
            dashOffset: null,
            fill: !1,
            fillColor: null,
            fillOpacity: .2,
            fillRule: "evenodd",
            interactive: !0,
            bubblingMouseEvents: !0
        },
        beforeAdd(e) {
            this._renderer = e.getRenderer(this)
        },
        onAdd() {
            this._renderer._initPath(this), this._reset(), this._renderer._addPath(this)
        },
        onRemove() {
            this._renderer._removePath(this)
        },
        redraw() {
            return this._map && this._renderer._updatePath(this), this
        },
        setStyle(e) {
            return u(this, e), this._renderer && this._renderer._updateStyle(this), this
        },
        bringToFront() {
            return this._renderer && this._renderer._bringToFront(this), this
        },
        bringToBack() {
            return this._renderer && this._renderer._bringToBack(this), this
        },
        getElement() {
            return this._path
        },
        _reset() {
            this._project(), this._update()
        },
        _clickTolerance() {
            return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer
              .options.tolerance
        }
    });

    const to = eo.extend({
        options: {
            fill: !0,
            radius: 10
        },
        initialize(e, t) {
            u(this, t), this._latlng = S(e), this._radius = this.options.radius
        },
        setLatLng(e) {
            return this._latlng = S(e), this.redraw(), this.fire("move", {
                latlng: this._latlng
            })
        },
        getLatLng() {
            return this._latlng
        },
        setRadius(e) {
            return this.options.radius = this._radius = e, this.redraw()
        },
        getRadius() {
            return this._radius
        },
        setStyle(e) {
            const t = e && e.radius || this._radius;
            return eo.prototype.setStyle.call(this, e), this.setRadius(t), this
        },
        _project() {
            this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds()
        },
        _updateBounds() {
            const e = this._radius, t = this._radiusY || e, i = this._clickTolerance(), n = [e + i, t + i];
            this._pxBounds = new k(this._point.subtract(n), this._point.add(n))
        },
        _update() {
            this._map && this._updatePath()
        },
        _updatePath() {
            this._renderer._updateCircle(this)
        },
        _empty() {
            return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
        },
        _containsPoint(e) {
            return e.distanceTo(this._point) <= this._radius + this._clickTolerance()
        }
    });

    const io = to.extend({
        initialize(e, i, n) {
            if ("number" == typeof i && (i = t({}, n, {
                radius: i
            })), u(this, i), this._latlng = S(e), isNaN(this.options.radius))
                throw new Error("Circle radius cannot be NaN");
            this._mRadius = this.options.radius
        },
        setRadius(e) {
            return this._mRadius = e, this.redraw()
        },
        getRadius() {
            return this._mRadius
        },
        getBounds() {
            const e = [this._radius, this._radiusY || this._radius];
            return new C(this._map.layerPointToLatLng(this._point.subtract(e)), this._map
              .layerPointToLatLng(this._point.add(e)))
        },
        setStyle: eo.prototype.setStyle,
        _project() {
            const e = this._latlng.lng, t = this._latlng.lat, i = this._map, n = i.options.crs;
            if (n.distance === mi.distance) {
                const o = Math.PI / 180;
                const s = this._mRadius / mi.R / o;
                const a = i.project([t + s, e]);
                const r = i.project([t - s, e]);

                const l = a.add(r)
                  .divideBy(2);

                const c = i.unproject(l)
                  .lat;

                let u = Math.acos((Math.cos(s * o) - Math.sin(t * o) * Math.sin(c * o)) /
                  (Math.cos(t * o) * Math.cos(c * o))) / o;

                (isNaN(u) || 0 === u) && (u = s / Math.cos(Math.PI / 180 * t)), this
                  ._point = l.subtract(i.getPixelOrigin()), this._radius = isNaN(u) ?
                  0 : l.x - i.project([c, e - u])
                  .x, this._radiusY = l.y - a.y
            } else {
                const d = n.unproject(n.project(this._latlng)
                  .subtract([this._mRadius, 0]));
                this._point = i.latLngToLayerPoint(this._latlng), this._radius = this
                  ._point.x - i.latLngToLayerPoint(d)
                  .x
            }
            this._updateBounds()
        }
    });

    var no = eo.extend({
        options: {
            smoothFactor: 1,
            noClip: !1
        },
        initialize(e, t) {
            u(this, t), this._setLatLngs(e)
        },
        getLatLngs() {
            return this._latlngs
        },
        setLatLngs(e) {
            return this._setLatLngs(e), this.redraw()
        },
        isEmpty() {
            return !this._latlngs.length
        },
        closestLayerPoint(e) {
            for (var t, i, n = 1 / 0, o = null, s = $t, a = 0, r = this._parts.length; r >
            a; a++)
                for (let l = this._parts[a], c = 1, u = l.length; u > c; c++) {
                    const d = s(e, t = l[c - 1], i = l[c], !0);
                    n > d && (n = d, o = s(e, t, i))
                }
            return o && (o.distance = Math.sqrt(n)), o
        },
        getCenter() {
            if (!this._map) throw new Error(
              "Must add layer to map before using getCenter()");
            let e;
            let t;
            let i;
            let n;
            let o;
            let s;
            let a;
            const r = this._rings[0];
            const l = r.length;
            if (!l) return null;
            for (e = 0, t = 0; l - 1 > e; e++) t += r[e].distanceTo(r[e + 1]) / 2;
            if (0 === t) return this._map.layerPointToLatLng(r[0]);
            for (e = 0, n = 0; l - 1 > e; e++)
                if (o = r[e], s = r[e + 1], i = o.distanceTo(s), (n += i) > t) return a =
                  (n - t) / i, this._map.layerPointToLatLng([s.x - a * (s.x - o.x),
                    s.y - a * (s.y - o.y)])
        },
        getBounds() {
            return this._bounds
        },
        addLatLng(e, t) {
            return t = t || this._defaultShape(), e = S(e), t.push(e), this._bounds
              .extend(e), this.redraw()
        },
        _setLatLngs(e) {
            this._bounds = new C, this._latlngs = this._convertLatLngs(e)
        },
        _defaultShape() {
            return Ft(this._latlngs) ? this._latlngs : this._latlngs[0]
        },
        _convertLatLngs(e) {
            for (var t = [], i = Ft(e), n = 0, o = e.length; o > n; n++) i ? (t[n] = S(e[
              n]), this._bounds.extend(t[n])) : t[n] = this._convertLatLngs(e[n]);
            return t
        },
        _project() {
            const e = new k;
            this._rings = [], this._projectLatlngs(this._latlngs, this._rings, e);
            const t = this._clickTolerance(), i = new y(t, t);
            this._bounds.isValid() && e.isValid() && (e.min._subtract(i), e.max._add(i),
              this._pxBounds = e)
        },
        _projectLatlngs(e, t, i) {
            let n;
            let o;
            const s = e[0] instanceof T;
            const a = e.length;
            if (s) {
                for (o = [], n = 0; a > n; n++) o[n] = this._map.latLngToLayerPoint(e[n]),
                  i.extend(o[n]);
                t.push(o)
            } else
                for (n = 0; a > n; n++) this._projectLatlngs(e[n], t, i)
        },
        _clipPoints() {
            const e = this._renderer._bounds;
            if (this._parts = [], this._pxBounds && this._pxBounds.intersects(e))
                if (this.options.noClip) this._parts = this._rings;
                else {
                    let t;
                    let i;
                    let n;
                    let o;
                    let s;
                    let a;
                    let r;
                    const l = this._parts;
                    for (t = 0, n = 0, o = this._rings.length; o > t; t++)
                        for (i = 0, s = (r = this._rings[t])
                          .length; s - 1 > i; i++)(a = Nt(r[i], r[i + 1], e, i, !0)) &&
                        (l[n] = l[n] || [], l[n].push(a[0]), a[1] === r[i + 1] &&
                        i !== s - 2 || (l[n].push(a[1]), n++))
                }
        },
        _simplifyPoints() {
            for (let e = this._parts,
                t = this.options.smoothFactor,
                i = 0,
                n = e
                  .length; n > i; i++) e[i] = Pt(e[i], t)
        },
        _update() {
            this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath())
        },
        _updatePath() {
            this._renderer._updatePoly(this)
        },
        _containsPoint(e, t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            const l = this._clickTolerance();
            if (!this._pxBounds || !this._pxBounds.contains(e)) return !1;
            for (i = 0, s = this._parts.length; s > i; i++)
                for (n = 0, o = (a = (r = this._parts[i])
                  .length) - 1; a > n; o = n++)
                    if ((t || 0 !== n) && It(e, r[o], r[n]) <= l) return !0;
            return !1
        }
    });

    no._flat = Bt;

    var oo = no.extend({
          options: {
              fill: !0
          },
          isEmpty() {
              return !this._latlngs.length || !this._latlngs[0].length
          },
          getCenter() {
              if (!this._map) throw new Error(
                "Must add layer to map before using getCenter()");
              let e;
              let t;
              let i;
              let n;
              let o;
              let s;
              let a;
              let r;
              let l;
              const c = this._rings[0];
              const u = c.length;
              if (!u) return null;
              for (s = a = r = 0, e = 0, t = u - 1; u > e; t = e++) i = c[e], n = c[t], o =
                i.y * n.x - n.y * i.x, a += (i.x + n.x) * o, r += (i.y + n.y) * o, s +=
                3 * o;
              return l = 0 === s ? c[0] : [a / s, r / s], this._map.layerPointToLatLng(l)
          },
          _convertLatLngs(e) {
              const t = no.prototype._convertLatLngs.call(this, e), i = t.length;
              return i >= 2 && t[0] instanceof T && t[0].equals(t[i - 1]) && t.pop(), t
          },
          _setLatLngs(e) {
              no.prototype._setLatLngs.call(this, e), Ft(this._latlngs) && (this
                ._latlngs = [this._latlngs])
          },
          _defaultShape() {
              return Ft(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]
          },
          _clipPoints() {
              let e = this._renderer._bounds;
              const t = this.options.weight;
              const i = new y(t, t);
              if (e = new k(e.min.subtract(i), e.max.add(i)), this._parts = [], this
                ._pxBounds && this._pxBounds.intersects(e))
                  if (this.options.noClip) this._parts = this._rings;
                  else
                      for (let n, o = 0, s = this._rings.length; s > o; o++)(n = Ht(this
                        ._rings[o], e, !0))
                        .length && this._parts.push(n)
          },
          _updatePath() {
              this._renderer._updatePoly(this, !0)
          },
          _containsPoint(e) {
              let t, i, n, o, s, a, r, l, c = !1;
              if (!this._pxBounds || !this._pxBounds.contains(e)) return !1;
              for (o = 0, r = this._parts.length; r > o; o++)
                  for (s = 0, a = (l = (t = this._parts[o])
                    .length) - 1; l > s; a = s++) i = t[s], n = t[a], i.y > e.y != n
                    .y > e.y && e.x < (n.x - i.x) * (e.y - i.y) / (n.y - i.y) + i.x && (
                    c = !c);
              return c || no.prototype._containsPoint.call(this, e, !0)
          }
      });

    var so = Kn.extend({
        initialize(e, t) {
            u(this, t), this._layers = {}, e && this.addData(e)
        },
        addData(e) {
            let t;
            let i;
            let n;
            const o = oi(e) ? e : e.features;
            if (o) {
                for (t = 0, i = o.length; i > t; t++)((n = o[t])
                  .geometries || n.geometry || n.features || n.coordinates) && this
                  .addData(n);
                return this
            }
            const s = this.options;
            if (s.filter && !s.filter(e)) return this;
            const a = Wt(e, s);
            return a ? (a.feature = Kt(e), a.defaultOptions = a.options, this.resetStyle(
              a), s.onEachFeature && s.onEachFeature(e, a), this.addLayer(a)) : this
        },
        resetStyle(e) {
            return e.options = t({}, e.defaultOptions), this._setLayerStyle(e, this
              .options.style), this
        },
        setStyle(e) {
            return this.eachLayer(function (t) {
                this._setLayerStyle(t, e)
            }, this)
        },
        _setLayerStyle(e, t) {
            "function" == typeof t && (t = t(e.feature)), e.setStyle && e.setStyle(t)
        }
    });

    const ao = {
        toGeoJSON(e) {
            return Gt(this, {
                type: "Point",
                coordinates: Ut(this.getLatLng(), e)
            })
        }
    };

    Xn.include(ao), io.include(ao), to.include(ao), no.include({
        toGeoJSON(e) {
            const t = !Ft(this._latlngs);
            const i = Zt(this._latlngs, t ? 1 : 0, !1, e);
            return Gt(this, {
                type: `${t ? "Multi" : ""}LineString`,
                coordinates: i
            });
        }
    }), oo.include({
        toGeoJSON(e) {
            const t = !Ft(this._latlngs);
            const i = t && !Ft(this._latlngs[0]);
            let n = Zt(this._latlngs, i ? 2 : t ? 1 : 0, !0, e);
            return t || (n = [n]), Gt(this, {
                type: `${i ? "Multi" : ""}Polygon`,
                coordinates: n
            });
        }
    }), Gn.include({
        toMultiPoint(e) {
            const t = [];
            return this.eachLayer(i => {
                t.push(i.toGeoJSON(e)
                  .geometry.coordinates)
            }), Gt(this, {
                type: "MultiPoint",
                coordinates: t
            });
        },
        toGeoJSON(e) {
            const t = this.feature && this.feature.geometry && this.feature.geometry.type;
            if ("MultiPoint" === t) return this.toMultiPoint(e);
            const i = "GeometryCollection" === t;
            const n = [];
            return this.eachLayer(t => {
                if (t.toGeoJSON) {
                    const o = t.toGeoJSON(e);
                    if (i) n.push(o.geometry);
                    else {
                        const s = Kt(o);
                        "FeatureCollection" === s.type ? n.push(...s
                          .features) : n.push(s)
                    }
                }
            }), i ? Gt(this, {
                geometries: n,
                type: "GeometryCollection"
            }) : {
                type: "FeatureCollection",
                features: n
            };
        }
    });
    const ro = Yt;

    const lo = Zn.extend({
        options: {
            opacity: 1,
            alt: "",
            interactive: !1,
            crossOrigin: !1,
            errorOverlayUrl: "",
            zIndex: 1,
            className: ""
        },
        initialize(e, t, i) {
            this._url = e, this._bounds = z(t), u(this, i)
        },
        onAdd() {
            this._image || (this._initImage(), this.options.opacity < 1 && this
              ._updateOpacity()), this.options.interactive && (X(this._image,
              "leaflet-interactive"), this.addInteractiveTarget(this._image)), this
              .getPane()
              .appendChild(this._image), this._reset()
        },
        onRemove() {
            G(this._image), this.options.interactive && this.removeInteractiveTarget(this
              ._image)
        },
        setOpacity(e) {
            return this.options.opacity = e, this._image && this._updateOpacity(), this
        },
        setStyle({opacity}) {
            return opacity && this.setOpacity(opacity), this;
        },
        bringToFront() {
            return this._map && Y(this._image), this
        },
        bringToBack() {
            return this._map && J(this._image), this
        },
        setUrl(e) {
            return this._url = e, this._image && (this._image.src = e), this
        },
        setBounds(e) {
            return this._bounds = z(e), this._map && this._reset(), this
        },
        getEvents() {
            const e = {
                zoom: this._reset,
                viewreset: this._reset
            };
            return this._zoomAnimated && (e.zoomanim = this._animateZoom), e
        },
        setZIndex(e) {
            return this.options.zIndex = e, this._updateZIndex(), this
        },
        getBounds() {
            return this._bounds
        },
        getElement() {
            return this._image
        },
        _initImage() {
            const e = "IMG" === this._url.tagName, t = this._image = e ? this._url : Z("img");
            X(t, "leaflet-image-layer"), this._zoomAnimated && X(t,
              "leaflet-zoom-animated"), this.options.className && X(t, this.options
              .className), t.onselectstart = a, t.onmousemove = a, t.onload = i(this
              .fire, this, "load"), t.onerror = i(this._overlayOnError, this,
              "error"), (this.options.crossOrigin || "" === this.options
              .crossOrigin) && (t.crossOrigin = !0 === this.options.crossOrigin ?
              "" : this.options.crossOrigin), this.options.zIndex && this
              ._updateZIndex(), e ? this._url = t.src : (t.src = this._url, t.alt = this
              .options.alt)
        },
        _animateZoom({zoom, center}) {
            const t = this._map.getZoomScale(zoom),
                  i = this._map._latLngBoundsToNewLayerBounds(this._bounds, zoom, center)
                    .min;
            at(this._image, i, t)
        },
        _reset() {
            const e = this._image,
                  t = new k(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this
                    ._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                  i = t.getSize();
            rt(e, t.min), e.style.width = `${i.x}px`, e.style.height = `${i.y}px`
        },
        _updateOpacity() {
            nt(this._image, this.options.opacity)
        },
        _updateZIndex() {
            this._image && void 0 !== this.options.zIndex && null !== this.options
              .zIndex && (this._image.style.zIndex = this.options.zIndex)
        },
        _overlayOnError() {
            this.fire("error");
            const e = this.options.errorOverlayUrl;
            e && this._url !== e && (this._url = e, this._image.src = e)
        }
    });

    const co = lo.extend({
        options: {
            autoplay: !0,
            loop: !0
        },
        _initImage() {
            const e = "VIDEO" === this._url.tagName, t = this._image = e ? this._url : Z("video");
            if (X(t, "leaflet-image-layer"), this._zoomAnimated && X(t,
              "leaflet-zoom-animated"), t.onselectstart = a, t.onmousemove = a, t
              .onloadeddata = i(this.fire, this, "load"), e) {
                for (var n = t.getElementsByTagName("source"), o = [], s = 0; s < n
                  .length; s++) o.push(n[s].src);
                this._url = n.length > 0 ? o : [t.src]
            } else {
                oi(this._url) || (this._url = [this._url]), t.autoplay = !!this.options
                  .autoplay, t.loop = !!this.options.loop;
                for (let r = 0; r < this._url.length; r++) {
                    const l = Z("source");
                    l.src = this._url[r], t.appendChild(l)
                }
            }
        }
    });

    const uo = Zn.extend({
        options: {
            offset: [0, 7],
            className: "",
            pane: "popupPane"
        },
        initialize(e, t) {
            u(this, e), this._source = t
        },
        onAdd({_zoomAnimated, _fadeAnimated}) {
            this._zoomAnimated = _zoomAnimated, this._container || this._initLayout(), _fadeAnimated && nt(this._container, 0), clearTimeout(this
              ._removeTimeout), this.getPane()
              .appendChild(this._container), this.update(), _fadeAnimated && nt(this
              ._container, 1), this.bringToFront()
        },
        onRemove({_fadeAnimated}) {
            _fadeAnimated ? (nt(this._container, 0), this._removeTimeout = setTimeout(i(
              G, void 0, this._container), 200)) : G(this._container)
        },
        getLatLng() {
            return this._latlng
        },
        setLatLng(e) {
            return this._latlng = S(e), this._map && (this._updatePosition(), this
              ._adjustPan()), this
        },
        getContent() {
            return this._content
        },
        setContent(e) {
            return this._content = e, this.update(), this
        },
        getElement() {
            return this._container
        },
        update() {
            this._map && (this._container.style.visibility = "hidden", this
              ._updateContent(), this._updateLayout(), this._updatePosition(), this
              ._container.style.visibility = "", this._adjustPan())
        },
        getEvents() {
            const e = {
                zoom: this._updatePosition,
                viewreset: this._updatePosition
            };
            return this._zoomAnimated && (e.zoomanim = this._animateZoom), e
        },
        isOpen() {
            return !!this._map && this._map.hasLayer(this)
        },
        bringToFront() {
            return this._map && Y(this._container), this
        },
        bringToBack() {
            return this._map && J(this._container), this
        },
        _updateContent() {
            if (this._content) {
                const e = this._contentNode,
                      t = "function" == typeof this._content ? this._content(this._source ||
                        this) : this._content;
                if ("string" == typeof t) e.innerHTML = t;
                else {
                    for (; e.hasChildNodes();) e.removeChild(e.firstChild);
                    e.appendChild(t)
                }
                this.fire("contentupdate")
            }
        },
        _updatePosition() {
            if (this._map) {
                const e = this._map.latLngToLayerPoint(this._latlng);
                let t = w(this.options.offset);
                const i = this._getAnchor();
                this._zoomAnimated ? rt(this._container, e.add(i)) : t = t.add(e)
                  .add(i);
                const n = this._containerBottom = -t.y, o = this._containerLeft = -Math.round(this._containerWidth / 2) + t.x;
                this._container.style.bottom = `${n}px`, this._container.style.left = `${o}px`
            }
        },
        _getAnchor() {
            return [0, 0]
        }
    });

    const ho = uo.extend({
        options: {
            maxWidth: 300,
            minWidth: 50,
            maxHeight: null,
            autoPan: !0,
            autoPanPaddingTopLeft: null,
            autoPanPaddingBottomRight: null,
            autoPanPadding: [5, 5],
            keepInView: !1,
            closeButton: !0,
            autoClose: !0,
            closeOnEscapeKey: !0,
            className: ""
        },
        openOn(e) {
            return e.openPopup(this), this
        },
        onAdd(e) {
            uo.prototype.onAdd.call(this, e), e.fire("popupopen", {
                popup: this
            }), this._source && (this._source.fire("popupopen", {
                popup: this
            }, !0), this._source instanceof eo || this._source.on("preclick", bt))
        },
        onRemove(e) {
            uo.prototype.onRemove.call(this, e), e.fire("popupclose", {
                popup: this
            }), this._source && (this._source.fire("popupclose", {
                popup: this
            }, !0), this._source instanceof eo || this._source.off("preclick",
              bt))
        },
        getEvents() {
            const e = uo.prototype.getEvents.call(this);
            return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick :
              this._map.options.closePopupOnClick) && (e.preclick = this._close),
            this.options.keepInView && (e.moveend = this._adjustPan), e
        },
        _close() {
            this._map && this._map.closePopup(this)
        },
        _initLayout() {
            const e = "leaflet-popup", t = this._container = Z("div", `${e} ${this.options.className || ""} leaflet-zoom-animated`), i = this._wrapper = Z("div", `${e}-content-wrapper`, t);
            if (this._contentNode = Z("div", `${e}-content`, i), wt(i), yt(this
              ._contentNode), ft(i, "contextmenu", bt), this._tipContainer = Z(
              "div", `${e}-tip-container`, t), this._tip = Z("div", `${e}-tip`, this
              ._tipContainer), this.options.closeButton) {
                const n = this._closeButton = Z("a", `${e}-close-button`, t);
                n.href = "#close", n.innerHTML = "&#215;", ft(n, "click", this
                  ._onCloseButtonClick, this)
            }
        },
        _updateLayout() {
            const e = this._contentNode, t = e.style;
            t.width = "", t.whiteSpace = "nowrap";
            let i = e.offsetWidth;
            i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options
              .minWidth), t.width = `${i + 1}px`, t.whiteSpace = "", t.height = "";
            const n = e.offsetHeight, o = this.options.maxHeight;
            o && n > o ? (t.height = `${o}px`, X(e, "leaflet-popup-scrolled")) : et(e,
              "leaflet-popup-scrolled"), this._containerWidth = this._container
              .offsetWidth
        },
        _animateZoom({zoom, center}) {
            const t = this._map._latLngToNewLayerPoint(this._latlng, zoom, center), i = this._getAnchor();
            rt(this._container, t.add(i))
        },
        _adjustPan() {
            if (this.options.autoPan) {
                this._map._panAnim && this._map._panAnim.stop();
                const e = this._map, t = parseInt(U(this._container, "marginBottom"), 10) || 0, i = this._container.offsetHeight + t, n = this._containerWidth, o = new y(this._containerLeft, -i - this._containerBottom);
                o._add(lt(this._container));
                const s = e.layerPointToContainerPoint(o);
                const a = w(this.options.autoPanPadding);
                const r = w(this.options.autoPanPaddingTopLeft || a);
                const l = w(this.options.autoPanPaddingBottomRight || a);
                const c = e.getSize();
                let u = 0;
                let d = 0;
                s.x + n + l.x > c.x && (u = s.x + n - c.x + l.x), s.x - u - r.x < 0 && (
                  u = s.x - r.x), s.y + i + l.y > c.y && (d = s.y + i - c.y + l.y),
                s.y - d - r.y < 0 && (d = s.y - r.y), (u || d) && e.fire(
                  "autopanstart")
                  .panBy([u, d])
            }
        },
        _onCloseButtonClick(e) {
            this._close(), xt(e)
        },
        _getAnchor() {
            return w(this._source && this._source._getPopupAnchor ? this._source
              ._getPopupAnchor() : [0, 0])
        }
    });

    zn.mergeOptions({
        closePopupOnClick: !0
    }), zn.include({
        openPopup(e, t, i) {
            return e instanceof ho || (e = new ho(i)
              .setContent(e)), t && e.setLatLng(t), this.hasLayer(e) ? this : (this
              ._popup && this._popup.options.autoClose && this.closePopup(), this
              ._popup = e, this.addLayer(e))
        },
        closePopup(e) {
            return e && e !== this._popup || (e = this._popup, this._popup = null), e &&
            this.removeLayer(e), this
        }
    }), Zn.include({
        bindPopup(e, t) {
            return e instanceof ho ? (u(e, t), this._popup = e, e._source = this) : (this
              ._popup && !t || (this._popup = new ho(t, this)), this._popup
              .setContent(e)), this._popupHandlersAdded || (this.on({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
            }), this._popupHandlersAdded = !0), this
        },
        unbindPopup() {
            return this._popup && (this.off({
                click: this._openPopup,
                keypress: this._onKeyPress,
                remove: this.closePopup,
                move: this._movePopup
            }), this._popupHandlersAdded = !1, this._popup = null), this
        },
        openPopup(e, t) {
            if (e instanceof Zn || (t = e, e = this), e instanceof Kn)
                for (const i in this._layers) {
                    e = this._layers[i];
                    break
                }
            return t || (t = e.getCenter ? e.getCenter() : e.getLatLng()), this._popup &&
            this._map && (this._popup._source = e, this._popup.update(), this._map
              .openPopup(this._popup, t)), this
        },
        closePopup() {
            return this._popup && this._popup._close(), this
        },
        togglePopup(e) {
            return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(
              e)), this
        },
        isPopupOpen() {
            return !!this._popup && this._popup.isOpen()
        },
        setPopupContent(e) {
            return this._popup && this._popup.setContent(e), this
        },
        getPopup() {
            return this._popup
        },
        _openPopup(e) {
            const t = e.layer || e.target;
            this._popup && this._map && (xt(e), t instanceof eo ? this.openPopup(e
              .layer || e.target, e.latlng) : this._map.hasLayer(this._popup) &&
            this._popup._source === t ? this.closePopup() : this.openPopup(t, e
              .latlng))
        },
        _movePopup({latlng}) {
            this._popup.setLatLng(latlng)
        },
        _onKeyPress(e) {
            13 === e.originalEvent.keyCode && this._openPopup(e)
        }
    });
    const po = uo.extend({
        options: {
            pane: "tooltipPane",
            offset: [0, 0],
            direction: "auto",
            permanent: !1,
            sticky: !1,
            interactive: !1,
            opacity: .9
        },
        onAdd(e) {
            uo.prototype.onAdd.call(this, e), this.setOpacity(this.options.opacity), e
              .fire("tooltipopen", {
                  tooltip: this
              }), this._source && this._source.fire("tooltipopen", {
                tooltip: this
            }, !0)
        },
        onRemove(e) {
            uo.prototype.onRemove.call(this, e), e.fire("tooltipclose", {
                tooltip: this
            }), this._source && this._source.fire("tooltipclose", {
                tooltip: this
            }, !0)
        },
        getEvents() {
            const e = uo.prototype.getEvents.call(this);
            return Ui && !this.options.permanent && (e.preclick = this._close), e
        },
        _close() {
            this._map && this._map.closeTooltip(this)
        },
        _initLayout() {
            const e = `leaflet-tooltip ${this.options.className || ""} leaflet-zoom-${this._zoomAnimated ? "animated" : "hide"}`;
            this._contentNode = this._container = Z("div", e)
        },
        _updateLayout() {},
        _adjustPan() {},
        _setPosition(e) {
            const t = this._map;
            const i = this._container;
            const n = t.latLngToContainerPoint(t.getCenter());
            const o = t.layerPointToContainerPoint(e);
            let s = this.options.direction;
            const a = i.offsetWidth;
            const r = i.offsetHeight;
            const l = w(this.options.offset);
            const c = this._getAnchor();
            "top" === s ? e = e.add(w(-a / 2 + l.x, -r + l.y + c.y, !0)) : "bottom" ===
            s ? e = e.subtract(w(a / 2 - l.x, -l.y, !0)) : "center" === s ? e = e
              .subtract(w(a / 2 + l.x, r / 2 - c.y + l.y, !0)) : "right" === s ||
            "auto" === s && o.x < n.x ? (s = "right", e = e.add(w(l.x + c.x, c.y - r /
              2 + l.y, !0))) : (s = "left", e = e.subtract(w(a + c.x - l.x, r / 2 -
              c.y - l.y, !0))), et(i, "leaflet-tooltip-right"), et(i,
              "leaflet-tooltip-left"), et(i, "leaflet-tooltip-top"), et(i,
              "leaflet-tooltip-bottom"), X(i, `leaflet-tooltip-${s}`), rt(i, e)
        },
        _updatePosition() {
            const e = this._map.latLngToLayerPoint(this._latlng);
            this._setPosition(e)
        },
        setOpacity(e) {
            this.options.opacity = e, this._container && nt(this._container, e)
        },
        _animateZoom({zoom, center}) {
            const t = this._map._latLngToNewLayerPoint(this._latlng, zoom, center);
            this._setPosition(t)
        },
        _getAnchor() {
            return w(this._source && this._source._getTooltipAnchor && !this.options
              .sticky ? this._source._getTooltipAnchor() : [0, 0])
        }
    });
    zn.include({
        openTooltip(e, t, i) {
            return e instanceof po || (e = new po(i)
              .setContent(e)), t && e.setLatLng(t), this.hasLayer(e) ? this : this
              .addLayer(e)
        },
        closeTooltip(e) {
            return e && this.removeLayer(e), this
        }
    }), Zn.include({
        bindTooltip(e, t) {
            return e instanceof po ? (u(e, t), this._tooltip = e, e._source = this) : (
              this._tooltip && !t || (this._tooltip = new po(t, this)), this
                ._tooltip.setContent(e)), this._initTooltipInteractions(), this
              ._tooltip.options.permanent && this._map && this._map.hasLayer(this) &&
            this.openTooltip(), this
        },
        unbindTooltip() {
            return this._tooltip && (this._initTooltipInteractions(!0), this
              .closeTooltip(), this._tooltip = null), this
        },
        _initTooltipInteractions(e) {
            if (e || !this._tooltipHandlersAdded) {
                const t = e ? "off" : "on";

                const i = {
                    remove: this.closeTooltip,
                    move: this._moveTooltip
                };

                this._tooltip.options.permanent ? i.add = this._openTooltip : (i
                  .mouseover = this._openTooltip, i.mouseout = this.closeTooltip,
                this._tooltip.options.sticky && (i.mousemove = this._moveTooltip),
                Ui && (i.click = this._openTooltip)), this[t](i), this
                  ._tooltipHandlersAdded = !e
            }
        },
        openTooltip(e, t) {
            if (e instanceof Zn || (t = e, e = this), e instanceof Kn)
                for (const i in this._layers) {
                    e = this._layers[i];
                    break
                }
            return t || (t = e.getCenter ? e.getCenter() : e.getLatLng()), this
              ._tooltip && this._map && (this._tooltip._source = e, this._tooltip
              .update(), this._map.openTooltip(this._tooltip, t), this._tooltip
              .options.interactive && this._tooltip._container && (X(this._tooltip
              ._container, "leaflet-clickable"), this.addInteractiveTarget(
              this._tooltip._container))), this
        },
        closeTooltip() {
            return this._tooltip && (this._tooltip._close(), this._tooltip.options
              .interactive && this._tooltip._container && (et(this._tooltip
              ._container, "leaflet-clickable"), this
              .removeInteractiveTarget(this._tooltip._container))), this
        },
        toggleTooltip(e) {
            return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this
              .openTooltip(e)), this
        },
        isTooltipOpen() {
            return this._tooltip.isOpen()
        },
        setTooltipContent(e) {
            return this._tooltip && this._tooltip.setContent(e), this
        },
        getTooltip() {
            return this._tooltip
        },
        _openTooltip(e) {
            const t = e.layer || e.target;
            this._tooltip && this._map && this.openTooltip(t, this._tooltip.options
              .sticky ? e.latlng : void 0)
        },
        _moveTooltip({latlng, originalEvent}) {
            let t;
            let i;
            let n = latlng;
            this._tooltip.options.sticky && originalEvent && (t = this._map
              .mouseEventToContainerPoint(originalEvent), i = this._map
              .containerPointToLayerPoint(t), n = this._map.layerPointToLatLng(i)),
              this._tooltip.setLatLng(n)
        }
    });
    const mo = Yn.extend({
        options: {
            iconSize: [12, 12],
            html: !1,
            bgPos: null,
            className: "leaflet-div-icon"
        },
        createIcon(e) {
            const t = e && "DIV" === e.tagName ? e : document.createElement("div");
            const i = this.options;
            if (t.innerHTML = !1 !== i.html ? i.html : "", i.bgPos) {
                const n = w(i.bgPos);
                t.style.backgroundPosition = `${-n.x}px ${-n.y}px`
            }
            return this._setIconStyles(t, "icon"), t
        },
        createShadow() {
            return null
        }
    });
    Yn.Default = Jn;

    const fo = Zn.extend({
          options: {
              tileSize: 256,
              opacity: 1,
              updateWhenIdle: Bi,
              updateWhenZooming: !0,
              updateInterval: 200,
              zIndex: 1,
              bounds: null,
              minZoom: 0,
              maxZoom: void 0,
              maxNativeZoom: void 0,
              minNativeZoom: void 0,
              noWrap: !1,
              pane: "tilePane",
              className: "",
              keepBuffer: 2
          },
          initialize(e) {
              u(this, e)
          },
          onAdd() {
              this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(),
                this._update()
          },
          beforeAdd(e) {
              e._addZoomLimit(this)
          },
          onRemove(e) {
              this._removeAllTiles(), G(this._container), e._removeZoomLimit(this), this
                ._container = null, this._tileZoom = void 0
          },
          bringToFront() {
              return this._map && (Y(this._container), this._setAutoZIndex(Math.max)), this
          },
          bringToBack() {
              return this._map && (J(this._container), this._setAutoZIndex(Math.min)), this
          },
          getContainer() {
              return this._container
          },
          setOpacity(e) {
              return this.options.opacity = e, this._updateOpacity(), this
          },
          setZIndex(e) {
              return this.options.zIndex = e, this._updateZIndex(), this
          },
          isLoading() {
              return this._loading
          },
          redraw() {
              return this._map && (this._removeAllTiles(), this._update()), this
          },
          getEvents() {
              const e = {
                  viewprereset: this._invalidateAll,
                  viewreset: this._resetView,
                  zoom: this._resetView,
                  moveend: this._onMoveEnd
              };
              return this.options.updateWhenIdle || (this._onMove || (this._onMove = o(this
                ._onMoveEnd, this.options.updateInterval, this)), e.move = this
                ._onMove), this._zoomAnimated && (e.zoomanim = this._animateZoom), e
          },
          createTile() {
              return document.createElement("div")
          },
          getTileSize() {
              const e = this.options.tileSize;
              return e instanceof y ? e : new y(e, e)
          },
          _updateZIndex() {
              this._container && void 0 !== this.options.zIndex && null !== this.options
                .zIndex && (this._container.style.zIndex = this.options.zIndex)
          },
          _setAutoZIndex(e) {
              for (var t, i = this.getPane()
                .children, n = -e(-1 / 0, 1 / 0), o = 0, s = i.length; s > o; o++) t =
                i[o].style.zIndex, i[o] !== this._container && t && (n = e(n, +t));
              isFinite(n) && (this.options.zIndex = n + e(-1, 1), this._updateZIndex())
          },
          _updateOpacity() {
              if (this._map && !xi) {
                  nt(this._container, this.options.opacity);
                  const e = +new Date;
                  let t = !1;
                  let i = !1;
                  for (const n in this._tiles) {
                      const o = this._tiles[n];
                      if (o.current && o.loaded) {
                          const s = Math.min(1, (e - o.loaded) / 200);
                          nt(o.el, s), 1 > s ? t = !0 : (o.active ? i = !0 : this
                            ._onOpaqueTile(o), o.active = !0)
                      }
                  }
                  i && !this._noPrune && this._pruneTiles(), t && (g(this._fadeFrame), this
                    ._fadeFrame = _(this._updateOpacity, this))
              }
          },
          _onOpaqueTile: a,
          _initContainer() {
              this._container || (this._container = Z("div", `leaflet-layer ${this
  .options.className || ""}`), this._updateZIndex(), this.options
                .opacity < 1 && this._updateOpacity(), this.getPane()
                .appendChild(this._container))
          },
          _updateLevels() {
              const e = this._tileZoom, t = this.options.maxZoom;
              if (void 0 !== e) {
                  for (const i in this._levels) this._levels[i].el.children.length || i ===
                  e ? (this._levels[i].el.style.zIndex = t - Math.abs(e - i), this
                    ._onUpdateLevel(i)) : (G(this._levels[i].el), this
                    ._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this
                    ._levels[i]);
                  let n = this._levels[e];
                  const o = this._map;
                  return n || ((n = this._levels[e] = {})
                    .el = Z("div", "leaflet-tile-container leaflet-zoom-animated",
                    this._container), n.el.style.zIndex = t, n.origin = o.project(
                    o.unproject(o.getPixelOrigin()), e)
                    .round(), n.zoom = e, this._setZoomTransform(n, o.getCenter(), o
                    .getZoom()), n.el.offsetWidth, this._onCreateLevel(n)), this
                    ._level = n, n
              }
          },
          _onUpdateLevel: a,
          _onRemoveLevel: a,
          _onCreateLevel: a,
          _pruneTiles() {
              if (this._map) {
                  let e;
                  let t;
                  const i = this._map.getZoom();
                  if (i > this.options.maxZoom || i < this.options.minZoom) this
                    ._removeAllTiles();
                  else {
                      for (e in this._tiles)(t = this._tiles[e])
                        .retain = t.current;
                      for (e in this._tiles)
                          if ((t = this._tiles[e])
                            .current && !t.active) {
                              const n = t.coords;
                              this._retainParent(n.x, n.y, n.z, n.z - 5) || this
                                ._retainChildren(n.x, n.y, n.z, n.z + 2)
                          } for (e in this._tiles) this._tiles[e].retain || this
                        ._removeTile(e)
                  }
              }
          },
          _removeTilesAtZoom(e) {
              for (const t in this._tiles) this._tiles[t].coords.z === e && this._removeTile(
                t)
          },
          _removeAllTiles() {
              for (const e in this._tiles) this._removeTile(e)
          },
          _invalidateAll() {
              for (const e in this._levels) G(this._levels[e].el), this._onRemoveLevel(e),
                delete this._levels[e];
              this._removeAllTiles(), this._tileZoom = void 0
          },
          _retainParent(e, t, i, n) {
              const o = Math.floor(e / 2), s = Math.floor(t / 2), a = i - 1, r = new y(+o, +s);
              r.z = +a;
              const l = this._tileCoordsToKey(r), c = this._tiles[l];
              return c && c.active ? (c.retain = !0, !0) : (c && c.loaded && (c.retain = !
                0), a > n && this._retainParent(o, s, a, n))
          },
          _retainChildren(e, t, i, n) {
              for (let o = 2 * e; 2 * e + 2 > o; o++)
                  for (let s = 2 * t; 2 * t + 2 > s; s++) {
                      const a = new y(o, s);
                      a.z = i + 1;
                      const r = this._tileCoordsToKey(a), l = this._tiles[r];
                      l && l.active ? l.retain = !0 : (l && l.loaded && (l.retain = !0), n >
                      i + 1 && this._retainChildren(o, s, i + 1, n))
                  }
          },
          _resetView(e) {
              const t = e && (e.pinch || e.flyTo);
              this._setView(this._map.getCenter(), this._map.getZoom(), t, t)
          },
          _animateZoom({center, zoom, noUpdate}) {
              this._setView(center, zoom, !0, noUpdate)
          },
          _clampZoom(e) {
              const t = this.options;
              return void 0 !== t.minNativeZoom && e < t.minNativeZoom ? t.minNativeZoom :
                void 0 !== t.maxNativeZoom && t.maxNativeZoom < e ? t.maxNativeZoom : e
          },
          _setView(e, t, i, n) {
              let o = this._clampZoom(Math.round(t));
              (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !==
                this.options.minZoom && o < this.options.minZoom) && (o = void 0);
              const s = this.options.updateWhenZooming && o !== this._tileZoom;
              n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(),
                this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(
                e), i || this._pruneTiles(), this._noPrune = !!i), this
                ._setZoomTransforms(e, t)
          },
          _setZoomTransforms(e, t) {
              for (const i in this._levels) this._setZoomTransform(this._levels[i], e, t)
          },
          _setZoomTransform({zoom, origin, el}, t, i) {
              const n = this._map.getZoomScale(i, zoom),
                    o = origin.multiplyBy(n)
                      .subtract(this._map._getNewPixelOrigin(t, i))
                      .round();
              Fi ? at(el, o, n) : rt(el, o)
          },
          _resetGrid() {
              const e = this._map, t = e.options.crs, i = this._tileSize = this.getTileSize(), n = this._tileZoom, o = this._map.getPixelWorldBounds(this._tileZoom);
              o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = t
                .wrapLng && !this.options.noWrap && [Math.floor(e.project([0, t.wrapLng[
                0]], n)
                .x / i.x), Math.ceil(e.project([0, t.wrapLng[1]], n)
                .x / i.y)], this._wrapY = t.wrapLat && !this.options.noWrap && [Math
                .floor(e.project([t.wrapLat[0], 0], n)
                  .y / i.x), Math.ceil(e.project([t.wrapLat[1], 0], n)
                .y / i.y)]
          },
          _onMoveEnd() {
              this._map && !this._map._animatingZoom && this._update()
          },
          _getTiledPixelBounds(e) {
              const t = this._map,
                    i = t._animatingZoom ? Math.max(t._animateToZoom, t.getZoom()) : t
                      .getZoom(),
                    n = t.getZoomScale(i, this._tileZoom),
                    o = t.project(e, this._tileZoom)
                      .floor(),
                    s = t.getSize()
                      .divideBy(2 * n);
              return new k(o.subtract(s), o.add(s))
          },
          _update(e) {
              const t = this._map;
              if (t) {
                  const i = this._clampZoom(t.getZoom());
                  if (void 0 === e && (e = t.getCenter()), void 0 !== this._tileZoom) {
                      const n = this._getTiledPixelBounds(e),
                            o = this._pxBoundsToTileRange(n),
                            s = o.getCenter(),
                            a = [],
                            r = this.options.keepBuffer,
                            l = new k(o.getBottomLeft()
                              .subtract([r, -r]), o.getTopRight()
                              .add([r, -r]));
                      if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) &&
                        isFinite(o.max.y))) throw new Error(
                        "Attempted to load an infinite number of tiles");
                      for (const c in this._tiles) {
                          const u = this._tiles[c].coords;
                          u.z === this._tileZoom && l.contains(new y(u.x, u.y)) || (this
                            ._tiles[c].current = !1)
                      }
                      if (Math.abs(i - this._tileZoom) > 1) this._setView(e, i);
                      else {
                          for (let d = o.min.y; d <= o.max.y; d++)
                              for (var h = o.min.x; h <= o.max.x; h++) {
                                  const p = new y(h, d);
                                  if (p.z = this._tileZoom, this._isValidTile(p)) {
                                      const m = this._tiles[this._tileCoordsToKey(p)];
                                      m ? m.current = !0 : a.push(p)
                                  }
                              }
                          if (a.sort((e, t) => e.distanceTo(s) - t.distanceTo(s)), 0 !== a.length) {
                              this._loading || (this._loading = !0, this.fire("loading"));
                              const f = document.createDocumentFragment();
                              for (h = 0; h < a.length; h++) this._addTile(a[h], f);
                              this._level.el.appendChild(f)
                          }
                      }
                  }
              }
          },
          _isValidTile(e) {
              const t = this._map.options.crs;
              if (!t.infinite) {
                  const i = this._globalTileRange;
                  if (!t.wrapLng && (e.x < i.min.x || e.x > i.max.x) || !t.wrapLat && (e.y <
                    i.min.y || e.y > i.max.y)) return !1
              }
              if (!this.options.bounds) return !0;
              const n = this._tileCoordsToBounds(e);
              return z(this.options.bounds)
                .overlaps(n)
          },
          _keyToBounds(e) {
              return this._tileCoordsToBounds(this._keyToTileCoords(e))
          },
          _tileCoordsToNwSe(e) {
              const t = this._map, i = this.getTileSize(), n = e.scaleBy(i), o = n.add(i);
              return [t.unproject(n, e.z), t.unproject(o, e.z)]
          },
          _tileCoordsToBounds(e) {
              const t = this._tileCoordsToNwSe(e);
              let i = new C(t[0], t[1]);
              return this.options.noWrap || (i = this._map.wrapLatLngBounds(i)), i
          },
          _tileCoordsToKey(e) {
              return `${e.x}:${e.y}:${e.z}`;
          },
          _keyToTileCoords(e) {
              const t = e.split(":"), i = new y(+t[0], +t[1]);
              return i.z = +t[2], i
          },
          _removeTile(e) {
              const t = this._tiles[e];
              t && (G(t.el), delete this._tiles[e], this.fire("tileunload", {
                  tile: t.el,
                  coords: this._keyToTileCoords(e)
              }))
          },
          _initTile(e) {
              X(e, "leaflet-tile");
              const t = this.getTileSize();
              e.style.width = `${t.x}px`, e.style.height = `${t.y}px`, e.onselectstart = a,
                e.onmousemove = a, xi && this.options.opacity < 1 && nt(e, this.options
                .opacity), Ti && !Si && (e.style.WebkitBackfaceVisibility = "hidden")
          },
          _addTile(e, t) {
              const n = this._getTilePos(e), o = this._tileCoordsToKey(e), s = this.createTile(this._wrapCoords(e), i(this._tileReady, this, e));
              this._initTile(s), this.createTile.length < 2 && _(i(this._tileReady, this, e,
                null, s)), rt(s, n), this._tiles[o] = {
                  el: s,
                  coords: e,
                  current: !0
              }, t.appendChild(s), this.fire("tileloadstart", {
                  tile: s,
                  coords: e
              })
          },
          _tileReady(e, t, n) {
              t && this.fire("tileerror", {
                  error: t,
                  tile: n,
                  coords: e
              });
              const o = this._tileCoordsToKey(e);
              (n = this._tiles[o]) && (n.loaded = +new Date, this._map._fadeAnimated ? (nt(n
                .el, 0), g(this._fadeFrame), this._fadeFrame = _(this
                ._updateOpacity, this)) : (n.active = !0, this._pruneTiles()), t || (
                X(n.el, "leaflet-tile-loaded"), this.fire("tileload", {
                    tile: n.el,
                    coords: e
                })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"),
                xi || !this._map._fadeAnimated ? _(this._pruneTiles, this) :
                  setTimeout(i(this._pruneTiles, this), 250)))
          },
          _getTilePos(e) {
              return e.scaleBy(this.getTileSize())
                .subtract(this._level.origin)
          },
          _wrapCoords(e) {
              const t = new y(this._wrapX ? s(e.x, this._wrapX) : e.x, this._wrapY ? s(e.y,
                this._wrapY) : e.y);
              return t.z = e.z, t
          },
          _pxBoundsToTileRange({min, max}) {
              const t = this.getTileSize();
              return new k(min.unscaleBy(t)
                .floor(), max.unscaleBy(t)
                .ceil()
                .subtract([1, 1]));
          },
          _noTilesToLoad() {
              for (const e in this._tiles)
                  if (!this._tiles[e].loaded) return !1;
              return !0
          }
      });

    var _o = fo.extend({
        options: {
            minZoom: 0,
            maxZoom: 18,
            subdomains: "abc",
            errorTileUrl: "",
            zoomOffset: 0,
            tms: !1,
            zoomReverse: !1,
            detectRetina: !1,
            crossOrigin: !1
        },
        initialize(e, t) {
            this._url = e, (t = u(this, t))
              .detectRetina && Ki && t.maxZoom > 0 && (t.tileSize = Math.floor(t
              .tileSize / 2), t.zoomReverse ? (t.zoomOffset--, t.minZoom++) : (t
              .zoomOffset++, t.maxZoom--), t.minZoom = Math.max(0, t.minZoom)),
            "string" == typeof t.subdomains && (t.subdomains = t.subdomains.split(
              "")), Ti || this.on("tileunload", this._onTileRemove)
        },
        setUrl(e, t) {
            return this._url === e && void 0 === t && (t = !0), this._url = e, t || this
              .redraw(), this
        },
        createTile(e, t) {
            const n = document.createElement("img");
            return ft(n, "load", i(this._tileOnLoad, this, t, n)), ft(n, "error", i(this
              ._tileOnError, this, t, n)), (this.options.crossOrigin || "" === this
              .options.crossOrigin) && (n.crossOrigin = !0 === this.options
              .crossOrigin ? "" : this.options.crossOrigin), n.alt = "", n
              .setAttribute("role", "presentation"), n.src = this.getTileUrl(e), n
        },
        getTileUrl(e) {
            const i = {
                r: Ki ? "@2x" : "",
                s: this._getSubdomain(e),
                x: e.x,
                y: e.y,
                z: this._getZoomForUrl()
            };
            if (this._map && !this._map.options.crs.infinite) {
                const n = this._globalTileRange.max.y - e.y;
                this.options.tms && (i.y = n), i["-y"] = n
            }
            return h(this._url, t(i, this.options))
        },
        _tileOnLoad(e, t) {
            xi ? setTimeout(i(e, this, null, t), 0) : e(null, t)
        },
        _tileOnError(e, t, i) {
            const n = this.options.errorTileUrl;
            n && t.getAttribute("src") !== n && (t.src = n), e(i, t)
        },
        _onTileRemove({tile}) {
            tile.onload = null
        },
        _getZoomForUrl() {
            let e = this._tileZoom;
            const t = this.options.maxZoom;
            const i = this.options.zoomReverse;
            const n = this.options.zoomOffset;
            return i && (e = t - e), e + n
        },
        _getSubdomain(e) {
            const t = Math.abs(e.x + e.y) % this.options.subdomains.length;
            return this.options.subdomains[t]
        },
        _abortLoading() {
            let e, t;
            for (e in this._tiles) this._tiles[e].coords.z !== this._tileZoom && ((t =
              this._tiles[e].el)
              .onload = a, t.onerror = a, t.complete || (t.src = si, G(t),
              delete this._tiles[e]))
        },
        _removeTile(e) {
            const t = this._tiles[e];
            return t ? (Ei || t.el.setAttribute("src", si), fo.prototype._removeTile.call(
              this, e)) : void 0
        },
        _tileReady(e, t, i) {
            return !this._map || i && i.getAttribute("src") === si ? void 0 : fo.prototype
              ._tileReady.call(this, e, t, i)
        }
    });

    const go = _o.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1,
            version: "1.1.1"
        },
        options: {
            crs: null,
            uppercase: !1
        },
        initialize(e, i) {
            this._url = e;
            const n = t({}, this.defaultWmsParams);
            for (const o in i) o in this.options || (n[o] = i[o]);
            const s = (i = u(this, i))
                      .detectRetina && Ki ? 2 : 1,
                  a = this.getTileSize();
            n.width = a.x * s, n.height = a.y * s, this.wmsParams = n
        },
        onAdd(e) {
            this._crs = this.options.crs || e.options.crs, this._wmsVersion = parseFloat(
              this.wmsParams.version);
            const t = this._wmsVersion >= 1.3 ? "crs" : "srs";
            this.wmsParams[t] = this._crs.code, _o.prototype.onAdd.call(this, e)
        },
        getTileUrl(e) {
            const t = this._tileCoordsToNwSe(e),
                  i = this._crs,
                  n = x(i.project(t[0]), i.project(t[1])),
                  o = n.min,
                  s = n.max,
                  a = (this._wmsVersion >= 1.3 && this._crs === qn ? [o.y, o.x, s.y, s.x] :
                    [o.x, o.y, s.x, s.y])
                    .join(","),
                  r = _o.prototype.getTileUrl.call(this, e);
            return r + d(this.wmsParams, r, this.options.uppercase) + (this.options
              .uppercase ? "&BBOX=" : "&bbox=") + a
        },
        setParams(e, i) {
            return t(this.wmsParams, e), i || this.redraw(), this
        }
    });

    _o.WMS = go, Jt.wms = (e, t) => new go(e, t);

    const vo = Zn.extend({
          options: {
              padding: .1,
              tolerance: 0
          },
          initialize(e) {
              u(this, e), n(this), this._layers = this._layers || {}
          },
          onAdd() {
              this._container || (this._initContainer(), this._zoomAnimated && X(this
                ._container, "leaflet-zoom-animated")), this.getPane()
                .appendChild(this._container), this._update(), this.on("update", this
                ._updatePaths, this)
          },
          onRemove() {
              this.off("update", this._updatePaths, this), this._destroyContainer()
          },
          getEvents() {
              const e = {
                  viewreset: this._reset,
                  zoom: this._onZoom,
                  moveend: this._update,
                  zoomend: this._onZoomEnd
              };
              return this._zoomAnimated && (e.zoomanim = this._onAnimZoom), e
          },
          _onAnimZoom({center, zoom}) {
              this._updateTransform(center, zoom)
          },
          _onZoom() {
              this._updateTransform(this._map.getCenter(), this._map.getZoom())
          },
          _updateTransform(e, t) {
              const i = this._map.getZoomScale(t, this._zoom),
                    n = lt(this._container),
                    o = this._map.getSize()
                      .multiplyBy(.5 + this.options.padding),
                    s = this._map.project(this._center, t),
                    a = this._map.project(e, t)
                      .subtract(s),
                    r = o.multiplyBy(-i)
                      .add(n)
                      .add(o)
                      .subtract(a);
              Fi ? at(this._container, r, i) : rt(this._container, r)
          },
          _reset() {
              this._update(), this._updateTransform(this._center, this._zoom);
              for (const e in this._layers) this._layers[e]._reset()
          },
          _onZoomEnd() {
              for (const e in this._layers) this._layers[e]._project()
          },
          _updatePaths() {
              for (const e in this._layers) this._layers[e]._update()
          },
          _update() {
              const e = this.options.padding,
                    t = this._map.getSize(),
                    i = this._map.containerPointToLayerPoint(t.multiplyBy(-e))
                      .round();
              this._bounds = new k(i, i.add(t.multiplyBy(1 + 2 * e))
                .round()), this._center = this._map.getCenter(), this._zoom = this
                ._map.getZoom()
          }
      });

    var bo = vo.extend({
        getEvents() {
            const e = vo.prototype.getEvents.call(this);
            return e.viewprereset = this._onViewPreReset, e
        },
        _onViewPreReset() {
            this._postponeUpdatePaths = !0
        },
        onAdd() {
            vo.prototype.onAdd.call(this), this._draw()
        },
        _initContainer() {
            const e = this._container = document.createElement("canvas");
            ft(e, "mousemove", o(this._onMouseMove, 32, this), this), ft(e,
              "click dblclick mousedown mouseup contextmenu", this._onClick, this),
              ft(e, "mouseout", this._handleMouseOut, this), this._ctx = e.getContext(
              "2d")
        },
        _destroyContainer() {
            g(this._redrawRequest), delete this._ctx, G(this._container), _t(this
              ._container), delete this._container
        },
        _updatePaths() {
            if (!this._postponeUpdatePaths) {
                this._redrawBounds = null;
                for (const e in this._layers) this._layers[e]._update();
                this._redraw()
            }
        },
        _update() {
            if (!this._map._animatingZoom || !this._bounds) {
                vo.prototype._update.call(this);
                const e = this._bounds, t = this._container, i = e.getSize(), n = Ki ? 2 : 1;
                rt(t, e.min), t.width = n * i.x, t.height = n * i.y, t.style.width = `${i.x}px`, t.style.height = `${i.y}px`, Ki && this._ctx.scale(2, 2), this
                  ._ctx.translate(-e.min.x, -e.min.y), this.fire("update")
            }
        },
        _reset() {
            vo.prototype._reset.call(this), this._postponeUpdatePaths && (this
              ._postponeUpdatePaths = !1, this._updatePaths())
        },
        _initPath(e) {
            this._updateDashArray(e), this._layers[n(e)] = e;
            const t = e._order = {
                layer: e,
                prev: this._drawLast,
                next: null
            };
            this._drawLast && (this._drawLast.next = t), this._drawLast = t, this
              ._drawFirst = this._drawFirst || this._drawLast
        },
        _addPath(e) {
            this._requestRedraw(e)
        },
        _removePath(e) {
            const t = e._order, i = t.next, o = t.prev;
            i ? i.prev = o : this._drawLast = o, o ? o.next = i : this._drawFirst = i,
              delete e._order, delete this._layers[n(e)], this._requestRedraw(e)
        },
        _updatePath(e) {
            this._extendRedrawBounds(e), e._project(), e._update(), this._requestRedraw(e)
        },
        _updateStyle(e) {
            this._updateDashArray(e), this._requestRedraw(e)
        },
        _updateDashArray({options}) {
            if ("string" == typeof options.dashArray) {
                let t;
                let i;
                const n = options.dashArray.split(/[, ]+/);
                const o = [];
                for (i = 0; i < n.length; i++) {
                    if (t = Number(n[i]), isNaN(t)) return;
                    o.push(t)
                }
                options._dashArray = o
            } else options._dashArray = options.dashArray
        },
        _requestRedraw(e) {
            this._map && (this._extendRedrawBounds(e), this._redrawRequest = this
              ._redrawRequest || _(this._redraw, this))
        },
        _extendRedrawBounds({_pxBounds, options}) {
            if (_pxBounds) {
                const t = (options.weight || 0) + 1;
                this._redrawBounds = this._redrawBounds || new k, this._redrawBounds
                  .extend(_pxBounds.min.subtract([t, t])), this._redrawBounds.extend(_pxBounds.max.add([t, t]))
            }
        },
        _redraw() {
            this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min
              ._floor(), this._redrawBounds.max._ceil()), this._clear(), this
              ._draw(), this._redrawBounds = null
        },
        _clear() {
            const e = this._redrawBounds;
            if (e) {
                const t = e.getSize();
                this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)
            } else this._ctx.clearRect(0, 0, this._container.width, this._container
              .height)
        },
        _draw() {
            let e;
            const t = this._redrawBounds;
            if (this._ctx.save(), t) {
                const i = t.getSize();
                this._ctx.beginPath(), this._ctx.rect(t.min.x, t.min.y, i.x, i.y), this
                  ._ctx.clip()
            }
            this._drawing = !0;
            for (let n = this._drawFirst; n; n = n.next) e = n.layer, (!t || e
              ._pxBounds && e._pxBounds.intersects(t)) && e._updatePath();
            this._drawing = !1, this._ctx.restore()
        },
        _updatePoly(e, t) {
            if (this._drawing) {
                let i;
                let n;
                let o;
                let s;
                const a = e._parts;
                const r = a.length;
                const l = this._ctx;
                if (r) {
                    for (l.beginPath(), i = 0; r > i; i++) {
                        for (n = 0, o = a[i].length; o > n; n++) s = a[i][n], l[n ?
                          "lineTo" : "moveTo"](s.x, s.y);
                        t && l.closePath()
                    }
                    this._fillStroke(l, e)
                }
            }
        },
        _updateCircle(e) {
            if (this._drawing && !e._empty()) {
                const t = e._point, i = this._ctx, n = Math.max(Math.round(e._radius), 1), o = (Math.max(Math.round(e._radiusY), 1) || n) / n;
                1 !== o && (i.save(), i.scale(1, o)), i.beginPath(), i.arc(t.x, t.y / o,
                  n, 0, 2 * Math.PI, !1), 1 !== o && i.restore(), this._fillStroke(
                  i, e)
            }
        },
        _fillStroke(e, {options}) {
            const i = options;
            i.fill && (e.globalAlpha = i.fillOpacity, e.fillStyle = i.fillColor || i
              .color, e.fill(i.fillRule || "evenodd")), i.stroke && 0 !== i
              .weight && (e.setLineDash && e.setLineDash(options && options
              ._dashArray || []), e.globalAlpha = i.opacity, e.lineWidth = i
              .weight, e.strokeStyle = i.color, e.lineCap = i.lineCap, e.lineJoin =
              i.lineJoin, e.stroke())
        },
        _onClick(e) {
            for (var t, i, n = this._map.mouseEventToLayerPoint(e), o = this
              ._drawFirst; o; o = o.next)(t = o.layer)
              .options.interactive && t._containsPoint(n) && !this._map._draggableMoved(
              t) && (i = t);
            i && (Tt(e), this._fireEvent([i], e))
        },
        _onMouseMove(e) {
            if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {
                const t = this._map.mouseEventToLayerPoint(e);
                this._handleMouseHover(e, t)
            }
        },
        _handleMouseOut(e) {
            const t = this._hoveredLayer;
            t && (et(this._container, "leaflet-interactive"), this._fireEvent([t], e,
              "mouseout"), this._hoveredLayer = null)
        },
        _handleMouseHover(e, t) {
            for (var i, n, o = this._drawFirst; o; o = o.next)(i = o.layer)
              .options.interactive && i._containsPoint(t) && (n = i);
            n !== this._hoveredLayer && (this._handleMouseOut(e), n && (X(this._container,
              "leaflet-interactive"), this._fireEvent([n], e, "mouseover"),
              this._hoveredLayer = n)), this._hoveredLayer && this._fireEvent([this
              ._hoveredLayer], e)
        },
        _fireEvent(e, t, i) {
            this._map._fireDOMEvent(t, i || t.type, e)
        },
        _bringToFront(e) {
            const t = e._order;
            if (t) {
                const i = t.next, n = t.prev;
                i && (i.prev = n, n ? n.next = i : i && (this._drawFirst = i), t.prev =
                  this._drawLast, this._drawLast.next = t, t.next = null, this
                  ._drawLast = t, this._requestRedraw(e))
            }
        },
        _bringToBack(e) {
            const t = e._order;
            if (t) {
                const i = t.next, n = t.prev;
                n && (n.next = i, i ? i.prev = n : n && (this._drawLast = n), t.prev =
                  null, t.next = this._drawFirst, this._drawFirst.prev = t, this
                  ._drawFirst = t, this._requestRedraw(e))
            }
        }
    });

    const yo = (() => {
        try {
            return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
              e => document.createElement(`<lvml:${e} class="lvml">`);
        } catch (e) {
            return e => document.createElement(`<${e} xmlns="urn:schemas-microsoft.com:vml" class="lvml">`);
        }
    })();

    const wo = {
        _initContainer() {
            this._container = Z("div", "leaflet-vml-container")
        },
        _update() {
            this._map._animatingZoom || (vo.prototype._update.call(this), this.fire("update"))
        },
        _initPath(e) {
            const t = e._container = yo("shape");
            X(t, `leaflet-vml-shape ${this.options.className || ""}`), t.coordsize = "1 1",
              e._path = yo("path"), t.appendChild(e._path), this._updateStyle(e), this
              ._layers[n(e)] = e
        },
        _addPath(e) {
            const t = e._container;
            this._container.appendChild(t), e.options.interactive && e.addInteractiveTarget(t)
        },
        _removePath(e) {
            const t = e._container;
            G(t), e.removeInteractiveTarget(t), delete this._layers[n(e)]
        },
        _updateStyle(e) {
            let t = e._stroke;
            let i = e._fill;
            const n = e.options;
            const o = e._container;
            o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (t || (t = e._stroke = yo(
              "stroke")), o.appendChild(t), t.weight = `${n.weight}px`, t.color = n
              .color, t.opacity = n.opacity, t.dashStyle = n.dashArray ? oi(n
              .dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g,
              " ") : "", t.endcap = n.lineCap.replace("butt", "flat"), t.joinstyle = n
              .lineJoin) : t && (o.removeChild(t), e._stroke = null), n.fill ? (i || (
              i = e._fill = yo("fill")), o.appendChild(i), i.color = n.fillColor ||
              n.color, i.opacity = n.fillOpacity) : i && (o.removeChild(i), e._fill =
              null)
        },
        _updateCircle(e) {
            const t = e._point.round(), i = Math.round(e._radius), n = Math.round(e._radiusY || i);
            this._setPath(e, e._empty() ? "M0 0" : `AL ${t.x},${t.y} ${i},${n} 0,23592600`)
        },
        _setPath({_path}, t) {
            _path.v = t
        },
        _bringToFront({_container}) {
            Y(_container)
        },
        _bringToBack({_container}) {
            J(_container)
        }
    };

    const ko = Qi ? yo : P;

    var xo = vo.extend({
        getEvents() {
            const e = vo.prototype.getEvents.call(this);
            return e.zoomstart = this._onZoomStart, e
        },
        _initContainer() {
            this._container = ko("svg"), this._container.setAttribute("pointer-events",
              "none"), this._rootGroup = ko("g"), this._container.appendChild(this
              ._rootGroup)
        },
        _destroyContainer() {
            G(this._container), _t(this._container), delete this._container, delete this
              ._rootGroup, delete this._svgSize
        },
        _onZoomStart() {
            this._update()
        },
        _update() {
            if (!this._map._animatingZoom || !this._bounds) {
                vo.prototype._update.call(this);
                const e = this._bounds, t = e.getSize(), i = this._container;
                this._svgSize && this._svgSize.equals(t) || (this._svgSize = t, i
                  .setAttribute("width", t.x), i.setAttribute("height", t.y)), rt(i,
                  e.min), i.setAttribute("viewBox", [e.min.x, e.min.y, t.x, t.y]
                  .join(" ")), this.fire("update")
            }
        },
        _initPath(e) {
            const t = e._path = ko("path");
            e.options.className && X(t, e.options.className), e.options.interactive && X(
              t, "leaflet-interactive"), this._updateStyle(e), this._layers[n(e)] =
              e
        },
        _addPath(e) {
            this._rootGroup || this._initContainer(), this._rootGroup.appendChild(e
              ._path), e.addInteractiveTarget(e._path)
        },
        _removePath(e) {
            G(e._path), e.removeInteractiveTarget(e._path), delete this._layers[n(e)]
        },
        _updatePath(e) {
            e._project(), e._update()
        },
        _updateStyle({_path, options}) {
            const t = _path, i = options;
            t && (i.stroke ? (t.setAttribute("stroke", i.color), t.setAttribute(
              "stroke-opacity", i.opacity), t.setAttribute("stroke-width", i
              .weight), t.setAttribute("stroke-linecap", i.lineCap), t
              .setAttribute("stroke-linejoin", i.lineJoin), i.dashArray ? t
              .setAttribute("stroke-dasharray", i.dashArray) : t
              .removeAttribute("stroke-dasharray"), i.dashOffset ? t
              .setAttribute("stroke-dashoffset", i.dashOffset) : t
              .removeAttribute("stroke-dashoffset")) : t.setAttribute("stroke",
              "none"), i.fill ? (t.setAttribute("fill", i.fillColor || i.color),
              t.setAttribute("fill-opacity", i.fillOpacity), t.setAttribute(
              "fill-rule", i.fillRule || "evenodd")) : t.setAttribute(
              "fill", "none"))
        },
        _updatePoly(e, t) {
            this._setPath(e, I(e._parts, t))
        },
        _updateCircle(e) {
            const t = e._point, i = Math.max(Math.round(e._radius), 1), n = `a${i},${Math.max(Math.round(e._radiusY), 1) || i} 0 1,0 `, o = e._empty() ? "M0 0" : `M${t.x - i},${t.y}${n}${2 * i},0 ${n}${2 * -i},0 `;
            this._setPath(e, o)
        },
        _setPath({_path}, t) {
            _path.setAttribute("d", t)
        },
        _bringToFront({_path}) {
            Y(_path)
        },
        _bringToBack({_path}) {
            J(_path)
        }
    });

    Qi && xo.include(wo), zn.include({
        getRenderer({options}) {
            let t = options.renderer || this._getPaneRenderer(options.pane) || this
              .options.renderer || this._renderer;
            return t || (t = this._renderer = this._createRenderer()), this.hasLayer(t) ||
            this.addLayer(t), t
        },
        _getPaneRenderer(e) {
            if ("overlayPane" === e || void 0 === e) return !1;
            let t = this._paneRenderers[e];
            return void 0 === t && (t = this._createRenderer({
                pane: e
            }), this._paneRenderers[e] = t), t
        },
        _createRenderer(e) {
            return this.options.preferCanvas && Qt(e) || Xt(e)
        }
    });
    const Co = oo.extend({
        initialize(e, t) {
            oo.prototype.initialize.call(this, this._boundsToLatLngs(e), t)
        },
        setBounds(e) {
            return this.setLatLngs(this._boundsToLatLngs(e))
        },
        _boundsToLatLngs(e) {
            return e = z(e), [e.getSouthWest(), e.getNorthWest(), e.getNorthEast(), e
              .getSouthEast()]
        }
    });
    xo.create = ko, xo.pointsToPath = I, so.geometryToLayer = Wt, so.coordsToLatLng = Vt, so
      .coordsToLatLngs = qt, so.latLngToCoords = Ut, so.latLngsToCoords = Zt, so.getFeature = Gt, so
      .asFeature = Kt, zn.mergeOptions({
        boxZoom: !0
    });
    const zo = Mn.extend({
        initialize(e) {
            this._map = e, this._container = e._container, this._pane = e._panes
              .overlayPane, this._resetStateTimeout = 0, e.on("unload", this._destroy,
              this)
        },
        addHooks() {
            ft(this._container, "mousedown", this._onMouseDown, this)
        },
        removeHooks() {
            _t(this._container, "mousedown", this._onMouseDown, this)
        },
        moved() {
            return this._moved
        },
        _destroy() {
            G(this._pane), delete this._pane
        },
        _resetState() {
            this._resetStateTimeout = 0, this._moved = !1
        },
        _clearDeferredResetState() {
            0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this
              ._resetStateTimeout = 0)
        },
        _onMouseDown(e) {
            return !e.shiftKey || 1 !== e.which && 1 !== e.button ? !1 : (this
              ._clearDeferredResetState(), this._resetState(), _i(), ct(), this
              ._startPoint = this._map.mouseEventToContainerPoint(e), ft(document, {
                contextmenu: xt,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this), void 0)
        },
        _onMouseMove(e) {
            this._moved || (this._moved = !0, this._box = Z("div", "leaflet-zoom-box",
              this._container), X(this._container, "leaflet-crosshair"), this
              ._map.fire("boxzoomstart")), this._point = this._map
              .mouseEventToContainerPoint(e);
            const t = new k(this._point, this._startPoint);
            const i = t.getSize();
            rt(this._box, t.min), this._box.style.width = `${i.x}px`, this._box.style
              .height = `${i.y}px`
        },
        _finish() {
            this._moved && (G(this._box), et(this._container, "leaflet-crosshair")), gi(),
              ut(), _t(document, {
                contextmenu: xt,
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp,
                keydown: this._onKeyDown
            }, this)
        },
        _onMouseUp(e) {
            if ((1 === e.which || 1 === e.button) && (this._finish(), this._moved)) {
                this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(i(
                  this._resetState, this), 0);
                const t = new C(this._map.containerPointToLatLng(this._startPoint), this
                  ._map.containerPointToLatLng(this._point));
                this._map.fitBounds(t)
                  .fire("boxzoomend", {
                      boxZoomBounds: t
                  })
            }
        },
        _onKeyDown({keyCode}) {
            27 === keyCode && this._finish()
        }
    });
    zn.addInitHook("addHandler", "boxZoom", zo), zn.mergeOptions({
        doubleClickZoom: !0
    });
    const To = Mn.extend({
        addHooks() {
            this._map.on("dblclick", this._onDoubleClick, this)
        },
        removeHooks() {
            this._map.off("dblclick", this._onDoubleClick, this)
        },
        _onDoubleClick({originalEvent, containerPoint}) {
            const t = this._map;
            const i = t.getZoom();
            const n = t.options.zoomDelta;
            const o = originalEvent.shiftKey ? i - n : i + n;
            "center" === t.options.doubleClickZoom ? t.setZoom(o) : t.setZoomAround(containerPoint, o)
        }
    });
    zn.addInitHook("addHandler", "doubleClickZoom", To), zn.mergeOptions({
        dragging: !0,
        inertia: !Si,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: 1 / 0,
        easeLinearity: .2,
        worldCopyJump: !1,
        maxBoundsViscosity: 0
    });
    const So = Mn.extend({
        addHooks() {
            if (!this._draggable) {
                const e = this._map;
                this._draggable = new Rn(e._mapPane, e._container), this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this), this._draggable.on("predrag", this._onPreDragLimit, this), e
                  .options.worldCopyJump && (this._draggable.on("predrag", this
                  ._onPreDragWrap, this), e.on("zoomend", this._onZoomEnd,
                  this), e.whenReady(this._onZoomEnd, this))
            }
            X(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable
              .enable(), this._positions = [], this._times = []
        },
        removeHooks() {
            et(this._map._container, "leaflet-grab"), et(this._map._container,
              "leaflet-touch-drag"), this._draggable.disable()
        },
        moved() {
            return this._draggable && this._draggable._moved
        },
        moving() {
            return this._draggable && this._draggable._moving
        },
        _onDragStart() {
            const e = this._map;
            if (e._stop(), this._map.options.maxBounds && this._map.options
              .maxBoundsViscosity) {
                const t = z(this._map.options.maxBounds);
                this._offsetLimit = x(this._map.latLngToContainerPoint(t.getNorthWest())
                  .multiplyBy(-1), this._map.latLngToContainerPoint(t
                  .getSouthEast())
                  .multiplyBy(-1)
                  .add(this._map.getSize())), this._viscosity = Math.min(1, Math
                  .max(0, this._map.options.maxBoundsViscosity))
            } else this._offsetLimit = null;
            e.fire("movestart")
              .fire("dragstart"), e.options.inertia && (this._positions = [], this
              ._times = [])
        },
        _onDrag(e) {
            if (this._map.options.inertia) {
                const t = this._lastTime = +new Date;

                const i = this._lastPos = this._draggable._absPos || this._draggable
                  ._newPos;

                this._positions.push(i), this._times.push(t), this._prunePositions(t)
            }
            this._map.fire("move", e)
              .fire("drag", e)
        },
        _prunePositions(e) {
            for (; this._positions.length > 1 && e - this._times[0] > 50;) this._positions
              .shift(), this._times.shift()
        },
        _onZoomEnd() {
            const e = this._map.getSize()
                .divideBy(2);

            const t = this._map.latLngToLayerPoint([0, 0]);
            this._initialWorldOffset = t.subtract(e)
              .x, this._worldWidth = this._map.getPixelWorldBounds()
              .getSize()
              .x
        },
        _viscousLimit(e, t) {
            return e - (e - t) * this._viscosity
        },
        _onPreDragLimit() {
            if (this._viscosity && this._offsetLimit) {
                const e = this._draggable._newPos.subtract(this._draggable._startPos);
                const t = this._offsetLimit;
                e.x < t.min.x && (e.x = this._viscousLimit(e.x, t.min.x)), e.y < t.min
                  .y && (e.y = this._viscousLimit(e.y, t.min.y)), e.x > t.max.x && (e
                  .x = this._viscousLimit(e.x, t.max.x)), e.y > t.max.y && (e.y =
                  this._viscousLimit(e.y, t.max.y)), this._draggable._newPos = this
                  ._draggable._startPos.add(e)
            }
        },
        _onPreDragWrap() {
            const e = this._worldWidth;
            const t = Math.round(e / 2);
            const i = this._initialWorldOffset;
            const n = this._draggable._newPos.x;
            const o = (n - t + i) % e + t - i;
            const s = (n + t + i) % e - t - i;
            const a = Math.abs(o + i) < Math.abs(s + i) ? o : s;
            this._draggable._absPos = this._draggable._newPos.clone(), this._draggable
              ._newPos.x = a
        },
        _onDragEnd(e) {
            const t = this._map;
            const i = t.options;
            const n = !i.inertia || this._times.length < 2;
            if (t.fire("dragend", e), n) t.fire("moveend");
            else {
                this._prunePositions(+new Date);
                const o = this._lastPos.subtract(this._positions[0]);
                const s = (this._lastTime - this._times[0]) / 1e3;
                const a = i.easeLinearity;
                const r = o.multiplyBy(a / s);
                const l = r.distanceTo([0, 0]);
                const c = Math.min(i.inertiaMaxSpeed, l);
                const u = r.multiplyBy(c / l);
                const d = c / (i.inertiaDeceleration * a);

                let h = u.multiplyBy(-d / 2)
                  .round();

                h.x || h.y ? (h = t._limitOffset(h, t.options.maxBounds), _(() => {
                    t.panBy(h, {
                        duration: d,
                        easeLinearity: a,
                        noMoveStart: !0,
                        animate: !0
                    })
                })) : t.fire("moveend")
            }
        }
    });
    zn.addInitHook("addHandler", "dragging", So), zn.mergeOptions({
        keyboard: !0,
        keyboardPanDelta: 80
    });
    const Ao = Mn.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 54, 173]
        },
        initialize(e) {
            this._map = e, this._setPanDelta(e.options.keyboardPanDelta), this
              ._setZoomDelta(e.options.zoomDelta)
        },
        addHooks() {
            const e = this._map._container;
            e.tabIndex <= 0 && (e.tabIndex = "0"), ft(e, {
                focus: this._onFocus,
                blur: this._onBlur,
                mousedown: this._onMouseDown
            }, this), this._map.on({
                focus: this._addHooks,
                blur: this._removeHooks
            }, this)
        },
        removeHooks() {
            this._removeHooks(), _t(this._map._container, {
                focus: this._onFocus,
                blur: this._onBlur,
                mousedown: this._onMouseDown
            }, this), this._map.off({
                focus: this._addHooks,
                blur: this._removeHooks
            }, this)
        },
        _onMouseDown() {
            if (!this._focused) {
                const e = document.body;
                const t = document.documentElement;
                const i = e.scrollTop || t.scrollTop;
                const n = e.scrollLeft || t.scrollLeft;
                this._map._container.focus(), window.scrollTo(n, i)
            }
        },
        _onFocus() {
            this._focused = !0, this._map.fire("focus")
        },
        _onBlur() {
            this._focused = !1, this._map.fire("blur")
        },
        _setPanDelta(e) {
            let t;
            let i;
            const n = this._panKeys = {};
            const o = this.keyCodes;
            for (t = 0, i = o.left.length; i > t; t++) n[o.left[t]] = [-1 * e, 0];
            for (t = 0, i = o.right.length; i > t; t++) n[o.right[t]] = [e, 0];
            for (t = 0, i = o.down.length; i > t; t++) n[o.down[t]] = [0, e];
            for (t = 0, i = o.up.length; i > t; t++) n[o.up[t]] = [0, -1 * e]
        },
        _setZoomDelta(e) {
            let t;
            let i;
            const n = this._zoomKeys = {};
            const o = this.keyCodes;
            for (t = 0, i = o.zoomIn.length; i > t; t++) n[o.zoomIn[t]] = e;
            for (t = 0, i = o.zoomOut.length; i > t; t++) n[o.zoomOut[t]] = -e
        },
        _addHooks() {
            ft(document, "keydown", this._onKeyDown, this)
        },
        _removeHooks() {
            _t(document, "keydown", this._onKeyDown, this)
        },
        _onKeyDown(e) {
            if (!(e.altKey || e.ctrlKey || e.metaKey)) {
                let t;
                const i = e.keyCode;
                const n = this._map;
                if (i in this._panKeys) n._panAnim && n._panAnim._inProgress || (t = this
                  ._panKeys[i], e.shiftKey && (t = w(t)
                  .multiplyBy(3)), n.panBy(t), n.options.maxBounds && n
                  .panInsideBounds(n.options.maxBounds));
                else if (i in this._zoomKeys) n.setZoom(n.getZoom() + (e.shiftKey ? 3 :
                  1) * this._zoomKeys[i]);
                else {
                    if (27 !== i || !n._popup || !n._popup.options.closeOnEscapeKey)
                        return;
                    n.closePopup()
                }
                xt(e)
            }
        }
    });
    zn.addInitHook("addHandler", "keyboard", Ao), zn.mergeOptions({
        scrollWheelZoom: !0,
        wheelDebounceTime: 40,
        wheelPxPerZoomLevel: 60
    });
    const Eo = Mn.extend({
        addHooks() {
            ft(this._map._container, "mousewheel", this._onWheelScroll, this), this
              ._delta = 0
        },
        removeHooks() {
            _t(this._map._container, "mousewheel", this._onWheelScroll, this)
        },
        _onWheelScroll(e) {
            const t = zt(e);
            const n = this._map.options.wheelDebounceTime;
            this._delta += t, this._lastMousePos = this._map.mouseEventToContainerPoint(
              e), this._startTime || (this._startTime = +new Date);
            const o = Math.max(n - (+new Date - this._startTime), 0);
            clearTimeout(this._timer), this._timer = setTimeout(i(this._performZoom,
              this), o), xt(e)
        },
        _performZoom() {
            const e = this._map;
            const t = e.getZoom();
            const i = this._map.options.zoomSnap || 0;
            e._stop();
            const n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel);
            const o = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2;
            const s = i ? Math.ceil(o / i) * i : o;
            const a = e._limitZoom(t + (this._delta > 0 ? s : -s)) - t;
            this._delta = 0, this._startTime = null, a && ("center" === e.options
              .scrollWheelZoom ? e.setZoom(t + a) : e.setZoomAround(this
              ._lastMousePos, t + a))
        }
    });
    zn.addInitHook("addHandler", "scrollWheelZoom", Eo), zn.mergeOptions({
        tap: !0,
        tapTolerance: 15
    });
    const Po = Mn.extend({
        addHooks() {
            ft(this._map._container, "touchstart", this._onDown, this)
        },
        removeHooks() {
            _t(this._map._container, "touchstart", this._onDown, this)
        },
        _onDown(e) {
            if (e.touches) {
                if (kt(e), this._fireClick = !0, e.touches.length > 1) return this
                  ._fireClick = !1, void clearTimeout(this._holdTimeout);
                const t = e.touches[0];
                const n = t.target;
                this._startPos = this._newPos = new y(t.clientX, t.clientY), n.tagName &&
                "a" === n.tagName.toLowerCase() && X(n, "leaflet-active"), this
                  ._holdTimeout = setTimeout(i(function () {
                    this._isTapValid() && (this._fireClick = !1, this._onUp(),
                      this._simulateEvent("contextmenu", t))
                }, this), 1e3), this._simulateEvent("mousedown", t), ft(document, {
                    touchmove: this._onMove,
                    touchend: this._onUp
                }, this)
            }
        },
        _onUp(e) {
            if (clearTimeout(this._holdTimeout), _t(document, {
                touchmove: this._onMove,
                touchend: this._onUp
            }, this), this._fireClick && e && e.changedTouches) {
                const t = e.changedTouches[0];
                const i = t.target;
                i && i.tagName && "a" === i.tagName.toLowerCase() && et(i,
                  "leaflet-active"), this._simulateEvent("mouseup", t), this
                  ._isTapValid() && this._simulateEvent("click", t)
            }
        },
        _isTapValid() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options
              .tapTolerance
        },
        _onMove({touches}) {
            const t = touches[0];
            this._newPos = new y(t.clientX, t.clientY), this._simulateEvent("mousemove",
              t)
        },
        _simulateEvent(e, t) {
            const i = document.createEvent("MouseEvents");
            i._simulated = !0, t.target._simulatedClick = !0, i.initMouseEvent(e, !0, !0,
              window, 1, t.screenX, t.screenY, t.clientX, t.clientY, !1, !1, !1, !1,
              0, null), t.target.dispatchEvent(i)
        }
    });
    Ui && !qi && zn.addInitHook("addHandler", "tap", Po), zn.mergeOptions({
        touchZoom: Ui && !Si,
        bounceAtZoomLimits: !0
    });
    const Io = Mn.extend({
        addHooks() {
            X(this._map._container, "leaflet-touch-zoom"), ft(this._map._container,
              "touchstart", this._onTouchStart, this)
        },
        removeHooks() {
            et(this._map._container, "leaflet-touch-zoom"), _t(this._map._container,
              "touchstart", this._onTouchStart, this)
        },
        _onTouchStart(e) {
            const t = this._map;
            if (e.touches && 2 === e.touches.length && !t._animatingZoom && !this
              ._zooming) {
                const i = t.mouseEventToContainerPoint(e.touches[0]);
                const n = t.mouseEventToContainerPoint(e.touches[1]);
                this._centerPoint = t.getSize()
                  ._divideBy(2), this._startLatLng = t.containerPointToLatLng(this
                  ._centerPoint), "center" !== t.options.touchZoom && (this
                  ._pinchStartLatLng = t.containerPointToLatLng(i.add(n)
                  ._divideBy(2))), this._startDist = i.distanceTo(n), this
                  ._startZoom = t.getZoom(), this._moved = !1, this._zooming = !0, t
                  ._stop(), ft(document, "touchmove", this._onTouchMove, this), ft(
                  document, "touchend", this._onTouchEnd, this), kt(e)
            }
        },
        _onTouchMove(e) {
            if (e.touches && 2 === e.touches.length && this._zooming) {
                const t = this._map;
                const n = t.mouseEventToContainerPoint(e.touches[0]);
                const o = t.mouseEventToContainerPoint(e.touches[1]);
                const s = n.distanceTo(o) / this._startDist;
                if (this._zoom = t.getScaleZoom(s, this._startZoom), !t.options
                  .bounceAtZoomLimits && (this._zoom < t.getMinZoom() && 1 > s || this
                  ._zoom > t.getMaxZoom() && s > 1) && (this._zoom = t._limitZoom(
                  this._zoom)), "center" === t.options.touchZoom) {
                    if (this._center = this._startLatLng, 1 === s) return
                } else {
                    const a = n._add(o)
                      ._divideBy(2)
                      ._subtract(this._centerPoint);
                    if (1 === s && 0 === a.x && 0 === a.y) return;
                    this._center = t.unproject(t.project(this._pinchStartLatLng, this
                      ._zoom)
                      .subtract(a), this._zoom)
                }
                this._moved || (t._moveStart(!0, !1), this._moved = !0), g(this
                  ._animRequest);
                const r = i(t._move, t, this._center, this._zoom, {
                    pinch: !0,
                    round: !1
                });
                this._animRequest = _(r, this, !0), kt(e)
            }
        },
        _onTouchEnd() {
            this._moved && this._zooming ? (this._zooming = !1, g(this._animRequest), _t(
              document, "touchmove", this._onTouchMove), _t(document,
              "touchend", this._onTouchEnd), this._map.options.zoomAnimation ?
              this._map._animateZoom(this._center, this._map._limitZoom(this._zoom),
                !0, this._map.options.zoomSnap) : this._map._resetView(this
                ._center, this._map._limitZoom(this._zoom))) : this._zooming = !1
        }
    });
    zn.addInitHook("addHandler", "touchZoom", Io), zn.BoxZoom = zo, zn.DoubleClickZoom = To, zn.Drag =
      So, zn.Keyboard = Ao, zn.ScrollWheelZoom = Eo, zn.Tap = Po, zn.TouchZoom = Io, Object.freeze =
      ei, e.version = "1.4.0+HEAD.3337f36", e.Control = Tn, e.control = Sn, e.Browser = Xi, e
      .Evented = di, e.Mixin = Dn, e.Util = ci, e.Class = v, e.Handler = Mn, e.extend = t, e.bind =
      i, e.stamp = n, e.setOptions = u, e.DomEvent = xn, e.DomUtil = bn, e.PosAnimation = Cn, e
      .Draggable = Rn, e.LineUtil = $n, e.PolyUtil = Fn, e.Point = y, e.point = w, e.Bounds = k, e
      .bounds = x, e.Transformation = A, e.transformation = E, e.Projection = Wn, e.LatLng = T, e
      .latLng = S, e.LatLngBounds = C, e.latLngBounds = z, e.CRS = pi, e.GeoJSON = so, e.geoJSON =
      Yt, e.geoJson = ro, e.Layer = Zn, e.LayerGroup = Gn, e.layerGroup = (e, t) => new Gn(e, t), e.FeatureGroup = Kn, e.featureGroup = e => new Kn(e), e.ImageOverlay = lo, e.imageOverlay = (e, t, i) => new lo(e, t, i), e.VideoOverlay = co, e.videoOverlay = (e, t, i) => new co(e, t, i), e.DivOverlay = uo, e.Popup = ho, e.popup = (e, t) => new ho(e, t), e.Tooltip = po, e.tooltip = (e, t) => new po(e, t), e.Icon = Yn, e.icon = e => new Yn(e), e.DivIcon = mo, e.divIcon = e => new mo(e), e.Marker = Xn, e.marker = (e, t) => new Xn(e, t), e.TileLayer = _o, e.tileLayer = Jt, e.GridLayer = fo, e.gridLayer = e => new fo(e), e.SVG = xo, e.svg = Xt, e.Renderer = vo, e.Canvas = bo, e.canvas = Qt, e.Path = eo, e
      .CircleMarker = to, e.circleMarker = (e, t) => new to(e, t), e.Circle = io, e.circle = (e, t, i) => new io(e, t, i), e.Polyline = no, e.polyline = (e, t) => new no(e, t), e.Polygon = oo, e.polygon = (e, t) => new oo(e, t), e.Rectangle = Co, e.rectangle = (e, t) => new Co(e, t), e.Map = zn, e.map = (e, t) => new zn(e, t);
    const Mo = window.L;
    e.noConflict = function () {
        return window.L = Mo, this
    }, window.L = e
}), !(e => {
    function t(e, t) {
        const i = (65535 & e) + (65535 & t);
        return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i
    }

    function i(e, t) {
        return e << t | e >>> 32 - t
    }

    function n(e, n, o, s, a, r) {
        return t(i(t(t(n, e), t(s, r)), a), o)
    }

    function o(e, t, i, o, s, a, r) {
        return n(t & i | ~t & o, e, t, s, a, r)
    }

    function s(e, t, i, o, s, a, r) {
        return n(t & o | i & ~o, e, t, s, a, r)
    }

    function a(e, t, i, o, s, a, r) {
        return n(t ^ i ^ o, e, t, s, a, r)
    }

    function r(e, t, i, o, s, a, r) {
        return n(i ^ (t | ~o), e, t, s, a, r)
    }

    function l(e, i) {
        e[i >> 5] |= 128 << i % 32, e[14 + (i + 64 >>> 9 << 4)] = i;
        let n;
        let l;
        let c;
        let u;
        let d;
        let h = 1732584193;
        let p = -271733879;
        let m = -1732584194;
        let f = 271733878;
        for (n = 0; n < e.length; n += 16) l = h, c = p, u = m, d = f, p = r(p = r(p = r(p = r(p = a(p =
            a(p = a(p = a(p = s(p = s(p = s(p = s(p = o(p = o(p = o(p = o(p, m = o(m,
              f = o(f, h = o(h, p, m, f,
                e[n], 7, -
                  680876936), p, m,
                e[n + 1], 12, -
                  389564586), h, p, e[
              n + 2], 17, 606105819
              ), f, h, e[n + 3], 22, -
                1044525330), m = o(m, f = o(f,
              h = o(h, p, m, f, e[n +
              4], 7, -176418897), p,
              m, e[n + 5], 12,
              1200080426), h, p, e[n +
              6], 17, -1473231341), f, h, e[
              n + 7], 22, -45705983), m = o(m,
              f = o(f, h = o(h, p, m, f, e[n +
                8], 7, 1770035416), p, m,
                e[n + 9], 12, -1958414417), h,
              p, e[n + 10], 17, -42063), f, h,
              e[n + 11], 22, -1990404162), m = o(m,
              f = o(f, h = o(h, p, m, f, e[n + 12],
                7, 1804603682), p, m, e[n +
              13], 12, -40341101), h, p, e[n +
              14], 17, -1502002290), f, h, e[n +
              15], 22, 1236535329), m = s(m, f = s(f,
              h = s(h, p, m, f, e[n + 1], 5, -
                165796510), p, m, e[n + 6], 9, -
                1069501632), h, p, e[n + 11], 14,
              643717713), f, h, e[n], 20, -373897302), m =
                s(m, f = s(f, h = s(h, p, m, f, e[n + 5], 5, -
                    701558691), p, m, e[n + 10], 9,
                  38016083), h, p, e[n + 15], 14, -
                  660478335), f, h, e[n + 4], 20, -405537848),
              m = s(m, f = s(f, h = s(h, p, m, f, e[n + 9], 5,
                568446438), p, m, e[n + 14], 9, -
                1019803690), h, p, e[n + 3], 14, -187363961), f,
              h, e[n + 8], 20, 1163531501), m = s(m, f = s(f, h = s(
              h, p, m, f, e[n + 13], 5, -1444681467), p, m,
              e[n + 2], 9, -51403784), h, p, e[n + 7], 14,
              1735328473), f, h, e[n + 12], 20, -1926607734), m = a(m,
              f = a(f, h = a(h, p, m, f, e[n + 5], 4, -378558), p, m, e[
              n + 8], 11, -2022574463), h, p, e[n + 11], 16,
              1839030562), f, h, e[n + 14], 23, -35309556), m = a(m, f = a(
              f, h = a(h, p, m, f, e[n + 1], 4, -1530992060), p, m, e[
              n + 4], 11, 1272893353), h, p, e[n + 7], 16, -
                155497632), f, h, e[n + 10], 23, -1094730640), m = a(m, f = a(f,
              h = a(h, p, m, f, e[n + 13], 4, 681279174), p, m, e[n], 11, -
                358537222), h, p, e[n + 3], 16, -722521979), f, h, e[n + 6], 23,
              76029189), m = a(m, f = a(f, h = a(h, p, m, f, e[n + 9], 4, -
            640364487), p, m, e[n + 12], 11, -421815835), h, p, e[n + 15], 16,
          530742520), f, h, e[n + 2], 23, -995338651), m = r(m, f = r(f, h = r(
          h, p, m, f, e[n], 6, -198630844), p, m, e[n + 7], 10, 1126891415), h,
          p, e[n + 14], 15, -1416354905), f, h, e[n + 5], 21, -57434055), m = r(m, f =
            r(f, h = r(h, p, m, f, e[n + 12], 6, 1700485571), p, m, e[n + 3], 10, -
              1894986606), h, p, e[n + 10], 15, -1051523), f, h, e[n + 1], 21, -
            2054922799), m = r(m, f = r(f, h = r(h, p, m, f, e[n + 8], 6, 1873313359), p, m,
          e[n + 15], 10, -30611744), h, p, e[n + 6], 15, -1560198380), f, h, e[n + 13], 21,
          1309151649), m = r(m, f = r(f, h = r(h, p, m, f, e[n + 4], 6, -145523070), p, m, e[n +
        11], 10, -1120210379), h, p, e[n + 2], 15, 718787259), f, h, e[n + 9], 21, -343485551),
          h = t(h, l), p = t(p, c), m = t(m, u), f = t(f, d);
        return [h, p, m, f]
    }

    function c(e) {
        let t;
        let i = "";
        const n = 32 * e.length;
        for (t = 0; n > t; t += 8) i += String.fromCharCode(255 & e[t >> 5] >>> t % 32);
        return i
    }

    function u(e) {
        let t;
        const i = [];
        for (i[(e.length >> 2) - 1] = void 0, t = 0; t < i.length; t += 1) i[t] = 0;
        const n = 8 * e.length;
        for (t = 0; n > t; t += 8) i[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
        return i
    }

    function d(e) {
        return c(l(u(e), 8 * e.length))
    }

    function h(e, t) {
        let i;
        let n;
        let o = u(e);
        const s = [];
        const a = [];
        for (s[15] = a[15] = void 0, o.length > 16 && (o = l(o, 8 * e.length)), i = 0; 16 > i; i += 1) s[
          i] = 909522486 ^ o[i], a[i] = 1549556828 ^ o[i];
        return n = l(s.concat(u(t)), 512 + 8 * t.length), c(l(a.concat(n), 640))
    }

    function p(e) {
        let t;
        let i;
        let n = "";
        for (i = 0; i < e.length; i += 1) t = e.charCodeAt(i), n += "0123456789abcdef".charAt(15 & t >>>
          4) + "0123456789abcdef".charAt(15 & t);
        return n
    }

    function m(e) {
        return unescape(encodeURIComponent(e))
    }

    function f(e) {
        return d(m(e))
    }

    function _(e) {
        return p(f(e))
    }

    function g(e, t) {
        return h(m(e), m(t))
    }

    function v(e, t) {
        return p(g(e, t))
    }

    function b(e, t, i) {
        return t ? i ? g(t, e) : v(t, e) : i ? f(e) : _(e)
    }
    "function" == typeof define && define.amd ? define(() => b) : "object" == typeof module && module.exports ? module.exports = b : e.md5 = b
})(this);
var map;
var alliance_member_buildings_show;
let geocoder;
let directionsService;
var building_eval_unload;

var building_markers =
    Array();

var building_markers_cache = Array();
var building_timers = Array();
var building_marker_image = "/images/building_fire.png";
var mission_markers = Array();
let mission_position_new_marker;
var mission_timers = Array();
var patient_timers = Array();
var mission_vehicles = Array();
var vehicle_delay_timers = Array();
const window_focus = !0;
var title_default = "";
const title_counter = 0;
let missionScrollUpdateWait = !1;
var mission_label = !0;
var vehicle_label = !0;
let vehicle_label_backup = !0;
var audio = !1;
var audio_chat = !1;
var audio_chat_highlight = !1;
var iframe_lightbox_number = 1;
var leitstelle_latitude = !1;
var leitstelle_longitude = !1;
var leitstelles = [];
var alliance_mission_distance = !1;
var mobile_bridge_content = Array();
var mobile_bridge_use = !1;
var mobile_version = 1;
var vehicle_markers = Array();
var icon_empty;
var vehicles_not_involved = Array();
var alliance_show_not_involved_vehicle = !1;
var vehicle_graphics = Array();
var vehicle_graphics_sorted = [];
var mission_graphics = Array();
let target_marker = !1;
var patient_timer_last_call;
var eventTimer;
var eventRunning = !1;
const lightbox_static = !1;
var mobile_show_vehicle = !1;
var show_vehicle = !1;
var alliance_ignore_fms = !1;
var buildingResetContentPossible = !0;
var buildingVehicleCache = {};
var aao_types = [];
var alliance_coadmin = !1;
var alliance_admin = !1;
var routes = {};
var missionMarkerBulkAdd = !1;
var patientBulkCache = {};
var prisonerBulkCache = {};
var buildingMarkerBulkContentCache = [];
var mapViewExpanded = !1;
var mapViewExpandedWindow = !1;
var alliance_chat_ban_countdown_timer;
var mission_overview_timer;
var mission_overview_last_count;
var buildingVehicleGraphicCache = {};
var TIME_MODIFIER_SONDERRECHTE = .8;
var TIME_MODIFIER_NORMAL = 1.1;
var sale_count_down = new Date(0);
var count_down_title;
var saleTimeout = null;
var apng_supported = !1;
var gameFlavour = null;
const i18nPrefix = null;
$(() => {
    "undefined" != typeof L && (L.Icon.Default.imagePath = "/leaflet/images/"), aao_types = [[
        "ambulance_or_rapid_responder", I18n.t(
          "intervention_order.vehicles.ambulance_or_rapid_responder")], ["wasser_amount",
        I18n.t("intervention_order.vehicles.water_amount")], ["wasser_amount_tlf", I18n.t(
      "intervention_order.vehicles.water_amount_tlf")], ["swat_suv", I18n.t(
      "intervention_order.vehicles.swat_suv")], ["hems", I18n.t(
      "intervention_order.vehicles.hems")], ["swat_armored_vehicle", I18n.t(
      "intervention_order.vehicles.swat_armored_vehicle")], ["hondengeleider", I18n.t(
      "intervention_order.vehicles.hondengeleider")], ["dlk_or_tm50", I18n.t(
      "intervention_order.vehicles.dlk_or_tm50")], ["gw_werkfeuerwehr", I18n.t(
      "intervention_order.vehicles.gw_werkfeuerwehr")], ["ulf", I18n.t(
      "intervention_order.vehicles.ulf")], ["tm50", I18n.t(
      "intervention_order.vehicles.tm50")], ["turboloescher", I18n.t(
      "intervention_order.vehicles.turboloescher")], ["rescueboat", I18n.t(
      "intervention_order.vehicles.rescueboat")], ["fireboat", I18n.t(
      "intervention_order.vehicles.fireboat")], ["mek_mtf", I18n.t(
      "intervention_order.vehicles.mek_mtf")], ["sek_zf", I18n.t(
      "intervention_order.vehicles.sek_zf")], ["sek_mtf", I18n.t(
      "intervention_order.vehicles.sek_mtf")], ["mek_zf", I18n.t(
      "intervention_order.vehicles.mek_zf")], ["elw2_or_ab_elw", I18n.t(
      "intervention_order.vehicles.elw2_or_ab_elw")], ["ab_einsatzleitung_only", I18n.t(
      "intervention_order.vehicles.ab_einsatzleitung_only")], ["gw_gefahrgut_only", I18n.t(
      "intervention_order.vehicles.gw_gefahrgut_only")], ["ab_gefahrgut_only", I18n.t(
      "intervention_order.vehicles.ab_gefahrgut_only")], [
        "thw_tauchkraftwagen_or_gw_taucher", I18n.t(
          "intervention_order.vehicles.thw_tauchkraftwagen_or_gw_taucher")], [
        "rettungstreppe", I18n.t("intervention_order.vehicles.rettungstreppe")], [
        "elw_airport", I18n.t("intervention_order.vehicles.elw_airport")], ["ktw_or_rtw", I18n
      .t("intervention_order.vehicles.ktw_or_rtw")], ["hlf_or_rw_and_lf", I18n.t(
      "intervention_order.vehicles.hlf_or_rw_and_lf")], ["elw1_or_elw2", I18n.t(
      "intervention_order.vehicles.elw1_or_elw2")], ["naw", I18n.t(
      "intervention_order.vehicles.naw")], ["naw_or_rtw_and_nef", I18n.t(
      "intervention_order.vehicles.naw_or_rtw_and_nef")], ["naw_or_rtw_and_nef_or_rth", I18n
      .t("intervention_order.vehicles.naw_or_rtw_and_nef_or_rth")], ["grtw", I18n.t(
      "intervention_order.vehicles.grtw")], ["grtw0", I18n.t(
      "intervention_order.vehicles.grtw0")], ["grtw1", I18n.t(
      "intervention_order.vehicles.grtw1")], ["wasserwerfer", I18n.t(
      "intervention_order.vehicles.wasserwerfer")], ["hlf_only", I18n.t(
      "intervention_order.vehicles.hlf_only")], ["boot", I18n.t(
      "intervention_order.vehicles.boot")], ["arff", I18n.t(
      "intervention_order.vehicles.arff")], ["k9", I18n.t(
      "intervention_order.vehicles.k9")], ["ovd_p", I18n.t(
      "intervention_order.vehicles.ovd_p")], ["mzb", I18n.t("intervention_order.vehicles.mzb")],
        ["thw_tauchkraftwagen", I18n.t("intervention_order.vehicles.thw_tauchkraftwagen")], [
            "thw_anh_mzab", I18n.t("intervention_order.vehicles.thw_anh_mzab")], ["thw_anh_schlb",
            I18n.t("intervention_order.vehicles.thw_anh_schlb")], ["thw_anh_mzb", I18n.t(
          "intervention_order.vehicles.thw_anh_mzb")], ["thw_lkw_7_lkr_19_tm", I18n.t(
          "intervention_order.vehicles.thw_lkw_7_lkr_19_tm")], ["gw_taucher", I18n.t(
          "intervention_order.vehicles.gw_taucher")], ["gw_wasserrettung", I18n.t(
          "intervention_order.vehicles.gw_wasserrettung")], ["swat", I18n.t(
          "intervention_order.vehicles.swat")], ["elw3", I18n.t(
          "intervention_order.vehicles.elw3")], ["lf_only", I18n.t(
          "intervention_order.vehicles.lf_only")], ["tlf_only", I18n.t(
          "intervention_order.vehicles.tlf_only")], ["fly_car", I18n.t(
          "intervention_order.vehicles.fly_car")], ["gwl2wasser_only", I18n.t(
          "intervention_order.vehicles.gwl2wasser_only")], ["abl2wasser_only", I18n.t(
          "intervention_order.vehicles.abl2wasser_only")], ["seg_elw", I18n.t(
          "intervention_order.vehicles.seg_elw")], ["polizeihubschrauber", I18n.t(
          "intervention_order.vehicles.polizeihubschrauber")], ["gw_san", I18n.t(
          "intervention_order.vehicles.gw_san")], ["ktw_b", I18n.t(
          "intervention_order.vehicles.ktw_b")], ["kdow_lna", I18n.t(
          "intervention_order.vehicles.kdow_lna")], ["fwk", I18n.t(
          "intervention_order.vehicles.fwk")], ["kdow_orgl", I18n.t(
          "intervention_order.vehicles.kdow_orgl")], ["dekon_p", I18n.t(
          "intervention_order.vehicles.dekon_p")], ["only_dekon_p", I18n.t(
          "intervention_order.vehicles.only_dekon_p")], ["only_ab_dekon_p", I18n.t(
          "intervention_order.vehicles.only_ab_dekon_p")], ["ab_atemschutz_only", I18n.t(
          "intervention_order.vehicles.ab_atemschutz_only")], ["gefkw", I18n.t(
          "intervention_order.vehicles.gefkw")], ["gw_atemschutz_only", I18n.t(
          "intervention_order.vehicles.gw_atemschutz_only")], ["ab_oel_only", I18n.t(
          "intervention_order.vehicles.ab_oel_only")], ["gw_oel_only", I18n.t(
          "intervention_order.vehicles.gw_oel_only")], ["rw_only", I18n.t(
          "intervention_order.vehicles.rescue_vehicle_only")], ["ab_ruest", I18n.t(
          "intervention_order.vehicles.ab_ruest")], ["ab_ruest_rw", I18n.t(
          "intervention_order.vehicles.ab_ruest_rw")], ["fire", I18n.t(
          "intervention_order.vehicles.fire_truck")], ["thw_mlw5", I18n.t(
          "intervention_order.vehicles.thw_mlw5")], ["mtw", I18n.t(
          "intervention_order.vehicles.mtw")], ["ktw", I18n.t(
          "intervention_order.vehicles.long_distance_ambulance")], ["gkw", I18n.t(
          "intervention_order.vehicles.gkw")], ["thw_mtw", I18n.t(
          "intervention_order.vehicles.thw_mtw")], ["thw_mzkw", I18n.t(
          "intervention_order.vehicles.thw_mzkw")], ["thw_dle", I18n.t(
          "intervention_order.vehicles.thw_dle")], ["thw_brmg_r", I18n.t(
          "intervention_order.vehicles.thw_brmg_r")], ["thw_lkw", I18n.t(
          "intervention_order.vehicles.thw_lkw")], ["dlk", I18n.t(
          "intervention_order.vehicles.turntable_ladder")], ["elw", I18n.t(
          "intervention_order.vehicles.battalion_chief_unit")], ["elw2", I18n.t(
          "intervention_order.vehicles.division_chief_unit")], ["gwa", I18n.t(
          "intervention_order.vehicles.mask_service_unit")], ["gwl2wasser", I18n.t(
          "intervention_order.vehicles.schlauchwagen")], ["gwoel", I18n.t(
          "intervention_order.vehicles.oil_unit")], ["gwmesstechnik", I18n.t(
          "intervention_order.vehicles.gw_messtechnik")], ["rw", I18n.t(
          "intervention_order.vehicles.rescue_vehicle")], ["rtw", I18n.t(
          "intervention_order.vehicles.ambulance")], ["nef", I18n.t(
          "intervention_order.vehicles.emergency_ambulance")], ["rth_only", I18n.t(
          "intervention_order.vehicles.rth_only")], ["nef_only", I18n.t(
          "intervention_order.vehicles.nef_only")], ["gwgefahrgut", I18n.t(
          "intervention_order.vehicles.gw_gefahrgut")], ["gwhoehenrettung", I18n.t(
          "intervention_order.vehicles.gw_hoehenrettung")], ["fustw", I18n.t(
          "intervention_order.vehicles.police_car")], ["lebefkw", I18n.t(
          "intervention_order.vehicles.lebefkw")], ["grukw", I18n.t(
          "intervention_order.vehicles.grukw")], ["fukw", I18n.t(
          "intervention_order.vehicles.fukw")], ["at_c", I18n.t(
          "intervention_order.vehicles.at_c")], ["at_o", I18n.t(
          "intervention_order.vehicles.at_o")], ["at_m", I18n.t(
          "intervention_order.vehicles.at_m")], ["brush_vehicle", I18n.t(
          "intervention_order.vehicles.brush_vehicle")], ["brush_truck", I18n.t(
          "intervention_order.vehicles.brush_truck")], ["brush_truck_1", I18n.t(
          "intervention_order.vehicles.brush_truck_1")], ["brush_truck_2", I18n.t(
          "intervention_order.vehicles.brush_truck_2")], ["brush_truck_3", I18n.t(
          "intervention_order.vehicles.brush_truck_3")], ["brush_truck_4", I18n.t(
          "intervention_order.vehicles.brush_truck_4")], ["brush_truck_5", I18n.t(
          "intervention_order.vehicles.brush_truck_5")], ["fire_aviation", I18n.t(
          "intervention_order.vehicles.fire_aviation")], ["water_drop_helicopter", I18n.t(
          "intervention_order.vehicles.water_drop_helicopter")], ["air_tanker", I18n.t(
          "intervention_order.vehicles.air_tanker")], ["heavy_air_tanker", I18n.t(
          "intervention_order.vehicles.heavy_air_tanker")], ["spokesman", I18n.t(
          "intervention_order.vehicles.spokesman")], ["rescue_dogs", I18n.t(
          "intervention_order.vehicles.rescue_dogs")], ["rescue_dogs_seg", I18n.t(
          "intervention_order.vehicles.rescue_dogs_seg")], ["rescue_dogs_thw", I18n.t(
          "intervention_order.vehicles.rescue_dogs_thw")], ["coresponder", I18n.t(
          "intervention_order.vehicles.coresponder")], ["joint_response_unit", I18n.t(
          "intervention_order.vehicles.joint_response_unit")], ["kdow_orgl_any", I18n.t(
          "intervention_order.vehicles.kdow_orgl_any")], ["fly_car_any", I18n.t(
          "intervention_order.vehicles.fly_car_any")], ["crew_carrier", I18n.t(
          "intervention_order.vehicles.crew_carrier")], ["dozer_trailer", I18n.t(
          "intervention_order.vehicles.dozer_trailer")], ["fbi_unit", I18n.t(
          "intervention_order.vehicles.fbi_unit")], ["fbi_investigation_unit", I18n.t(
          "intervention_order.vehicles.fbi_investigation_unit")], ["fbi_mobile_command", I18n.t(
          "intervention_order.vehicles.fbi_mobile_command")], ["fbi_bomb_tech", I18n.t(
          "intervention_order.vehicles.fbi_bomb_tech")], ["fbi_drone", I18n.t(
          "intervention_order.vehicles.fbi_drone")], ["sheriff_unit", I18n.t(
          "intervention_order.vehicles.sheriff_unit")], ["any_traffic_car", I18n.t(
          "intervention_order.vehicles.any_traffic_car")], ["police_motorcycle", I18n.t(
          "intervention_order.vehicles.police_motorcycle")], ["police_horse", I18n.t(
          "intervention_order.vehicles.police_horse")], ["fustw_or_police_motorcycle", I18n.t(
          "intervention_order.vehicles.fustw_or_police_motorcycle")], ["commerce_police", I18n
          .t("intervention_order.vehicles.commerce_police")], ["elw_police", I18n.t(
          "intervention_order.vehicles.elw_police")], ["bike_police", I18n.t(
          "intervention_order.vehicles.bike_police")], ["police_car_3", I18n.t(
          "intervention_order.vehicles.police_car_3")], ["helicopter_bucket", I18n.t(
          "intervention_order.vehicles.helicopter_bucket")]], $("#restore_map")
      .click(() => {
          mapViewRestore()
      }), $("#coins_top")
      .click(() => mobile_bridge_use ? (mobileBridgeAdd("coins_window", {}), !1) : !0), "undefined" != typeof L && (icon_empty = L.icon({
        iconUrl: "/images/pfeil_rot.png",
        iconSize: [0, 0],
        iconAnchor: iconAnchorCalculate([0, 0])
    })), window.setInterval(() => {
        patientTimer()
    }, 1e3), $("#lightbox_close_inside")
      .click(() => {
          tutorial.callLightBoxCloseListener(), tellParent("lightboxClose()")
      }), $("#lightbox_close")
      .click(() => {
          lightboxClose()
      }), $("#lightbox_background")
      .click(() => {
          lightboxClose()
      }), $("#map_adress_search_form")
      .submit(() => (mapMoveToSearch(), !1)), $("body")
      .on("keyup", ".search_input_field", function () {
        const e = $(this)
            .attr("search_class");

        const t = $(this)
          .val()
          .toUpperCase();

        $(`.${e}`)
          .each(function () {
              $(this)
                .attr("search_attribute")
                .toUpperCase().includes(t) ? $(this)
                .show() : $(this)
                .hide()
          })
    }), $("body")
      .on("keyup", "#search_input_field_missions", () => {
          searchMission()
      }), $("#chat_panel_body")
      .on("click", ".alliance_chat_copy_username", function () {
          $("#alliance_chat_message")
            .val(`${$("#alliance_chat_message")
    .val()}@${$(this)
    .attr("username")} `), $("#alliance_chat_message")
            .focus()
      }), $("#chat_panel_body")
      .on("click", ".alliance_chat_private_username", function () {
          $("#alliance_chat_message")
            .val(`/w ${$(this)
    .attr("username")} `), $("#alliance_chat_message")
            .focus()
      }), $("#news")
      .click(function () {
          return newsNew(!1), $.ajax({
              url: "/news/gelesen",
              cache: !1
          }), mobile_bridge_use && "de_DE" != I18n.locale && "nl_NL" != I18n.locale ? (
            lightboxOpen($(this)
              .attr("href")), !1) : void 0
      }), $("#newspage_facebook")
      .click(function () {
          return !mobile_bridge_use || "de_DE" != I18n.locale && "nl_NL" != I18n.locale ?
            void 0 : (lightboxOpen($(this)
              .attr("href")), !1)
      }), $("#missions-panel-body")
      .scroll(function () {
          clearTimeout($.data(this, "scrollTimer")), $.data(this, "scrollTimer", setTimeout(
            () => {
                progressBarScrollUpdate()
            }, 400)), missionScrollUpdateWait || (missionScrollUpdateWait = !0,
            setTimeout(() => {
                missionScrollUpdate(), missionScrollUpdateWait = !1
            }, 300))
      }), $("#bigMapMenuMissionButton")
      .click(() => {
          bigMapMenuOpenClose($("#missions_outer")), progressBarScrollUpdate()
      }), $("#bigMapMenuBuildingButton")
      .click(() => {
          bigMapMenuOpenClose($("#buildings_outer"))
      }), $("#bigMapMenuRadioButton")
      .click(() => {
          bigMapMenuOpenClose($("#radio_outer")), $("#bigMapMenuRadioButton")
            .removeClass("bigMapMenuButtonGreen")
      }), $("#bigMapMenuChatButton")
      .click(() => {
          bigMapMenuOpenClose($("#chat_outer")), $("#bigMapMenuChatButton")
            .removeClass("bigMapMenuButtonGreen")
            .removeClass("bigMapMenuButtonBlack")
      }), $(".aao")
      .click(function () {
          return aaoClickHandler(this)
      }), $(".vehicle_group")
      .click(function () {
          return vehicleGroupClickHandler(this)
      }), $(".btn_alliance_radio")
      .click(() => {
          alliance_ignore_fms_set(!alliance_ignore_fms, !0)
      }), $("#logout_button")
      .click(function () {
          return 4 == mobile_version ? ($.ajax({
              url: $(this)
                .attr("href"),
              method: "delete",
              cache: !1
          }), mobileBridgeAdd("reload", {}), !1) : !0
      }), $("#new_alliance_chat")
      .submit(function () {
          return $.ajax({
              url: $(this)
                .attr("action"),
              data: $(this)
                .serialize(),
              cache: !1,
              type: "POST",
              success(e) {
                  "usernotfound" == e && alert(I18n.t("javascript.user_not_found"))
              },
              error(e) {
                  alert(e)
              }
          }), $("#alliance_chat_message")
            .val(""), !1;
      }), $(".sign-up-button")
      .click(() => (change_state(!0), !1)), $("body")
      .on("click", ".building_marker_image", function () {
          const e = $(this)
            .attr("building_id");
          toggleVehicleBuilding(e)
      }), $("body")
      .on("click", ".hidden_vehicle_list_caption", function () {
          const e = $(this)
            .attr("building_id");
          toggleVehicleBuilding(e)
      }), $("body")
      .on("mouseenter", ".building_list_vehicle_element", function () {
          if (1 == mobile_bridge_use || 0 == mouse_over_disable_inactive_elements) return !0;
          const e = $(this)
            .attr("vehicle_id");
          $.each(mission_markers, (e, t) => {
              "undefined" != typeof mapkit ? (t.opacity = .2, t.visible = !1, t
                .selected = !1) : (t.setOpacity(.2), t.closeTooltip())
          }), $.each(vehicle_markers, (t, i) => {
              if (i.visible && i.vehicle_id != e) "undefined" != typeof mapkit ? (i
                .opacity = .2, i.selected = !1) : (i.setOpacity(.2), i
                .closeTooltip());
              else if (i.vehicle_id == e && !i.vehicle_marker_deleted) {
                  target_marker && ("undefined" != typeof mapkit ? map.removeAnnotation(
                    target_marker) : map.removeLayer(target_marker),
                    target_marker = !1);
                  const n = routes[i.rh][routes[i.rh].length - 1];
                  "undefined" != typeof mapkit ? (target_marker = new mapkit
                    .ImageAnnotation(new mapkit.Coordinate(n[0], n[1]), {
                        url: {
                            1: "/images/direction_down.png"
                        }
                    }), target_marker.title = "Ziel", map.addAnnotation(
                    target_marker)) : (target_marker = L.marker([n[0], n[
                    1]], {
                      title: "Ziel",
                      icon: icon_empty
                  })
                    .addTo(map), iconMapGenerate("/images/direction_down.png",
                    target_marker))
              }
          }), $.each(building_markers_cache, (e, t) => {
              t.opacity = .2
          }), $.each(building_markers, (e, t) => {
              "undefined" != typeof mapkit ? (t.opacity = .2, t.visible = !1) : t
                .setOpacity(.2)
          })
      }), $("body")
      .on("mouseleave", ".building_list_vehicle_element", () => 1 == mobile_bridge_use || 0 == mouse_over_disable_inactive_elements ? !0 : (
      target_marker && ("undefined" != typeof mapkit ? map.removeAnnotation(
        target_marker) : map.removeLayer(target_marker), target_marker = !1), $
        .each(vehicle_markers, (e, t) => {
            t.visible && ("undefined" != typeof mapkit ? t.opacity = 1 : t
              .setOpacity(1))
        }), $.each(mission_markers, (e, t) => {
          "undefined" != typeof mapkit ? (t.opacity = 1, t.visible = !0) : (t
            .setOpacity(1), mission_label ? t.openTooltip() : t
            .closeTooltip())
      }), $.each(building_markers_cache, (e, t) => {
          t.opacity = 1
      }), $.each(building_markers, (e, t) => {
          "undefined" != typeof mapkit ? (t.opacity = 1, t.visible = !0) : t
            .setOpacity(1)
      }), void 0)), $("body")
      .on("mouseenter", ".missionSideBarEntry", function () {
          if (1 == mobile_bridge_use || 0 == mouse_over_disable_inactive_elements) return !0;
          const e = $(this)
            .attr("mission_id");
          $.each(mission_markers, (t, i) => {
              i.mission_id != e ? "undefined" != typeof mapkit ? (i.opacity = .2, i
                  .visible = !1) : (i.setOpacity(.2), i.closeTooltip()) :
                "undefined" == typeof mapkit && i.openTooltip()
          }), vehicle_label_backup = vehicle_label, vehicle_label = !1, $.each(
            vehicle_markers,
            (e, t) => {
                t.visible && ("undefined" != typeof mapkit ? (t.opacity = .2, t
                  .selected = !1) : (t.setOpacity(.2), t.closeTooltip()))
            }), $.each(building_markers_cache, (e, t) => {
              t.opacity = .2
          }), $.each(building_markers, (e, t) => {
              "undefined" != typeof mapkit ? (t.opacity = .2, t.visible = !1) : t
                .setOpacity(.2)
          }), "null" != $(this)
            .attr("target_latitude") && (target_marker && ("undefined" != typeof mapkit ? map
            .removeAnnotation(target_marker) : map.removeLayer(target_marker),
            target_marker = !1), "undefined" != typeof mapkit ? (target_marker =
            new mapkit.ImageAnnotation(new mapkit.Coordinate(parseFloat($(this)
              .attr("target_latitude")), parseFloat($(this)
              .attr("target_longitude"))), {
                url: {
                    1: "/images/direction_down.png"
                }
            }), target_marker.title = "Ziel", map.addAnnotation(target_marker)) : (
            target_marker = L.marker([$(this)
              .attr("target_latitude"), $(this)
              .attr("target_longitude")], {
                title: "Ziel",
                icon: icon_empty
            })
              .addTo(map), iconMapGenerate("/images/direction_down.png", target_marker)
          ))
      }), $("body")
      .on("mouseleave", ".missionSideBarEntry", () => 1 == mobile_bridge_use || 0 == mouse_over_disable_inactive_elements ? !0 : (
      target_marker && ("undefined" != typeof mapkit ? map.removeAnnotation(
        target_marker) : map.removeLayer(target_marker), target_marker = !1),
        vehicle_label = vehicle_label_backup, $.each(vehicle_markers, (e, t) => {
          t.visible && ("undefined" != typeof mapkit ? t.opacity = 1 : (t
            .setOpacity(1), vehicle_label ? t.openTooltip() : t
            .closeTooltip()))
      }), $.each(mission_markers, (e, t) => {
          "undefined" != typeof mapkit ? (t.opacity = 1, t.visible = !0) : (t
            .setOpacity(1), mission_label ? t.openTooltip() : t
            .closeTooltip())
      }), $.each(building_markers_cache, (e, t) => {
          t.opacity = 1
      }), $.each(building_markers, (e, t) => {
          "undefined" != typeof mapkit ? (t.opacity = 1, t.visible = !0) : t
            .setOpacity(1)
      }), void 0)), $("#buildings")
      .on("submit", "form.ajax", function (event) {
          return buildingResetContentPossible = !1, building_eval_unload && (eval(
            building_eval_unload), building_eval_unload = null), $.ajax({
              url: $(this)
                .attr("action"),
              data: $(this)
                .serialize(),
              cache: !1,
              type: "POST",
              success(e) {
                  $("#buildings")
                    .html(e), bigMapWindowSizeChanged()
              },
              error(e) {
                  alert(e)
              }
          }), $("#buildings")
            .html("Loading..."), !1;
      }), $("#buildings")
      .on("click", "a.ajax", function () {
          return buildingLoadContent($(this)
            .attr("href")), !1
      }), $("#missions")
      .on("click", "a.building_ajax", function () {
          return buildingLoadContent($(this)
            .attr("href")), !1
      }), $("#buildings")
      .on("click", ".backalarm", function () {
          return $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1,
              success() {}
          }), !1;
      }), $("body")
      .on("click", ".vehicle_search", function () {
          return vehicleSearch($(this)
            .attr("vehicle_id")), !1
      }), $("#audio_switch")
      .click(function () {
          return $("#current_audio")
            .html(I18n.t("common.loading")), $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1
          })
            .success(e => {
                $("#ajax_temp")
                  .html(e)
            }), !1;
      }), $("#audio_chat_switch")
      .click(function () {
          return $("#current_audio_chat")
            .html(I18n.t("common.loading")), $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1
          })
            .success(e => {
                $("#ajax_temp")
                  .html(e)
            }), !1;
      }), $("#audio_chat_highlight_switch")
      .click(function () {
          return $("#current_audio_chat_highlight")
            .html(I18n.t("common.loading")), $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1
          })
            .success(e => {
                $("#ajax_temp")
                  .html(e)
            }), !1;
      }), $("#mission_label_switch")
      .click(function () {
          return $("#current_mission_label")
            .html(I18n.t("common.loading")), $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1
          })
            .success(e => {
                $("#ajax_temp")
                  .html(e)
            }), !1;
      }), $("#vehicle_label_switch")
      .click(function () {
          return $("#current_vehicle_label")
            .html(I18n.t("common.loading")), $.ajax({
              url: $(this)
                .attr("href"),
              cache: !1
          })
            .success(e => {
                $("#ajax_temp")
                  .html(e)
            }), !1;
      }), $("body")
      .on("click", ".lightbox-open", function () {
          return lightboxOpen($(this)
            .attr("href")), !1
      }), $("body")
      .on("click", ".radio_message_close", function () {
          return $(`.radio_message_vehicle_${$(this)
  .attr("vehicle_id")}`)
            .remove(), !1;
      }), $("body")
      .on("click", ".map_position_mover", function () {
          if ("undefined" == typeof $(this)
            .attr("target_latitude") || "null" == $(this)
            .attr("target_latitude")) mapViewExpanded ? mapViewExpandedWindow.map.setView([$(
            this)
            .data("latitude"), $(this)
            .data("longitude")]) : "undefined" != typeof mapkit ? map.setCenterAnimated(
            new mapkit.Coordinate($(this)
              .data("latitude"), $(this)
              .data("longitude")), !0) : map.setView([$(this)
            .data("latitude"), $(this)
            .data("longitude")]);
          else if (mapViewExpanded) mapViewExpandedWindow.map.fitBounds([[$(this)
            .data("latitude"), $(this)
            .data("longitude")], [$(this)
            .attr("target_latitude"), $(this)
            .attr("target_longitude")]]);
          else if ("undefined" == typeof mapkit) map.fitBounds([[$(this)
            .data("latitude"), $(this)
            .data("longitude")], [$(this)
            .attr("target_latitude"), $(this)
            .attr("target_longitude")]]);
          else {
              let e = parseFloat($(this)
                  .data("latitude")) - parseFloat($(this)
                  .attr("target_latitude"));

              let t = parseFloat($(this)
                .data("latitude")) - parseFloat($(this)
                .attr("target_latitude"));

              const i = parseFloat($(this)
                .attr("target_latitude")) + e / 2;

              const n = parseFloat($(this)
                .attr("target_longitude")) + t / 2;

              0 > e && (e = -1 * e), 0 > t && (t = -1 * t);
              const o = new mapkit.Coordinate(i, n);
              const s = new mapkit.CoordinateSpan(e + .05, t + .05);
              const a = new mapkit.CoordinateRegion(o, s);
              map.setRegionAnimated(a, !0)
          }
          return !1
      }), setupTimer({
        $timer: $(".credit-modifier-event .timer"),
        onTimerEnd() {
            $(".credit-modifier-event")
              .remove()
        }
    }), setupTimer({
        $timer: $(".coin-reduction-event .timer"),
        onTimerEnd() {
            $(".coin-reduction-event")
              .remove()
        }
    })
});
const mapKitFactoryVehicleAnnotation = (e, t) => {
    const i = document.createElement("img");
    return i.src = t.url[1], i
};
Date.now || (Date.now = () => (new Date)
  .getTime());
var current_state = "register";

const breadcrumbnav = (() => {
    let e;
    return {
        init(e) {
            this.clear(), this.add(e), $(document)
              .bind("keypress", "b", () => {
                  breadcrumbnav.back()
              })
        },
        back() {
            const t = $(`#${e[e.length - 1]}`)[0];
            null != t && t.click()
        },
        add(t) {
            e.push(t)
        },
        clear() {
            e = []
        }
    };
})();

$(document)
  .on("shown.bs.dropdown", e => {
      if ("auto" == $(e.target)
        .attr("menu-adjust")) {
          const t = $(e.target)
            .find(".dropdown-menu");
          $(e.target)
            .find(".dropdown-toggle");
          const i = t.offset();
          i.left + t.width() > $(window)
            .width() - $(window)
            .scrollLeft() && t.addClass("dropdown-menu-right")
      }
  })
  .on("hidden.bs.dropdown", ".dropdown", e => {
      if ("auto" == $(e.target)
        .attr("menu-adjust")) {
          const t = $(e.target)
            .find(".dropdown-menu");
          t.removeClass("dropdown-menu-right")
      }
  });

const dynamicLayouter = (() => {
      let e = {};
      return {
          init() {
              dynamicLayouter.clear(), dynamicLayouter.initLayouter(), dynamicLayouter.resize()
          },
          initLayouter() {
              dynamicLayouter.initCookiesBannerLayouter()
          },
          resize() {
              for (const e in dynamicLayouter.resizeFunctions()) dynamicLayouter.resizeFunctions()[e]()
          },
          initCookiesBannerLayouter() {
              const t = $("#bigMapMenu"), i = $(".js-cookies-eu"), n = $("#navbar-mobile-footer");
              i.length && (t.length || n.length) && ($(".cookies-eu-ok")
                .on("click", () => {
                    i.css("height", "0px"), e.recalculateCookiesBanner(), delete e
                      .recalculateCookiesBanner
                }), dynamicLayouter.resizeFunctions()
                .recalculateCookiesBanner = dynamicLayouter.recalculateCookiesBanner)
          },
          recalculateCookiesBanner() {
              const e = $("#bigMapMenu")
                        .length ? $("#bigMapMenu") : $("#navbar-mobile-footer"),
                    t = $(".js-cookies-eu");
              t.length && e.length ? e.css("bottom", t.height()) : e.css("bottom", 0)
          },
          resizeFunctions() {
              return e
          },
          clear() {
              e = {}
          }
      };
  })();

var BUTTON_STATES = {
    loading: "loading",
    enabled: "enabled",
    disabled: "disabled"
};

/*!
 * Bootstrap v3.3.6 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if ("undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");+(({fn}) => {
    const t = fn.jquery.split(" ")[0].split(".");
    if (t[0] < 2 && t[1] < 9 || 1 == t[0] && 9 == t[1] && t[2] < 1 || t[0] > 2) throw new Error(
      "Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")
})(jQuery), +(e => {
    function t() {
        const e = document.createElement("bootstrap");

        const t = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };

        for (const i in t)
            if (void 0 !== e.style[i]) return {
                end: t[i]
            };
        return !1
    }
    e.fn.emulateTransitionEnd = function (t) {
        let i = !1;
        const n = this;
        e(this)
          .one("bsTransitionEnd", () => {
              i = !0
          });
        const o = () => {
            i || e(n)
              .trigger(e.support.transition.end)
        };
        return setTimeout(o, t), this
    }, e(() => {
        e.support.transition = t(), e.support.transition && (e.event.special.bsTransitionEnd = {
            bindType: e.support.transition.end,
            delegateType: e.support.transition.end,
            handle(t) {
                return e(t.target)
                  .is(this) ? t.handleObj.handler.apply(this, arguments) : void 0
            }
        })
    })
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const i = e(this);
            let o = i.data("bs.alert");
            o || i.data("bs.alert", o = new n(this)), "string" == typeof t && o[t].call(i)
        });
    }
    const i = '[data-dismiss="alert"]';

    var n = function (t) {
        e(t)
          .on("click", i, this.close)
    };

    n.VERSION = "3.3.6", n.TRANSITION_DURATION = 150, n.prototype.close = function (t) {
        function i() {
            a.detach()
              .trigger("closed.bs.alert")
              .remove()
        }
        const o = e(this);
        let s = o.attr("data-target");
        s || (s = o.attr("href"), s = s && s.replace(/.*(?=#[^\s]*$)/, ""));
        var a = e(s);
        t && t.preventDefault(), a.length || (a = o.closest(".alert")), a.trigger(t = e.Event(
          "close.bs.alert")), t.isDefaultPrevented() || (a.removeClass("in"), e.support
          .transition && a.hasClass("fade") ? a.one("bsTransitionEnd", i)
          .emulateTransitionEnd(n.TRANSITION_DURATION) : i())
    };
    const o = e.fn.alert;
    e.fn.alert = t, e.fn.alert.Constructor = n, e.fn.alert.noConflict = function () {
        return e.fn.alert = o, this
    }, e(document)
      .on("click.bs.alert.data-api", i, n.prototype.close)
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.button");
            const s = "object" == typeof t && t;
            o || n.data("bs.button", o = new i(this, s)), "toggle" == t ? o.toggle() : t && o
              .setState(t)
        });
    }
    var i = function (t, n) {
        this.$element = e(t), this.options = e.extend({}, i.DEFAULTS, n), this.isLoading = !1
    };
    i.VERSION = "3.3.6", i.DEFAULTS = {
        loadingText: "loading..."
    }, i.prototype.setState = function (t) {
        const i = "disabled";
        const n = this.$element;
        const o = n.is("input") ? "val" : "html";
        const s = n.data();
        t += "Text", null == s.resetText && n.data("resetText", n[o]()), setTimeout(e.proxy(function () {
            n[o](null == s[t] ? this.options[t] : s[t]), "loadingText" == t ? (this
              .isLoading = !0, n.addClass(i)
              .attr(i, i)) : this.isLoading && (this.isLoading = !1, n.removeClass(i)
              .removeAttr(i))
        }, this), 0)
    }, i.prototype.toggle = function () {
        let e = !0;
        const t = this.$element.closest('[data-toggle="buttons"]');
        if (t.length) {
            const i = this.$element.find("input");
            "radio" == i.prop("type") ? (i.prop("checked") && (e = !1), t.find(".active")
              .removeClass("active"), this.$element.addClass("active")) : "checkbox" == i.prop(
              "type") && (i.prop("checked") !== this.$element.hasClass("active") && (e = !1), this
              .$element.toggleClass("active")), i.prop("checked", this.$element.hasClass("active")),
            e && i.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element
          .toggleClass("active")
    };
    const n = e.fn.button;
    e.fn.button = t, e.fn.button.Constructor = i, e.fn.button.noConflict = function () {
        return e.fn.button = n, this
    }, e(document)
      .on("click.bs.button.data-api", '[data-toggle^="button"]', i => {
          let n = e(i.target);
          n.hasClass("btn") || (n = n.closest(".btn")), t.call(n, "toggle"), e(i.target)
            .is('input[type="radio"]') || e(i.target)
            .is('input[type="checkbox"]') || i.preventDefault()
      })
      .on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', t => {
          e(t.target)
            .closest(".btn")
            .toggleClass("focus", /^focus(in)?$/.test(t.type))
      })
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.carousel");
            const s = e.extend({}, i.DEFAULTS, n.data(), "object" == typeof t && t);
            const a = "string" == typeof t ? t : s.slide;
            o || n.data("bs.carousel", o = new i(this, s)), "number" == typeof t ? o.to(t) : a ? o[a]
            () : s.interval && o.pause()
              .cycle()
        });
    }
    var i = function (t, i) {
        this.$element = e(t), this.$indicators = this.$element.find(".carousel-indicators"), this
          .options = i, this.paused = null, this.sliding = null, this.interval = null, this.$active =
          null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", e
          .proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document
          .documentElement) && this.$element.on("mouseenter.bs.carousel", e.proxy(this.pause, this))
          .on("mouseleave.bs.carousel", e.proxy(this.cycle, this))
    };
    i.VERSION = "3.3.6", i.TRANSITION_DURATION = 600, i.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, i.prototype.keydown = function (e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            e.preventDefault()
        }
    }, i.prototype.cycle = function (t) {
        return t || (this.paused = !1), this.interval && clearInterval(this.interval), this.options
          .interval && !this.paused && (this.interval = setInterval(e.proxy(this.next, this), this
          .options.interval)), this
    }, i.prototype.getItemIndex = function (e) {
        return this.$items = e.parent()
          .children(".item"), this.$items.index(e || this.$active)
    }, i.prototype.getItemForDirection = function (e, t) {
        const i = this.getItemIndex(t);
        const n = "prev" == e && 0 === i || "next" == e && i == this.$items.length - 1;
        if (n && !this.options.wrap) return t;
        const o = "prev" == e ? -1 : 1;
        const s = (i + o) % this.$items.length;
        return this.$items.eq(s)
    }, i.prototype.to = function (e) {
        const t = this;
        const i = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        return e > this.$items.length - 1 || 0 > e ? void 0 : this.sliding ? this.$element.one(
          "slid.bs.carousel",
          () => {
              t.to(e)
          }) : i == e ? this.pause()
          .cycle() : this.slide(e > i ? "next" : "prev", this.$items.eq(e));
    }, i.prototype.pause = function (t) {
        return t || (this.paused = !0), this.$element.find(".next, .prev")
          .length && e.support.transition && (this.$element.trigger(e.support.transition.end), this
          .cycle(!0)), this.interval = clearInterval(this.interval), this
    }, i.prototype.next = function () {
        return this.sliding ? void 0 : this.slide("next")
    }, i.prototype.prev = function () {
        return this.sliding ? void 0 : this.slide("prev")
    }, i.prototype.slide = function (t, n) {
        const o = this.$element.find(".item.active");
        const s = n || this.getItemForDirection(t, o);
        const a = this.interval;
        const r = "next" == t ? "left" : "right";
        const l = this;
        if (s.hasClass("active")) return this.sliding = !1;
        const c = s[0];

        const u = e.Event("slide.bs.carousel", {
            relatedTarget: c,
            direction: r
        });

        if (this.$element.trigger(u), !u.isDefaultPrevented()) {
            if (this.sliding = !0, a && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active")
                  .removeClass("active");
                const d = e(this.$indicators.children()[this.getItemIndex(s)]);
                d && d.addClass("active")
            }
            const h = e.Event("slid.bs.carousel", {
                relatedTarget: c,
                direction: r
            });
            return e.support.transition && this.$element.hasClass("slide") ? (s.addClass(t), s[0]
              .offsetWidth, o.addClass(r), s.addClass(r), o.one("bsTransitionEnd", () => {
                s.removeClass([t, r].join(" "))
                  .addClass("active"), o.removeClass(["active", r].join(" ")), l.sliding = !
                  1, setTimeout(() => {
                    l.$element.trigger(h)
                }, 0)
            })
              .emulateTransitionEnd(i.TRANSITION_DURATION)) : (o.removeClass("active"), s.addClass(
              "active"), this.sliding = !1, this.$element.trigger(h)), a && this.cycle(), this;
        }
    };
    const n = e.fn.carousel;
    e.fn.carousel = t, e.fn.carousel.Constructor = i, e.fn.carousel.noConflict = function () {
        return e.fn.carousel = n, this
    };
    const o = function (i) {
        let n;
        const o = e(this);
        const s = e(o.attr("data-target") || (n = o.attr("href")) && n.replace(/.*(?=#[^\s]+$)/, ""));
        if (s.hasClass("carousel")) {
            const a = e.extend({}, s.data(), o.data());
            const r = o.attr("data-slide-to");
            r && (a.interval = !1), t.call(s, a), r && s.data("bs.carousel")
              .to(r), i.preventDefault()
        }
    };
    e(document)
      .on("click.bs.carousel.data-api", "[data-slide]", o)
      .on("click.bs.carousel.data-api", "[data-slide-to]", o), e(window)
      .on("load", () => {
          e('[data-ride="carousel"]')
            .each(function () {
                const i = e(this);
                t.call(i, i.data())
            })
      })
})(jQuery), +(e => {
    function t(t) {
        let i;
        const n = t.attr("data-target") || (i = t.attr("href")) && i.replace(/.*(?=#[^\s]+$)/, "");
        return e(n)
    }

    function i(t) {
        return this.each(function () {
            const i = e(this);
            let o = i.data("bs.collapse");
            const s = e.extend({}, n.DEFAULTS, i.data(), "object" == typeof t && t);
            !o && s.toggle && /show|hide/.test(t) && (s.toggle = !1), o || i.data("bs.collapse", o =
              new n(this, s)), "string" == typeof t && o[t]()
        });
    }
    var n = function (t, i) {
        this.$element = e(t), this.options = e.extend({}, n.DEFAULTS, i), this.$trigger = e(
          `[data-toggle="collapse"][href="#${t.id}"],[data-toggle="collapse"][data-target="#${t.id}"]`), this.transitioning = null, this.options.parent ? this.$parent = this
          .getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options
          .toggle && this.toggle()
    };
    n.VERSION = "3.3.6", n.TRANSITION_DURATION = 350, n.DEFAULTS = {
        toggle: !0
    }, n.prototype.dimension = function () {
        const e = this.$element.hasClass("width");
        return e ? "width" : "height"
    }, n.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            let t;

            const o = this.$parent && this.$parent.children(".panel")
              .children(".in, .collapsing");

            if (!(o && o.length && (t = o.data("bs.collapse"), t && t.transitioning))) {
                const s = e.Event("show.bs.collapse");
                if (this.$element.trigger(s), !s.isDefaultPrevented()) {
                    o && o.length && (i.call(o, "hide"), t || o.data("bs.collapse", null));
                    const a = this.dimension();
                    this.$element.removeClass("collapse")
                      .addClass("collapsing")[a](0)
                      .attr("aria-expanded", !0), this.$trigger.removeClass("collapsed")
                      .attr("aria-expanded", !0), this.transitioning = 1;
                    const r = function () {
                        this.$element.removeClass("collapsing")
                          .addClass("collapse in")[a](""), this.transitioning = 0, this.$element
                          .trigger("shown.bs.collapse")
                    };
                    if (!e.support.transition) return r.call(this);
                    const l = e.camelCase(["scroll", a].join("-"));
                    this.$element.one("bsTransitionEnd", e.proxy(r, this))
                      .emulateTransitionEnd(n.TRANSITION_DURATION)[a](this.$element[0][l])
                }
            }
        }
    }, n.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
            const t = e.Event("hide.bs.collapse");
            if (this.$element.trigger(t), !t.isDefaultPrevented()) {
                const i = this.dimension();
                this.$element[i](this.$element[i]())[0].offsetHeight, this.$element.addClass("collapsing")
                  .removeClass("collapse in")
                  .attr("aria-expanded", !1), this.$trigger.addClass("collapsed")
                  .attr("aria-expanded", !1), this.transitioning = 1;
                const o = function () {
                    this.transitioning = 0, this.$element.removeClass("collapsing")
                      .addClass("collapse")
                      .trigger("hidden.bs.collapse")
                };
                return e.support.transition ? void this.$element[i](0)
                  .one("bsTransitionEnd", e.proxy(o, this))
                  .emulateTransitionEnd(n.TRANSITION_DURATION) : o.call(this)
            }
        }
    }, n.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, n.prototype.getParent = function () {
        return e(this.options.parent)
          .find(`[data-toggle="collapse"][data-parent="${this.options.parent}"]`)
          .each(e.proxy(function (i, n) {
              const o = e(n);
              this.addAriaAndCollapsedClass(t(o), o)
          }, this))
          .end();
    }, n.prototype.addAriaAndCollapsedClass = (e, t) => {
        const i = e.hasClass("in");
        e.attr("aria-expanded", i), t.toggleClass("collapsed", !i)
          .attr("aria-expanded", i)
    };
    const o = e.fn.collapse;
    e.fn.collapse = i, e.fn.collapse.Constructor = n, e.fn.collapse.noConflict = function () {
        return e.fn.collapse = o, this
    }, e(document)
      .on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (n) {
        const o = e(this);
        o.attr("data-target") || n.preventDefault();
        const s = t(o);
        const a = s.data("bs.collapse");
        const r = a ? "toggle" : o.data();
        i.call(s, r)
    })
})(jQuery), +(e => {
    function t(t) {
        let i = t.attr("data-target");
        i || (i = t.attr("href"), i = i && /#[A-Za-z]/.test(i) && i.replace(/.*(?=#[^\s]*$)/, ""));
        const n = i && e(i);
        return n && n.length ? n : t.parent()
    }

    function i(i) {
        i && 3 === i.which || (e(o)
          .remove(), e(s)
          .each(function () {
            const n = e(this);
            const o = t(n);

            const s = {
                relatedTarget: this
            };

            o.hasClass("open") && (i && "click" == i.type && /input|textarea/i.test(i.target
              .tagName) && e.contains(o[0], i.target) || (o.trigger(i = e.Event(
              "hide.bs.dropdown", s)), i.isDefaultPrevented() || (n.attr(
              "aria-expanded", "false"), o.removeClass("open")
              .trigger(e.Event("hidden.bs.dropdown", s)))))
        }))
    }

    function n(t) {
        return this.each(function () {
            const i = e(this);
            let n = i.data("bs.dropdown");
            n || i.data("bs.dropdown", n = new a(this)), "string" == typeof t && n[t].call(i)
        });
    }
    var o = ".dropdown-backdrop";
    var s = '[data-toggle="dropdown"]';

    var a = function (t) {
        e(t)
          .on("click.bs.dropdown", this.toggle)
    };

    a.VERSION = "3.3.6", a.prototype.toggle = function (n) {
        const o = e(this);
        if (!o.is(".disabled, :disabled")) {
            const s = t(o);
            const a = s.hasClass("open");
            if (i(), !a) {
                "ontouchstart" in document.documentElement && !s.closest(".navbar-nav")
                  .length && e(document.createElement("div"))
                  .addClass("dropdown-backdrop")
                  .insertAfter(e(this))
                  .on("click", i);
                const r = {
                    relatedTarget: this
                };
                if (s.trigger(n = e.Event("show.bs.dropdown", r)), n.isDefaultPrevented()) return;
                o.trigger("focus")
                  .attr("aria-expanded", "true"), s.toggleClass("open")
                  .trigger(e.Event("shown.bs.dropdown", r))
            }
            return !1
        }
    }, a.prototype.keydown = function (i) {
        if (/(38|40|27|32)/.test(i.which) && !/input|textarea/i.test(i.target.tagName)) {
            const n = e(this);
            if (i.preventDefault(), i.stopPropagation(), !n.is(".disabled, :disabled")) {
                const o = t(n);
                const a = o.hasClass("open");
                if (!a && 27 != i.which || a && 27 == i.which) return 27 == i.which && o.find(s)
                  .trigger("focus"), n.trigger("click");
                const r = " li:not(.disabled):visible a";
                const l = o.find(`.dropdown-menu${r}`);
                if (l.length) {
                    let c = l.index(i.target);
                    38 == i.which && c > 0 && c--, 40 == i.which && c < l.length - 1 && c++, ~c || (c =
                      0), l.eq(c)
                      .trigger("focus")
                }
            }
        }
    };
    const r = e.fn.dropdown;
    e.fn.dropdown = n, e.fn.dropdown.Constructor = a, e.fn.dropdown.noConflict = function () {
        return e.fn.dropdown = r, this
    }, e(document)
      .on("click.bs.dropdown.data-api", i)
      .on("click.bs.dropdown.data-api", ".dropdown form", e => {
          e.stopPropagation()
      })
      .on("click.bs.dropdown.data-api", s, a.prototype.toggle)
      .on("keydown.bs.dropdown.data-api", s, a.prototype.keydown)
      .on("keydown.bs.dropdown.data-api", ".dropdown-menu", a.prototype.keydown)
})(jQuery), +(e => {
    function t(t, n) {
        return this.each(function () {
            const o = e(this);
            let s = o.data("bs.modal");
            const a = e.extend({}, i.DEFAULTS, o.data(), "object" == typeof t && t);
            s || o.data("bs.modal", s = new i(this, a)), "string" == typeof t ? s[t](n) : a.show && s
              .show(n)
        });
    }
    var i = function (t, i) {
        this.options = i, this.$body = e(document.body), this.$element = e(t), this.$dialog = this
          .$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this
          .originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options
          .remote && this.$element.find(".modal-content")
          .load(this.options.remote, e.proxy(function () {
              this.$element.trigger("loaded.bs.modal")
          }, this))
    };
    i.VERSION = "3.3.6", i.TRANSITION_DURATION = 300, i.BACKDROP_TRANSITION_DURATION = 150, i.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, i.prototype.toggle = function (e) {
        return this.isShown ? this.hide() : this.show(e)
    }, i.prototype.show = function (t) {
        const n = this;

        const o = e.Event("show.bs.modal", {
            relatedTarget: t
        });

        this.$element.trigger(o), this.isShown || o.isDefaultPrevented() || (this.isShown = !0, this
          .checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(),
          this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', e
          .proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", () => {
            n.$element.one("mouseup.dismiss.bs.modal", t => {
                e(t.target)
                  .is(n.$element) && (n.ignoreBackdropClick = !0)
            })
        }), this.backdrop(() => {
            const o = e.support.transition && n.$element.hasClass("fade");
            n.$element.parent()
              .length || n.$element.appendTo(n.$body), n.$element.show()
              .scrollTop(0), n.adjustDialog(), o && n.$element[0].offsetWidth, n.$element
              .addClass("in"), n.enforceFocus();
            const s = e.Event("shown.bs.modal", {
                relatedTarget: t
            });
            o ? n.$dialog.one("bsTransitionEnd", () => {
                n.$element.trigger("focus")
                  .trigger(s)
            })
              .emulateTransitionEnd(i.TRANSITION_DURATION) : n.$element.trigger("focus")
              .trigger(s)
        }))
    }, i.prototype.hide = function (t) {
        t && t.preventDefault(), t = e.Event("hide.bs.modal"), this.$element.trigger(t), this.isShown && !
          t.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), e(document)
          .off("focusin.bs.modal"), this.$element.removeClass("in")
          .off("click.dismiss.bs.modal")
          .off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), e
          .support.transition && this.$element.hasClass("fade") ? this.$element.one(
          "bsTransitionEnd", e.proxy(this.hideModal, this))
          .emulateTransitionEnd(i.TRANSITION_DURATION) : this.hideModal())
    }, i.prototype.enforceFocus = function () {
        e(document)
          .off("focusin.bs.modal")
          .on("focusin.bs.modal", e.proxy(function (e) {
              this.$element[0] === e.target || this.$element.has(e.target)
                .length || this.$element.trigger("focus")
          }, this))
    }, i.prototype.escape = function () {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", e.proxy(
          function({which}) {
              27 == which && this.hide()
          }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, i.prototype.resize = function () {
        this.isShown ? e(window)
          .on("resize.bs.modal", e.proxy(this.handleUpdate, this)) : e(window)
          .off("resize.bs.modal")
    }, i.prototype.hideModal = function () {
        const e = this;
        this.$element.hide(), this.backdrop(() => {
            e.$body.removeClass("modal-open"), e.resetAdjustments(), e.resetScrollbar(), e
              .$element.trigger("hidden.bs.modal")
        })
    }, i.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, i.prototype.backdrop = function (t) {
        const n = this;
        const o = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            const s = e.support.transition && o;
            if (this.$backdrop = e(document.createElement("div"))
              .addClass(`modal-backdrop ${o}`)
              .appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", e.proxy(function (e) {
                return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(e
                  .target === e.currentTarget && ("static" == this.options.backdrop ?
                  this.$element[0].focus() : this.hide()))
            }, this)), s && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !t) return;
            s ? this.$backdrop.one("bsTransitionEnd", t)
              .emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : t()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            const a = () => {
                n.removeBackdrop(), t && t()
            };
            e.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd",
              a)
              .emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION) : a()
        } else t && t()
    }, i.prototype.handleUpdate = function () {
        this.adjustDialog()
    }, i.prototype.adjustDialog = function () {
        const e = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && e ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !e ? this.scrollbarWidth : ""
        })
    }, i.prototype.resetAdjustments = function () {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        })
    }, i.prototype.checkScrollbar = function () {
        let e = window.innerWidth;
        if (!e) {
            const t = document.documentElement.getBoundingClientRect();
            e = t.right - Math.abs(t.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < e, this.scrollbarWidth = this
          .measureScrollbar()
    }, i.prototype.setScrollbar = function () {
        const e = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this
          .$body.css("padding-right", e + this.scrollbarWidth)
    }, i.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }, i.prototype.measureScrollbar = function () {
        const e = document.createElement("div");
        e.className = "modal-scrollbar-measure", this.$body.append(e);
        const t = e.offsetWidth - e.clientWidth;
        return this.$body[0].removeChild(e), t
    };
    const n = e.fn.modal;
    e.fn.modal = t, e.fn.modal.Constructor = i, e.fn.modal.noConflict = function () {
        return e.fn.modal = n, this
    }, e(document)
      .on("click.bs.modal.data-api", '[data-toggle="modal"]', function (i) {
        const n = e(this);
        const o = n.attr("href");
        const s = e(n.attr("data-target") || o && o.replace(/.*(?=#[^\s]+$)/, ""));

        const a = s.data("bs.modal") ? "toggle" : e.extend({
            remote: !/#/.test(o) && o
        }, s.data(), n.data());

        n.is("a") && i.preventDefault(), s.one("show.bs.modal", e => {
            e.isDefaultPrevented() || s.one("hidden.bs.modal", () => {
                n.is(":visible") && n.trigger("focus")
            })
        }), t.call(s, a, this)
    })
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.tooltip");
            const s = "object" == typeof t && t;
            (o || !/destroy|hide/.test(t)) && (o || n.data("bs.tooltip", o = new i(this, s)),
            "string" == typeof t && o[t]())
        });
    }
    var i = function (e, t) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState =
          null, this.$element = null, this.inState = null, this.init("tooltip", e, t)
    };
    i.VERSION = "3.3.6", i.TRANSITION_DURATION = 150, i.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    }, i.prototype.init = function (t, i, n) {
        if (this.enabled = !0, this.type = t, this.$element = e(i), this.options = this.getOptions(n),
          this.$viewport = this.options.viewport && e(e.isFunction(this.options.viewport) ? this.options
            .viewport.call(this, this.$element) : this.options.viewport.selector || this.options
            .viewport), this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        }, this.$element[0] instanceof document.constructor && !this.options.selector)
            throw new Error(`\`selector\` option must be specified when initializing ${this.type} on the window.document object!`);
        for (let o = this.options.trigger.split(" "), s = o.length; s--;) {
            const a = o[s];
            if ("click" == a) this.$element.on(`click.${this.type}`, this.options.selector, e.proxy(this
              .toggle, this));
            else if ("manual" != a) {
                const r = "hover" == a ? "mouseenter" : "focusin";
                const l = "hover" == a ? "mouseleave" : "focusout";
                this.$element.on(`${r}.${this.type}`, this.options.selector, e.proxy(this.enter, this)),
                  this.$element.on(`${l}.${this.type}`, this.options.selector, e.proxy(this.leave,
                    this))
            }
        }
        this.options.selector ? this._options = e.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }, i.prototype.getDefaults = () => i.DEFAULTS, i.prototype.getOptions = function (t) {
        return t = e.extend({}, this.getDefaults(), this.$element.data(), t), t.delay && "number" ==
        typeof t.delay && (t.delay = {
            show: t.delay,
            hide: t.delay
        }), t
    }, i.prototype.getDelegateOptions = function () {
        const t = {};
        const i = this.getDefaults();
        return this._options && e.each(this._options, (e, n) => {
            i[e] != n && (t[e] = n)
        }), t;
    }, i.prototype.enter = function (t) {
        let i = t instanceof this.constructor ? t : e(t.currentTarget)
          .data(`bs.${this.type}`);
        return i || (i = new this.constructor(t.currentTarget, this.getDelegateOptions()), e(t
          .currentTarget)
          .data(`bs.${this.type}`, i)), t instanceof e.Event && (i.inState["focusin" == t.type ?
          "focus" : "hover"] = !0), i.tip()
          .hasClass("in") || "in" == i.hoverState ? void(i.hoverState = "in") : (clearTimeout(i
          .timeout), i.hoverState = "in", i.options.delay && i.options.delay.show ? void(i.timeout =
          setTimeout(() => {
              "in" == i.hoverState && i.show()
          }, i.options.delay.show)) : i.show());
    }, i.prototype.isInStateTrue = function () {
        for (const e in this.inState)
            if (this.inState[e]) return !0;
        return !1
    }, i.prototype.leave = function (t) {
        let i = t instanceof this.constructor ? t : e(t.currentTarget)
          .data(`bs.${this.type}`);
        return i || (i = new this.constructor(t.currentTarget, this.getDelegateOptions()), e(t
          .currentTarget)
          .data(`bs.${this.type}`, i)), t instanceof e.Event && (i.inState["focusout" == t.type ?
          "focus" : "hover"] = !1), i.isInStateTrue() ? void 0 : (clearTimeout(i.timeout), i
          .hoverState = "out", i.options.delay && i.options.delay.hide ? void(i.timeout =
          setTimeout(() => {
              "out" == i.hoverState && i.hide()
          }, i.options.delay.hide)) : i.hide());
    }, i.prototype.show = function () {
        const t = e.Event(`show.bs.${this.type}`);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(t);
            const n = e.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (t.isDefaultPrevented() || !n) return;
            const o = this;
            const s = this.tip();
            const a = this.getUID(this.type);
            this.setContent(), s.attr("id", a), this.$element.attr("aria-describedby", a), this.options
              .animation && s.addClass("fade");

            let r = "function" == typeof this.options.placement ? this.options.placement.call(this, s[0],
              this.$element[0]) : this.options.placement;

            const l = /\s?auto?\s?/i;
            const c = l.test(r);
            c && (r = r.replace(l, "") || "top"), s.detach()
              .css({
                  top: 0,
                  left: 0,
                  display: "block"
              })
              .addClass(r)
              .data(`bs.${this.type}`, this), this.options.container ? s.appendTo(this.options
              .container) : s.insertAfter(this.$element), this.$element.trigger(`inserted.bs.${this.type}`);
            const u = this.getPosition();
            const d = s[0].offsetWidth;
            const h = s[0].offsetHeight;
            if (c) {
                const p = r;
                const m = this.getPosition(this.$viewport);
                r = "bottom" == r && u.bottom + h > m.bottom ? "top" : "top" == r && u.top - h < m.top ?
                  "bottom" : "right" == r && u.right + d > m.width ? "left" : "left" == r && u.left -
                  d < m.left ? "right" : r, s.removeClass(p)
                  .addClass(r)
            }
            const f = this.getCalculatedOffset(r, u, d, h);
            this.applyPlacement(f, r);
            const _ = () => {
                const e = o.hoverState;
                o.$element.trigger(`shown.bs.${o.type}`), o.hoverState = null, "out" == e && o.leave(
                  o)
            };
            e.support.transition && this.$tip.hasClass("fade") ? s.one("bsTransitionEnd", _)
              .emulateTransitionEnd(i.TRANSITION_DURATION) : _()
        }
    }, i.prototype.applyPlacement = function (t, i) {
        const n = this.tip();
        const o = n[0].offsetWidth;
        const s = n[0].offsetHeight;
        let a = parseInt(n.css("margin-top"), 10);
        let r = parseInt(n.css("margin-left"), 10);
        isNaN(a) && (a = 0), isNaN(r) && (r = 0), t.top += a, t.left += r, e.offset.setOffset(n[0], e
          .extend({
              using(e) {
                  n.css({
                      top: Math.round(e.top),
                      left: Math.round(e.left)
                  })
              }
          }, t), 0), n.addClass("in");
        const l = n[0].offsetWidth;
        const c = n[0].offsetHeight;
        "top" == i && c != s && (t.top = t.top + s - c);
        const u = this.getViewportAdjustedDelta(i, t, l, c);
        u.left ? t.left += u.left : t.top += u.top;
        const d = /top|bottom/.test(i);
        const h = d ? 2 * u.left - o + l : 2 * u.top - s + c;
        const p = d ? "offsetWidth" : "offsetHeight";
        n.offset(t), this.replaceArrow(h, n[0][p], d)
    }, i.prototype.replaceArrow = function (e, t, i) {
        this.arrow()
          .css(i ? "left" : "top", `${50 * (1 - e / t)}%`)
          .css(i ? "top" : "left", "")
    }, i.prototype.setContent = function () {
        const e = this.tip();
        const t = this.getTitle();
        e.find(".tooltip-inner")[this.options.html ? "html" : "text"](t), e.removeClass(
          "fade in top bottom left right")
    }, i.prototype.hide = function (t) {
        function n() {
            "in" != o.hoverState && s.detach(), o.$element.removeAttr("aria-describedby")
              .trigger(`hidden.bs.${o.type}`), t && t()
        }
        var o = this;
        var s = e(this.$tip);
        const a = e.Event(`hide.bs.${this.type}`);
        return this.$element.trigger(a), a.isDefaultPrevented() ? void 0 : (s.removeClass("in"), e.support
          .transition && s.hasClass("fade") ? s.one("bsTransitionEnd", n)
          .emulateTransitionEnd(i.TRANSITION_DURATION) : n(), this.hoverState = null, this)
    }, i.prototype.fixTitle = function () {
        const e = this.$element;
        (e.attr("title") || "string" != typeof e.attr("data-original-title")) && e.attr(
          "data-original-title", e.attr("title") || "")
          .attr("title", "")
    }, i.prototype.hasContent = function () {
        return this.getTitle()
    }, i.prototype.getPosition = function(t = this.$element) {
        const i = t[0];
        const n = "BODY" == i.tagName;
        let o = i.getBoundingClientRect();
        null == o.width && (o = e.extend({}, o, {
            width: o.right - o.left,
            height: o.bottom - o.top
        }));

        const s = n ? {
              top: 0,
              left: 0
          } : t.offset();

        const a = {
            scroll: n ? document.documentElement.scrollTop || document.body.scrollTop : t.scrollTop()
        };

        const r = n ? {
            width: e(window)
              .width(),
            height: e(window)
              .height()
        } : null;

        return e.extend({}, o, a, r, s)
    }, i.prototype.getCalculatedOffset = (e, t, i, n) => "bottom" == e ? {
        top: t.top + t.height,
        left: t.left + t.width / 2 - i / 2
    } : "top" == e ? {
        top: t.top - n,
        left: t.left + t.width / 2 - i / 2
    } : "left" == e ? {
        top: t.top + t.height / 2 - n / 2,
        left: t.left - i
    } : {
        top: t.top + t.height / 2 - n / 2,
        left: t.left + t.width
    }, i.prototype.getViewportAdjustedDelta = function (e, t, i, n) {
        const o = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return o;
        const s = this.options.viewport && this.options.viewport.padding || 0;
        const a = this.getPosition(this.$viewport);
        if (/right|left/.test(e)) {
            const r = t.top - s - a.scroll;
            const l = t.top + s - a.scroll + n;
            r < a.top ? o.top = a.top - r : l > a.top + a.height && (o.top = a.top + a.height - l)
        } else {
            const c = t.left - s;
            const u = t.left + s + i;
            c < a.left ? o.left = a.left - c : u > a.right && (o.left = a.left + a.width - u)
        }
        return o
    }, i.prototype.getTitle = function () {
        let e;
        const t = this.$element;
        const i = this.options;
        return e = t.attr("data-original-title") || ("function" == typeof i.title ? i.title.call(t[0]) : i
          .title)
    }, i.prototype.getUID = e => {
        do e += ~~(1e6 * Math.random()); while (document.getElementById(e));
        return e
    }, i.prototype.tip = function () {
        if (!this.$tip && (this.$tip = e(this.options.template), 1 != this.$tip.length)) throw new Error(
          `${this.type} \`template\` option must consist of exactly 1 top-level element!`);
        return this.$tip
    }, i.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip()
          .find(".tooltip-arrow")
    }, i.prototype.enable = function () {
        this.enabled = !0
    }, i.prototype.disable = function () {
        this.enabled = !1
    }, i.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }, i.prototype.toggle = function (t) {
        let i = this;
        t && (i = e(t.currentTarget)
          .data(`bs.${this.type}`), i || (i = new this.constructor(t.currentTarget, this
          .getDelegateOptions()), e(t.currentTarget)
          .data(`bs.${this.type}`, i))), t ? (i.inState.click = !i.inState.click, i
          .isInStateTrue() ? i.enter(i) : i.leave(i)) : i.tip()
          .hasClass("in") ? i.leave(i) : i.enter(i)
    }, i.prototype.destroy = function () {
        const e = this;
        clearTimeout(this.timeout), this.hide(() => {
            e.$element.off(`.${e.type}`)
              .removeData(`bs.${e.type}`), e.$tip && e.$tip.detach(), e.$tip = null, e.$arrow =
              null, e.$viewport = null
        })
    };
    const n = e.fn.tooltip;
    e.fn.tooltip = t, e.fn.tooltip.Constructor = i, e.fn.tooltip.noConflict = function () {
        return e.fn.tooltip = n, this
    }
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.popover");
            const s = "object" == typeof t && t;
            (o || !/destroy|hide/.test(t)) && (o || n.data("bs.popover", o = new i(this, s)),
            "string" == typeof t && o[t]())
        });
    }
    var i = function (e, t) {
        this.init("popover", e, t)
    };
    if (!e.fn.tooltip) throw new Error("Popover requires tooltip.js");
    i.VERSION = "3.3.6", i.DEFAULTS = e.extend({}, e.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), i.prototype = e.extend({}, e.fn.tooltip.Constructor.prototype), i.prototype.constructor = i, i
      .prototype.getDefaults = () => i.DEFAULTS, i.prototype.setContent = function () {
        const e = this.tip();
        const t = this.getTitle();
        const i = this.getContent();
        e.find(".popover-title")[this.options.html ? "html" : "text"](t), e.find(".popover-content")
          .children()
          .detach()
          .end()[this.options.html ? "string" == typeof i ? "html" : "append" : "text"](i), e
          .removeClass("fade top bottom left right in"), e.find(".popover-title")
          .html() || e.find(".popover-title")
          .hide()
    }, i.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }, i.prototype.getContent = function () {
        const e = this.$element;
        const t = this.options;
        return e.attr("data-content") || ("function" == typeof t.content ? t.content.call(e[0]) : t
          .content)
    }, i.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip()
          .find(".arrow")
    };
    const n = e.fn.popover;
    e.fn.popover = t, e.fn.popover.Constructor = i, e.fn.popover.noConflict = function () {
        return e.fn.popover = n, this
    }
})(jQuery), +(e => {
    function t(i, n) {
        this.$body = e(document.body), this.$scrollElement = e(e(i)
          .is(document.body) ? window : i), this.options = e.extend({}, t.DEFAULTS, n), this.selector =
          `${this.options.target || ""} .nav li > a`, this.offsets = [], this.targets = [], this
          .activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", e
          .proxy(this.process, this)), this.refresh(), this.process()
    }

    function i(i) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.scrollspy");
            const s = "object" == typeof i && i;
            o || n.data("bs.scrollspy", o = new t(this, s)), "string" == typeof i && o[i]()
        });
    }
    t.VERSION = "3.3.6", t.DEFAULTS = {
        offset: 10
    }, t.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document
          .documentElement.scrollHeight)
    }, t.prototype.refresh = function () {
        const t = this;
        let i = "offset";
        let n = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), e.isWindow(this
          .$scrollElement[0]) || (i = "position", n = this.$scrollElement.scrollTop()), this.$body
          .find(this.selector)
          .map(function () {
            const t = e(this);
            const o = t.data("target") || t.attr("href");
            const s = /^#./.test(o) && e(o);
            return s && s.length && s.is(":visible") && [[s[i]()
              .top + n, o]] || null
        })
          .sort((e, t) => e[0] - t[0])
          .each(function () {
              t.offsets.push(this[0]), t.targets.push(this[1])
          })
    }, t.prototype.process = function () {
        let e;
        const t = this.$scrollElement.scrollTop() + this.options.offset;
        const i = this.getScrollHeight();
        const n = this.options.offset + i - this.$scrollElement.height();
        const o = this.offsets;
        const s = this.targets;
        const a = this.activeTarget;
        if (this.scrollHeight != i && this.refresh(), t >= n) return a != (e = s[s.length - 1]) && this
          .activate(e);
        if (a && t < o[0]) return this.activeTarget = null, this.clear();
        for (e = o.length; e--;) a != s[e] && t >= o[e] && (void 0 === o[e + 1] || t < o[e + 1]) && this
          .activate(s[e])
    }, t.prototype.activate = function (t) {
        this.activeTarget = t, this.clear();
        const i = `${this.selector}[data-target="${t}"],${this.selector}[href="${t}"]`;

        let n = e(i)
          .parents("li")
          .addClass("active");

        n.parent(".dropdown-menu")
          .length && (n = n.closest("li.dropdown")
          .addClass("active")), n.trigger("activate.bs.scrollspy")
    }, t.prototype.clear = function () {
        e(this.selector)
          .parentsUntil(this.options.target, ".active")
          .removeClass("active")
    };
    const n = e.fn.scrollspy;
    e.fn.scrollspy = i, e.fn.scrollspy.Constructor = t, e.fn.scrollspy.noConflict = function () {
        return e.fn.scrollspy = n, this
    }, e(window)
      .on("load.bs.scrollspy.data-api", () => {
          e('[data-spy="scroll"]')
            .each(function () {
                const t = e(this);
                i.call(t, t.data())
            })
      })
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.tab");
            o || n.data("bs.tab", o = new i(this)), "string" == typeof t && o[t]()
        });
    }
    var i = function (t) {
        this.element = e(t)
    };
    i.VERSION = "3.3.6", i.TRANSITION_DURATION = 150, i.prototype.show = function () {
        const t = this.element;
        const i = t.closest("ul:not(.dropdown-menu)");
        let n = t.data("target");
        if (n || (n = t.attr("href"), n = n && n.replace(/.*(?=#[^\s]*$)/, "")), !t.parent("li")
          .hasClass("active")) {
            const o = i.find(".active:last a");

            const s = e.Event("hide.bs.tab", {
                relatedTarget: t[0]
            });

            const a = e.Event("show.bs.tab", {
                relatedTarget: o[0]
            });

            if (o.trigger(s), t.trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
                const r = e(n);
                this.activate(t.closest("li"), i), this.activate(r, r.parent(), () => {
                    o.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: t[0]
                    }), t.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: o[0]
                    })
                })
            }
        }
    }, i.prototype.activate = (t, n, o) => {
        function s() {
            a.removeClass("active")
              .find("> .dropdown-menu > .active")
              .removeClass("active")
              .end()
              .find('[data-toggle="tab"]')
              .attr("aria-expanded", !1), t.addClass("active")
              .find('[data-toggle="tab"]')
              .attr("aria-expanded", !0), r ? (t[0].offsetWidth, t.addClass("in")) : t.removeClass(
              "fade"), t.parent(".dropdown-menu")
              .length && t.closest("li.dropdown")
              .addClass("active")
              .end()
              .find('[data-toggle="tab"]')
              .attr("aria-expanded", !0), o && o()
        }
        var a = n.find("> .active");

        var r = o && e.support.transition && (a.length && a.hasClass("fade") || !!n.find("> .fade")
          .length);

        a.length && r ? a.one("bsTransitionEnd", s)
          .emulateTransitionEnd(i.TRANSITION_DURATION) : s(), a.removeClass("in")
    };
    const n = e.fn.tab;
    e.fn.tab = t, e.fn.tab.Constructor = i, e.fn.tab.noConflict = function () {
        return e.fn.tab = n, this
    };
    const o = function (i) {
        i.preventDefault(), t.call(e(this), "show")
    };
    e(document)
      .on("click.bs.tab.data-api", '[data-toggle="tab"]', o)
      .on("click.bs.tab.data-api", '[data-toggle="pill"]', o)
})(jQuery), +(e => {
    function t(t) {
        return this.each(function () {
            const n = e(this);
            let o = n.data("bs.affix");
            const s = "object" == typeof t && t;
            o || n.data("bs.affix", o = new i(this, s)), "string" == typeof t && o[t]()
        });
    }
    var i = function (t, n) {
        this.options = e.extend({}, i.DEFAULTS, n), this.$target = e(this.options.target)
          .on("scroll.bs.affix.data-api", e.proxy(this.checkPosition, this))
          .on("click.bs.affix.data-api", e.proxy(this.checkPositionWithEventLoop, this)), this
          .$element = e(t), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this
          .checkPosition()
    };
    i.VERSION = "3.3.6", i.RESET = "affix affix-top affix-bottom", i.DEFAULTS = {
        offset: 0,
        target: window
    }, i.prototype.getState = function (e, t, i, n) {
        const o = this.$target.scrollTop();
        const s = this.$element.offset();
        const a = this.$target.height();
        if (null != i && "top" == this.affixed) return i > o ? "top" : !1;
        if ("bottom" == this.affixed) return null != i ? o + this.unpin <= s.top ? !1 : "bottom" : e -
        n >= o + a ? !1 : "bottom";
        const r = null == this.affixed;
        const l = r ? o : s.top;
        const c = r ? a : t;
        return null != i && i >= o ? "top" : null != n && l + c >= e - n ? "bottom" : !1
    }, i.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(i.RESET)
          .addClass("affix");
        const e = this.$target.scrollTop();
        const t = this.$element.offset();
        return this.pinnedOffset = t.top - e
    }, i.prototype.checkPositionWithEventLoop = function () {
        setTimeout(e.proxy(this.checkPosition, this), 1)
    }, i.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
            const t = this.$element.height();
            const n = this.options.offset;
            let o = n.top;
            let s = n.bottom;

            const a = Math.max(e(document)
              .height(), e(document.body)
              .height());

            "object" != typeof n && (s = o = n), "function" == typeof o && (o = n.top(this.$element)),
            "function" == typeof s && (s = n.bottom(this.$element));
            const r = this.getState(a, t, o, s);
            if (this.affixed != r) {
                null != this.unpin && this.$element.css("top", "");
                const l = `affix${r ? `-${r}` : ""}`;
                const c = e.Event(`${l}.bs.affix`);
                if (this.$element.trigger(c), c.isDefaultPrevented()) return;
                this.affixed = r, this.unpin = "bottom" == r ? this.getPinnedOffset() : null, this
                  .$element.removeClass(i.RESET)
                  .addClass(l)
                  .trigger(`${l.replace("affix", "affixed")}.bs.affix`)
            }
            "bottom" == r && this.$element.offset({
                top: a - t - s
            })
        }
    };
    const n = e.fn.affix;
    e.fn.affix = t, e.fn.affix.Constructor = i, e.fn.affix.noConflict = function () {
        return e.fn.affix = n, this
    }, e(window)
      .on("load", () => {
          e('[data-spy="affix"]')
            .each(function () {
              const i = e(this);
              const n = i.data();
              n.offset = n.offset || {}, null != n.offsetBottom && (n.offset.bottom = n
                .offsetBottom), null != n.offsetTop && (n.offset.top = n.offsetTop), t
                .call(i, n)
          })
      })
})(jQuery), (e => {
    "function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof exports ? e(
      require("jquery")) : e(jQuery)
})(e => {
    function t(t, n, o) {
        var n = {
            content: {
                message: "object" == typeof n ? n.message : n,
                title: n.title ? n.title : "",
                icon: n.icon ? n.icon : "",
                url: n.url ? n.url : "#",
                target: n.target ? n.target : "-"
            }
        };
        o = e.extend(!0, {}, n, o), this.settings = e.extend(!0, {}, i, o), this._defaults = i, "-" ==
        this.settings.content.target && (this.settings.content.target = this.settings.url_target),
          this.animations = {
              start: "webkitAnimationStart oanimationstart MSAnimationStart animationstart",
              end: "webkitAnimationEnd oanimationend MSAnimationEnd animationend"
          }, "number" == typeof this.settings.offset && (this.settings.offset = {
            x: this.settings.offset,
            y: this.settings.offset
        }), this.init()
    }
    var i = {
        element: "body",
        position: null,
        type: "info",
        allow_dismiss: !0,
        newest_on_top: !1,
        showProgressbar: !1,
        placement: {
            from: "top",
            align: "right"
        },
        offset: 20,
        spacing: 10,
        z_index: 1031,
        delay: 5e3,
        timer: 1e3,
        url_target: "_blank",
        mouse_over: null,
        animate: {
            enter: "animated fadeInDown",
            exit: "animated fadeOutUp"
        },
        onShow: null,
        onShown: null,
        onClose: null,
        onClosed: null,
        icon_type: "class",
        template: '<div data-notify="container" class="col-xs-11 col-sm-4 alert alert-{0}" role="alert"><button type="button" aria-hidden="true" class="close" data-notify="dismiss">&times;</button><span data-notify="icon"></span> <span data-notify="title">{1}</span> <span data-notify="message">{2}</span><div class="progress" data-notify="progressbar"><div class="progress-bar progress-bar-{0}" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div></div><a href="{3}" target="{4}" data-notify="url"></a></div>'
    };
    String.format = function(...args) {
        for (var e = args[0], t = 1; t < args.length; t++) e = e.replace(RegExp(`\\{${t -
  1}\\}`, "gm"), args[t]);
        return e
    }, e.extend(t.prototype, {
        init() {
            const e = this;
            this.buildNotify(), this.settings.content.icon && this.setIcon(), "#" != this
              .settings.content.url && this.styleURL(), this.placement(), this.bind(), this
              .notify = {
                $ele: this.$ele,
                update(t, i) {
                    let n = {};
                    "string" == typeof t ? n[t] = i : n = t;
                    for (var t in n) switch (t) {
                        case "type":
                            this.$ele.removeClass(`alert-${e.settings.type}`), this
                              .$ele.find(
                                '[data-notify="progressbar"] > .progress-bar')
                              .removeClass(`progress-bar-${e.settings.type}`), e
                              .settings.type = n[t], this.$ele.addClass(`alert-${n[t]}`)
                              .find('[data-notify="progressbar"] > .progress-bar')
                              .addClass(`progress-bar-${n[t]}`);
                            break;
                        case "icon":
                            const o = this.$ele.find('[data-notify="icon"]');
                            "class" == e.settings.icon_type.toLowerCase() ? o
                              .removeClass(e.settings.content.icon)
                              .addClass(n[t]) : (o.is("img") || o.find("img"), o
                              .attr("src", n[t]));
                            break;
                        case "progress":
                            const s = e.settings.delay - e.settings.delay * (n[t] /
                              100);
                            this.$ele.data("notify-delay", s), this.$ele.find(
                              '[data-notify="progressbar"] > div')
                              .attr("aria-valuenow", n[t])
                              .css("width", `${n[t]}%`);
                            break;
                        case "url":
                            this.$ele.find('[data-notify="url"]')
                              .attr("href", n[t]);
                            break;
                        case "target":
                            this.$ele.find('[data-notify="url"]')
                              .attr("target", n[t]);
                            break;
                        default:
                            this.$ele.find(`[data-notify="${t}"]`)
                              .html(n[t])
                    }
                    const a = this.$ele.outerHeight() + parseInt(e.settings.spacing) +
                      parseInt(e.settings.offset.y);
                    e.reposition(a)
                },
                close() {
                    e.close()
                }
            }
        },
        buildNotify() {
            const t = this.settings.content;
            this.$ele = e(String.format(this.settings.template, this.settings.type, t.title, t
              .message, t.url, t.target)), this.$ele.attr("data-notify-position", `${this
  .settings.placement.from}-${this.settings.placement.align}`), this
              .settings.allow_dismiss || this.$ele.find('[data-notify="dismiss"]')
              .css("display", "none"), (this.settings.delay <= 0 && !this.settings
              .showProgressbar || !this.settings.showProgressbar) && this.$ele.find(
              '[data-notify="progressbar"]')
              .remove()
        },
        setIcon() {
            "class" == this.settings.icon_type.toLowerCase() ? this.$ele.find(
              '[data-notify="icon"]')
              .addClass(this.settings.content.icon) : this.$ele.find('[data-notify="icon"]')
              .is("img") ? this.$ele.find('[data-notify="icon"]')
              .attr("src", this.settings.content.icon) : this.$ele.find(
              '[data-notify="icon"]')
              .append(`<img src="${this.settings.content.icon}" alt="Notify Icon" />`)
        },
        styleURL() {
            this.$ele.find('[data-notify="url"]')
              .css({
                  backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)",
                  height: "100%",
                  left: "0px",
                  position: "absolute",
                  top: "0px",
                  width: "100%",
                  zIndex: this.settings.z_index + 1
              }), this.$ele.find('[data-notify="dismiss"]')
              .css({
                  position: "absolute",
                  right: "10px",
                  top: "5px",
                  zIndex: this.settings.z_index + 2
              })
        },
        placement() {
            const t = this;
            let i = this.settings.offset.y;

            const n = {
                display: "inline-block",
                margin: "0px auto",
                position: this.settings.position ? this.settings.position : "body" ===
                this.settings.element ? "fixed" : "absolute",
                transition: "all .5s ease-in-out",
                zIndex: this.settings.z_index
            };

            let o = !1;
            const s = this.settings;
            switch (e(`[data-notify-position="${this.settings.placement.from}-${this
  .settings.placement.align}"]:not([data-closing="true"])`)
              .each(function () {
                  return i = Math.max(i, parseInt(e(this)
                    .css(s.placement.from)) + parseInt(e(this)
                    .outerHeight()) + parseInt(s.spacing))
              }), 1 == this.settings.newest_on_top && (i = this.settings.offset.y), n[this
              .settings.placement.from] = `${i}px`, this.settings.placement.align) {
                case "left":
                case "right":
                    n[this.settings.placement.align] = `${this.settings.offset.x}px`;
                    break;
                case "center":
                    n.left = 0, n.right = 0
            }
            this.$ele.css(n)
              .addClass(this.settings.animate.enter), e.each(Array("webkit", "moz", "o",
              "ms", ""), (e, i) => {
                t.$ele[0].style[`${i}AnimationIterationCount`] = 1
            }), e(this.settings.element)
              .append(this.$ele), 1 == this.settings.newest_on_top && (i = parseInt(i) +
              parseInt(this.settings.spacing) + this.$ele.outerHeight(), this
              .reposition(i)), e.isFunction(t.settings.onShow) && t.settings.onShow
              .call(this.$ele), this.$ele.one(this.animations.start, () => {
                o = !0
            })
              .one(this.animations.end, function () {
                  e.isFunction(t.settings.onShown) && t.settings.onShown.call(this)
              }), setTimeout(function () {
                o || e.isFunction(t.settings.onShown) && t.settings.onShown.call(this)
            }, 600)
        },
        bind() {
            const t = this;
            if (this.$ele.find('[data-notify="dismiss"]')
              .on("click", () => {
                  t.close()
              }), this.$ele.mouseover(function () {
                e(this)
                  .data("data-hover", "true")
            })
              .mouseout(function () {
                  e(this)
                    .data("data-hover", "false")
              }), this.$ele.data("data-hover", "false"), this.settings.delay > 0) {
                t.$ele.data("notify-delay", t.settings.delay);
                const i = setInterval(() => {
                    const e = parseInt(t.$ele.data("notify-delay")) - t.settings.timer;
                    if ("false" === t.$ele.data("data-hover") && "pause" == t.settings
                      .mouse_over || "pause" != t.settings.mouse_over) {
                        const n = 100 * ((t.settings.delay - e) / t.settings.delay);
                        t.$ele.data("notify-delay", e), t.$ele.find(
                          '[data-notify="progressbar"] > div')
                          .attr("aria-valuenow", n)
                          .css("width", `${n}%`)
                    }
                    e <= -t.settings.timer && (clearInterval(i), t.close())
                }, t.settings.timer);
            }
        },
        close() {
            const t = this;
            const i = parseInt(this.$ele.css(this.settings.placement.from));
            let n = !1;
            this.$ele.data("closing", "true")
              .addClass(this.settings.animate.exit), t.reposition(i), e.isFunction(t
              .settings.onClose) && t.settings.onClose.call(this.$ele), this.$ele.one(
              this.animations.start,
              () => {
                  n = !0
              })
              .one(this.animations.end, function () {
                  e(this)
                    .remove(), e.isFunction(t.settings.onClosed) && t.settings
                    .onClosed.call(this)
              }), setTimeout(() => {
                n || (t.$ele.remove(), t.settings.onClosed && t.settings.onClosed(t
                  .$ele))
            }, 600)
        },
        reposition(t) {
            const i = this;

            const n = `[data-notify-position="${this.settings.placement.from}-${this
  .settings.placement.align}"]:not([data-closing="true"])`;

            let o = this.$ele.nextAll(n);
            1 == this.settings.newest_on_top && (o = this.$ele.prevAll(n)), o.each(
              function () {
                  e(this)
                    .css(i.settings.placement.from, t), t = parseInt(t) + parseInt(i
                    .settings.spacing) + e(this)
                    .outerHeight()
              })
        }
    }), e.notify = function (e, i) {
        const n = new t(this, e, i);
        return n.notify
    }, e.notifyDefaults = t => i = e.extend(!0, {}, i, t), e.notifyClose = t => {
        "undefined" == typeof t || "all" == t ? e("[data-notify]")
          .find('[data-notify="dismiss"]')
          .trigger("click") : e(`[data-notify-position="${t}"]`)
          .find('[data-notify="dismiss"]')
          .trigger("click")
    }
}), /*!
* Bootstrap-select v1.12.4 (http://silviomoreto.github.io/bootstrap-select)
*
* Copyright 2013-2017 bootstrap-select
* Licensed under MIT (https://github.com/silviomoreto/bootstrap-select/blob/master/LICENSE)
*/
!((e, t) => {
    "function" == typeof define && define.amd ? define(["jquery"], e => t(e)) : "object" == typeof module && module.exports ? module.exports = t(require("jquery")) : t(e.jQuery)
})(this, e => {
    !(e => {
        function t(t) {
            const i = [{
                re: /[\xC0-\xC6]/g,
                ch: "A"
            }, {
                re: /[\xE0-\xE6]/g,
                ch: "a"
            }, {
                re: /[\xC8-\xCB]/g,
                ch: "E"
            }, {
                re: /[\xE8-\xEB]/g,
                ch: "e"
            }, {
                re: /[\xCC-\xCF]/g,
                ch: "I"
            }, {
                re: /[\xEC-\xEF]/g,
                ch: "i"
            }, {
                re: /[\xD2-\xD6]/g,
                ch: "O"
            }, {
                re: /[\xF2-\xF6]/g,
                ch: "o"
            }, {
                re: /[\xD9-\xDC]/g,
                ch: "U"
            }, {
                re: /[\xF9-\xFC]/g,
                ch: "u"
            }, {
                re: /[\xC7-\xE7]/g,
                ch: "c"
            }, {
                re: /[\xD1]/g,
                ch: "N"
            }, {
                re: /[\xF1]/g,
                ch: "n"
            }];
            return e.each(i, function () {
                t = t ? t.replace(this.re, this.ch) : ""
            }), t
        }

        function i(t) {
            const i = arguments;
            const n = t;
            [].shift.apply(i);
            let o;

            const s = this.each(function () {
                const t = e(this);
                if (t.is("select")) {
                    let s = t.data("selectpicker");
                    const a = "object" == typeof n && n;
                    if (s) {
                        if (a)
                            for (const r in a) a.hasOwnProperty(r) && (s.options[r] = a[r])
                    } else {
                        const l = e.extend({}, d.DEFAULTS, e.fn.selectpicker.defaults || {}, t
                          .data(), a);
                        l.template = e.extend({}, d.DEFAULTS.template, e.fn.selectpicker
                          .defaults ? e.fn.selectpicker.defaults.template : {}, t.data()
                          .template, a.template), t.data("selectpicker", s = new d(this, l))
                    }
                    "string" == typeof n && (o = s[n] instanceof Function ? s[n](...i) : s
                      .options[n])
                }
            });

            return "undefined" != typeof o ? o : s
        }
        String.prototype.includes || !(() => {
            const e = {}.toString;

            const t = (() => {
                try {
                    var e = {};
                    const t = Object.defineProperty;
                    var i = t(e, e, e) && t;
                } catch (e) {}
                return i
            })();

            const i = "".indexOf;

            const n = function (t) {
                if (null == this) throw new TypeError;
                const n = String(this);
                if (t && "[object RegExp]" == e.call(t)) throw new TypeError;
                const o = n.length;
                const s = String(t);
                const a = s.length;
                const r = arguments.length > 1 ? arguments[1] : void 0;
                let l = r ? Number(r) : 0;
                l != l && (l = 0);
                const c = Math.min(Math.max(l, 0), o);
                return !(a + c > o) && -1 != i.call(n, s, l)
            };

            t ? t(String.prototype, "includes", {
                value: n,
                configurable: !0,
                writable: !0
            }) : String.prototype.includes = n
        })(), String.prototype.startsWith || !(() => {
            const e = (() => {
                  try {
                      var e = {};
                      const t = Object.defineProperty;
                      var i = t(e, e, e) && t;
                  } catch (e) {}
                  return i
              })();

            const t = {}.toString;

            const i = function (e) {
                if (null == this) throw new TypeError;
                const i = String(this);
                if (e && "[object RegExp]" == t.call(e)) throw new TypeError;
                const n = i.length;
                const o = String(e);
                const s = o.length;
                const a = arguments.length > 1 ? arguments[1] : void 0;
                let r = a ? Number(a) : 0;
                r != r && (r = 0);
                const l = Math.min(Math.max(r, 0), n);
                if (s + l > n) return !1;
                for (let c = -1; ++c < s;)
                    if (i.charCodeAt(l + c) != o.charCodeAt(c)) return !1;
                return !0
            };

            e ? e(String.prototype, "startsWith", {
                value: i,
                configurable: !0,
                writable: !0
            }) : String.prototype.startsWith = i
        })(), Object.keys || (Object.keys = (e, t, i) => {
            i = [];
            for (t in e) i.hasOwnProperty.call(e, t) && i.push(t);
            return i
        });
        const n = {
            useDefault: !1,
            _set: e.valHooks.select.set
        };
        e.valHooks.select.set = function (t, i) {
            return i && !n.useDefault && e(t)
              .data("selected", !0), n._set.apply(this, arguments)
        };
        let o = null;

        const s = (() => {
            try {
                return new Event("change"), !0
            } catch (e) {
                return !1
            }
        })();

        e.fn.triggerNative = function (e) {
            let t;
            const i = this[0];
            i.dispatchEvent ? (s ? t = new Event(e, {
                bubbles: !0
            }) : (t = document.createEvent("Event"), t.initEvent(e, !0, !1)), i.dispatchEvent(
              t)) : i.fireEvent ? (t = document.createEventObject(), t.eventType = e, i
              .fireEvent(`on${e}`, t)) : this.trigger(e)
        }, e.expr.pseudos.icontains = (t, i, n) => {
            const o = e(t)
                .find("a");

            const s = (o.data("tokens") || o.text())
              .toString()
              .toUpperCase();

            return s.includes(n[3].toUpperCase())
        }, e.expr.pseudos.ibegins = (t, i, n) => {
            const o = e(t)
                .find("a");

            const s = (o.data("tokens") || o.text())
              .toString()
              .toUpperCase();

            return s.startsWith(n[3].toUpperCase())
        }, e.expr.pseudos.aicontains = (t, i, n) => {
            const o = e(t)
                .find("a");

            const s = (o.data("tokens") || o.data("normalizedText") || o.text())
              .toString()
              .toUpperCase();

            return s.includes(n[3].toUpperCase())
        }, e.expr.pseudos.aibegins = (t, i, n) => {
            const o = e(t)
                .find("a");

            const s = (o.data("tokens") || o.data("normalizedText") || o.text())
              .toString()
              .toUpperCase();

            return s.startsWith(n[3].toUpperCase())
        };

        const a = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;"
          };

        const r = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#x27;": "'",
            "&#x60;": "`"
        };

        const l = e => {
            const t = t => e[t],
                  i = `(?:${Object.keys(e)
  .join("|")})`,
                  n = RegExp(i),
                  o = RegExp(i, "g");
            return e => (e = null == e ? "" : `${e}`, n.test(e) ? e.replace(o, t) : e);
        };

        const c = l(a);
        const u = l(r);

        var d = function (t, i) {
            n.useDefault || (e.valHooks.select.set = n._set, n.useDefault = !0), this.$element = e(t),
              this.$newElement = null, this.$button = null, this.$menu = null, this.$lis = null,
              this.options = i, null === this.options.title && (this.options.title = this.$element
              .attr("title"));
            const o = this.options.windowPadding;
            "number" == typeof o && (this.options.windowPadding = [o, o, o, o]), this.val = d
              .prototype.val, this.render = d.prototype.render, this.refresh = d.prototype.refresh,
              this.setStyle = d.prototype.setStyle, this.selectAll = d.prototype.selectAll, this
              .deselectAll = d.prototype.deselectAll, this.destroy = d.prototype.destroy, this
              .remove = d.prototype.remove, this.show = d.prototype.show, this.hide = d.prototype
              .hide, this.init()
        };

        d.VERSION = "1.12.4", d.DEFAULTS = {
            noneSelectedText: "Nothing selected",
            noneResultsText: "No results matched {0}",
            countSelectedText(e) {
                return 1 == e ? "{0} item selected" : "{0} items selected"
            },
            maxOptionsText(e, t) {
                return [1 == e ? "Limit reached ({n} item max)" : "Limit reached ({n} items max)",
                    1 == t ? "Group limit reached ({n} item max)" :
                      "Group limit reached ({n} items max)"]
            },
            selectAllText: "Select All",
            deselectAllText: "Deselect All",
            doneButton: !1,
            doneButtonText: "Close",
            multipleSeparator: ", ",
            styleBase: "btn",
            style: "btn-default",
            size: "auto",
            title: null,
            selectedTextFormat: "values",
            width: !1,
            container: !1,
            hideDisabled: !1,
            showSubtext: !1,
            showIcon: !0,
            showContent: !0,
            dropupAuto: !0,
            header: !1,
            liveSearch: !1,
            liveSearchPlaceholder: null,
            liveSearchNormalize: !1,
            liveSearchStyle: "contains",
            actionsBox: !1,
            iconBase: "glyphicon",
            tickIcon: "glyphicon-ok",
            showTick: !1,
            template: {
                caret: '<span class="caret"></span>'
            },
            maxOptions: !1,
            mobile: !1,
            selectOnTab: !1,
            dropdownAlignRight: !1,
            windowPadding: 0
        }, d.prototype = {
            constructor: d,
            init() {
                const t = this;
                const i = this.$element.attr("id");
                this.$element.addClass("bs-select-hidden"), this.liObj = {}, this.multiple = this
                  .$element.prop("multiple"), this.autofocus = this.$element.prop("autofocus"),
                  this.$newElement = this.createView(), this.$element.after(this.$newElement)
                  .appendTo(this.$newElement), this.$button = this.$newElement.children(
                  "button"), this.$menu = this.$newElement.children(".dropdown-menu"), this
                  .$menuInner = this.$menu.children(".inner"), this.$searchbox = this.$menu
                  .find("input"), this.$element.removeClass("bs-select-hidden"), this.options
                  .dropdownAlignRight === !0 && this.$menu.addClass("dropdown-menu-right"),
                "undefined" != typeof i && (this.$button.attr("data-id", i), e(`label[for="${i}"]`)
                  .click(e => {
                      e.preventDefault(), t.$button.focus()
                  })), this.checkDisabled(), this.clickListener(), this.options
                  .liveSearch && this.liveSearchListener(), this.render(), this.setStyle(), this
                  .setWidth(), this.options.container && this.selectPosition(), this.$menu.data(
                  "this", this), this.$newElement.data("this", this), this.options.mobile &&
                this.mobile(), this.$newElement.on({
                    "hide.bs.dropdown": function (e) {
                        t.$menuInner.attr("aria-expanded", !1), t.$element.trigger(
                          "hide.bs.select", e)
                    },
                    "hidden.bs.dropdown": function (e) {
                        t.$element.trigger("hidden.bs.select", e)
                    },
                    "show.bs.dropdown": function (e) {
                        t.$menuInner.attr("aria-expanded", !0), t.$element.trigger(
                          "show.bs.select", e)
                    },
                    "shown.bs.dropdown": function (e) {
                        t.$element.trigger("shown.bs.select", e)
                    }
                }), t.$element[0].hasAttribute("required") && this.$element.on("invalid",
                  () => {
                      t.$button.addClass("bs-invalid"), t.$element.on({
                          "focus.bs.select": function () {
                              t.$button.focus(), t.$element.off(
                                "focus.bs.select")
                          },
                          "shown.bs.select": function () {
                              t.$element.val(t.$element.val())
                                .off("shown.bs.select")
                          },
                          "rendered.bs.select": function () {
                              this.validity.valid && t.$button.removeClass(
                                "bs-invalid"), t.$element.off(
                                "rendered.bs.select")
                          }
                      }), t.$button.on("blur.bs.select", () => {
                          t.$element.focus()
                            .blur(), t.$button.off("blur.bs.select")
                      })
                  }), setTimeout(() => {
                    t.$element.trigger("loaded.bs.select")
                })
            },
            createDropdown() {
                const t = this.multiple || this.options.showTick ? " show-tick" : "";

                const i = this.$element.parent()
                  .hasClass("input-group") ? " input-group-btn" : "";

                const n = this.autofocus ? " autofocus" : "";

                const o = this.options.header ?
                  `<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>${this.options.header}</div>` : "";

                const s = this.options.liveSearch ?
                  `<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"${null === this.options.liveSearchPlaceholder ? "" : ` placeholder="${c(this
  .options.liveSearchPlaceholder)}"`} role="textbox" aria-label="Search"></div>` : "";

                const a = this.multiple && this.options.actionsBox ?
                  `<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn btn-default">${this.options.selectAllText}</button><button type="button" class="actions-btn bs-deselect-all btn btn-default">${this.options.deselectAllText}</button></div></div>` : "";

                const r = this.multiple && this.options.doneButton ?
                  `<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm btn-default">${this.options.doneButtonText}</button></div></div>` : "";

                const l = `<div class="btn-group bootstrap-select${t}${i}"><button type="button" class="${this.options.styleBase} dropdown-toggle" data-toggle="dropdown"${n} role="button"><span class="filter-option pull-left"></span>&nbsp;<span class="bs-caret">${this.options.template.caret}</span></button><div class="dropdown-menu open" role="combobox">${o}${s}${a}<ul class="dropdown-menu inner" role="listbox" aria-expanded="false"></ul>${r}</div></div>`;
                return e(l)
            },
            createView() {
                const e = this.createDropdown();
                const t = this.createLi();
                return e.find("ul")[0].innerHTML = t, e
            },
            reloadLi() {
                const e = this.createLi();
                this.$menuInner[0].innerHTML = e
            },
            createLi() {
                const i = this;
                const n = [];
                let o = 0;
                const s = document.createElement("option");
                let a = -1;

                const r = (e, t, i, n) => `<li${"undefined" != typeof i && "" !== i ? ` class="${i}"` : ""}${"undefined" != typeof t && null !== t ?
  ` data-original-index="${t}"` : ""}${"undefined" !=
  typeof n && null !== n ? `data-optgroup="${n}"` : ""}>${e}</li>`;

                const l = (n, o, s, a) => `<a tabindex="0"${"undefined" != typeof o ? ` class="${o}"` : ""}${s ? ` style="${s}"` : ""}${i.options
    .liveSearchNormalize ? ` data-normalized-text="${t(c(e(n)
    .html()))}"` : ""}${"undefined" != typeof a || null !==
  a ? ` data-tokens="${a}"` : ""} role="option">${n}<span class="${i.options.iconBase} ${i.options.tickIcon} check-mark"></span></a>`;

                if (this.options.title && !this.multiple && (a--, !this.$element.find(
                  ".bs-title-option")
                  .length)) {
                    const u = this.$element[0];
                    s.className = "bs-title-option", s.innerHTML = this.options.title, s.value =
                      "", u.insertBefore(s, u.firstChild);
                    const d = e(u.options[u.selectedIndex]);
                    void 0 === d.attr("selected") && void 0 === this.$element.data("selected") &&
                    (s.selected = !0)
                }
                const h = this.$element.find("option");
                return h.each(function (t) {
                    const s = e(this);
                    if (a++, !s.hasClass("bs-title-option")) {
                        let u;
                        const d = this.className || "";
                        const p = c(this.style.cssText);
                        let m = s.data("content") ? s.data("content") : s.html();
                        const f = s.data("tokens") ? s.data("tokens") : null;

                        const _ = "undefined" != typeof s.data("subtext") ?
                          `<small class="text-muted">${s.data("subtext")}</small>` : "";

                        let g = "undefined" != typeof s.data("icon") ? `<span class="${i
  .options.iconBase} ${s.data("icon")}"></span> ` : "";

                        const v = s.parent();
                        const b = "OPTGROUP" === v[0].tagName;
                        const y = b && v[0].disabled;
                        const w = this.disabled || y;
                        if ("" !== g && w && (g = `<span>${g}</span>`), i.options
                          .hideDisabled && (w && !b || y)) return u = s.data(
                          "prevHiddenIndex"), s.next()
                          .data("prevHiddenIndex", void 0 !== u ? u : t), void a--;
                        if (s.data("content") || (m = `${g}<span class="text">${m}${_}</span>`), b && s.data("divider") !== !0) {
                            if (i.options.hideDisabled && w) {
                                if (void 0 === v.data("allOptionsDisabled")) {
                                    const k = v.children();
                                    v.data("allOptionsDisabled", k.filter(":disabled")
                                      .length === k.length)
                                }
                                if (v.data("allOptionsDisabled")) return void a--
                            }
                            const x = ` ${v[0].className}` || "";
                            if (0 === s.index()) {
                                o += 1;
                                let C = v[0].label;

                                const z = "undefined" != typeof v.data("subtext") ?
                                  `<small class="text-muted">${v.data("subtext")}</small>` : "";

                                const T = v.data("icon") ? `<span class="${i.options
  .iconBase} ${v.data("icon")}"></span> ` : "";

                                C = `${T}<span class="text">${c(C)}${z}</span>`,
                                0 !== t && n.length > 0 && (a++, n.push(r("", null,
                                  "divider", `${o}div`))), a++, n.push(r(C, null,
                                  `dropdown-header${x}`, o))
                            }
                            if (i.options.hideDisabled && w) return void a--;
                            n.push(r(l(m, `opt ${d}${x}`, p, f), t, "", o))
                        } else if (s.data("divider") === !0) n.push(r("", t, "divider"));
                        else if (s.data("hidden") === !0) u = s.data("prevHiddenIndex"), s
                          .next()
                          .data("prevHiddenIndex", void 0 !== u ? u : t), n.push(r(l(m,
                          d, p, f), t, "hidden is-hidden"));
                        else {
                            let S = this.previousElementSibling && "OPTGROUP" === this
                              .previousElementSibling.tagName;
                            if (!S && i.options.hideDisabled && (u = s.data(
                              "prevHiddenIndex"), void 0 !== u)) {
                                const A = h.eq(u)[0].previousElementSibling;
                                A && "OPTGROUP" === A.tagName && !A.disabled && (S = !0)
                            }
                            S && (a++, n.push(r("", null, "divider", `${o}div`))), n.push(
                              r(l(m, d, p, f), t))
                        }
                        i.liObj[t] = a
                    }
                }), this.multiple || 0 !== this.$element.find("option:selected")
                  .length || this.options.title || this.$element.find("option")
                  .eq(0)
                  .prop("selected", !0)
                  .attr("selected", "selected"), n.join("");
            },
            findLis() {
                return null == this.$lis && (this.$lis = this.$menu.find("li")), this.$lis
            },
            render(t) {
                let i;
                const n = this;
                const o = this.$element.find("option");
                t !== !1 && o.each(function (e) {
                    const t = n.findLis()
                      .eq(n.liObj[e]);
                    n.setDisabled(e, this.disabled || "OPTGROUP" === this.parentNode
                      .tagName && this.parentNode.disabled, t), n.setSelected(e,
                      this.selected, t)
                }), this.togglePlaceholder(), this.tabIndex();

                const s = o.map(function () {
                      if (this.selected) {
                          if (n.options.hideDisabled && (this.disabled || "OPTGROUP" ===
                            this.parentNode.tagName && this.parentNode.disabled))
                              return;
                          let t;
                          const i = e(this);

                          const o = i.data("icon") && n.options.showIcon ? `<i class="${n
  .options.iconBase} ${i.data("icon")}"></i> ` : "";

                          return t = n.options.showSubtext && i.data("subtext") && !n
                            .multiple ? ` <small class="text-muted">${i.data(
  "subtext")}</small>` : "", "undefined" != typeof i.attr(
                            "title") ? i.attr("title") : i.data("content") && n
                            .options.showContent ? i.data("content")
                            .toString() : o + i.html() + t;
                      }
                  })
                    .toArray();

                let a = this.multiple ? s.join(this.options.multipleSeparator) : s[0];
                if (this.multiple && this.options.selectedTextFormat.includes("count")) {
                    const r = this.options.selectedTextFormat.split(">");
                    if (r.length > 1 && s.length > r[1] || 1 == r.length && s.length >= 2) {
                        i = this.options.hideDisabled ? ", [disabled]" : "";

                        const l = o.not(`[data-divider="true"], [data-hidden="true"]${i}`)
                            .length;

                        const c = "function" == typeof this.options.countSelectedText ? this.options
                          .countSelectedText(s.length, l) : this.options.countSelectedText;

                        a = c.replace("{0}", s.length.toString())
                          .replace("{1}", l.toString())
                    }
                }
                void 0 == this.options.title && (this.options.title = this.$element.attr(
                  "title")), "static" == this.options.selectedTextFormat && (a = this.options
                  .title), a || (a = "undefined" != typeof this.options.title ? this.options
                  .title : this.options.noneSelectedText), this.$button.attr("title", u(e
                  .trim(a.replace(/<[^>]*>?/g, "")))), this.$button.children(
                  ".filter-option")
                  .html(a), this.$element.trigger("rendered.bs.select")
            },
            setStyle(e, t) {
                this.$element.attr("class") && this.$newElement.addClass(this.$element.attr(
                  "class")
                  .replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi,
                    ""));
                const i = e ? e : this.options.style;
                "add" == t ? this.$button.addClass(i) : "remove" == t ? this.$button.removeClass(
                  i) : (this.$button.removeClass(this.options.style), this.$button.addClass(
                  i))
            },
            liHeight(t) {
                if (t || this.options.size !== !1 && !this.sizeInfo) {
                    const i = document.createElement("div");
                    const n = document.createElement("div");
                    const o = document.createElement("ul");
                    const s = document.createElement("li");
                    const a = document.createElement("li");
                    const r = document.createElement("a");
                    const l = document.createElement("span");

                    const c = this.options.header && this.$menu.find(".popover-title")
                      .length > 0 ? this.$menu.find(".popover-title")[0].cloneNode(!0) : null;

                    const u = this.options.liveSearch ? document.createElement("div") : null;

                    const d = this.options.actionsBox && this.multiple && this.$menu.find(
                      ".bs-actionsbox")
                      .length > 0 ? this.$menu.find(".bs-actionsbox")[0].cloneNode(!0) : null;

                    const h = this.options.doneButton && this.multiple && this.$menu.find(
                      ".bs-donebutton")
                      .length > 0 ? this.$menu.find(".bs-donebutton")[0].cloneNode(!0) : null;

                    if (l.className = "text", i.className = `${this.$menu[0].parentNode.className} open`, n.className = "dropdown-menu open", o.className =
                      "dropdown-menu inner", s.className = "divider", l.appendChild(document
                      .createTextNode("Inner text")), r.appendChild(l), a.appendChild(r), o
                      .appendChild(a), o.appendChild(s), c && n.appendChild(c), u) {
                        const p = document.createElement("input");
                        u.className = "bs-searchbox", p.className = "form-control", u.appendChild(
                          p), n.appendChild(u)
                    }
                    d && n.appendChild(d), n.appendChild(o), h && n.appendChild(h), i.appendChild(
                      n), document.body.appendChild(i);
                    const m = r.offsetHeight;
                    const f = c ? c.offsetHeight : 0;
                    const _ = u ? u.offsetHeight : 0;
                    const g = d ? d.offsetHeight : 0;
                    const v = h ? h.offsetHeight : 0;

                    const b = e(s)
                      .outerHeight(!0);

                    const y = "function" == typeof getComputedStyle && getComputedStyle(n);
                    const w = y ? null : e(n);

                    const k = {
                        vert: parseInt(y ? y.paddingTop : w.css("paddingTop")) + parseInt(y ?
                          y.paddingBottom : w.css("paddingBottom")) + parseInt(y ? y
                          .borderTopWidth : w.css("borderTopWidth")) + parseInt(y ? y
                          .borderBottomWidth : w.css("borderBottomWidth")),
                        horiz: parseInt(y ? y.paddingLeft : w.css("paddingLeft")) + parseInt(
                          y ? y.paddingRight : w.css("paddingRight")) + parseInt(y ? y
                          .borderLeftWidth : w.css("borderLeftWidth")) + parseInt(y ? y
                          .borderRightWidth : w.css("borderRightWidth"))
                    };

                    const x = {
                        vert: k.vert + parseInt(y ? y.marginTop : w.css("marginTop")) +
                          parseInt(y ? y.marginBottom : w.css("marginBottom")) + 2,
                        horiz: k.horiz + parseInt(y ? y.marginLeft : w.css("marginLeft")) +
                          parseInt(y ? y.marginRight : w.css("marginRight")) + 2
                    };

                    document.body.removeChild(i), this.sizeInfo = {
                        liHeight: m,
                        headerHeight: f,
                        searchHeight: _,
                        actionsHeight: g,
                        doneButtonHeight: v,
                        dividerHeight: b,
                        menuPadding: k,
                        menuExtras: x
                    }
                }
            },
            setSize() {
                if (this.findLis(), this.liHeight(), this.options.header && this.$menu.css(
                  "padding-top", 0), this.options.size !== !1) {
                    let t;
                    let i;
                    let n;
                    let o;
                    let s;
                    let a;
                    let r;
                    let l;
                    const c = this;
                    const u = this.$menu;
                    const d = this.$menuInner;
                    const h = e(window);
                    const p = this.$newElement[0].offsetHeight;
                    const m = this.$newElement[0].offsetWidth;
                    const f = this.sizeInfo.liHeight;
                    const _ = this.sizeInfo.headerHeight;
                    const g = this.sizeInfo.searchHeight;
                    const v = this.sizeInfo.actionsHeight;
                    const b = this.sizeInfo.doneButtonHeight;
                    const y = this.sizeInfo.dividerHeight;
                    const w = this.sizeInfo.menuPadding;
                    const k = this.sizeInfo.menuExtras;
                    const x = this.options.hideDisabled ? ".disabled" : "";

                    const C = () => {
                        let t;
                        const i = c.$newElement.offset();
                        const n = e(c.options.container);
                        c.options.container && !n.is("body") ? (t = n.offset(), t.top +=
                          parseInt(n.css("borderTopWidth")), t.left += parseInt(n.css(
                          "borderLeftWidth"))) : t = {
                            top: 0,
                            left: 0
                        };
                        const o = c.options.windowPadding;
                        s = i.top - t.top - h.scrollTop(), a = h.height() - s - p - t.top - o[
                          2], r = i.left - t.left - h.scrollLeft(), l = h.width() - r -
                          m - t.left - o[1], s -= o[0], r -= o[3]
                    };

                    if (C(), "auto" === this.options.size) {
                        const z = () => {
                            let h;

                            const p = (t, i) => n => i ? n.classList ? n.classList.contains(t) :
                              e(n)
                                .hasClass(t) : !(n.classList ? n.classList
                              .contains(t) : e(n)
                              .hasClass(t));

                            const y = c.$menuInner[0].getElementsByTagName("li");

                            const x = Array.prototype.filter ? Array.prototype.filter.call(y, p(
                              "hidden", !1)) : c.$lis.not(".hidden");

                            const z = Array.prototype.filter ? Array.prototype.filter.call(x, p(
                              "dropdown-header", !0)) : x.filter(".dropdown-header");

                            C(), t = a - k.vert, i = l - k.horiz, c.options.container ? (u
                              .data("height") || u.data("height", u.height()), n = u
                              .data("height"), u.data("width") || u.data("width", u
                              .width()), o = u.data("width")) : (n = u.height(), o =
                              u.width()), c.options.dropupAuto && c.$newElement
                              .toggleClass("dropup", s > a && t - k.vert < n), c.$newElement
                              .hasClass("dropup") && (t = s - k.vert), "auto" === c.options
                              .dropdownAlignRight && u.toggleClass("dropdown-menu-right",
                              r > l && i - k.horiz < o - m), h = x.length + z.length >
                            3 ? 3 * f + k.vert - 2 : 0, u.css({
                                "max-height": `${t}px`,
                                overflow: "hidden",
                                "min-height": `${h + _ + g + v + b}px`
                            }), d.css({
                                "max-height": `${t - _ - g - v - b - w.vert}px`,
                                "overflow-y": "auto",
                                "min-height": `${Math.max(h - w.vert, 0)}px`
                            })
                        };
                        z(), this.$searchbox.off("input.getSize propertychange.getSize")
                          .on("input.getSize propertychange.getSize", z), h.off(
                          "resize.getSize scroll.getSize")
                          .on("resize.getSize scroll.getSize", z)
                    } else if (this.options.size && "auto" != this.options.size && this.$lis.not(
                      x)
                      .length > this.options.size) {
                        const T = this.$lis.not(".divider")
                            .not(x)
                            .children()
                            .slice(0, this.options.size)
                            .last()
                            .parent()
                            .index();

                        const S = this.$lis.slice(0, T + 1)
                          .filter(".divider")
                          .length;

                        t = f * this.options.size + S * y + w.vert, c.options.container ? (u.data(
                          "height") || u.data("height", u.height()), n = u.data(
                          "height")) : n = u.height(), c.options.dropupAuto && this
                          .$newElement.toggleClass("dropup", s > a && t - k.vert < n), u.css({
                            "max-height": `${t + _ + g + v + b}px`,
                            overflow: "hidden",
                            "min-height": ""
                        }), d.css({
                            "max-height": `${t - w.vert}px`,
                            "overflow-y": "auto",
                            "min-height": ""
                        })
                    }
                }
            },
            setWidth() {
                if ("auto" === this.options.width) {
                    this.$menu.css("min-width", "0");

                    const e = this.$menu.parent()
                        .clone()
                        .appendTo("body");

                    const t = this.options.container ? this.$newElement.clone()
                      .appendTo("body") : e;

                    const i = e.children(".dropdown-menu")
                      .outerWidth();

                    const n = t.css("width", "auto")
                      .children("button")
                      .outerWidth();

                    e.remove(), t.remove(), this.$newElement.css("width", `${Math.max(i, n)}px`)
                } else "fit" === this.options.width ? (this.$menu.css("min-width", ""), this
                  .$newElement.css("width", "")
                  .addClass("fit-width")) : this.options.width ? (this.$menu.css(
                  "min-width", ""), this.$newElement.css("width", this.options.width)) : (
                  this.$menu.css("min-width", ""), this.$newElement.css("width", ""));
                this.$newElement.hasClass("fit-width") && "fit" !== this.options.width && this
                  .$newElement.removeClass("fit-width")
            },
            selectPosition() {
                this.$bsContainer = e('<div class="bs-container" />');
                let t;
                let i;
                let n;
                const o = this;
                const s = e(this.options.container);

                const a = e => {
                    o.$bsContainer.addClass(e.attr("class")
                      .replace(/form-control|fit-width/gi, ""))
                      .toggleClass("dropup", e.hasClass("dropup")), t = e.offset(), s.is(
                      "body") ? i = {
                        top: 0,
                        left: 0
                    } : (i = s.offset(), i.top += parseInt(s.css("borderTopWidth")) - s
                      .scrollTop(), i.left += parseInt(s.css("borderLeftWidth")) - s
                      .scrollLeft()), n = e.hasClass("dropup") ? 0 : e[0].offsetHeight,
                      o.$bsContainer.css({
                          top: t.top - i.top + n,
                          left: t.left - i.left,
                          width: e[0].offsetWidth
                      })
                };

                this.$button.on("click", function () {
                    const t = e(this);
                    o.isDisabled() || (a(o.$newElement), o.$bsContainer.appendTo(o.options
                      .container)
                      .toggleClass("open", !t.hasClass("open"))
                      .append(o.$menu))
                }), e(window)
                  .on("resize scroll", () => {
                      a(o.$newElement)
                  }), this.$element.on("hide.bs.select", () => {
                    o.$menu.data("height", o.$menu.height()), o.$bsContainer.detach()
                })
            },
            setSelected(e, t, i) {
                i || (this.togglePlaceholder(), i = this.findLis()
                  .eq(this.liObj[e])), i.toggleClass("selected", t)
                  .find("a")
                  .attr("aria-selected", t)
            },
            setDisabled(e, t, i) {
                i || (i = this.findLis()
                  .eq(this.liObj[e])), t ? i.addClass("disabled")
                  .children("a")
                  .attr("href", "#")
                  .attr("tabindex", -1)
                  .attr("aria-disabled", !0) : i.removeClass("disabled")
                  .children("a")
                  .removeAttr("href")
                  .attr("tabindex", 0)
                  .attr("aria-disabled", !1)
            },
            isDisabled() {
                return this.$element[0].disabled
            },
            checkDisabled() {
                const e = this;
                this.isDisabled() ? (this.$newElement.addClass("disabled"), this.$button.addClass(
                  "disabled")
                  .attr("tabindex", -1)
                  .attr("aria-disabled", !0)) : (this.$button.hasClass("disabled") && (this
                  .$newElement.removeClass("disabled"), this.$button.removeClass(
                  "disabled")
                  .attr("aria-disabled", !1)), -1 != this.$button.attr("tabindex") ||
                this.$element.data("tabindex") || this.$button.removeAttr("tabindex")),
                  this.$button.click(() => !e.isDisabled())
            },
            togglePlaceholder() {
                const e = this.$element.val();
                this.$button.toggleClass("bs-placeholder", null === e || "" === e || e
                  .constructor === Array && 0 === e.length)
            },
            tabIndex() {
                this.$element.data("tabindex") !== this.$element.attr("tabindex") && -98 !== this
                  .$element.attr("tabindex") && "-98" !== this.$element.attr("tabindex") && (
                  this.$element.data("tabindex", this.$element.attr("tabindex")), this
                    .$button.attr("tabindex", this.$element.data("tabindex"))), this.$element
                  .attr("tabindex", -98)
            },
            clickListener() {
                const t = this;
                const i = e(document);
                i.data("spaceSelect", !1), this.$button.on("keyup", e => {
                    /(32)/.test(e.keyCode.toString(10)) && i.data("spaceSelect") && (e
                      .preventDefault(), i.data("spaceSelect", !1))
                }), this.$button.on("click", () => {
                    t.setSize()
                }), this.$element.on("shown.bs.select", () => {
                    if (t.options.liveSearch || t.multiple) {
                        if (!t.multiple) {
                            const e = t.liObj[t.$element[0].selectedIndex];
                            if ("number" != typeof e || t.options.size === !1) return;
                            let i = t.$lis.eq(e)[0].offsetTop - t.$menuInner[0].offsetTop;
                            i = i - t.$menuInner[0].offsetHeight / 2 + t.sizeInfo
                              .liHeight / 2, t.$menuInner[0].scrollTop = i
                        }
                    } else t.$menuInner.find(".selected a")
                      .focus()
                }), this.$menuInner.on("click", "li a", function (i) {
                    const n = e(this);

                    const s = n.parent()
                      .data("originalIndex");

                    const a = t.$element.val();
                    const r = t.$element.prop("selectedIndex");
                    let l = !0;
                    if (t.multiple && 1 !== t.options.maxOptions && i.stopPropagation(), i
                      .preventDefault(), !t.isDisabled() && !n.parent()
                      .hasClass("disabled")) {
                        const c = t.$element.find("option");
                        const u = c.eq(s);
                        const d = u.prop("selected");
                        const h = u.parent("optgroup");
                        const p = t.options.maxOptions;
                        const m = h.data("maxOptions") || !1;
                        if (t.multiple) {
                            if (u.prop("selected", !d), t.setSelected(s, !d), n.blur(),
                            p !== !1 || m !== !1) {
                                const f = p < c.filter(":selected")
                                    .length;

                                const _ = m < h.find("option:selected")
                                  .length;

                                if (p && f || m && _)
                                    if (p && 1 == p) c.prop("selected", !1), u.prop(
                                      "selected", !0), t.$menuInner.find(
                                      ".selected")
                                      .removeClass("selected"), t.setSelected(s, !0);
                                    else if (m && 1 == m) {
                                        h.find("option:selected")
                                          .prop("selected", !1), u.prop("selected", !0);
                                        const g = n.parent()
                                          .data("optgroup");
                                        t.$menuInner.find(`[data-optgroup="${g}"]`)
                                          .removeClass("selected"), t.setSelected(s, !0)
                                    } else {
                                        const v = "string" == typeof t.options.maxOptionsText ?
                                          [t.options.maxOptionsText, t.options
                                            .maxOptionsText] : t.options.maxOptionsText;

                                        const b = "function" == typeof v ? v(p, m) : v;
                                        let y = b[0].replace("{n}", p);
                                        let w = b[1].replace("{n}", m);
                                        const k = e('<div class="notify"></div>');
                                        b[2] && (y = y.replace("{var}", b[2][p > 1 ? 0 : 1]),
                                          w = w.replace("{var}", b[2][m > 1 ? 0 : 1])),
                                          u.prop("selected", !1), t.$menu.append(k), p &&
                                        f && (k.append(e(`<div>${y}</div>`)), l = !1,
                                          t.$element.trigger("maxReached.bs.select")),
                                        m && _ && (k.append(e(`<div>${w}</div>`)),
                                          l = !1, t.$element.trigger(
                                          "maxReachedGrp.bs.select")), setTimeout(
                                          () => {
                                              t.setSelected(s, !1)
                                          }, 10), k.delay(750)
                                          .fadeOut(300, function () {
                                              e(this)
                                                .remove()
                                          })
                                    }
                            }
                        } else c.prop("selected", !1), u.prop("selected", !0), t
                          .$menuInner.find(".selected")
                          .removeClass("selected")
                          .find("a")
                          .attr("aria-selected", !1), t.setSelected(s, !0);
                        !t.multiple || t.multiple && 1 === t.options.maxOptions ? t
                          .$button.focus() : t.options.liveSearch && t.$searchbox
                          .focus(), l && (a != t.$element.val() && t.multiple || r != t
                          .$element.prop("selectedIndex") && !t.multiple) && (o = [
                            s, u.prop("selected"), d], t.$element.triggerNative(
                          "change"))
                    }
                }), this.$menu.on("click",
                  "li.disabled a, .popover-title, .popover-title :not(.close)",
                  function (i) {
                      i.currentTarget == this && (i.preventDefault(), i.stopPropagation(), t
                        .options.liveSearch && !e(i.target)
                        .hasClass("close") ? t.$searchbox.focus() : t.$button.focus())
                  }), this.$menuInner.on("click", ".divider, .dropdown-header", e => {
                    e.preventDefault(), e.stopPropagation(), t.options.liveSearch ? t
                      .$searchbox.focus() : t.$button.focus()
                }), this.$menu.on("click", ".popover-title .close", () => {
                    t.$button.click()
                }), this.$searchbox.on("click", e => {
                    e.stopPropagation()
                }), this.$menu.on("click", ".actions-btn", function (i) {
                    t.options.liveSearch ? t.$searchbox.focus() : t.$button.focus(), i
                      .preventDefault(), i.stopPropagation(), e(this)
                      .hasClass("bs-select-all") ? t.selectAll() : t.deselectAll()
                }), this.$element.change(() => {
                    t.render(!1), t.$element.trigger("changed.bs.select", o), o = null
                })
            },
            liveSearchListener() {
                const i = this;
                const n = e('<li class="no-results"></li>');
                this.$button.on("click.dropdown.data-api", () => {
                    i.$menuInner.find(".active")
                      .removeClass("active"), i.$searchbox.val() && (i.$searchbox.val(
                      ""), i.$lis.not(".is-hidden")
                      .removeClass("hidden"), n.parent()
                      .length && n.remove()), i.multiple || i.$menuInner.find(
                      ".selected")
                      .addClass("active"), setTimeout(() => {
                        i.$searchbox.focus()
                    }, 10)
                }), this.$searchbox.on(
                  "click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api",
                  e => {
                      e.stopPropagation()
                  }), this.$searchbox.on("input propertychange", () => {
                    if (i.$lis.not(".is-hidden")
                      .removeClass("hidden"), i.$lis.filter(".active")
                      .removeClass("active"), n.remove(), i.$searchbox.val()) {
                        let o;
                        const s = i.$lis.not(".is-hidden, .divider, .dropdown-header");
                        if (o = i.options.liveSearchNormalize ? s.not(`:a${i
  ._searchStyle()}("${t(i.$searchbox.val())}")`) : s
                          .not(`:${i._searchStyle()}("${i.$searchbox.val()}")`), o.length === s.length) n.html(i.options
                          .noneResultsText.replace("{0}", `"${c(i.$searchbox
    .val())}"`)), i.$menuInner.append(n), i.$lis.addClass(
                          "hidden");
                        else {
                            o.addClass("hidden");
                            let a;
                            const r = i.$lis.not(".hidden");
                            r.each(function (t) {
                                const i = e(this);
                                i.hasClass("divider") ? void 0 === a ? i.addClass(
                                  "hidden") : (a && a.addClass("hidden"),
                                  a = i) : i.hasClass("dropdown-header") &&
                                r.eq(t + 1)
                                  .data("optgroup") !== i.data("optgroup") ? i
                                  .addClass("hidden") : a = null
                            }), a && a.addClass("hidden"), s.not(".hidden")
                              .first()
                              .addClass("active"), i.$menuInner.scrollTop(0)
                        }
                    }
                })
            },
            _searchStyle() {
                const e = {
                    begins: "ibegins",
                    startsWith: "ibegins"
                };
                return e[this.options.liveSearchStyle] || "icontains"
            },
            val(e) {
                return "undefined" != typeof e ? (this.$element.val(e), this.render(), this
                  .$element) : this.$element.val()
            },
            changeAll(t) {
                if (this.multiple) {
                    "undefined" == typeof t && (t = !0), this.findLis();
                    const i = this.$element.find("option");
                    const n = this.$lis.not(".divider, .dropdown-header, .disabled, .hidden");
                    const o = n.length;
                    const s = [];
                    if (t) {
                        if (n.filter(".selected")
                          .length === n.length) return
                    } else if (0 === n.filter(".selected")
                      .length) return;
                    n.toggleClass("selected", t);
                    for (let a = 0; o > a; a++) {
                        const r = n[a].getAttribute("data-original-index");
                        s[s.length] = i.eq(r)[0]
                    }
                    e(s)
                      .prop("selected", t), this.render(!1), this.togglePlaceholder(), this
                      .$element.triggerNative("change")
                }
            },
            selectAll() {
                return this.changeAll(!0)
            },
            deselectAll() {
                return this.changeAll(!1)
            },
            toggle(e) {
                e = e || window.event, e && e.stopPropagation(), this.$button.trigger("click")
            },
            keydown(t) {
                let i;
                let n;
                let o;
                let s;
                const a = e(this);

                const r = a.is("input") ? a.parent()
                  .parent() : a.parent();

                const l = r.data("this");
                const c = ":not(.disabled, .hidden, .dropdown-header, .divider)";

                const u = {
                    32: " ",
                    48: "0",
                    49: "1",
                    50: "2",
                    51: "3",
                    52: "4",
                    53: "5",
                    54: "6",
                    55: "7",
                    56: "8",
                    57: "9",
                    59: ";",
                    65: "a",
                    66: "b",
                    67: "c",
                    68: "d",
                    69: "e",
                    70: "f",
                    71: "g",
                    72: "h",
                    73: "i",
                    74: "j",
                    75: "k",
                    76: "l",
                    77: "m",
                    78: "n",
                    79: "o",
                    80: "p",
                    81: "q",
                    82: "r",
                    83: "s",
                    84: "t",
                    85: "u",
                    86: "v",
                    87: "w",
                    88: "x",
                    89: "y",
                    90: "z",
                    96: "0",
                    97: "1",
                    98: "2",
                    99: "3",
                    100: "4",
                    101: "5",
                    102: "6",
                    103: "7",
                    104: "8",
                    105: "9"
                };

                if (s = l.$newElement.hasClass("open"), !s && (t.keyCode >= 48 && t.keyCode <=
                  57 || t.keyCode >= 96 && t.keyCode <= 105 || t.keyCode >= 65 && t
                    .keyCode <= 90)) return l.options.container ? l.$button.trigger("click") :
                  (l.setSize(), l.$menu.parent()
                    .addClass("open"), s = !0), void l.$searchbox.focus();
                if (l.options.liveSearch && /(^9$|27)/.test(t.keyCode.toString(10)) && s && (t
                  .preventDefault(), t.stopPropagation(), l.$menuInner.click(), l.$button
                  .focus()), /(38|40)/.test(t.keyCode.toString(10))) {
                    if (i = l.$lis.filter(c), !i.length) return;
                    n = l.options.liveSearch ? i.index(i.filter(".active")) : i.index(i.find("a")
                      .filter(":focus")
                      .parent()), o = l.$menuInner.data("prevIndex"), 38 == t.keyCode ? (!l
                      .options.liveSearch && n != o || -1 == n || n--, 0 > n && (n += i
                      .length)) : 40 == t.keyCode && ((l.options.liveSearch || n ==
                      o) && n++, n %= i.length), l.$menuInner.data("prevIndex", n), l
                      .options.liveSearch ? (t.preventDefault(), a.hasClass(
                      "dropdown-toggle") || (i.removeClass("active")
                      .eq(n)
                      .addClass("active")
                      .children("a")
                      .focus(), a.focus())) : i.eq(n)
                      .children("a")
                      .focus()
                } else if (!a.is("input")) {
                    let d;
                    let h;
                    const p = [];
                    i = l.$lis.filter(c), i.each(function (i) {
                        e.trim(e(this)
                          .children("a")
                          .text()
                          .toLowerCase())
                          .substring(0, 1) == u[t.keyCode] && p.push(i)
                    }), d = e(document)
                      .data("keycount"), d++, e(document)
                      .data("keycount", d), h = e.trim(e(":focus")
                      .text()
                      .toLowerCase())
                      .substring(0, 1), h != u[t.keyCode] ? (d = 1, e(document)
                      .data("keycount", d)) : d >= p.length && (e(document)
                      .data("keycount", 0), d > p.length && (d = 1)), i.eq(p[d - 1])
                      .children("a")
                      .focus()
                }
                if ((/(13|32)/.test(t.keyCode.toString(10)) || /(^9$)/.test(t.keyCode.toString(
                  10)) && l.options.selectOnTab) && s) {
                    if (/(32)/.test(t.keyCode.toString(10)) || t.preventDefault(), l.options
                      .liveSearch) /(32)/.test(t.keyCode.toString(10)) || (l.$menuInner.find(
                      ".active a")
                      .click(), a.focus());
                    else {
                        const m = e(":focus");
                        m.click(), m.focus(), t.preventDefault(), e(document)
                          .data("spaceSelect", !0)
                    }
                    e(document)
                      .data("keycount", 0)
                }(/(^9$|27)/.test(t.keyCode.toString(10)) && s && (l.multiple || l.options
                      .liveSearch) || /(27)/.test(t.keyCode.toString(10)) && !s) && (l.$menu
                      .parent()
                      .removeClass("open"), l.options.container && l.$newElement.removeClass(
                      "open"), l.$button.focus())
            },
            mobile() {
                this.$element.addClass("mobile-device")
            },
            refresh() {
                this.$lis = null, this.liObj = {}, this.reloadLi(), this.render(), this
                  .checkDisabled(), this.liHeight(!0), this.setStyle(), this.setWidth(), this
                  .$lis && this.$searchbox.trigger("propertychange"), this.$element.trigger(
                  "refreshed.bs.select")
            },
            hide() {
                this.$newElement.hide()
            },
            show() {
                this.$newElement.show()
            },
            remove() {
                this.$newElement.remove(), this.$element.remove()
            },
            destroy() {
                this.$newElement.before(this.$element)
                  .remove(), this.$bsContainer ? this.$bsContainer.remove() : this.$menu
                  .remove(), this.$element.off(".bs.select")
                  .removeData("selectpicker")
                  .removeClass("bs-select-hidden selectpicker")
            }
        };
        const h = e.fn.selectpicker;
        e.fn.selectpicker = i, e.fn.selectpicker.Constructor = d, e.fn.selectpicker.noConflict =
          function () {
              return e.fn.selectpicker = h, this
          }, e(document)
          .data("keycount", 0)
          .on("keydown.bs.select",
            '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input',
            d.prototype.keydown)
          .on("focusin.modal",
            '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input',
            e => {
                e.stopPropagation()
            }), e(window)
          .on("load.bs.select.data-api", () => {
              e(".selectpicker")
                .each(function () {
                    const t = e(this);
                    i.call(t, t.data())
                })
          })
    })(e)
}), /*!
* Bootstrap-select v1.12.4 (https://silviomoreto.github.io/bootstrap-select)
*
* Copyright 2013-2018 bootstrap-select
* Licensed under MIT (https://github.com/silviomoreto/bootstrap-select/blob/master/LICENSE)
*/
((e, t) => {
    "function" == typeof define && define.amd ? define(["jquery"], e => t(e)) : "object" == typeof module && module.exports ? module.exports = t(require("jquery")) : t(e.jQuery)
})(this, e => {
    !(({fn}) => {
        fn.selectpicker.defaults = {
            noneSelectedText: "-",
            noneResultsText: "Keine Ergebnisse für {0}",
            countSelectedText(e) {
                return 1 == e ? "{0} Element ausgewählt" : "{0} Elemente ausgewählt"
            },
            maxOptionsText(e, t) {
                return [1 == e ? "Limit erreicht ({n} Element max.)" :
                  "Limit erreicht ({n} Elemente max.)", 1 == t ?
                  "Gruppen-Limit erreicht ({n} Element max.)" :
                  "Gruppen-Limit erreicht ({n} Elemente max.)"]
            },
            selectAllText: "Alles auswählen",
            deselectAllText: "Nichts auswählen",
            multipleSeparator: ", "
        }
    })(e)
}), (e => {
    function t(e, t) {
        return typeof t === e
    }

    function i(e) {
        return !Object.keys(e)
          .length
    }

    function n(e, t) {
        for (var i = e === !!e, o = i ? 2 : 1, s = i ? t : e, a = i ? e : !1; o < arguments.length; o++) {
            const r = arguments[o];
            for (const l in r) {
                const c = r[l];
                if (!ut(c)) {
                    const u = null !== c && "object" == typeof c && Object.getPrototypeOf(c) === Object
                        .prototype;

                    const d = Array.isArray(c);
                    s[l] = a && (u || d) ? n(!0, s[l] || (d ? [] : {}), c) : c
                }
            }
        }
        return s
    }

    function o(e, t) {
        const i = e.indexOf(t);
        i > -1 && e.splice(i, 1)
    }

    function s(e, t) {
        if (Array.isArray(e) || "length" in e && ht(e.length))
            for (let i = 0; i < e.length; i++) t(i, e[i]);
        else Object.keys(e)
          .forEach(i => {
              t(i, e[i])
          })
    }

    function a(e) {
        return e = parseFloat(e), isFinite(e) ? e : 0
    }

    function r(e, t, i) {
        const n = (i || document)
          .createElement(e);
        return s(t || {}, (e, t) => {
            "style" === e ? n.style.cssText = t : e in n ? n[e] = t : n.setAttribute(e, t)
        }), n;
    }

    function l(e, t) {
        for (let i = e || {};
             (i = i.parentNode) && !/(9|11)/.test(i.nodeType);)
            if (!t || k(i, t)) return i
    }

    function c(e, t) {
        return k(e, t) ? e : l(e, t)
    }

    function u(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }

    function d(e, t) {
        e.appendChild(t)
    }

    function h(e, t) {
        return e.querySelectorAll(t)
    }

    function p(e, t, i, n, o) {
        t.split(" ")
          .forEach(t => {
              let s;
              ct(i) ? (s = n[`_sce-event-${t}${i}`] || (t => {
                  for (let o = t.target; o && o !== e;) {
                      if (k(o, i)) return n.call(o, t), void 0;
                      o = o.parentNode
                  }
              }), n[`_sce-event-${t}${i}`] = s) : (s = i, o = n), e.addEventListener(t, s, o || !1)
          })
    }

    function m(e, t, i, n, o) {
        t.split(" ")
          .forEach(t => {
              let s;
              ct(i) ? s = n[`_sce-event-${t}${i}`] : (s = i, o = n), e.removeEventListener(t, s, o || !
                1)
          })
    }

    function f(e, t, i) {
        return arguments.length < 3 ? e.getAttribute(t) : (null == i ? _(e, t) : e.setAttribute(t, i), void 0)
    }

    function _(e, t) {
        e.removeAttribute(t)
    }

    function g(e) {
        y(e, "display", "none")
    }

    function v(e) {
        y(e, "display", "")
    }

    function b(e) {
        D(e) ? g(e) : v(e)
    }

    function y(e, t, i) {
        if (arguments.length < 3) {
            if (ct(t)) return 1 === e.nodeType ? getComputedStyle(e)[t] : null;
            s(t, (t, i) => {
                y(e, t, i)
            })
        } else {
            const n = (i || 0 === i) && !isNaN(i);
            e.style[t] = n ? `${i}px` : i
        }
    }

    function w(e, t, i) {
        const n = arguments.length;
        const o = {};
        if (e.nodeType === mt) {
            if (1 === n) return s(e.attributes, (e, {name, value}) => {
                /^data\-/i.test(name) && (o[name.substr(5)] = value)
            }), o;
            if (2 === n) return f(e, `data-${t}`);
            f(e, `data-${t}`, String(i))
        }
    }

    function k(e, t) {
        let i = !1;
        return e && e.nodeType === mt && (i = (e.matches || e.msMatchesSelector || e.webkitMatchesSelector)
          .call(e, t)), i
    }

    function x(e, t) {
        return e !== t && e.contains && e.contains(t)
    }

    function C({previousElementSibling}, t) {
        const i = previousElementSibling;
        return t && i ? k(i, t) ? i : null : i
    }

    function z(e, t) {
        return t.parentNode.insertBefore(e, t)
    }

    function T({className}) {
        return className.trim()
          .split(/\s+/);
    }

    function S(e, t) {
        return k(e, `.${t}`);
    }

    function A(e, t) {
        const i = T(e);
        !i.includes(t) && i.push(t), e.className = i.join(" ")
    }

    function E(e, t) {
        const i = T(e);
        o(i, t), e.className = i.join(" ")
    }

    function P(e, t, i) {
        i = ut(i) ? !S(e, t) : i, i ? A(e, t) : E(e, t)
    }

    function I(e, t) {
        if (ut(t)) {
            const i = getComputedStyle(e);
            const n = a(i.paddingLeft) + a(i.paddingRight);
            const o = a(i.borderLeftWidth) + a(i.borderRightWidth);
            return e.offsetWidth - n - o
        }
        y(e, "width", t)
    }

    function M(e, t) {
        if (ut(t)) {
            const i = getComputedStyle(e);
            const n = a(i.paddingTop) + a(i.paddingBottom);
            const o = a(i.borderTopWidth) + a(i.borderBottomWidth);
            return e.offsetHeight - n - o
        }
        y(e, "height", t)
    }

    function j(e, t, i) {
        let n;
        dt(window.CustomEvent) ? n = new CustomEvent(t, {
            bubbles: !0,
            cancelable: !0,
            detail: i
        }) : (n = e.ownerDocument.createEvent("CustomEvent"), n.initCustomEvent(t, !0, !0, i)), e
          .dispatchEvent(n)
    }

    function D(e) {
        return !!e.getClientRects()
          .length
    }

    function N(e) {
        return e.replace(/^-ms-/, "ms-")
          .replace(/-(\w)/g, (e, t) => t.toUpperCase());
    }

    function L(e, t, i, n, o) {
        for (e = o ? e.lastChild : e.firstChild; e;) {
            const s = o ? e.previousSibling : e.nextSibling;
            if (!i && t(e) === !1 || !n && L(e, t, i, n, o) === !1 || i && t(e) === !1) return !1;
            e = s
        }
    }

    function O(e, t, i, n) {
        L(e, t, i, n, !0)
    }

    function R(e, t = document) {
        const i = t.createDocumentFragment();
        const n = r("div", {}, t);
        for (n.innerHTML = e; n.firstChild;) d(i, n.firstChild);
        return i
    }

    function $(e) {
        return e && (!k(e, "p,div") || e.className || f(e, "style") || !i(w(e)))
    }

    function F(e, t) {
        const i = r(t, {}, e.ownerDocument);
        for (s(e.attributes, (e, {name, value}) => {
            try {
                f(i, name, value)
            } catch (n) {}
        }); e.firstChild;) d(i, e.firstChild);
        return e.parentNode.replaceChild(i, e), i
    }

    function B({nodeType, nodeName}) {
        return /11?|9/.test(nodeType) ?
          !"|iframe|area|base|basefont|br|col|frame|hr|img|input|wbr|isindex|link|meta|param|command|embed|keygen|source|track|object|".includes(`|${nodeName.toLowerCase()}|`) : !1;
    }

    function H(e, t) {
        let i;

        const n = (e || {})
          .nodeType || ft;

        return n !== mt ? n === ft : (i = e.tagName.toLowerCase(), "code" === i ? !t : !gt.includes(`|${i}|`));
    }

    function W({style}, {style}) {
        style.cssText = style.cssText + style.cssText
    }

    function V(e) {
        const t = e => {
            for (; H(e.parentNode, !0);) e = e.parentNode;
            return e
        };
        L(e, e => {
            const i = "ul,ol";
            const n = !H(e, !0);
            if (n && H(e.parentNode, !0)) {
                const o = t(e);
                const s = G(o, e);
                const a = e;
                W(o, a), z(s, o), z(a, o)
            }
            if (n && k(e, i) && k(e.parentNode, i)) {
                let l = C(e, "li");
                l || (l = r("li"), z(l, e)), d(l, e)
            }
        })
    }

    function q(e, t) {
        for (; e = e.parentNode;)
            if (x(e, t)) return e
    }

    function U(e, t) {
        return e ? (t ? e.previousSibling : e.nextSibling) || U(e.parentNode, t) : null
    }

    function Z(e) {
        let t;
        let i;
        let n;
        let o;
        let s;
        let a;
        let r;
        const l = y(e, "whiteSpace");
        const c = /line$/i.test(l);
        let d = e.firstChild;
        if (!/pre(\-wrap)?$/i.test(l))
            for (; d;) {
                if (a = d.nextSibling, t = d.nodeValue, i = d.nodeType, i === mt && d.firstChild && Z(d),
                i === ft) {
                    for (n = U(d), o = U(d, !0), r = !1; S(o, "sceditor-ignore");) o = U(o, !0);
                    if (H(d) && o) {
                        for (s = o; s.lastChild;)
                            for (s = s.lastChild; S(s, "sceditor-ignore");) s = U(s, !0);
                        r = s.nodeType === ft ? /[\t\n\r ]$/.test(s.nodeValue) : !H(s)
                    }
                    t = t.replace(/\u200B/g, ""), o && H(o) && !r || (t = t.replace(c ? /^[\t ]+/ :
                      /^[\t\n\r ]+/, "")), n && H(n) || (t = t.replace(c ? /[\t ]+$/ : /[\t\n\r ]+$/,
                      "")), t.length ? d.nodeValue = t.replace(c ? /[\t ]+/g : /[\t\n\r ]+/g, " ") : u(
                      d)
                }
                d = a
            }
    }

    function G(e, t) {
        const i = e.ownerDocument.createRange();
        return i.setStartBefore(e), i.setEndAfter(t), i.extractContents()
    }

    function K(e) {
        for (var t = 0, i = 0; e;) t += e.offsetLeft, i += e.offsetTop, e = e.offsetParent;
        return {
            left: t,
            top: i
        }
    }

    function Y(e, t) {
        let i;
        let n;
        const o = e.style;
        if (pt[t] || (pt[t] = N(t)), t = pt[t], n = o[t], "textAlign" === t) {
            if (i = o.direction, n = n || y(e, t), y(e.parentNode, t) === n || "block" !== y(e, "display") ||
            k(e, "hr,th")) return "";
            if (/right/i.test(n) && "rtl" === i || /left/i.test(n) && "ltr" === i) return ""
        }
        return n
    }

    function J(e, t, i) {
        const n = Y(e, t);
        return n ? !i || n === i || Array.isArray(i) && i.includes(n) : !1;
    }

    function Q(e) {
        return e.replace(/([\-.*+?^=!:${}()|\[\]\/\\])/g, "\\$1")
    }

    function X(e, t) {
        if (!e) return e;
        const i = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "  ": "&nbsp; ",
            "\r\n": "<br />",
            "\r": "<br />",
            "\n": "<br />"
        };
        return t !== !1 && (i['"'] = "&#34;", i["'"] = "&#39;", i["`"] = "&#96;"), e = e.replace(
          / {2}|\r\n|[&<>\r\n'"`]/g,
          e => i[e] || e);
    }

    function et(e) {
        let t;
        const i = /^[^\/]*:/i;
        const n = window.location;
        return e && i.test(e) && !Ct.test(e) ? (t = n.pathname.split("/"), t.pop(), `${n.protocol}//${n
  .host}${t.join("/")}/${e}`) : e;
    }

    function tt(e, t, i) {
        let n = zt[e];
        return Object.keys(t)
          .forEach(e => {
              n = n.replace(new RegExp(Q(`{${e}}`), "g"), t[e])
          }), i && (n = R(n)), n;
    }

    function it(e) {
        if ("mozHidden" in document)
            for (let t, i = e.getBody(); i;) {
                if (t = i, t.firstChild) t = t.firstChild;
                else {
                    for (; t && !t.nextSibling;) t = t.parentNode;
                    t && (t = t.nextSibling)
                }
                3 === i.nodeType && /[\n\r\t]+/.test(i.nodeValue) && (/^pre/.test(y(i.parentNode,
                  "whiteSpace")) || u(i)), i = t
            }
    }

    function nt(e) {
        const t = this;
        let i = [];

        const n = e => `signal${e.charAt(0)
  .toUpperCase()}${e.slice(1)}`;

        const o = (t, o) => {
            t = [].slice.call(t);
            let s;
            let a;
            const r = n(t.shift());
            for (s = 0; s < i.length; s++)
                if (r in i[s] && (a = i[s][r].apply(e, t), o)) return a
        };

        t.call = function(...args) {
            o(args, !1)
        }, t.callOnlyFirst = function(...args) {
            return o(args, !0);
        }, t.hasHandler = e => {
            let t = i.length;
            for (e = n(e); t--;)
                if (e in i[t]) return !0;
            return !1
        }, t.exists = e => e in At ? (e = At[e], "function" == typeof e && "object" == typeof e.prototype) : !1, t.isRegistered = e => {
            if (t.exists(e))
                for (let n = i.length; n--;)
                    if (i[n] instanceof At[e]) return !0;
            return !1
        }, t.register = n => !t.exists(n) || t.isRegistered(n) ? !1 : (n = new At[n], i.push(n), "init" in n && n
          .init.call(e), !0), t.deregister = n => {
            let o;
            let s = i.length;
            let a = !1;
            if (!t.isRegistered(n)) return a;
            for (; s--;) i[s] instanceof At[n] && (o = i.splice(s, 1)[0], a = !0, "destroy" in o && o
              .destroy.call(e));
            return a
        }, t.destroy = () => {
            for (let t = i.length; t--;) "destroy" in i[t] && i[t].destroy.call(e);
            i = [], e = null
        }
    }

    function ot(e, t) {
        let i;
        let n;
        const o = t || e.contentDocument || e.document;
        const s = "sceditor-start-marker";
        const a = "sceditor-end-marker";
        const l = this;
        l.insertHTML = (e, t) => {
            let i;
            let n;
            const s = l.selectedRange();
            if (!s) return !1;
            for (t && (e += l.selectedHtml() + t), n = r("p", {}, o), i = o.createDocumentFragment(), n
              .innerHTML = e; n.firstChild;) d(i, n.firstChild);
            l.insertNode(i)
        }, n = (e, t, n) => {
            let c;
            let u = o.createDocumentFragment();
            if ("string" == typeof e ? (t && (e += l.selectedHtml() + t), u = R(e)) : (d(u, e), t && (d(u,
              l.selectedRange()
                .extractContents()), d(u, t))), c = u.lastChild) {
                for (; !H(c.lastChild, !0);) c = c.lastChild;
                if (B(c) ? c.lastChild || d(c, document.createTextNode("​")) : c = u, l.removeMarkers(),
                  d(c, i(s)), d(c, i(a)), n) {
                    const h = r("div");
                    return d(h, u), h.innerHTML
                }
                return u
            }
        }, l.insertNode = (e, t) => {
            const i = n(e, t);
            const o = l.selectedRange();
            const s = o.commonAncestorContainer;
            return i ? (o.deleteContents(), s && 3 !== s.nodeType && !B(s) ? z(i, s) : o.insertNode(i), l
              .restoreRange(), void 0) : !1
        }, l.cloneSelected = () => {
            const e = l.selectedRange();
            return e ? e.cloneRange() : void 0
        }, l.selectedRange = () => {
            let t;
            let i;
            const n = e.getSelection();
            if (n) {
                if (n.rangeCount <= 0) {
                    for (i = o.body; i.firstChild;) i = i.firstChild;
                    t = o.createRange(), t.setStartBefore(i), n.addRange(t)
                }
                return n.rangeCount > 0 && (t = n.getRangeAt(0)), t
            }
        }, l.hasSelection = () => {
            const t = e.getSelection();
            return t && t.rangeCount > 0
        }, l.selectedHtml = () => {
            let e;
            const t = l.selectedRange();
            return t ? (e = r("p", {}, o), d(e, t.cloneContents()), e.innerHTML) : ""
        }, l.parentNode = () => {
            const e = l.selectedRange();
            return e ? e.commonAncestorContainer : void 0
        }, l.getFirstBlockParent = e => {
            const t = e => H(e, !0) ? (e = e ? e.parentNode : null, e ? t(e) : e) : e;
            return t(e || l.parentNode())
        }, l.insertNodeAt = (e, t) => {
            const i = l.selectedRange();
            const n = l.cloneSelected();
            return n ? (n.collapse(e), n.insertNode(t), l.selectRange(i), void 0) : !1
        }, i = e => {
            l.removeMarker(e);
            const t = r("span", {
                id: e,
                className: "sceditor-selection sceditor-ignore",
                style: "display:none;line-height:0"
            }, o);
            return t.innerHTML = " ", t
        }, l.insertMarkers = () => {
            const e = l.selectedRange();
            const t = i(s);
            l.removeMarkers(), l.insertNodeAt(!0, t), e && e.collapsed ? t.parentNode.insertBefore(i(a), t
              .nextSibling) : l.insertNodeAt(!1, i(a))
        }, l.getMarker = e => o.getElementById(e), l.removeMarker = e => {
            const t = l.getMarker(e);
            t && u(t)
        }, l.removeMarkers = () => {
            l.removeMarker(s), l.removeMarker(a)
        }, l.saveRange = () => {
            l.insertMarkers()
        }, l.selectRange = t => {
            let i;
            const n = e.getSelection();
            const s = t.endContainer;
            if (!Et && t.collapsed && s && !H(s, !0)) {
                for (i = s.lastChild; i && k(i, ".sceditor-ignore");) i = i.previousSibling;
                if (k(i, "br")) {
                    const a = o.createRange();
                    a.setEndAfter(i), a.collapse(!1), l.compare(t, a) && (t.setStartBefore(i), t.collapse(
                      !0))
                }
            }
            n && (l.clear(), n.addRange(t))
        }, l.restoreRange = () => {
            let e;
            let t = l.selectedRange();
            const i = l.getMarker(s);
            const n = l.getMarker(a);
            return i && n && t ? (e = i.nextSibling === n, t = o.createRange(), t.setStartBefore(i), t
              .setEndAfter(n), e && t.collapse(!0), l.selectRange(t), l.removeMarkers(), void 0) : !
              1
        }, l.selectOuterText = (e, t) => {
            let i;
            let n;
            const o = l.cloneSelected();
            return o ? (o.collapse(!1), i = Pt(o, !0, e), n = Pt(o, !1, t), o.setStart(i.node, i.offset),
              o.setEnd(n.node, n.offset), l.selectRange(o), void 0) : !1
        }, l.getOuterText = (e, t) => {
            const i = l.cloneSelected();
            return i ? (i.collapse(!e), Pt(i, e, t)
              .text) : ""
        }, l.replaceKeyword = (e, t, i, n, o, s) => {
            i || e.sort((e, t) => e[0].length - t[0].length);
            let a;
            let r;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            const f = "(^|[\\s    ])";
            let _ = e.length;
            const g = o ? 1 : 0;
            let v = n || e[_ - 1][0].length;
            for (o && v++, s = s || "", a = l.getOuterText(!0, v), d = a.length, a += s, t && (a += l
              .getOuterText(!1, v)); _--;)
                if (p = e[_][0], m = p.length, u = Math.max(0, d - m - g), c = -1, o ? (r = a.substr(u)
                  .match(new RegExp(f + Q(p) + f)), r && (c = r.index + u + r[1].length)) : c = a
                  .indexOf(p, u), c > -1 && d >= c && c + m + g >= d) return h = d - c, l
                  .selectOuterText(h, m - h - (/^\S/.test(s) ? 1 : 0)), l.insertHTML(e[_][1]), !0;
            return !1
        }, l.compare = (e, t) => (t || (t = l.selectedRange()), e && t ? 0 === e.compareBoundaryPoints(Range.END_TO_END,
          t) && 0 === e.compareBoundaryPoints(Range.START_TO_START, t) : !e && !t), l.clear = () => {
            const t = e.getSelection();
            t && (t.removeAllRanges ? t.removeAllRanges() : t.empty && t.empty())
        }
    }

    function st(e, t) {
        const i = /[^\s\xA0\u2002\u2003\u2009\u00a0]+/;
        const n = e && h(e, "img[data-sceditor-emoticon]");
        if (e && n.length)
            for (let o = 0; o < n.length; o++) {
                const s = n[o];
                const a = s.parentNode;
                const r = s.previousSibling;
                let l = s.nextSibling;
                if (r && i.test(r.nodeValue.slice(-1)) || l && i.test((l.nodeValue || "")[0])) {
                    const c = t.cloneSelected();
                    let d = -1;
                    const p = c.startContainer;
                    let m = r.nodeValue;
                    null === m && (m = r.innerText || ""), m += w(s, "sceditor-emoticon"), p === l && (d = m
                      .length + c.startOffset), p === e && e.childNodes[c.startOffset] === l && (d = m
                      .length), p === r && (d = c.startOffset), l && l.nodeType === ft || (l = a
                      .insertBefore(a.ownerDocument.createTextNode(""), l)), l.insertData(0, m), u(r),
                      u(s), d > -1 && (c.setStart(l, d), c.collapse(!0), t.selectRange(c))
                }
            }
    }

    function at(e, t, i) {
        const n = e.ownerDocument;
        const o = "(^|\\s| | | | |$)";
        const a = [];
        const r = {};
        l(e, "code") || (s(t, e => {
            r[e] = new RegExp(o + Q(e) + o), a.push(e)
        }), a.sort(({length}, {length}) => length - length), function c(e) {
            for (e = e.firstChild; e;) {
                if (e.nodeType !== mt || k(e, "code") || c(e), e.nodeType === ft)
                    for (let o = 0; o < a.length; o++) {
                        const s = e.nodeValue;
                        const l = a[o];
                        const u = i ? s.search(r[l]) : s.indexOf(l);
                        if (u > -1) {
                            const d = s.indexOf(l, u);
                            const h = R(t[l], n);
                            const p = s.substr(d + l.length);
                            h.appendChild(n.createTextNode(p)), e.nodeValue = s.substr(0, d), e
                              .parentNode.insertBefore(h, e.nextSibling)
                        }
                    }
                e = e.nextSibling
            }
        }(e))
    }

    function rt(e, t) {
        let i;
        L(e, e => {
            H(e, !0) ? (i || (i = r("p", {}, t), z(i, e)), (e.nodeType !== ft || "" !== e
              .nodeValue) && d(i, e)) : i = null
        }, !1, !0)
    }

    function lt(e, t) {
        let i;
        let a;
        let l;
        let _;
        let x;
        let C;
        let T;
        let N;
        let L;
        let R;
        let W;
        let q;
        let U;
        let G;
        let Y;
        let J;
        let Q;
        let et;
        let it;
        let ht;
        let pt;
        let gt;
        let bt;
        let yt;
        let Ct;
        let zt;
        let Tt;
        let At;
        let Et;
        let Pt;
        let Lt;
        let Ot;
        let Rt;
        let $t;
        let Ft;
        let Bt;
        let Ht;
        let Wt;
        let Vt;
        let qt;
        let Ut;
        let Zt;
        let Gt;
        let Kt;
        let Yt;
        let Jt;
        let Qt;
        let Xt;
        let ei;
        let ti;
        let ii;
        let ni;
        let oi;
        let si;
        let ai;
        let ri;
        let li;
        let ci;
        let ui;
        let di;
        let hi;
        let pi;
        let mi;
        const fi = this;
        const _i = {};
        const gi = [];
        const vi = [];
        const bi = {};
        const yi = {};
        let wi = {};
        fi.commands = n(!0, {}, t.commands || St);
        const ki = fi.opts = n(!0, {}, vt, t);
        fi.opts.emoticons = t.emoticons || vt.emoticons, Tt = () => {
            e._sceditor = fi, ki.locale && "en" !== ki.locale && Rt(), a = r("div", {
                className: "sceditor-container"
            }), z(a, e), y(a, "z-index", ki.zIndex), jt && A(a, `ie ie${jt}`), ht = e.required, e
              .required = !1;
            const t = lt.formats[ki.format];
            i = t ? new t : {}, "init" in i && i.init.call(fi), Ot(), Wt(), $t(), Lt(), Ft(), Bt(), xt ||
            fi.toggleSourceMode(), ti();
            const n = () => {
                m(It, "load", n), ki.autofocus && ai(), mi(), ni(), Y.call("ready"), "onReady" in i &&
                i.onReady.call(fi)
            };
            p(It, "load", n), "complete" === Mt.readyState && n()
        }, Ot = () => {
            let e = ki.plugins;
            e = e ? e.toString()
              .split(",") : [], Y = new nt(fi), e.forEach(e => {
                Y.register(e.trim())
            })
        }, Rt = () => {
            let e;
            U = lt.locale[ki.locale], U || (e = ki.locale.split("-"), U = lt.locale[e[0]]), U && U
              .dateFormat && (ki.dateFormat = U.dateFormat)
        }, Lt = () => {
            N = r("textarea"), _ = r("iframe", {
                frameborder: 0,
                allowfullscreen: !0
            }), ki.startInSourceMode ? (A(a, "sourceMode"), g(_)) : (A(a, "wysiwygMode"), g(N)), ki
              .spellcheck || f(a, "spellcheck", "false"), "https:" === It.location.protocol && f(_,
              "src", "javascript:false"), d(a, _), d(a, N), fi.dimensions(ki.width || I(e), ki
              .height || M(e));
            let t = jt ? `ie ie${jt}` : "";
            t += kt ? " ios" : "", T = _.contentDocument, T.open(), T.write(tt("html", {
                attrs: ` class="${t}"`,
                spellcheck: ki.spellcheck ? "" : 'spellcheck="false"',
                charset: ki.charset,
                style: ki.style
            })), T.close(), C = T.body, x = _.contentWindow, fi.readOnly(!!ki.readOnly), (kt || wt ||
              jt) && (M(C, "100%"), jt || p(C, "touchend", fi.focus));
            const i = f(e, "tabindex");
            f(N, "tabindex", i), f(_, "tabindex", i), G = new ot(x), g(e), fi.val(e.value);
            const n = ki.placeholder || f(e, "placeholder");
            n && (N.placeholder = n, f(C, "placeholder", n))
        }, Ft = () => {
            ki.autoUpdate && (p(C, "blur", pi), p(N, "blur", pi)), null === ki.rtl && (ki.rtl = "rtl" ===
              y(N, "direction")), fi.rtl(!!ki.rtl), ki.autoExpand && (p(C, "load", mi, _t), p(C,
              "input keyup", mi)), ki.resizeEnabled && Ht(), f(a, "id", ki.id), fi.emoticons(ki
              .emoticonsEnabled)
        }, Bt = () => {
            const t = e.form;
            const i = "compositionstart compositionend";
            const n = "keydown keyup keypress focus blur contextmenu";

            const o = "onselectionchange" in T ? "selectionchange" :
              "keyup focus blur contextmenu mouseup touchend click";

            p(Mt, "click", Xt), t && (p(t, "reset", Kt), p(t, "submit", fi.updateOriginal, _t)), p(C,
              "keypress", Gt), p(C, "keydown", Ut), p(C, "keydown", Zt), p(C, "keyup", ni), p(C,
              "blur", di), p(C, "keyup", hi), p(C, "paste", Vt), p(C, i, Jt), p(C, o, oi), p(C, n,
              Qt), ki.emoticonsCompat && It.getSelection && p(C, "keyup", li), p(C, "blur",
              () => {
                  fi.val() || A(C, "placeholder")
              }), p(C, "focus", () => {
                E(C, "placeholder")
            }), p(N, "blur", di), p(N, "keyup", hi), p(N, "keydown", Ut), p(N, i, Jt), p(N, n, Qt), p(
              T, "mousedown", Yt), p(T, o, oi), p(T, "beforedeactivate keyup mouseup", Pt), p(T,
              "keyup", ni), p(T, "focus", () => {
                R = null
            }), p(a, "selectionchanged", si), p(a, "selectionchanged", ti), p(a,
              "selectionchanged valuechanged nodechanged pasteraw paste", Qt)
        }, $t = () => {
            let e;
            const t = fi.commands;

            const i = (ki.toolbarExclude || "")
              .split(",");

            const n = ki.toolbar.split("|");
            l = r("div", {
                className: "sceditor-toolbar",
                unselectable: "on"
            }), ki.icons in lt.icons && (zt = new lt.icons[ki.icons]), s(n, (n, o) => {
                e = r("div", {
                    className: "sceditor-group"
                }), s(o.split(","), (n, o) => {
                    let s;
                    let a;
                    const r = t[o];
                    if (r && !(i.includes(o))) {
                        if (a = r.shortcut, s = tt("toolbarButton", {
                            name: o,
                            dispName: fi._(r.name || r.tooltip || o)
                        }, !0)
                          .firstChild, zt && zt.create) {
                            const l = zt.create(o);
                            l && (z(zt.create(o), s.firstChild), A(s, "has-icon"))
                        }
                        s._sceTxtMode = !!r.txtExec, s._sceWysiwygMode = !!r.exec, P(s,
                          "disabled", !r.exec), p(s, "click", e => {
                            S(s, "disabled") || Et(s, r), ti(), e.preventDefault()
                        }), p(s, "mousedown", e => {
                            fi.closeDropDown(), e.preventDefault()
                        }), r.tooltip && f(s, "title", fi._(r.tooltip) + (a ? ` (${a})` : "")), a && fi.addShortcut(a, o), r.state ? vi
                          .push({
                              name: o,
                              state: r.state
                          }) : ct(r.exec) && vi.push({
                            name: o,
                            state: r.exec
                        }), d(e, s), yi[o] = s
                    }
                }), e.firstChild && d(l, e)
            }), d(ki.toolbarContainer || a, l)
        }, Ht = () => {
            let e;
            let t;
            let i;
            let n;
            let o;
            let s;

            const l = r("div", {
                  className: "sceditor-grip"
              });

            const c = r("div", {
                className: "sceditor-resize-cover"
            });

            const u = "touchmove mousemove";
            const h = "touchcancel touchend mouseup";
            let f = 0;
            let _ = 0;
            let b = 0;
            let y = 0;
            let w = 0;
            let k = 0;
            const x = I(a);
            const C = M(a);
            let z = !1;
            const T = fi.rtl();
            if (e = ki.resizeMinHeight || C / 1.5, t = ki.resizeMaxHeight || 2.5 * C, i = ki
              .resizeMinWidth || x / 1.25, n = ki.resizeMaxWidth || 1.25 * x, o = o => {
                "touchmove" === o.type ? (o = It.event, b = o.changedTouches[0].pageX, y = o
                  .changedTouches[0].pageY) : (b = o.pageX, y = o.pageY);
                let s = k + (y - _);
                let a = T ? w - (b - f) : w + (b - f);
                n > 0 && a > n && (a = n), i > 0 && i > a && (a = i), ki.resizeWidth || (a = !1), t >
                0 && s > t && (s = t), e > 0 && e > s && (s = e), ki.resizeHeight || (s = !1), (
                  a || s) && fi.dimensions(a, s), o.preventDefault()
            }, s = e => {
                z && (z = !1, g(c), E(a, "resizing"), m(Mt, u, o), m(Mt, h, s), e.preventDefault())
            }, zt && zt.create) {
                const S = zt.create("grip");
                S && (d(l, S), A(l, "has-icon"))
            }
            d(a, l), d(a, c), g(c), p(l, "touchstart mousedown", e => {
                "touchstart" === e.type ? (e = It.event, f = e.touches[0].pageX, _ = e.touches[0]
                  .pageY) : (f = e.pageX, _ = e.pageY), w = I(a), k = M(a), z = !0, A(a,
                  "resizing"), v(c), p(Mt, u, o), p(Mt, h, s), e.preventDefault()
            })
        }, Wt = () => {
            const e = ki.emoticons;
            const t = ki.emoticonsRoot || "";
            e && (wi = n({}, e.more, e.dropdown, e.hidden)), s(wi, (e, i) => {
                wi[e] = tt("emoticon", {
                    key: e,
                    url: t + (i.url || i),
                    tooltip: i.tooltip || e
                }), ki.emoticonsEnabled && gi.push(r("img", {
                    src: t + (i.url || i)
                }))
            })
        }, ai = () => {
            let e;
            let t;
            let i = C.firstChild;
            const n = !!ki.autofocusEnd;
            if (D(a)) {
                if (fi.sourceMode()) return t = n ? N.value.length : 0, N.setSelectionRange(t, t), void 0;
                if (Z(C), n)
                    for ((i = C.lastChild) || (i = r("p", {}, T), d(C, i)); i.lastChild;) i = i.lastChild,
                    !Dt && k(i, "br") && i.previousSibling && (i = i.previousSibling);
                e = T.createRange(), B(i) ? e.selectNodeContents(i) : (e.setStartBefore(i), n && e
                  .setStartAfter(i)), e.collapse(!n), G.selectRange(e), et = e, n && (C.scrollTop =
                  C.scrollHeight), fi.focus()
            }
        }, fi.readOnly = e => "boolean" != typeof e ? !N.readonly : (C.contentEditable = !e, N.readonly = !e, ei(e),
          fi), fi.rtl = e => {
            const t = e ? "rtl" : "ltr";
            return "boolean" != typeof e ? "rtl" === f(N, "dir") : (f(C, "dir", t), f(N, "dir", t), E(a,
              "rtl"), E(a, "ltr"), A(a, t), zt && zt.rtl && zt.rtl(e), fi)
        }, ei = e => {
            const t = fi.inSourceMode() ? "_sceTxtMode" : "_sceWysiwygMode";
            s(yi, (i, n) => {
                P(n, "disabled", e || !n[t])
            })
        }, fi.width = (e, t) => e || 0 === e ? (fi.dimensions(e, null, t), fi) : I(a), fi.dimensions = (e, t, i) => (e = e || 0 === e ? e : !1, t = t || 0 === t ? t : !1, e === !1 && t === !1 ? {
            width: fi.width(),
            height: fi.height()
        } : (e !== !1 && (i !== !1 && (ki.width = e), I(a, e)), t !== !1 && (i !== !1 && (ki
          .height = t), M(a, t)), fi)), fi.height = (e, t) => e || 0 === e ? (fi.dimensions(null, e, t), fi) : M(a), fi.maximize = e => {
            const t = "sceditor-maximize";
            return ut(e) ? S(a, t) : (e = !!e, e && (yt = It.pageYOffset), P(Mt.documentElement, t, e), P(
              Mt.body, t, e), P(a, t, e), fi.width(e ? "100%" : ki.width, !1), fi.height(e ?
              "100%" : ki.height, !1), e || It.scrollTo(0, yt), mi(), fi)
        }, mi = () => {
            ki.autoExpand && !bt && (bt = setTimeout(fi.expandToContent, 200))
        }, fi.expandToContent = t => {
            if (!fi.maximize()) {
                if (clearTimeout(bt), bt = !1, !gt) {
                    const i = ki.resizeMinHeight || ki.height || M(e);
                    gt = {
                        min: i,
                        max: ki.resizeMaxHeight || 2 * i
                    }
                }
                const n = Mt.createRange();
                n.selectNodeContents(C);
                const o = n.getBoundingClientRect();
                const s = T.documentElement.clientHeight - 1;
                const a = o.bottom - o.top;
                let r = fi.height() + 1 + (a - s);
                t || -1 === gt.max || (r = Math.min(r, gt.max)), fi.height(Math.ceil(Math.max(r, gt.min)))
            }
        }, fi.destroy = () => {
            if (Y) {
                Y.destroy(), G = null, R = null, Y = null, L && u(L), m(Mt, "click", Xt);
                const t = e.form;
                t && (m(t, "reset", Kt), m(t, "submit", fi.updateOriginal)), u(N), u(l), u(a), delete e
                  ._sceditor, v(e), e.required = ht
            }
        }, fi.createDropDown = ({offsetTop, offsetLeft, clientHeight}, t, i, o) => {
            let l;
            const c = `sceditor-${t}`;
            fi.closeDropDown(!0), L && S(L, c) || (o !== !1 && s(h(i, ":not(input):not(textarea)"),
              (e, t) => {
                  t.nodeType === mt && f(t, "unselectable", "on")
              }), l = n({
                top: offsetTop,
                left: offsetLeft,
                marginTop: clientHeight
            }, ki.dropDownCss), L = r("div", {
                className: `sceditor-dropdown ${c}`
            }), y(L, l), d(L, i), d(a, L), p(L, "click focusin", e => {
                e.stopPropagation()
            }), setTimeout(() => {
                if (L) {
                    const e = h(L, "input,textarea")[0];
                    e && e.focus()
                }
            }))
        }, Xt = ({which, defaultPrevented}) => {
            3 !== which && L && !defaultPrevented && (pi(), fi.closeDropDown())
        }, Vt = e => {
            const t = jt || wt;
            const i = C;
            const n = e.clipboardData;

            const o = e => {
                const t = new FileReader;
                t.onload = e => {
                    qt({
                        html: `<img src="${e.target.result}" />`
                    })
                }, t.readAsDataURL(e)
            };

            if (n && !t) {
                const s = {};
                const a = n.types;
                const r = n.items;
                e.preventDefault();
                for (let l = 0; l < a.length; l++) {
                    if (It.FileReader && r && Nt.test(r[l].type)) return o(n.items[l].getAsFile());
                    s[a[l]] = n.getData(a[l])
                }
                s.text = s["text/plain"], s.html = s["text/html"], qt(s)
            } else if (!Ct) {
                const c = i.scrollTop;
                for (G.saveRange(), Ct = Mt.createDocumentFragment(); i.firstChild;) d(Ct, i.firstChild);
                setTimeout(() => {
                    const e = i.innerHTML;
                    i.innerHTML = "", d(i, Ct), i.scrollTop = c, Ct = !1, G.restoreRange(), qt({
                        html: e
                    })
                }, 0)
            }
        }, qt = e => {
            const t = r("div", {}, T);
            Y.call("pasteRaw", e), j(a, "pasteraw", e), e.html ? (t.innerHTML = e.html, V(t)) : t
              .innerHTML = X(e.text || "");
            const n = {
                val: t.innerHTML
            };
            "fragmentToSource" in i && (n.val = i.fragmentToSource(n.val, T, J)), Y.call("paste", n), j(a,
              "paste", n), "fragmentToHtml" in i && (n.val = i.fragmentToHtml(n.val, J)), Y.call(
              "pasteHtml", n), fi.wysiwygEditorInsertHtml(n.val, null, !0)
        }, fi.closeDropDown = e => {
            L && (u(L), L = null), e === !0 && fi.focus()
        }, fi.wysiwygEditorInsertHtml = (e, t, i) => {
            let n;
            let o;
            let s;
            const a = M(_);
            fi.focus(), (i || !c(Q, "code")) && (G.insertHTML(e, t), G.saveRange(), At(), n = h(C,
              "#sceditor-end-marker")[0], v(n), o = C.scrollTop, s = K(n)
              .top + 1.5 * n.offsetHeight - a, g(n), (s > o || o > s + a) && (C.scrollTop = s), ui(!
              1), G.restoreRange(), ni())
        }, fi.wysiwygEditorInsertText = (e, t) => {
            fi.wysiwygEditorInsertHtml(X(e), X(t))
        }, fi.insertText = (e, t) => (fi.inSourceMode() ? fi.sourceEditorInsertText(e, t) : fi.wysiwygEditorInsertText(e, t), fi), fi.sourceEditorInsertText = (e, t) => {
            let i;
            let n;
            const o = N.selectionStart;
            const s = N.selectionEnd;
            i = N.scrollTop, N.focus(), n = N.value, t && (e += n.substring(o, s) + t), N.value = n
              .substring(0, o) + e + n.substring(s, n.length), N.selectionStart = o + e.length - (t ? t
              .length : 0), N.selectionEnd = N.selectionStart, N.scrollTop = i, N.focus(), ui()
        }, fi.getRangeHelper = () => G, fi.sourceEditorCaret = function (e) {
            return N.focus(), e ? (N.selectionStart = e.start, N.selectionEnd = e.end, this) : {
                start: N.selectionStart,
                end: N.selectionEnd
            }
        }, fi.val = (e, t) => ct(e) ? (fi.inSourceMode() ? fi.setSourceEditorValue(e) : (t !== !1 && "toHtml" in i &&
        (e = i.toHtml(e)), fi.setWysiwygEditorValue(e)), fi) : fi.inSourceMode() ? fi
          .getSourceEditorValue(!1) : fi.getWysiwygEditorValue(t), fi.insert = (e, t, n, o, s) => {
            if (fi.inSourceMode()) return fi.sourceEditorInsertText(e, t), fi;
            if (t) {
                let a = G.selectedHtml();
                n !== !1 && "fragmentToSource" in i && (a = i.fragmentToSource(a, T, J)), e += a + t
            }
            return n !== !1 && "fragmentToHtml" in i && (e = i.fragmentToHtml(e, J)), n !== !1 && s === !
              0 && (e = e.replace(/&lt;/g, "<")
              .replace(/&gt;/g, ">")
              .replace(/&amp;/g, "&")), fi.wysiwygEditorInsertHtml(e), fi
        }, fi.getWysiwygEditorValue = e => {
            for (var t, n = r("div", {}, T), o = C.childNodes, s = 0; s < o.length; s++) d(n, o[s]
              .cloneNode(!0));
            return d(C, n), V(n), u(n), t = n.innerHTML, e !== !1 && i.hasOwnProperty("toSource") && (t =
              i.toSource(t, T)), t
        }, fi.getBody = () => C, fi.getContentAreaContainer = () => _, fi.getSourceEditorValue = e => {
            let t = N.value;
            return e !== !1 && "toHtml" in i && (t = i.toHtml(t)), t
        }, fi.setWysiwygEditorValue = e => {
            e || (e = `<p>${jt ? "" : "<br />"}</p>`), C.innerHTML = e, At(), ni(), ui(), mi()
        }, fi.setSourceEditorValue = e => {
            N.value = e, ui()
        }, fi.updateOriginal = () => {
            e.value = fi.val()
        }, At = () => {
            ki.emoticonsEnabled && at(C, wi, ki.emoticonsCompat)
        }, fi.inSourceMode = () => S(a, "sourceMode"), fi.sourceMode = e => {
            const t = fi.inSourceMode();
            return "boolean" != typeof e ? t : ((t && !e || !t && e) && fi.toggleSourceMode(), fi)
        }, fi.toggleSourceMode = () => {
            const e = fi.inSourceMode();
            (xt || !e) && (e || (G.saveRange(), G.clear()), fi.blur(), e ? fi.setWysiwygEditorValue(fi
              .getSourceEditorValue()) : fi.setSourceEditorValue(fi.getWysiwygEditorValue()), R =
              null, b(N), b(_), P(a, "wysiwygMode", e), P(a, "sourceMode", !e), ei(), ti())
        }, ii = () => (N.focus(), N.value.substring(N.selectionStart, N.selectionEnd)), Et = (e, t) => {
            fi.inSourceMode() ? t.txtExec && (Array.isArray(t.txtExec) ? fi.sourceEditorInsertText(...t.txtExec) : t.txtExec.call(fi, e, ii())) : t.exec && (dt(t.exec) ? t.exec.call(
              fi, e) : fi.execCommand(t.exec, t.hasOwnProperty("execParam") ? t.execParam :
              null))
        }, Pt = () => {
            jt && (R = G.selectedRange())
        }, fi.execCommand = (e, t) => {
            let i = !1;
            const n = fi.commands[e];
            if (fi.focus(), !c(G.parentNode(), "code")) {
                try {
                    i = T.execCommand(e, !1, t)
                } catch (o) {}!i && n && n.errorMessage && alert(fi._(n.errorMessage)), ti()
            }
        }, oi = () => {
            function e() {
                if (x.getSelection() && x.getSelection()
                  .rangeCount <= 0) et = null;
                else if (G && !G.compare(et)) {
                    if (et = G.cloneSelected(), et && et.collapsed) {
                        let e = et.startContainer;
                        const t = et.startOffset;
                        for (t && e.nodeType !== ft && (e = e.childNodes[t]); e && e.parentNode !== C;)
                            e = e.parentNode;
                        e && H(e, !0) && (G.saveRange(), rt(C, T), G.restoreRange())
                    }
                    j(a, "selectionchanged")
                }
                it = !1
            }
            it || (it = !0, "onselectionchange" in T ? e() : setTimeout(e, 100))
        }, si = () => {
            let e;
            const t = G.parentNode();
            J !== t && (e = J, J = t, Q = G.getFirstBlockParent(t), j(a, "nodechanged", {
                oldNode: e,
                newNode: J
            }))
        }, fi.currentNode = () => J, fi.currentBlockNode = () => Q, ti = () => {
            let e;
            let t;
            const i = "active";
            const n = T;
            const o = fi.sourceMode();
            if (fi.readOnly()) return s(h(l, i), (e, t) => {
                E(t, i)
            }), void 0;
            o || (t = G.parentNode(), e = G.getFirstBlockParent(t));
            for (let a = 0; a < vi.length; a++) {
                let r = 0;
                const c = yi[vi[a].name];
                const u = vi[a].state;
                const d = o && !c._sceTxtMode || !o && !c._sceWysiwygMode;
                if (ct(u)) {
                    if (!o) try {
                        r = n.queryCommandEnabled(u) ? 0 : -1, r > -1 && (r = n.queryCommandState(u) ?
                          1 : 0)
                    } catch (p) {}
                } else d || (r = u.call(fi, t, e));
                P(c, "disabled", d || 0 > r), P(c, i, r > 0)
            }
            zt && zt.update && zt.update(o, t, e)
        }, Gt = e => {
            if (!e.defaultPrevented && (fi.closeDropDown(), 13 === e.which)) {
                const t = "li,ul,ol";
                if (!k(Q, t) && $(Q)) {
                    R = null;
                    const i = r("br", {}, T);
                    if (G.insertNode(i), !Dt) {
                        const n = i.parentNode;
                        let o = n.lastChild;
                        o && o.nodeType === ft && "" === o.nodeValue && (u(o), o = n.lastChild), !H(n, !
                          0) && o === i && H(i.previousSibling) && G.insertHTML("<br>")
                    }
                    e.preventDefault()
                }
            }
        }, ni = () => {
            O(C, e => {
                if (e.nodeType === mt && !/inline/.test(y(e, "display")) && !k(e,
                  ".sceditor-nlf") && $(e)) {
                    const t = r("p", {}, T);
                    return t.className = "sceditor-nlf", t.innerHTML = Dt ? "" : "<br />", d(C,
                      t), !1
                }
                return 3 === e.nodeType && !/^\s*$/.test(e.nodeValue) || k(e, "br") ? !1 : void 0
            })
        }, Kt = () => {
            fi.val(e.value)
        }, Yt = () => {
            fi.closeDropDown(), R = null
        }, fi._ = function(...args) {
            let e;
            const t = args;
            return U && U[t[0]] && (t[0] = U[t[0]]), t[0].replace(/\{(\d+)\}/g, (i, n) => t[n - 0 + 1] !== e ? t[n - 0 + 1] : `{${n}}`);
        }, Qt = e => {
            Y && Y.call(`${e.type}Event`, e, fi);
            const t = (e.target === N ? "scesrc" : "scewys") + e.type;
            _i[t] && _i[t].forEach(t => {
                t.call(fi, e)
            })
        }, fi.bind = (e, t, i, n) => {
            e = e.split(" ");
            for (let o = e.length; o--;)
                if (dt(t)) {
                    const s = `scewys${e[o]}`;
                    const a = `scesrc${e[o]}`;
                    i || (_i[s] = _i[s] || [], _i[s].push(t)), n || (_i[a] = _i[a] || [], _i[a].push(t)),
                    "valuechanged" === e[o] && (ui.hasHandler = !0)
                } return fi
        }, fi.unbind = (e, t, i, n) => {
            e = e.split(" ");
            for (let s = e.length; s--;) dt(t) && (i || o(_i[`scewys${e[s]}`] || [], t), n || o(_i[
            `scesrc${e[s]}`] || [], t));
            return fi
        }, fi.blur = (e, t, i) => (dt(e) ? fi.bind("blur", e, t, i) : fi.sourceMode() ? N.blur() : C.blur(), fi), fi.focus = (e, t, i) => {
            if (dt(e)) fi.bind("focus", e, t, i);
            else if (fi.inSourceMode()) N.focus();
            else {
                if (h(T, ":focus")
                  .length) return;
                let n;
                const o = G.selectedRange();
                et || ai(), !Dt && o && 1 === o.endOffset && o.collapsed && (n = o.endContainer, n &&
                1 === n.childNodes.length && k(n.firstChild, "br") && (o.setStartBefore(n
                  .firstChild), o.collapse(!0), G.selectRange(o))), x.focus(), C.focus(), R && (
                  G.selectRange(R), R = null)
            }
            return ti(), fi
        }, fi.keyDown = (e, t, i) => fi.bind("keydown", e, t, i), fi.keyPress = (e, t, i) => fi.bind("keypress", e, t, i), fi.keyUp = (e, t, i) => fi.bind("keyup", e, t, i), fi.nodeChanged = e => fi.bind("nodechanged", e, !1, !0), fi.selectionChanged = e => fi.bind("selectionchanged", e, !1, !0), fi.valueChanged = (e, t, i) => fi.bind("valuechanged", e, t, i), ri = e => {
            let t;
            let i = 0;
            let n = fi.emoticonsCache;
            const o = String.fromCharCode(e.which);
            c(Q, "code") || (n || (n = [], s(wi, (e, t) => {
                n[i++] = [e, t]
            }), n.sort((e, t) => e[0].length - t[0].length), fi.emoticonsCache = n, fi.longestEmoticonCode = n[n.length - 1][0].length), t = G
              .replaceKeyword(fi.emoticonsCache, !0, !0, fi.longestEmoticonCode, ki.emoticonsCompat,
                o), t && (ki.emoticonsCompat && /^\s$/.test(o) || e.preventDefault()))
        }, li = () => {
            st(Q, G)
        }, fi.emoticons = e => {
            if (!e && e !== !1) return ki.emoticonsEnabled;
            if (ki.emoticonsEnabled = e, e) p(C, "keypress", ri), fi.sourceMode() || (G.saveRange(), At(),
              ui(!1), G.restoreRange());
            else {
                const t = h(C, "img[data-sceditor-emoticon]");
                s(t, (e, t) => {
                    const i = w(t, "sceditor-emoticon");
                    const n = T.createTextNode(i);
                    t.parentNode.replaceChild(n, t)
                }), m(C, "keypress", ri), ui()
            }
            return fi
        }, fi.css = e => (pt || (pt = r("style", {
            id: "inline"
        }, T), d(T.head, pt)), ct(e) ? (pt.styleSheet ? pt.styleSheet.cssText = e : pt.innerHTML =
          e, fi) : pt.styleSheet ? pt.styleSheet.cssText : pt.innerHTML), Ut = e => {
            let t = [];

            const i = {
                "`": "~",
                1: "!",
                2: "@",
                3: "#",
                4: "$",
                5: "%",
                6: "^",
                7: "&",
                8: "*",
                9: "(",
                0: ")",
                "-": "_",
                "=": "+",
                ";": ": ",
                "'": '"',
                ",": "<",
                ".": ">",
                "/": "?",
                "\\": "|",
                "[": "{",
                "]": "}"
            };

            const n = {
                8: "backspace",
                9: "tab",
                13: "enter",
                19: "pause",
                20: "capslock",
                27: "esc",
                32: "space",
                33: "pageup",
                34: "pagedown",
                35: "end",
                36: "home",
                37: "left",
                38: "up",
                39: "right",
                40: "down",
                45: "insert",
                46: "del",
                91: "win",
                92: "win",
                93: "select",
                96: "0",
                97: "1",
                98: "2",
                99: "3",
                100: "4",
                101: "5",
                102: "6",
                103: "7",
                104: "8",
                105: "9",
                106: "*",
                107: "+",
                109: "-",
                110: ".",
                111: "/",
                112: "f1",
                113: "f2",
                114: "f3",
                115: "f4",
                116: "f5",
                117: "f6",
                118: "f7",
                119: "f8",
                120: "f9",
                121: "f10",
                122: "f11",
                123: "f12",
                144: "numlock",
                145: "scrolllock",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'"
            };

            const o = {
                109: "-",
                110: "del",
                111: "/",
                96: "0",
                97: "1",
                98: "2",
                99: "3",
                100: "4",
                101: "5",
                102: "6",
                103: "7",
                104: "8",
                105: "9"
            };

            const s = e.which;

            let a = n[s] || String.fromCharCode(s)
              .toLowerCase();

            (e.ctrlKey || e.metaKey) && t.push("ctrl"), e.altKey && t.push("alt"), e.shiftKey && (t.push(
              "shift"), o[s] ? a = o[s] : i[a] && (a = i[a])), a && (16 > s || s > 18) && t.push(a),
              t = t.join("+"), bi[t] && bi[t].call(fi) === !1 && (e.stopPropagation(), e
              .preventDefault())
        }, fi.addShortcut = (e, t) => (e = e.toLowerCase(), bi[e] = ct(t) ? () => (Et(yi[t], fi.commands[t]), !1) : t, fi), fi.removeShortcut = e => (delete bi[e.toLowerCase()], fi), Zt = e => {
            let t;
            let i;
            let n;
            let o;
            if (!ki.disableBlockRemove && 8 === e.which && (n = G.selectedRange()) && (t = n
              .startContainer, i = n.startOffset, 0 === i && (o = ci()) && !k(o, "body"))) {
                for (; t !== o;) {
                    for (; t.previousSibling;)
                        if (t = t.previousSibling, t.nodeType !== ft || t.nodeValue) return;
                    if (!(t = t.parentNode)) return
                }
                fi.clearBlockFormatting(o), e.preventDefault()
            }
        }, ci = () => {
            for (var e = Q; !$(e) || H(e, !0);)
                if (!(e = e.parentNode) || k(e, "body")) return;
            return e
        }, fi.clearBlockFormatting = e => (e = e || ci(), !e || k(e, "body") ? fi : (G.saveRange(), e.className = "", R = null, f(
          e, "style", ""), k(e, "p,div,td") || F(e, "p"), G.restoreRange(), fi)), ui = e => {
            if (Y && (Y.hasHandler("valuechangedEvent") || ui.hasHandler)) {
                let t;
                const i = fi.sourceMode();
                const n = !i && G.hasSelection();
                W = !1, e = e !== !1 && !T.getElementById("sceditor-start-marker"), q && (clearTimeout(q),
                  q = !1), n && e && G.saveRange(), t = i ? N.value : C.innerHTML, t !== ui
                  .lastVal && (ui.lastVal = t, j(a, "valuechanged", {
                    rawValue: i ? fi.val() : t
                })), n && e && G.removeMarkers()
            }
        }, di = () => {
            q && ui()
        }, hi = ({which}) => {
            const t = which;
            const i = hi.lastChar;
            const n = 13 === i || 32 === i;
            const o = 8 === i || 46 === i;
            hi.lastChar = t, W || (13 === t || 32 === t ? n ? hi.triggerNext = !0 : ui() : 8 === t ||
            46 === t ? o ? hi.triggerNext = !0 : ui() : hi.triggerNext && (ui(), hi
              .triggerNext = !1), clearTimeout(q), q = setTimeout(() => {
                W || ui()
            }, 1500))
        }, Jt = ({type}) => {
            W = /start/i.test(type), W || ui()
        }, pi = () => {
            fi.updateOriginal()
        }, Tt()
    }
    e = e && e.hasOwnProperty("default") ? e["default"] : e;
    var ct = t.bind(null, "string");
    var ut = t.bind(null, "undefined");
    var dt = t.bind(null, "function");
    var ht = t.bind(null, "number");
    var pt = {};
    var mt = 1;
    var ft = 3;
    var _t = !0;

    var gt =
      "|body|hr|p|div|h1|h2|h3|h4|h5|h6|address|pre|form|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|blockquote|center|";

    var vt = {
        toolbar: "bold,italic,underline,strike,subscript,superscript|left,center,right,justify|font,size,color,removeformat|cut,copy,pastetext|bulletlist,orderedlist,indent,outdent|table|code,quote|horizontalrule,image,email,link,unlink|emoticon,youtube,date,time|ltr,rtl|print,maximize,source",
        toolbarExclude: null,
        style: "jquery.sceditor.default.css",
        fonts: "Arial,Arial Black,Comic Sans MS,Courier New,Georgia,Impact,Sans-serif,Serif,Times New Roman,Trebuchet MS,Verdana",
        colors: "#000000,#44B8FF,#1E92F7,#0074D9,#005DC2,#00369B,#b3d5f4|#444444,#C3FFFF,#9DF9FF,#7FDBFF,#68C4E8,#419DC1,#d9f4ff|#666666,#72FF84,#4CEA5E,#2ECC40,#17B529,#008E02,#c0f0c6|#888888,#FFFF44,#FFFA1E,#FFDC00,#E8C500,#C19E00,#fff5b3|#aaaaaa,#FFC95F,#FFA339,#FF851B,#E86E04,#C14700,#ffdbbb|#cccccc,#FF857A,#FF5F54,#FF4136,#E82A1F,#C10300,#ffc6c3|#eeeeee,#FF56FF,#FF30DC,#F012BE,#D900A7,#B20080,#fbb8ec|#ffffff,#F551FF,#CF2BE7,#B10DC9,#9A00B2,#9A00B2,#e8b6ef",
        locale: f(document.documentElement, "lang") || "en",
        charset: "utf-8",
        emoticonsCompat: !1,
        emoticonsEnabled: !0,
        emoticonsRoot: "",
        emoticons: {
            dropdown: {
                ":)": "emoticons/smile.png",
                ":angel:": "emoticons/angel.png",
                ":angry:": "emoticons/angry.png",
                "8-)": "emoticons/cool.png",
                ":'(": "emoticons/cwy.png",
                ":ermm:": "emoticons/ermm.png",
                ":D": "emoticons/grin.png",
                "<3": "emoticons/heart.png",
                ":(": "emoticons/sad.png",
                ":O": "emoticons/shocked.png",
                ":P": "emoticons/tongue.png",
                ";)": "emoticons/wink.png"
            },
            more: {
                ":alien:": "emoticons/alien.png",
                ":blink:": "emoticons/blink.png",
                ":blush:": "emoticons/blush.png",
                ":cheerful:": "emoticons/cheerful.png",
                ":devil:": "emoticons/devil.png",
                ":dizzy:": "emoticons/dizzy.png",
                ":getlost:": "emoticons/getlost.png",
                ":happy:": "emoticons/happy.png",
                ":kissing:": "emoticons/kissing.png",
                ":ninja:": "emoticons/ninja.png",
                ":pinch:": "emoticons/pinch.png",
                ":pouty:": "emoticons/pouty.png",
                ":sick:": "emoticons/sick.png",
                ":sideways:": "emoticons/sideways.png",
                ":silly:": "emoticons/silly.png",
                ":sleeping:": "emoticons/sleeping.png",
                ":unsure:": "emoticons/unsure.png",
                ":woot:": "emoticons/w00t.png",
                ":wassat:": "emoticons/wassat.png"
            },
            hidden: {
                ":whistling:": "emoticons/whistling.png",
                ":love:": "emoticons/wub.png"
            }
        },
        width: null,
        height: null,
        resizeEnabled: !0,
        resizeMinWidth: null,
        resizeMinHeight: null,
        resizeMaxHeight: null,
        resizeMaxWidth: null,
        resizeHeight: !0,
        resizeWidth: !0,
        dateFormat: "year-month-day",
        toolbarContainer: null,
        enablePasteFiltering: !1,
        disablePasting: !1,
        readOnly: !1,
        rtl: !1,
        autofocus: !1,
        autofocusEnd: !0,
        autoExpand: !1,
        autoUpdate: !1,
        spellcheck: !0,
        runWithoutWysiwygSupport: !1,
        startInSourceMode: !1,
        id: null,
        plugins: "",
        zIndex: null,
        bbcodeTrim: !1,
        disableBlockRemove: !1,
        parserOptions: {},
        dropDownCss: {}
    };

    const bt = navigator.userAgent;

    const yt = (() => {
        let e;
        let t = 3;
        const i = document;
        const n = i.createElement("div");
        const o = n.getElementsByTagName("i");
        do n.innerHTML = `<!--[if gt IE ${++t}]><i></i><![endif]-->`; while (o[0]);
        return i.documentMode && i.all && window.atob && (t = 10), 4 === t && i.documentMode && (t = 11),
          t > 4 ? t : e
    })();

    var wt = "-ms-ime-align" in document.documentElement.style;
    var kt = /iPhone|iPod|iPad| wosbrowser\//i.test(bt);

    var xt = (() => {
        let e;
        let t;
        const i = document.createElement("div");
        return i.contentEditable = !0, "contentEditable" in document.documentElement && "true" === i
          .contentEditable ? (t = /Opera Mobi|Opera Mini/i.test(bt), /Android/i.test(bt) && (t = !1),
        / Silk\//i.test(bt) && (e = /AppleWebKit\/(\d+)/.exec(bt), t = e && e[1] ? e[1] < 534 : !
          0), kt && (t = /OS [0-4](_\d)+ like Mac/i.test(bt)), /Firefox/i.test(bt) && (t = !1),
        /OneBrowser/i.test(bt) && (t = !1), "UCWEB" === navigator.vendor && (t = !1), 9 >= yt && (
          t = !0), !t) : !1
    })();

    var Ct =
      /^(https?|s?ftp|mailto|spotify|skype|ssh|teamspeak|tel):|(\/\/)|data:image\/(png|bmp|gif|p?jpe?g);/i;

    var zt = {
        html: '<!DOCTYPE html><html{attrs}><head><style>.ie * {min-height: auto !important} .ie table td {height:15px} @supports (-ms-ime-align:auto) { * { min-height: auto !important; } }</style><meta http-equiv="Content-Type" content="text/html;charset={charset}" /><link rel="stylesheet" type="text/css" href="{style}" /></head><body contenteditable="true" {spellcheck}><p></p></body></html>',
        toolbarButton: '<a class="sceditor-button sceditor-button-{name}" data-sceditor-command="{name}" unselectable="on"><div unselectable="on">{dispName}</div></a>',
        emoticon: '<img src="{url}" data-sceditor-emoticon="{key}" alt="{key}" title="{tooltip}" />',
        fontOpt: '<a class="sceditor-font-option" href="#" data-font="{font}"><font face="{font}">{font}</font></a>',
        sizeOpt: '<a class="sceditor-fontsize-option" data-size="{size}" href="#"><font size="{size}">{size}</font></a>',
        pastetext: '<div><label for="txt">{label}</label> <textarea cols="20" rows="7" id="txt"></textarea></div><div><input type="button" class="button" value="{insert}" /></div>',
        table: '<div><label for="rows">{rows}</label><input type="text" id="rows" value="2" /></div><div><label for="cols">{cols}</label><input type="text" id="cols" value="2" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        image: '<div><label for="link">{url}</label> <input type="text" id="image" dir="ltr" placeholder="https://" /></div><div><label for="width">{width}</label> <input type="text" id="width" size="2" dir="ltr" /></div><div><label for="height">{height}</label> <input type="text" id="height" size="2" dir="ltr" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        email: '<div><label for="email">{label}</label> <input type="text" id="email" dir="ltr" /></div><div><label for="des">{desc}</label> <input type="text" id="des" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        link: '<div><label for="link">{url}</label> <input type="text" id="link" dir="ltr" placeholder="https://" /></div><div><label for="des">{desc}</label> <input type="text" id="des" /></div><div><input type="button" class="button" value="{ins}" /></div>',
        youtubeMenu: '<div><label for="link">{label}</label> <input type="text" id="link" dir="ltr" placeholder="https://" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        youtube: '<iframe width="560" height="315" frameborder="0" allowfullscreen src="https://www.youtube.com/embed/{id}?wmode=opaque&start={time}" data-youtube-id="{id}"></iframe>'
    };

    const Tt = yt && 11 > yt;

    var St = {
        bold: {
            exec: "bold",
            tooltip: "Bold",
            shortcut: "Ctrl+B"
        },
        italic: {
            exec: "italic",
            tooltip: "Italic",
            shortcut: "Ctrl+I"
        },
        underline: {
            exec: "underline",
            tooltip: "Underline",
            shortcut: "Ctrl+U"
        },
        strike: {
            exec: "strikethrough",
            tooltip: "Strikethrough"
        },
        subscript: {
            exec: "subscript",
            tooltip: "Subscript"
        },
        superscript: {
            exec: "superscript",
            tooltip: "Superscript"
        },
        left: {
            state(e) {
                if (e && 3 === e.nodeType && (e = e.parentNode), e) {
                    const t = "ltr" === y(e, "direction"), i = y(e, "textAlign");
                    return "left" === i || i === (t ? "start" : "end")
                }
            },
            exec: "justifyleft",
            tooltip: "Align left"
        },
        center: {
            exec: "justifycenter",
            tooltip: "Center"
        },
        right: {
            state(e) {
                if (e && 3 === e.nodeType && (e = e.parentNode), e) {
                    const t = "ltr" === y(e, "direction"), i = y(e, "textAlign");
                    return "right" === i || i === (t ? "end" : "start")
                }
            },
            exec: "justifyright",
            tooltip: "Align right"
        },
        justify: {
            exec: "justifyfull",
            tooltip: "Justify"
        },
        font: {
            _dropDown(e, t, i) {
                const n = r("div");
                p(n, "click", "a", function (t) {
                    i(w(this, "font")), e.closeDropDown(!0), t.preventDefault()
                }), e.opts.fonts.split(",")
                  .forEach(e => {
                      d(n, tt("fontOpt", {
                          font: e
                      }, !0))
                  }), e.createDropDown(t, "font-picker", n)
            },
            exec(e) {
                const t = this;
                St.font._dropDown(t, e, e => {
                    t.execCommand("fontname", e)
                })
            },
            tooltip: "Font Name"
        },
        size: {
            _dropDown(e, t, i) {
                const n = r("div");
                p(n, "click", "a", function (t) {
                    i(w(this, "size")), e.closeDropDown(!0), t.preventDefault()
                });
                for (let o = 1; 7 >= o; o++) d(n, tt("sizeOpt", {
                    size: o
                }, !0));
                e.createDropDown(t, "fontsize-picker", n)
            },
            exec(e) {
                const t = this;
                St.size._dropDown(t, e, e => {
                    t.execCommand("fontsize", e)
                })
            },
            tooltip: "Font Size"
        },
        color: {
            _dropDown(e, t, i) {
                const n = r("div");
                let o = "";
                const s = St.color;
                s._htmlCache || (e.opts.colors.split("|")
                  .forEach(e => {
                      o += '<div class="sceditor-color-column">', e.split(",")
                        .forEach(e => {
                            o += `<a href="#" class="sceditor-color-option" style="background-color: ${e}" data-color="${e}"></a>`
                        }), o += "</div>"
                  }), s._htmlCache = o), d(n, R(s._htmlCache)), p(n, "click", "a", function (
                  t) {
                    i(w(this, "color")), e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "color-picker", n)
            },
            exec(e) {
                const t = this;
                St.color._dropDown(t, e, e => {
                    t.execCommand("forecolor", e)
                })
            },
            tooltip: "Font Color"
        },
        removeformat: {
            exec: "removeformat",
            tooltip: "Remove Formatting"
        },
        cut: {
            exec: "cut",
            tooltip: "Cut",
            errorMessage: "Your browser does not allow the cut command. Please use the keyboard shortcut Ctrl/Cmd-X"
        },
        copy: {
            exec: "copy",
            tooltip: "Copy",
            errorMessage: "Your browser does not allow the copy command. Please use the keyboard shortcut Ctrl/Cmd-C"
        },
        paste: {
            exec: "paste",
            tooltip: "Paste",
            errorMessage: "Your browser does not allow the paste command. Please use the keyboard shortcut Ctrl/Cmd-V"
        },
        pastetext: {
            exec(e) {
                let t;
                const i = r("div");
                const n = this;
                d(i, tt("pastetext", {
                    label: n._("Paste your text inside the following box:"),
                    insert: n._("Insert")
                }, !0)), p(i, "click", ".button", e => {
                    t = h(i, "#txt")[0].value, t && n.wysiwygEditorInsertText(t), n
                      .closeDropDown(!0), e.preventDefault()
                }), n.createDropDown(e, "pastetext", i)
            },
            tooltip: "Paste Text"
        },
        bulletlist: {
            exec() {
                it(this), this.execCommand("insertunorderedlist")
            },
            tooltip: "Bullet list"
        },
        orderedlist: {
            exec() {
                it(this), this.execCommand("insertorderedlist")
            },
            tooltip: "Numbered list"
        },
        indent: {
            state(e, t) {
                let i, n, o;
                return k(t, "li") ? 0 : k(t, "ul,ol,menu") && (i = this.getRangeHelper()
                  .selectedRange(), n = i.startContainer.parentNode, o = i.endContainer
                  .parentNode, n !== n.parentNode.firstElementChild || k(o, "li") && o !== o
                  .parentNode.lastElementChild) ? 0 : -1
            },
            exec() {
                const e = this,
                      t = e.getRangeHelper()
                        .getFirstBlockParent();
                e.focus(), c(t, "ul,ol,menu") && e.execCommand("indent")
            },
            tooltip: "Add indent"
        },
        outdent: {
            state(e, t) {
                return c(t, "ul,ol,menu") ? 0 : -1
            },
            exec() {
                const e = this.getRangeHelper()
                  .getFirstBlockParent();
                c(e, "ul,ol,menu") && this.execCommand("outdent")
            },
            tooltip: "Remove one indent"
        },
        table: {
            exec(e) {
                const t = this, i = r("div");
                d(i, tt("table", {
                    rows: t._("Rows:"),
                    cols: t._("Cols:"),
                    insert: t._("Insert")
                }, !0)), p(i, "click", ".button", e => {
                    const n = Number(h(i, "#rows")[0].value);
                    const o = Number(h(i, "#cols")[0].value);
                    let s = "<table>";
                    n > 0 && o > 0 && (s += Array(n + 1)
                      .join(`<tr>${Array(o + 1)
    .join(`<td>${Tt ? "" : "<br />"}</td>`)}</tr>`),
                      s += "</table>", t.wysiwygEditorInsertHtml(s), t.closeDropDown(!
                      0), e.preventDefault())
                }), t.createDropDown(e, "inserttable", i)
            },
            tooltip: "Insert a table"
        },
        horizontalrule: {
            exec: "inserthorizontalrule",
            tooltip: "Insert a horizontal rule"
        },
        code: {
            exec() {
                this.wysiwygEditorInsertHtml("<code>", `${Tt ? "" : "<br />"}</code>`)
            },
            tooltip: "Code"
        },
        image: {
            _dropDown(e, t, i, n) {
                const o = r("div");
                d(o, tt("image", {
                    url: e._("URL:"),
                    width: e._("Width (optional):"),
                    height: e._("Height (optional):"),
                    insert: e._("Insert")
                }, !0));
                const s = h(o, "#image")[0];
                s.value = i, p(o, "click", ".button", t => {
                    s.value && n(s.value, h(o, "#width")[0].value, h(o, "#height")[0].value),
                      e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertimage", o)
            },
            exec(e) {
                const t = this;
                St.image._dropDown(t, e, "", (e, i, n) => {
                    let o = "";
                    i && (o += ` width="${i}"`), n && (o += ` height="${n}"`), t
                      .wysiwygEditorInsertHtml(`<img${o} src="${e}" />`)
                })
            },
            tooltip: "Insert an image"
        },
        email: {
            _dropDown(e, t, i) {
                const n = r("div");
                d(n, tt("email", {
                    label: e._("E-mail:"),
                    desc: e._("Description (optional):"),
                    insert: e._("Insert")
                }, !0)), p(n, "click", ".button", t => {
                    const o = h(n, "#email")[0].value;
                    o && i(o, h(n, "#des")[0].value), e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertemail", n)
            },
            exec(e) {
                const t = this;
                St.email._dropDown(t, e, (e, i) => {
                    t.focus(), !t.getRangeHelper()
                      .selectedHtml() || i ? t.wysiwygEditorInsertHtml(`<a href="mailto:${e}">${i || e}</a>`) : t.execCommand("createlink",
                      `mailto:${e}`)
                })
            },
            tooltip: "Insert an email"
        },
        link: {
            _dropDown(e, t, i) {
                function n(t) {
                    s.value && i(s.value, h(o, "#des")[0].value), e.closeDropDown(!0), t
                      .preventDefault()
                }
                var o = r("div");
                d(o, tt("link", {
                    url: e._("URL:"),
                    desc: e._("Description (optional):"),
                    ins: e._("Insert")
                }, !0));
                var s = h(o, "#link")[0];
                p(o, "click", ".button", n), p(o, "keypress", e => {
                    13 === e.which && s.value && n(e)
                }, _t), e.createDropDown(t, "insertlink", o)
            },
            exec(e) {
                const t = this;
                St.link._dropDown(t, e, (e, i) => {
                    t.focus(), i || !t.getRangeHelper()
                      .selectedHtml() ? (i = i || e, t.wysiwygEditorInsertHtml(`<a href="${e}">${i}</a>`)) : t.execCommand("createlink", e)
                })
            },
            tooltip: "Insert a link"
        },
        unlink: {
            state() {
                return c(this.currentNode(), "a") ? 0 : -1
            },
            exec() {
                const e = c(this.currentNode(), "a");
                if (e) {
                    for (; e.firstChild;) z(e.firstChild, e);
                    u(e)
                }
            },
            tooltip: "Unlink"
        },
        quote: {
            exec(e, t, i) {
                let n = "<blockquote>", o = "</blockquote>";
                t ? (i = i ? `<cite>${i}</cite>` : "", n = n + i + t + o, o = null) : "" === this
                  .getRangeHelper()
                  .selectedHtml() && (o = (Tt ? "" : "<br />") + o), this.wysiwygEditorInsertHtml(n,
                  o)
            },
            tooltip: "Insert a Quote"
        },
        emoticon: {
            exec(e) {
                const t = this,
                      i = o => {
                          let a;
                          const l = t.opts;
                          const c = l.emoticonsRoot || "";
                          const u = l.emoticonsCompat;
                          const h = t.getRangeHelper();
                          const m = u && " " !== h.getOuterText(!0, 1) ? " " : "";
                          const _ = u && " " !== h.getOuterText(!1, 1) ? " " : "";
                          const g = r("div");
                          let v = r("div");
                          let b = 0;
                          const y = n({}, l.emoticons.dropdown, o ? l.emoticons.more : {});
                          return d(g, v), b = Math.sqrt(Object.keys(y)
                            .length), p(g, "click", "img", function (e) {
                              t.insert(m + f(this, "alt") + _, null, !1)
                                .closeDropDown(!0), e.preventDefault()
                          }), s(y, (e, t) => {
                              d(v, r("img", {
                                  src: c + (t.url || t),
                                  alt: e,
                                  title: t.tooltip || e
                              })), v.children.length >= b && (v = r("div"), d(g, v))
                          }), !o && l.emoticons.more && (a = r("a", {
                              className: "sceditor-more"
                          }), d(a, document.createTextNode(t._("More"))), p(a, "click",
                            n => {
                                t.createDropDown(e, "more-emoticons", i(!0)), n
                                  .preventDefault()
                            }), d(g, a)), g;
                      };
                t.createDropDown(e, "emoticons", i(!1))
            },
            txtExec(e) {
                St.emoticon.exec.call(this, e)
            },
            tooltip: "Insert an emoticon"
        },
        youtube: {
            _dropDown(e, t, i) {
                const n = r("div");
                d(n, tt("youtubeMenu", {
                    label: e._("Video URL:"),
                    insert: e._("Insert")
                }, !0)), p(n, "click", ".button", t => {
                    const o = h(n, "#link")[0].value;
                    const a = o.match(/(?:v=|v\/|embed\/|youtu.be\/)(.{11})/);
                    const r = o.match(/[&|?](?:star)?t=((\d+[hms]?){1,3})/);
                    let l = 0;
                    r && s(r[1].split(/[hms]/), (e, t) => {
                        "" !== t && (l = 60 * l + Number(t))
                    }), a && /^[a-zA-Z0-9_\-]{11}$/.test(a[1]) && i(a[1], l), e
                      .closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertlink", n)
            },
            exec(e) {
                const t = this;
                St.youtube._dropDown(t, e, (e, i) => {
                    t.wysiwygEditorInsertHtml(tt("youtube", {
                        id: e,
                        time: i
                    }))
                })
            },
            tooltip: "Insert a YouTube video"
        },
        date: {
            _date({opts}) {
                const t = new Date;
                let i = t.getYear();
                let n = t.getMonth() + 1;
                let o = t.getDate();
                return 2e3 > i && (i = 1900 + i), 10 > n && (n = `0${n}`), 10 > o && (o = `0${o}`), opts.dateFormat.replace(/year/i, i)
                  .replace(/month/i, n)
                  .replace(/day/i, o);
            },
            exec() {
                this.insertText(St.date._date(this))
            },
            txtExec() {
                this.insertText(St.date._date(this))
            },
            tooltip: "Insert current date"
        },
        time: {
            _time() {
                const e = new Date;
                let t = e.getHours();
                let i = e.getMinutes();
                let n = e.getSeconds();
                return 10 > t && (t = `0${t}`), 10 > i && (i = `0${i}`), 10 > n && (n = `0${n}`), `${t}:${i}:${n}`;
            },
            exec() {
                this.insertText(St.time._time())
            },
            txtExec() {
                this.insertText(St.time._time())
            },
            tooltip: "Insert current time"
        },
        ltr: {
            state(e, t) {
                return t && "ltr" === t.style.direction
            },
            exec() {
                const e = this;
                const t = e.getRangeHelper();
                let i = t.getFirstBlockParent();
                if (e.focus(), i && !k(i, "body") || (e.execCommand("formatBlock", "p"), i = t
                  .getFirstBlockParent(), i && !k(i, "body"))) {
                    const n = "ltr" === y(i, "direction") ? "" : "ltr";
                    y(i, "direction", n)
                }
            },
            tooltip: "Left-to-Right"
        },
        rtl: {
            state(e, t) {
                return t && "rtl" === t.style.direction
            },
            exec() {
                const e = this;
                const t = e.getRangeHelper();
                let i = t.getFirstBlockParent();
                if (e.focus(), i && !k(i, "body") || (e.execCommand("formatBlock", "p"), i = t
                  .getFirstBlockParent(), i && !k(i, "body"))) {
                    const n = "rtl" === y(i, "direction") ? "" : "rtl";
                    y(i, "direction", n)
                }
            },
            tooltip: "Right-to-Left"
        },
        print: {
            exec: "print",
            tooltip: "Print"
        },
        maximize: {
            state() {
                return this.maximize()
            },
            exec() {
                this.maximize(!this.maximize())
            },
            txtExec() {
                this.maximize(!this.maximize())
            },
            tooltip: "Maximize",
            shortcut: "Ctrl+Shift+M"
        },
        source: {
            state() {
                return this.sourceMode()
            },
            exec() {
                this.toggleSourceMode()
            },
            txtExec() {
                this.toggleSourceMode()
            },
            tooltip: "View source",
            shortcut: "Ctrl+Shift+S"
        },
        ignore: {}
    };

    var At = {};
    nt.plugins = At;
    var Et = yt && 11 > yt;

    var Pt = ({startContainer, startOffset}, t, i) => {
        let n, o, s, a, r, l = "", c = startContainer, u = startOffset;
        for (c && 3 !== c.nodeType && (c = c.childNodes[u], u = 0), s = a = u; i > l.length && c && 3 ===
        c.nodeType;) n = c.nodeValue, o = i - l.length, r && (a = n.length, s = 0), r = c, t ? (s =
          Math.max(a - o, 0), u = s, l = n.substr(s, a - s) + l, c = r.previousSibling) : (a = Math
          .min(o, n.length), u = s + a, l += n.substr(s, a), c = r.nextSibling);
        return {
            node: r || c,
            offset: u,
            text: l
        }
    };

    var It = window;
    var Mt = document;
    var jt = yt;
    var Dt = jt && 11 > jt;
    var Nt = /^image\/(p?jpe?g|gif|png|bmp)$/i;
    lt.locale = {}, lt.formats = {}, lt.icons = {}, lt.command = {
        get(e) {
            return St[e] || null
        },
        set(e, t) {
            return e && t ? (t = n(St[e] || {}, t), t.remove = () => {
                lt.command.remove(e)
            }, St[e] = t, this) : !1;
        },
        remove(e) {
            return St[e] && delete St[e], this
        }
    },
      /**
       * SCEditor
       * http://www.sceditor.com/
       *
       * Copyright (C) 2017, Sam Clarke (samclarke.com)
       *
       * SCEditor is licensed under the MIT license:
       *	http://www.opensource.org/licenses/mit-license.php
       *
       * @fileoverview SCEditor - A lightweight WYSIWYG BBCode and HTML editor
       * @author Sam Clarke
       */
      window.sceditor = {
          command: lt.command,
          commands: St,
          defaultOptions: vt,
          ie: yt,
          ios: kt,
          isWysiwygSupported: xt,
          regexEscape: Q,
          escapeEntities: X,
          escapeUriScheme: et,
          dom: {
              css: y,
              attr: f,
              removeAttr: _,
              is: k,
              closest: c,
              width: I,
              height: M,
              traverse: L,
              rTraverse: O,
              parseHTML: R,
              hasStyling: $,
              convertElement: F,
              blockLevelList: gt,
              canHaveChildren: B,
              isInline: H,
              copyCSS: W,
              fixNesting: V,
              findCommonAncestor: q,
              getSibling: U,
              removeWhiteSpace: Z,
              extractContents: G,
              getOffset: K,
              getStyle: Y,
              hasStyle: J
          },
          locale: lt.locale,
          icons: lt.icons,
          utils: {
              each: s,
              isEmptyObject: i,
              extend: n
          },
          plugins: nt.plugins,
          formats: lt.formats,
          create(e, t) {
              t = t || {}, l(e, ".sceditor-container") || (t.runWithoutWysiwygSupport || xt) && new lt(
                e, t)
          },
          instance({_sceditor}) {
              return _sceditor;
          }
      },
      /**
       * SCEditor
       * http://www.sceditor.com/
       *
       * Copyright (C) 2017, Sam Clarke (samclarke.com)
       *
       * SCEditor is licensed under the MIT license:
       *	http://www.opensource.org/licenses/mit-license.php
       *
       * @fileoverview SCEditor - A lightweight WYSIWYG BBCode and HTML editor
       * @author Sam Clarke
       * @requires jQuery
       */
      e.sceditor = window.sceditor, e.fn.sceditor = function (t) {
        let i;
        const n = [];
        return this.each(function () {
            i = this._sceditor, "state" === t ? n.push(!!i) : "instance" === t ? n.push(i) : i ||
              e.sceditor.create(this, t)
        }), n.length ? 1 === n.length ? n[0] : n : this
    }
})(jQuery), (e => {
    function t(e, t) {
        return typeof t === e
    }

    function i(e) {
        return !Object.keys(e)
          .length
    }

    function n(e, t) {
        for (var i = e === !!e, o = i ? 2 : 1, s = i ? t : e, a = i ? e : !1; o < arguments.length; o++) {
            const r = arguments[o];
            for (const l in r) {
                const c = r[l];
                if (!ut(c)) {
                    const u = null !== c && "object" == typeof c && Object.getPrototypeOf(c) === Object
                        .prototype;

                    const d = Array.isArray(c);
                    s[l] = a && (u || d) ? n(!0, s[l] || (d ? [] : {}), c) : c
                }
            }
        }
        return s
    }

    function o(e, t) {
        const i = e.indexOf(t);
        i > -1 && e.splice(i, 1)
    }

    function s(e, t) {
        if (Array.isArray(e) || "length" in e && ht(e.length))
            for (let i = 0; i < e.length; i++) t(i, e[i]);
        else Object.keys(e)
          .forEach(i => {
              t(i, e[i])
          })
    }

    function a(e) {
        return e = parseFloat(e), isFinite(e) ? e : 0
    }

    function r(e, t, i) {
        const n = (i || document)
          .createElement(e);
        return s(t || {}, (e, t) => {
            "style" === e ? n.style.cssText = t : e in n ? n[e] = t : n.setAttribute(e, t)
        }), n;
    }

    function l(e, t) {
        for (let i = e || {};
             (i = i.parentNode) && !/(9|11)/.test(i.nodeType);)
            if (!t || k(i, t)) return i
    }

    function c(e, t) {
        return k(e, t) ? e : l(e, t)
    }

    function u(e) {
        e.parentNode && e.parentNode.removeChild(e)
    }

    function d(e, t) {
        e.appendChild(t)
    }

    function h(e, t) {
        return e.querySelectorAll(t)
    }

    function p(e, t, i, n, o) {
        t.split(" ")
          .forEach(t => {
              let s;
              ct(i) ? (s = n[`_sce-event-${t}${i}`] || (t => {
                  for (let o = t.target; o && o !== e;) {
                      if (k(o, i)) return n.call(o, t), void 0;
                      o = o.parentNode
                  }
              }), n[`_sce-event-${t}${i}`] = s) : (s = i, o = n), e.addEventListener(t, s, o || !1)
          })
    }

    function m(e, t, i, n, o) {
        t.split(" ")
          .forEach(t => {
              let s;
              ct(i) ? s = n[`_sce-event-${t}${i}`] : (s = i, o = n), e.removeEventListener(t, s, o || !
                1)
          })
    }

    function f(e, t, i) {
        return arguments.length < 3 ? e.getAttribute(t) : (null == i ? _(e, t) : e.setAttribute(t, i), void 0)
    }

    function _(e, t) {
        e.removeAttribute(t)
    }

    function g(e) {
        y(e, "display", "none")
    }

    function v(e) {
        y(e, "display", "")
    }

    function b(e) {
        D(e) ? g(e) : v(e)
    }

    function y(e, t, i) {
        if (arguments.length < 3) {
            if (ct(t)) return 1 === e.nodeType ? getComputedStyle(e)[t] : null;
            s(t, (t, i) => {
                y(e, t, i)
            })
        } else {
            const n = (i || 0 === i) && !isNaN(i);
            e.style[t] = n ? `${i}px` : i
        }
    }

    function w(e, t, i) {
        const n = arguments.length;
        const o = {};
        if (e.nodeType === mt) {
            if (1 === n) return s(e.attributes, (e, {name, value}) => {
                /^data\-/i.test(name) && (o[name.substr(5)] = value)
            }), o;
            if (2 === n) return f(e, `data-${t}`);
            f(e, `data-${t}`, String(i))
        }
    }

    function k(e, t) {
        let i = !1;
        return e && e.nodeType === mt && (i = (e.matches || e.msMatchesSelector || e.webkitMatchesSelector)
          .call(e, t)), i
    }

    function x(e, t) {
        return e !== t && e.contains && e.contains(t)
    }

    function C({previousElementSibling}, t) {
        const i = previousElementSibling;
        return t && i ? k(i, t) ? i : null : i
    }

    function z(e, t) {
        return t.parentNode.insertBefore(e, t)
    }

    function T({className}) {
        return className.trim()
          .split(/\s+/);
    }

    function S(e, t) {
        return k(e, `.${t}`);
    }

    function A(e, t) {
        const i = T(e);
        !i.includes(t) && i.push(t), e.className = i.join(" ")
    }

    function E(e, t) {
        const i = T(e);
        o(i, t), e.className = i.join(" ")
    }

    function P(e, t, i) {
        i = ut(i) ? !S(e, t) : i, i ? A(e, t) : E(e, t)
    }

    function I(e, t) {
        if (ut(t)) {
            const i = getComputedStyle(e);
            const n = a(i.paddingLeft) + a(i.paddingRight);
            const o = a(i.borderLeftWidth) + a(i.borderRightWidth);
            return e.offsetWidth - n - o
        }
        y(e, "width", t)
    }

    function M(e, t) {
        if (ut(t)) {
            const i = getComputedStyle(e);
            const n = a(i.paddingTop) + a(i.paddingBottom);
            const o = a(i.borderTopWidth) + a(i.borderBottomWidth);
            return e.offsetHeight - n - o
        }
        y(e, "height", t)
    }

    function j(e, t, i) {
        let n;
        dt(window.CustomEvent) ? n = new CustomEvent(t, {
            bubbles: !0,
            cancelable: !0,
            detail: i
        }) : (n = e.ownerDocument.createEvent("CustomEvent"), n.initCustomEvent(t, !0, !0, i)), e
          .dispatchEvent(n)
    }

    function D(e) {
        return !!e.getClientRects()
          .length
    }

    function N(e) {
        return e.replace(/^-ms-/, "ms-")
          .replace(/-(\w)/g, (e, t) => t.toUpperCase());
    }

    function L(e, t, i, n, o) {
        for (e = o ? e.lastChild : e.firstChild; e;) {
            const s = o ? e.previousSibling : e.nextSibling;
            if (!i && t(e) === !1 || !n && L(e, t, i, n, o) === !1 || i && t(e) === !1) return !1;
            e = s
        }
    }

    function O(e, t, i, n) {
        L(e, t, i, n, !0)
    }

    function R(e, t = document) {
        const i = t.createDocumentFragment();
        const n = r("div", {}, t);
        for (n.innerHTML = e; n.firstChild;) d(i, n.firstChild);
        return i
    }

    function $(e) {
        return e && (!k(e, "p,div") || e.className || f(e, "style") || !i(w(e)))
    }

    function F(e, t) {
        const i = r(t, {}, e.ownerDocument);
        for (s(e.attributes, (e, {name, value}) => {
            try {
                f(i, name, value)
            } catch (n) {}
        }); e.firstChild;) d(i, e.firstChild);
        return e.parentNode.replaceChild(i, e), i
    }

    function B({nodeType, nodeName}) {
        return /11?|9/.test(nodeType) ?
          !"|iframe|area|base|basefont|br|col|frame|hr|img|input|wbr|isindex|link|meta|param|command|embed|keygen|source|track|object|".includes(`|${nodeName.toLowerCase()}|`) : !1;
    }

    function H(e, t) {
        let i;

        const n = (e || {})
          .nodeType || ft;

        return n !== mt ? n === ft : (i = e.tagName.toLowerCase(), "code" === i ? !t : !gt.includes(`|${i}|`));
    }

    function W({style}, {style}) {
        style.cssText = style.cssText + style.cssText
    }

    function V(e) {
        const t = e => {
            for (; H(e.parentNode, !0);) e = e.parentNode;
            return e
        };
        L(e, e => {
            const i = "ul,ol";
            const n = !H(e, !0);
            if (n && H(e.parentNode, !0)) {
                const o = t(e);
                const s = G(o, e);
                const a = e;
                W(o, a), z(s, o), z(a, o)
            }
            if (n && k(e, i) && k(e.parentNode, i)) {
                let l = C(e, "li");
                l || (l = r("li"), z(l, e)), d(l, e)
            }
        })
    }

    function q(e, t) {
        for (; e = e.parentNode;)
            if (x(e, t)) return e
    }

    function U(e, t) {
        return e ? (t ? e.previousSibling : e.nextSibling) || U(e.parentNode, t) : null
    }

    function Z(e) {
        let t;
        let i;
        let n;
        let o;
        let s;
        let a;
        let r;
        const l = y(e, "whiteSpace");
        const c = /line$/i.test(l);
        let d = e.firstChild;
        if (!/pre(\-wrap)?$/i.test(l))
            for (; d;) {
                if (a = d.nextSibling, t = d.nodeValue, i = d.nodeType, i === mt && d.firstChild && Z(d),
                i === ft) {
                    for (n = U(d), o = U(d, !0), r = !1; S(o, "sceditor-ignore");) o = U(o, !0);
                    if (H(d) && o) {
                        for (s = o; s.lastChild;)
                            for (s = s.lastChild; S(s, "sceditor-ignore");) s = U(s, !0);
                        r = s.nodeType === ft ? /[\t\n\r ]$/.test(s.nodeValue) : !H(s)
                    }
                    t = t.replace(/\u200B/g, ""), o && H(o) && !r || (t = t.replace(c ? /^[\t ]+/ :
                      /^[\t\n\r ]+/, "")), n && H(n) || (t = t.replace(c ? /[\t ]+$/ : /[\t\n\r ]+$/,
                      "")), t.length ? d.nodeValue = t.replace(c ? /[\t ]+/g : /[\t\n\r ]+/g, " ") : u(
                      d)
                }
                d = a
            }
    }

    function G(e, t) {
        const i = e.ownerDocument.createRange();
        return i.setStartBefore(e), i.setEndAfter(t), i.extractContents()
    }

    function K(e) {
        for (var t = 0, i = 0; e;) t += e.offsetLeft, i += e.offsetTop, e = e.offsetParent;
        return {
            left: t,
            top: i
        }
    }

    function Y(e, t) {
        let i;
        let n;
        const o = e.style;
        if (pt[t] || (pt[t] = N(t)), t = pt[t], n = o[t], "textAlign" === t) {
            if (i = o.direction, n = n || y(e, t), y(e.parentNode, t) === n || "block" !== y(e, "display") ||
            k(e, "hr,th")) return "";
            if (/right/i.test(n) && "rtl" === i || /left/i.test(n) && "ltr" === i) return ""
        }
        return n
    }

    function J(e, t, i) {
        const n = Y(e, t);
        return n ? !i || n === i || Array.isArray(i) && i.includes(n) : !1;
    }

    function Q(e) {
        return e.replace(/([\-.*+?^=!:${}()|\[\]\/\\])/g, "\\$1")
    }

    function X(e, t) {
        if (!e) return e;
        const i = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "  ": "&nbsp; ",
            "\r\n": "<br />",
            "\r": "<br />",
            "\n": "<br />"
        };
        return t !== !1 && (i['"'] = "&#34;", i["'"] = "&#39;", i["`"] = "&#96;"), e = e.replace(
          / {2}|\r\n|[&<>\r\n'"`]/g,
          e => i[e] || e);
    }

    function et(e) {
        let t;
        const i = /^[^\/]*:/i;
        const n = window.location;
        return e && i.test(e) && !Ct.test(e) ? (t = n.pathname.split("/"), t.pop(), `${n.protocol}//${n
  .host}${t.join("/")}/${e}`) : e;
    }

    function tt(e, t, i) {
        let n = zt[e];
        return Object.keys(t)
          .forEach(e => {
              n = n.replace(new RegExp(Q(`{${e}}`), "g"), t[e])
          }), i && (n = R(n)), n;
    }

    function it(e) {
        if ("mozHidden" in document)
            for (let t, i = e.getBody(); i;) {
                if (t = i, t.firstChild) t = t.firstChild;
                else {
                    for (; t && !t.nextSibling;) t = t.parentNode;
                    t && (t = t.nextSibling)
                }
                3 === i.nodeType && /[\n\r\t]+/.test(i.nodeValue) && (/^pre/.test(y(i.parentNode,
                  "whiteSpace")) || u(i)), i = t
            }
    }

    function nt(e) {
        const t = this;
        let i = [];

        const n = e => `signal${e.charAt(0)
  .toUpperCase()}${e.slice(1)}`;

        const o = (t, o) => {
            t = [].slice.call(t);
            let s;
            let a;
            const r = n(t.shift());
            for (s = 0; s < i.length; s++)
                if (r in i[s] && (a = i[s][r].apply(e, t), o)) return a
        };

        t.call = function(...args) {
            o(args, !1)
        }, t.callOnlyFirst = function(...args) {
            return o(args, !0);
        }, t.hasHandler = e => {
            let t = i.length;
            for (e = n(e); t--;)
                if (e in i[t]) return !0;
            return !1
        }, t.exists = e => e in At ? (e = At[e], "function" == typeof e && "object" == typeof e.prototype) : !1, t.isRegistered = e => {
            if (t.exists(e))
                for (let n = i.length; n--;)
                    if (i[n] instanceof At[e]) return !0;
            return !1
        }, t.register = n => !t.exists(n) || t.isRegistered(n) ? !1 : (n = new At[n], i.push(n), "init" in n && n
          .init.call(e), !0), t.deregister = n => {
            let o;
            let s = i.length;
            let a = !1;
            if (!t.isRegistered(n)) return a;
            for (; s--;) i[s] instanceof At[n] && (o = i.splice(s, 1)[0], a = !0, "destroy" in o && o
              .destroy.call(e));
            return a
        }, t.destroy = () => {
            for (let t = i.length; t--;) "destroy" in i[t] && i[t].destroy.call(e);
            i = [], e = null
        }
    }

    function ot(e, t) {
        let i;
        let n;
        const o = t || e.contentDocument || e.document;
        const s = "sceditor-start-marker";
        const a = "sceditor-end-marker";
        const l = this;
        l.insertHTML = (e, t) => {
            let i;
            let n;
            const s = l.selectedRange();
            if (!s) return !1;
            for (t && (e += l.selectedHtml() + t), n = r("p", {}, o), i = o.createDocumentFragment(), n
              .innerHTML = e; n.firstChild;) d(i, n.firstChild);
            l.insertNode(i)
        }, n = (e, t, n) => {
            let c;
            let u = o.createDocumentFragment();
            if ("string" == typeof e ? (t && (e += l.selectedHtml() + t), u = R(e)) : (d(u, e), t && (d(u,
              l.selectedRange()
                .extractContents()), d(u, t))), c = u.lastChild) {
                for (; !H(c.lastChild, !0);) c = c.lastChild;
                if (B(c) ? c.lastChild || d(c, document.createTextNode("​")) : c = u, l.removeMarkers(),
                  d(c, i(s)), d(c, i(a)), n) {
                    const h = r("div");
                    return d(h, u), h.innerHTML
                }
                return u
            }
        }, l.insertNode = (e, t) => {
            const i = n(e, t);
            const o = l.selectedRange();
            const s = o.commonAncestorContainer;
            return i ? (o.deleteContents(), s && 3 !== s.nodeType && !B(s) ? z(i, s) : o.insertNode(i), l
              .restoreRange(), void 0) : !1
        }, l.cloneSelected = () => {
            const e = l.selectedRange();
            return e ? e.cloneRange() : void 0
        }, l.selectedRange = () => {
            let t;
            let i;
            const n = e.getSelection();
            if (n) {
                if (n.rangeCount <= 0) {
                    for (i = o.body; i.firstChild;) i = i.firstChild;
                    t = o.createRange(), t.setStartBefore(i), n.addRange(t)
                }
                return n.rangeCount > 0 && (t = n.getRangeAt(0)), t
            }
        }, l.hasSelection = () => {
            const t = e.getSelection();
            return t && t.rangeCount > 0
        }, l.selectedHtml = () => {
            let e;
            const t = l.selectedRange();
            return t ? (e = r("p", {}, o), d(e, t.cloneContents()), e.innerHTML) : ""
        }, l.parentNode = () => {
            const e = l.selectedRange();
            return e ? e.commonAncestorContainer : void 0
        }, l.getFirstBlockParent = e => {
            const t = e => H(e, !0) ? (e = e ? e.parentNode : null, e ? t(e) : e) : e;
            return t(e || l.parentNode())
        }, l.insertNodeAt = (e, t) => {
            const i = l.selectedRange();
            const n = l.cloneSelected();
            return n ? (n.collapse(e), n.insertNode(t), l.selectRange(i), void 0) : !1
        }, i = e => {
            l.removeMarker(e);
            const t = r("span", {
                id: e,
                className: "sceditor-selection sceditor-ignore",
                style: "display:none;line-height:0"
            }, o);
            return t.innerHTML = " ", t
        }, l.insertMarkers = () => {
            const e = l.selectedRange();
            const t = i(s);
            l.removeMarkers(), l.insertNodeAt(!0, t), e && e.collapsed ? t.parentNode.insertBefore(i(a), t
              .nextSibling) : l.insertNodeAt(!1, i(a))
        }, l.getMarker = e => o.getElementById(e), l.removeMarker = e => {
            const t = l.getMarker(e);
            t && u(t)
        }, l.removeMarkers = () => {
            l.removeMarker(s), l.removeMarker(a)
        }, l.saveRange = () => {
            l.insertMarkers()
        }, l.selectRange = t => {
            let i;
            const n = e.getSelection();
            const s = t.endContainer;
            if (!Et && t.collapsed && s && !H(s, !0)) {
                for (i = s.lastChild; i && k(i, ".sceditor-ignore");) i = i.previousSibling;
                if (k(i, "br")) {
                    const a = o.createRange();
                    a.setEndAfter(i), a.collapse(!1), l.compare(t, a) && (t.setStartBefore(i), t.collapse(
                      !0))
                }
            }
            n && (l.clear(), n.addRange(t))
        }, l.restoreRange = () => {
            let e;
            let t = l.selectedRange();
            const i = l.getMarker(s);
            const n = l.getMarker(a);
            return i && n && t ? (e = i.nextSibling === n, t = o.createRange(), t.setStartBefore(i), t
              .setEndAfter(n), e && t.collapse(!0), l.selectRange(t), l.removeMarkers(), void 0) : !
              1
        }, l.selectOuterText = (e, t) => {
            let i;
            let n;
            const o = l.cloneSelected();
            return o ? (o.collapse(!1), i = Pt(o, !0, e), n = Pt(o, !1, t), o.setStart(i.node, i.offset),
              o.setEnd(n.node, n.offset), l.selectRange(o), void 0) : !1
        }, l.getOuterText = (e, t) => {
            const i = l.cloneSelected();
            return i ? (i.collapse(!e), Pt(i, e, t)
              .text) : ""
        }, l.replaceKeyword = (e, t, i, n, o, s) => {
            i || e.sort((e, t) => e[0].length - t[0].length);
            let a;
            let r;
            let c;
            let u;
            let d;
            let h;
            let p;
            let m;
            const f = "(^|[\\s    ])";
            let _ = e.length;
            const g = o ? 1 : 0;
            let v = n || e[_ - 1][0].length;
            for (o && v++, s = s || "", a = l.getOuterText(!0, v), d = a.length, a += s, t && (a += l
              .getOuterText(!1, v)); _--;)
                if (p = e[_][0], m = p.length, u = Math.max(0, d - m - g), c = -1, o ? (r = a.substr(u)
                  .match(new RegExp(f + Q(p) + f)), r && (c = r.index + u + r[1].length)) : c = a
                  .indexOf(p, u), c > -1 && d >= c && c + m + g >= d) return h = d - c, l
                  .selectOuterText(h, m - h - (/^\S/.test(s) ? 1 : 0)), l.insertHTML(e[_][1]), !0;
            return !1
        }, l.compare = (e, t) => (t || (t = l.selectedRange()), e && t ? 0 === e.compareBoundaryPoints(Range.END_TO_END,
          t) && 0 === e.compareBoundaryPoints(Range.START_TO_START, t) : !e && !t), l.clear = () => {
            const t = e.getSelection();
            t && (t.removeAllRanges ? t.removeAllRanges() : t.empty && t.empty())
        }
    }

    function st(e, t) {
        const i = /[^\s\xA0\u2002\u2003\u2009\u00a0]+/;
        const n = e && h(e, "img[data-sceditor-emoticon]");
        if (e && n.length)
            for (let o = 0; o < n.length; o++) {
                const s = n[o];
                const a = s.parentNode;
                const r = s.previousSibling;
                let l = s.nextSibling;
                if (r && i.test(r.nodeValue.slice(-1)) || l && i.test((l.nodeValue || "")[0])) {
                    const c = t.cloneSelected();
                    let d = -1;
                    const p = c.startContainer;
                    let m = r.nodeValue;
                    null === m && (m = r.innerText || ""), m += w(s, "sceditor-emoticon"), p === l && (d = m
                      .length + c.startOffset), p === e && e.childNodes[c.startOffset] === l && (d = m
                      .length), p === r && (d = c.startOffset), l && l.nodeType === ft || (l = a
                      .insertBefore(a.ownerDocument.createTextNode(""), l)), l.insertData(0, m), u(r),
                      u(s), d > -1 && (c.setStart(l, d), c.collapse(!0), t.selectRange(c))
                }
            }
    }

    function at(e, t, i) {
        const n = e.ownerDocument;
        const o = "(^|\\s| | | | |$)";
        const a = [];
        const r = {};
        l(e, "code") || (s(t, e => {
            r[e] = new RegExp(o + Q(e) + o), a.push(e)
        }), a.sort(({length}, {length}) => length - length), function c(e) {
            for (e = e.firstChild; e;) {
                if (e.nodeType !== mt || k(e, "code") || c(e), e.nodeType === ft)
                    for (let o = 0; o < a.length; o++) {
                        const s = e.nodeValue;
                        const l = a[o];
                        const u = i ? s.search(r[l]) : s.indexOf(l);
                        if (u > -1) {
                            const d = s.indexOf(l, u);
                            const h = R(t[l], n);
                            const p = s.substr(d + l.length);
                            h.appendChild(n.createTextNode(p)), e.nodeValue = s.substr(0, d), e
                              .parentNode.insertBefore(h, e.nextSibling)
                        }
                    }
                e = e.nextSibling
            }
        }(e))
    }

    function rt(e, t) {
        let i;
        L(e, e => {
            H(e, !0) ? (i || (i = r("p", {}, t), z(i, e)), (e.nodeType !== ft || "" !== e
              .nodeValue) && d(i, e)) : i = null
        }, !1, !0)
    }

    function lt(e, t) {
        let i;
        let a;
        let l;
        let _;
        let x;
        let C;
        let T;
        let N;
        let L;
        let R;
        let W;
        let q;
        let U;
        let G;
        let Y;
        let J;
        let Q;
        let et;
        let it;
        let ht;
        let pt;
        let gt;
        let bt;
        let yt;
        let Ct;
        let zt;
        let Tt;
        let At;
        let Et;
        let Pt;
        let Lt;
        let Ot;
        let Rt;
        let $t;
        let Ft;
        let Bt;
        let Ht;
        let Wt;
        let Vt;
        let qt;
        let Ut;
        let Zt;
        let Gt;
        let Kt;
        let Yt;
        let Jt;
        let Qt;
        let Xt;
        let ei;
        let ti;
        let ii;
        let ni;
        let oi;
        let si;
        let ai;
        let ri;
        let li;
        let ci;
        let ui;
        let di;
        let hi;
        let pi;
        let mi;
        const fi = this;
        const _i = {};
        const gi = [];
        const vi = [];
        const bi = {};
        const yi = {};
        let wi = {};
        fi.commands = n(!0, {}, t.commands || St);
        const ki = fi.opts = n(!0, {}, vt, t);
        fi.opts.emoticons = t.emoticons || vt.emoticons, Tt = () => {
            e._sceditor = fi, ki.locale && "en" !== ki.locale && Rt(), a = r("div", {
                className: "sceditor-container"
            }), z(a, e), y(a, "z-index", ki.zIndex), jt && A(a, `ie ie${jt}`), ht = e.required, e
              .required = !1;
            const t = lt.formats[ki.format];
            i = t ? new t : {}, "init" in i && i.init.call(fi), Ot(), Wt(), $t(), Lt(), Ft(), Bt(), xt ||
            fi.toggleSourceMode(), ti();
            const n = () => {
                m(It, "load", n), ki.autofocus && ai(), mi(), ni(), Y.call("ready"), "onReady" in i &&
                i.onReady.call(fi)
            };
            p(It, "load", n), "complete" === Mt.readyState && n()
        }, Ot = () => {
            let e = ki.plugins;
            e = e ? e.toString()
              .split(",") : [], Y = new nt(fi), e.forEach(e => {
                Y.register(e.trim())
            })
        }, Rt = () => {
            let e;
            U = lt.locale[ki.locale], U || (e = ki.locale.split("-"), U = lt.locale[e[0]]), U && U
              .dateFormat && (ki.dateFormat = U.dateFormat)
        }, Lt = () => {
            N = r("textarea"), _ = r("iframe", {
                frameborder: 0,
                allowfullscreen: !0
            }), ki.startInSourceMode ? (A(a, "sourceMode"), g(_)) : (A(a, "wysiwygMode"), g(N)), ki
              .spellcheck || f(a, "spellcheck", "false"), "https:" === It.location.protocol && f(_,
              "src", "javascript:false"), d(a, _), d(a, N), fi.dimensions(ki.width || I(e), ki
              .height || M(e));
            let t = jt ? `ie ie${jt}` : "";
            t += kt ? " ios" : "", T = _.contentDocument, T.open(), T.write(tt("html", {
                attrs: ` class="${t}"`,
                spellcheck: ki.spellcheck ? "" : 'spellcheck="false"',
                charset: ki.charset,
                style: ki.style
            })), T.close(), C = T.body, x = _.contentWindow, fi.readOnly(!!ki.readOnly), (kt || wt ||
              jt) && (M(C, "100%"), jt || p(C, "touchend", fi.focus));
            const i = f(e, "tabindex");
            f(N, "tabindex", i), f(_, "tabindex", i), G = new ot(x), g(e), fi.val(e.value);
            const n = ki.placeholder || f(e, "placeholder");
            n && (N.placeholder = n, f(C, "placeholder", n))
        }, Ft = () => {
            ki.autoUpdate && (p(C, "blur", pi), p(N, "blur", pi)), null === ki.rtl && (ki.rtl = "rtl" ===
              y(N, "direction")), fi.rtl(!!ki.rtl), ki.autoExpand && (p(C, "load", mi, _t), p(C,
              "input keyup", mi)), ki.resizeEnabled && Ht(), f(a, "id", ki.id), fi.emoticons(ki
              .emoticonsEnabled)
        }, Bt = () => {
            const t = e.form;
            const i = "compositionstart compositionend";
            const n = "keydown keyup keypress focus blur contextmenu";

            const o = "onselectionchange" in T ? "selectionchange" :
              "keyup focus blur contextmenu mouseup touchend click";

            p(Mt, "click", Xt), t && (p(t, "reset", Kt), p(t, "submit", fi.updateOriginal, _t)), p(C,
              "keypress", Gt), p(C, "keydown", Ut), p(C, "keydown", Zt), p(C, "keyup", ni), p(C,
              "blur", di), p(C, "keyup", hi), p(C, "paste", Vt), p(C, i, Jt), p(C, o, oi), p(C, n,
              Qt), ki.emoticonsCompat && It.getSelection && p(C, "keyup", li), p(C, "blur",
              () => {
                  fi.val() || A(C, "placeholder")
              }), p(C, "focus", () => {
                E(C, "placeholder")
            }), p(N, "blur", di), p(N, "keyup", hi), p(N, "keydown", Ut), p(N, i, Jt), p(N, n, Qt), p(
              T, "mousedown", Yt), p(T, o, oi), p(T, "beforedeactivate keyup mouseup", Pt), p(T,
              "keyup", ni), p(T, "focus", () => {
                R = null
            }), p(a, "selectionchanged", si), p(a, "selectionchanged", ti), p(a,
              "selectionchanged valuechanged nodechanged pasteraw paste", Qt)
        }, $t = () => {
            let e;
            const t = fi.commands;

            const i = (ki.toolbarExclude || "")
              .split(",");

            const n = ki.toolbar.split("|");
            l = r("div", {
                className: "sceditor-toolbar",
                unselectable: "on"
            }), ki.icons in lt.icons && (zt = new lt.icons[ki.icons]), s(n, (n, o) => {
                e = r("div", {
                    className: "sceditor-group"
                }), s(o.split(","), (n, o) => {
                    let s;
                    let a;
                    const r = t[o];
                    if (r && !(i.includes(o))) {
                        if (a = r.shortcut, s = tt("toolbarButton", {
                            name: o,
                            dispName: fi._(r.name || r.tooltip || o)
                        }, !0)
                          .firstChild, zt && zt.create) {
                            const l = zt.create(o);
                            l && (z(zt.create(o), s.firstChild), A(s, "has-icon"))
                        }
                        s._sceTxtMode = !!r.txtExec, s._sceWysiwygMode = !!r.exec, P(s,
                          "disabled", !r.exec), p(s, "click", e => {
                            S(s, "disabled") || Et(s, r), ti(), e.preventDefault()
                        }), p(s, "mousedown", e => {
                            fi.closeDropDown(), e.preventDefault()
                        }), r.tooltip && f(s, "title", fi._(r.tooltip) + (a ? ` (${a})` : "")), a && fi.addShortcut(a, o), r.state ? vi
                          .push({
                              name: o,
                              state: r.state
                          }) : ct(r.exec) && vi.push({
                            name: o,
                            state: r.exec
                        }), d(e, s), yi[o] = s
                    }
                }), e.firstChild && d(l, e)
            }), d(ki.toolbarContainer || a, l)
        }, Ht = () => {
            let e;
            let t;
            let i;
            let n;
            let o;
            let s;

            const l = r("div", {
                  className: "sceditor-grip"
              });

            const c = r("div", {
                className: "sceditor-resize-cover"
            });

            const u = "touchmove mousemove";
            const h = "touchcancel touchend mouseup";
            let f = 0;
            let _ = 0;
            let b = 0;
            let y = 0;
            let w = 0;
            let k = 0;
            const x = I(a);
            const C = M(a);
            let z = !1;
            const T = fi.rtl();
            if (e = ki.resizeMinHeight || C / 1.5, t = ki.resizeMaxHeight || 2.5 * C, i = ki
              .resizeMinWidth || x / 1.25, n = ki.resizeMaxWidth || 1.25 * x, o = o => {
                "touchmove" === o.type ? (o = It.event, b = o.changedTouches[0].pageX, y = o
                  .changedTouches[0].pageY) : (b = o.pageX, y = o.pageY);
                let s = k + (y - _);
                let a = T ? w - (b - f) : w + (b - f);
                n > 0 && a > n && (a = n), i > 0 && i > a && (a = i), ki.resizeWidth || (a = !1), t >
                0 && s > t && (s = t), e > 0 && e > s && (s = e), ki.resizeHeight || (s = !1), (
                  a || s) && fi.dimensions(a, s), o.preventDefault()
            }, s = e => {
                z && (z = !1, g(c), E(a, "resizing"), m(Mt, u, o), m(Mt, h, s), e.preventDefault())
            }, zt && zt.create) {
                const S = zt.create("grip");
                S && (d(l, S), A(l, "has-icon"))
            }
            d(a, l), d(a, c), g(c), p(l, "touchstart mousedown", e => {
                "touchstart" === e.type ? (e = It.event, f = e.touches[0].pageX, _ = e.touches[0]
                  .pageY) : (f = e.pageX, _ = e.pageY), w = I(a), k = M(a), z = !0, A(a,
                  "resizing"), v(c), p(Mt, u, o), p(Mt, h, s), e.preventDefault()
            })
        }, Wt = () => {
            const e = ki.emoticons;
            const t = ki.emoticonsRoot || "";
            e && (wi = n({}, e.more, e.dropdown, e.hidden)), s(wi, (e, i) => {
                wi[e] = tt("emoticon", {
                    key: e,
                    url: t + (i.url || i),
                    tooltip: i.tooltip || e
                }), ki.emoticonsEnabled && gi.push(r("img", {
                    src: t + (i.url || i)
                }))
            })
        }, ai = () => {
            let e;
            let t;
            let i = C.firstChild;
            const n = !!ki.autofocusEnd;
            if (D(a)) {
                if (fi.sourceMode()) return t = n ? N.value.length : 0, N.setSelectionRange(t, t), void 0;
                if (Z(C), n)
                    for ((i = C.lastChild) || (i = r("p", {}, T), d(C, i)); i.lastChild;) i = i.lastChild,
                    !Dt && k(i, "br") && i.previousSibling && (i = i.previousSibling);
                e = T.createRange(), B(i) ? e.selectNodeContents(i) : (e.setStartBefore(i), n && e
                  .setStartAfter(i)), e.collapse(!n), G.selectRange(e), et = e, n && (C.scrollTop =
                  C.scrollHeight), fi.focus()
            }
        }, fi.readOnly = e => "boolean" != typeof e ? !N.readonly : (C.contentEditable = !e, N.readonly = !e, ei(e),
          fi), fi.rtl = e => {
            const t = e ? "rtl" : "ltr";
            return "boolean" != typeof e ? "rtl" === f(N, "dir") : (f(C, "dir", t), f(N, "dir", t), E(a,
              "rtl"), E(a, "ltr"), A(a, t), zt && zt.rtl && zt.rtl(e), fi)
        }, ei = e => {
            const t = fi.inSourceMode() ? "_sceTxtMode" : "_sceWysiwygMode";
            s(yi, (i, n) => {
                P(n, "disabled", e || !n[t])
            })
        }, fi.width = (e, t) => e || 0 === e ? (fi.dimensions(e, null, t), fi) : I(a), fi.dimensions = (e, t, i) => (e = e || 0 === e ? e : !1, t = t || 0 === t ? t : !1, e === !1 && t === !1 ? {
            width: fi.width(),
            height: fi.height()
        } : (e !== !1 && (i !== !1 && (ki.width = e), I(a, e)), t !== !1 && (i !== !1 && (ki
          .height = t), M(a, t)), fi)), fi.height = (e, t) => e || 0 === e ? (fi.dimensions(null, e, t), fi) : M(a), fi.maximize = e => {
            const t = "sceditor-maximize";
            return ut(e) ? S(a, t) : (e = !!e, e && (yt = It.pageYOffset), P(Mt.documentElement, t, e), P(
              Mt.body, t, e), P(a, t, e), fi.width(e ? "100%" : ki.width, !1), fi.height(e ?
              "100%" : ki.height, !1), e || It.scrollTo(0, yt), mi(), fi)
        }, mi = () => {
            ki.autoExpand && !bt && (bt = setTimeout(fi.expandToContent, 200))
        }, fi.expandToContent = t => {
            if (!fi.maximize()) {
                if (clearTimeout(bt), bt = !1, !gt) {
                    const i = ki.resizeMinHeight || ki.height || M(e);
                    gt = {
                        min: i,
                        max: ki.resizeMaxHeight || 2 * i
                    }
                }
                const n = Mt.createRange();
                n.selectNodeContents(C);
                const o = n.getBoundingClientRect();
                const s = T.documentElement.clientHeight - 1;
                const a = o.bottom - o.top;
                let r = fi.height() + 1 + (a - s);
                t || -1 === gt.max || (r = Math.min(r, gt.max)), fi.height(Math.ceil(Math.max(r, gt.min)))
            }
        }, fi.destroy = () => {
            if (Y) {
                Y.destroy(), G = null, R = null, Y = null, L && u(L), m(Mt, "click", Xt);
                const t = e.form;
                t && (m(t, "reset", Kt), m(t, "submit", fi.updateOriginal)), u(N), u(l), u(a), delete e
                  ._sceditor, v(e), e.required = ht
            }
        }, fi.createDropDown = ({offsetTop, offsetLeft, clientHeight}, t, i, o) => {
            let l;
            const c = `sceditor-${t}`;
            fi.closeDropDown(!0), L && S(L, c) || (o !== !1 && s(h(i, ":not(input):not(textarea)"),
              (e, t) => {
                  t.nodeType === mt && f(t, "unselectable", "on")
              }), l = n({
                top: offsetTop,
                left: offsetLeft,
                marginTop: clientHeight
            }, ki.dropDownCss), L = r("div", {
                className: `sceditor-dropdown ${c}`
            }), y(L, l), d(L, i), d(a, L), p(L, "click focusin", e => {
                e.stopPropagation()
            }), setTimeout(() => {
                if (L) {
                    const e = h(L, "input,textarea")[0];
                    e && e.focus()
                }
            }))
        }, Xt = ({which, defaultPrevented}) => {
            3 !== which && L && !defaultPrevented && (pi(), fi.closeDropDown())
        }, Vt = e => {
            const t = jt || wt;
            const i = C;
            const n = e.clipboardData;

            const o = e => {
                const t = new FileReader;
                t.onload = e => {
                    qt({
                        html: `<img src="${e.target.result}" />`
                    })
                }, t.readAsDataURL(e)
            };

            if (n && !t) {
                const s = {};
                const a = n.types;
                const r = n.items;
                e.preventDefault();
                for (let l = 0; l < a.length; l++) {
                    if (It.FileReader && r && Nt.test(r[l].type)) return o(n.items[l].getAsFile());
                    s[a[l]] = n.getData(a[l])
                }
                s.text = s["text/plain"], s.html = s["text/html"], qt(s)
            } else if (!Ct) {
                const c = i.scrollTop;
                for (G.saveRange(), Ct = Mt.createDocumentFragment(); i.firstChild;) d(Ct, i.firstChild);
                setTimeout(() => {
                    const e = i.innerHTML;
                    i.innerHTML = "", d(i, Ct), i.scrollTop = c, Ct = !1, G.restoreRange(), qt({
                        html: e
                    })
                }, 0)
            }
        }, qt = e => {
            const t = r("div", {}, T);
            Y.call("pasteRaw", e), j(a, "pasteraw", e), e.html ? (t.innerHTML = e.html, V(t)) : t
              .innerHTML = X(e.text || "");
            const n = {
                val: t.innerHTML
            };
            "fragmentToSource" in i && (n.val = i.fragmentToSource(n.val, T, J)), Y.call("paste", n), j(a,
              "paste", n), "fragmentToHtml" in i && (n.val = i.fragmentToHtml(n.val, J)), Y.call(
              "pasteHtml", n), fi.wysiwygEditorInsertHtml(n.val, null, !0)
        }, fi.closeDropDown = e => {
            L && (u(L), L = null), e === !0 && fi.focus()
        }, fi.wysiwygEditorInsertHtml = (e, t, i) => {
            let n;
            let o;
            let s;
            const a = M(_);
            fi.focus(), (i || !c(Q, "code")) && (G.insertHTML(e, t), G.saveRange(), At(), n = h(C,
              "#sceditor-end-marker")[0], v(n), o = C.scrollTop, s = K(n)
              .top + 1.5 * n.offsetHeight - a, g(n), (s > o || o > s + a) && (C.scrollTop = s), ui(!
              1), G.restoreRange(), ni())
        }, fi.wysiwygEditorInsertText = (e, t) => {
            fi.wysiwygEditorInsertHtml(X(e), X(t))
        }, fi.insertText = (e, t) => (fi.inSourceMode() ? fi.sourceEditorInsertText(e, t) : fi.wysiwygEditorInsertText(e, t), fi), fi.sourceEditorInsertText = (e, t) => {
            let i;
            let n;
            const o = N.selectionStart;
            const s = N.selectionEnd;
            i = N.scrollTop, N.focus(), n = N.value, t && (e += n.substring(o, s) + t), N.value = n
              .substring(0, o) + e + n.substring(s, n.length), N.selectionStart = o + e.length - (t ? t
              .length : 0), N.selectionEnd = N.selectionStart, N.scrollTop = i, N.focus(), ui()
        }, fi.getRangeHelper = () => G, fi.sourceEditorCaret = function (e) {
            return N.focus(), e ? (N.selectionStart = e.start, N.selectionEnd = e.end, this) : {
                start: N.selectionStart,
                end: N.selectionEnd
            }
        }, fi.val = (e, t) => ct(e) ? (fi.inSourceMode() ? fi.setSourceEditorValue(e) : (t !== !1 && "toHtml" in i &&
        (e = i.toHtml(e)), fi.setWysiwygEditorValue(e)), fi) : fi.inSourceMode() ? fi
          .getSourceEditorValue(!1) : fi.getWysiwygEditorValue(t), fi.insert = (e, t, n, o, s) => {
            if (fi.inSourceMode()) return fi.sourceEditorInsertText(e, t), fi;
            if (t) {
                let a = G.selectedHtml();
                n !== !1 && "fragmentToSource" in i && (a = i.fragmentToSource(a, T, J)), e += a + t
            }
            return n !== !1 && "fragmentToHtml" in i && (e = i.fragmentToHtml(e, J)), n !== !1 && s === !
              0 && (e = e.replace(/&lt;/g, "<")
              .replace(/&gt;/g, ">")
              .replace(/&amp;/g, "&")), fi.wysiwygEditorInsertHtml(e), fi
        }, fi.getWysiwygEditorValue = e => {
            for (var t, n = r("div", {}, T), o = C.childNodes, s = 0; s < o.length; s++) d(n, o[s]
              .cloneNode(!0));
            return d(C, n), V(n), u(n), t = n.innerHTML, e !== !1 && i.hasOwnProperty("toSource") && (t =
              i.toSource(t, T)), t
        }, fi.getBody = () => C, fi.getContentAreaContainer = () => _, fi.getSourceEditorValue = e => {
            let t = N.value;
            return e !== !1 && "toHtml" in i && (t = i.toHtml(t)), t
        }, fi.setWysiwygEditorValue = e => {
            e || (e = `<p>${jt ? "" : "<br />"}</p>`), C.innerHTML = e, At(), ni(), ui(), mi()
        }, fi.setSourceEditorValue = e => {
            N.value = e, ui()
        }, fi.updateOriginal = () => {
            e.value = fi.val()
        }, At = () => {
            ki.emoticonsEnabled && at(C, wi, ki.emoticonsCompat)
        }, fi.inSourceMode = () => S(a, "sourceMode"), fi.sourceMode = e => {
            const t = fi.inSourceMode();
            return "boolean" != typeof e ? t : ((t && !e || !t && e) && fi.toggleSourceMode(), fi)
        }, fi.toggleSourceMode = () => {
            const e = fi.inSourceMode();
            (xt || !e) && (e || (G.saveRange(), G.clear()), fi.blur(), e ? fi.setWysiwygEditorValue(fi
              .getSourceEditorValue()) : fi.setSourceEditorValue(fi.getWysiwygEditorValue()), R =
              null, b(N), b(_), P(a, "wysiwygMode", e), P(a, "sourceMode", !e), ei(), ti())
        }, ii = () => (N.focus(), N.value.substring(N.selectionStart, N.selectionEnd)), Et = (e, t) => {
            fi.inSourceMode() ? t.txtExec && (Array.isArray(t.txtExec) ? fi.sourceEditorInsertText(...t.txtExec) : t.txtExec.call(fi, e, ii())) : t.exec && (dt(t.exec) ? t.exec.call(
              fi, e) : fi.execCommand(t.exec, t.hasOwnProperty("execParam") ? t.execParam :
              null))
        }, Pt = () => {
            jt && (R = G.selectedRange())
        }, fi.execCommand = (e, t) => {
            let i = !1;
            const n = fi.commands[e];
            if (fi.focus(), !c(G.parentNode(), "code")) {
                try {
                    i = T.execCommand(e, !1, t)
                } catch (o) {}!i && n && n.errorMessage && alert(fi._(n.errorMessage)), ti()
            }
        }, oi = () => {
            function e() {
                if (x.getSelection() && x.getSelection()
                  .rangeCount <= 0) et = null;
                else if (G && !G.compare(et)) {
                    if (et = G.cloneSelected(), et && et.collapsed) {
                        let e = et.startContainer;
                        const t = et.startOffset;
                        for (t && e.nodeType !== ft && (e = e.childNodes[t]); e && e.parentNode !== C;)
                            e = e.parentNode;
                        e && H(e, !0) && (G.saveRange(), rt(C, T), G.restoreRange())
                    }
                    j(a, "selectionchanged")
                }
                it = !1
            }
            it || (it = !0, "onselectionchange" in T ? e() : setTimeout(e, 100))
        }, si = () => {
            let e;
            const t = G.parentNode();
            J !== t && (e = J, J = t, Q = G.getFirstBlockParent(t), j(a, "nodechanged", {
                oldNode: e,
                newNode: J
            }))
        }, fi.currentNode = () => J, fi.currentBlockNode = () => Q, ti = () => {
            let e;
            let t;
            const i = "active";
            const n = T;
            const o = fi.sourceMode();
            if (fi.readOnly()) return s(h(l, i), (e, t) => {
                E(t, i)
            }), void 0;
            o || (t = G.parentNode(), e = G.getFirstBlockParent(t));
            for (let a = 0; a < vi.length; a++) {
                let r = 0;
                const c = yi[vi[a].name];
                const u = vi[a].state;
                const d = o && !c._sceTxtMode || !o && !c._sceWysiwygMode;
                if (ct(u)) {
                    if (!o) try {
                        r = n.queryCommandEnabled(u) ? 0 : -1, r > -1 && (r = n.queryCommandState(u) ?
                          1 : 0)
                    } catch (p) {}
                } else d || (r = u.call(fi, t, e));
                P(c, "disabled", d || 0 > r), P(c, i, r > 0)
            }
            zt && zt.update && zt.update(o, t, e)
        }, Gt = e => {
            if (!e.defaultPrevented && (fi.closeDropDown(), 13 === e.which)) {
                const t = "li,ul,ol";
                if (!k(Q, t) && $(Q)) {
                    R = null;
                    const i = r("br", {}, T);
                    if (G.insertNode(i), !Dt) {
                        const n = i.parentNode;
                        let o = n.lastChild;
                        o && o.nodeType === ft && "" === o.nodeValue && (u(o), o = n.lastChild), !H(n, !
                          0) && o === i && H(i.previousSibling) && G.insertHTML("<br>")
                    }
                    e.preventDefault()
                }
            }
        }, ni = () => {
            O(C, e => {
                if (e.nodeType === mt && !/inline/.test(y(e, "display")) && !k(e,
                  ".sceditor-nlf") && $(e)) {
                    const t = r("p", {}, T);
                    return t.className = "sceditor-nlf", t.innerHTML = Dt ? "" : "<br />", d(C,
                      t), !1
                }
                return 3 === e.nodeType && !/^\s*$/.test(e.nodeValue) || k(e, "br") ? !1 : void 0
            })
        }, Kt = () => {
            fi.val(e.value)
        }, Yt = () => {
            fi.closeDropDown(), R = null
        }, fi._ = function(...args) {
            let e;
            const t = args;
            return U && U[t[0]] && (t[0] = U[t[0]]), t[0].replace(/\{(\d+)\}/g, (i, n) => t[n - 0 + 1] !== e ? t[n - 0 + 1] : `{${n}}`);
        }, Qt = e => {
            Y && Y.call(`${e.type}Event`, e, fi);
            const t = (e.target === N ? "scesrc" : "scewys") + e.type;
            _i[t] && _i[t].forEach(t => {
                t.call(fi, e)
            })
        }, fi.bind = (e, t, i, n) => {
            e = e.split(" ");
            for (let o = e.length; o--;)
                if (dt(t)) {
                    const s = `scewys${e[o]}`;
                    const a = `scesrc${e[o]}`;
                    i || (_i[s] = _i[s] || [], _i[s].push(t)), n || (_i[a] = _i[a] || [], _i[a].push(t)),
                    "valuechanged" === e[o] && (ui.hasHandler = !0)
                } return fi
        }, fi.unbind = (e, t, i, n) => {
            e = e.split(" ");
            for (let s = e.length; s--;) dt(t) && (i || o(_i[`scewys${e[s]}`] || [], t), n || o(_i[
            `scesrc${e[s]}`] || [], t));
            return fi
        }, fi.blur = (e, t, i) => (dt(e) ? fi.bind("blur", e, t, i) : fi.sourceMode() ? N.blur() : C.blur(), fi), fi.focus = (e, t, i) => {
            if (dt(e)) fi.bind("focus", e, t, i);
            else if (fi.inSourceMode()) N.focus();
            else {
                if (h(T, ":focus")
                  .length) return;
                let n;
                const o = G.selectedRange();
                et || ai(), !Dt && o && 1 === o.endOffset && o.collapsed && (n = o.endContainer, n &&
                1 === n.childNodes.length && k(n.firstChild, "br") && (o.setStartBefore(n
                  .firstChild), o.collapse(!0), G.selectRange(o))), x.focus(), C.focus(), R && (
                  G.selectRange(R), R = null)
            }
            return ti(), fi
        }, fi.keyDown = (e, t, i) => fi.bind("keydown", e, t, i), fi.keyPress = (e, t, i) => fi.bind("keypress", e, t, i), fi.keyUp = (e, t, i) => fi.bind("keyup", e, t, i), fi.nodeChanged = e => fi.bind("nodechanged", e, !1, !0), fi.selectionChanged = e => fi.bind("selectionchanged", e, !1, !0), fi.valueChanged = (e, t, i) => fi.bind("valuechanged", e, t, i), ri = e => {
            let t;
            let i = 0;
            let n = fi.emoticonsCache;
            const o = String.fromCharCode(e.which);
            c(Q, "code") || (n || (n = [], s(wi, (e, t) => {
                n[i++] = [e, t]
            }), n.sort((e, t) => e[0].length - t[0].length), fi.emoticonsCache = n, fi.longestEmoticonCode = n[n.length - 1][0].length), t = G
              .replaceKeyword(fi.emoticonsCache, !0, !0, fi.longestEmoticonCode, ki.emoticonsCompat,
                o), t && (ki.emoticonsCompat && /^\s$/.test(o) || e.preventDefault()))
        }, li = () => {
            st(Q, G)
        }, fi.emoticons = e => {
            if (!e && e !== !1) return ki.emoticonsEnabled;
            if (ki.emoticonsEnabled = e, e) p(C, "keypress", ri), fi.sourceMode() || (G.saveRange(), At(),
              ui(!1), G.restoreRange());
            else {
                const t = h(C, "img[data-sceditor-emoticon]");
                s(t, (e, t) => {
                    const i = w(t, "sceditor-emoticon");
                    const n = T.createTextNode(i);
                    t.parentNode.replaceChild(n, t)
                }), m(C, "keypress", ri), ui()
            }
            return fi
        }, fi.css = e => (pt || (pt = r("style", {
            id: "inline"
        }, T), d(T.head, pt)), ct(e) ? (pt.styleSheet ? pt.styleSheet.cssText = e : pt.innerHTML =
          e, fi) : pt.styleSheet ? pt.styleSheet.cssText : pt.innerHTML), Ut = e => {
            let t = [];

            const i = {
                "`": "~",
                1: "!",
                2: "@",
                3: "#",
                4: "$",
                5: "%",
                6: "^",
                7: "&",
                8: "*",
                9: "(",
                0: ")",
                "-": "_",
                "=": "+",
                ";": ": ",
                "'": '"',
                ",": "<",
                ".": ">",
                "/": "?",
                "\\": "|",
                "[": "{",
                "]": "}"
            };

            const n = {
                8: "backspace",
                9: "tab",
                13: "enter",
                19: "pause",
                20: "capslock",
                27: "esc",
                32: "space",
                33: "pageup",
                34: "pagedown",
                35: "end",
                36: "home",
                37: "left",
                38: "up",
                39: "right",
                40: "down",
                45: "insert",
                46: "del",
                91: "win",
                92: "win",
                93: "select",
                96: "0",
                97: "1",
                98: "2",
                99: "3",
                100: "4",
                101: "5",
                102: "6",
                103: "7",
                104: "8",
                105: "9",
                106: "*",
                107: "+",
                109: "-",
                110: ".",
                111: "/",
                112: "f1",
                113: "f2",
                114: "f3",
                115: "f4",
                116: "f5",
                117: "f6",
                118: "f7",
                119: "f8",
                120: "f9",
                121: "f10",
                122: "f11",
                123: "f12",
                144: "numlock",
                145: "scrolllock",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'"
            };

            const o = {
                109: "-",
                110: "del",
                111: "/",
                96: "0",
                97: "1",
                98: "2",
                99: "3",
                100: "4",
                101: "5",
                102: "6",
                103: "7",
                104: "8",
                105: "9"
            };

            const s = e.which;

            let a = n[s] || String.fromCharCode(s)
              .toLowerCase();

            (e.ctrlKey || e.metaKey) && t.push("ctrl"), e.altKey && t.push("alt"), e.shiftKey && (t.push(
              "shift"), o[s] ? a = o[s] : i[a] && (a = i[a])), a && (16 > s || s > 18) && t.push(a),
              t = t.join("+"), bi[t] && bi[t].call(fi) === !1 && (e.stopPropagation(), e
              .preventDefault())
        }, fi.addShortcut = (e, t) => (e = e.toLowerCase(), bi[e] = ct(t) ? () => (Et(yi[t], fi.commands[t]), !1) : t, fi), fi.removeShortcut = e => (delete bi[e.toLowerCase()], fi), Zt = e => {
            let t;
            let i;
            let n;
            let o;
            if (!ki.disableBlockRemove && 8 === e.which && (n = G.selectedRange()) && (t = n
              .startContainer, i = n.startOffset, 0 === i && (o = ci()) && !k(o, "body"))) {
                for (; t !== o;) {
                    for (; t.previousSibling;)
                        if (t = t.previousSibling, t.nodeType !== ft || t.nodeValue) return;
                    if (!(t = t.parentNode)) return
                }
                fi.clearBlockFormatting(o), e.preventDefault()
            }
        }, ci = () => {
            for (var e = Q; !$(e) || H(e, !0);)
                if (!(e = e.parentNode) || k(e, "body")) return;
            return e
        }, fi.clearBlockFormatting = e => (e = e || ci(), !e || k(e, "body") ? fi : (G.saveRange(), e.className = "", R = null, f(
          e, "style", ""), k(e, "p,div,td") || F(e, "p"), G.restoreRange(), fi)), ui = e => {
            if (Y && (Y.hasHandler("valuechangedEvent") || ui.hasHandler)) {
                let t;
                const i = fi.sourceMode();
                const n = !i && G.hasSelection();
                W = !1, e = e !== !1 && !T.getElementById("sceditor-start-marker"), q && (clearTimeout(q),
                  q = !1), n && e && G.saveRange(), t = i ? N.value : C.innerHTML, t !== ui
                  .lastVal && (ui.lastVal = t, j(a, "valuechanged", {
                    rawValue: i ? fi.val() : t
                })), n && e && G.removeMarkers()
            }
        }, di = () => {
            q && ui()
        }, hi = ({which}) => {
            const t = which;
            const i = hi.lastChar;
            const n = 13 === i || 32 === i;
            const o = 8 === i || 46 === i;
            hi.lastChar = t, W || (13 === t || 32 === t ? n ? hi.triggerNext = !0 : ui() : 8 === t ||
            46 === t ? o ? hi.triggerNext = !0 : ui() : hi.triggerNext && (ui(), hi
              .triggerNext = !1), clearTimeout(q), q = setTimeout(() => {
                W || ui()
            }, 1500))
        }, Jt = ({type}) => {
            W = /start/i.test(type), W || ui()
        }, pi = () => {
            fi.updateOriginal()
        }, Tt()
    }
    e = e && e.hasOwnProperty("default") ? e["default"] : e;
    var ct = t.bind(null, "string");
    var ut = t.bind(null, "undefined");
    var dt = t.bind(null, "function");
    var ht = t.bind(null, "number");
    var pt = {};
    var mt = 1;
    var ft = 3;
    var _t = !0;

    var gt =
      "|body|hr|p|div|h1|h2|h3|h4|h5|h6|address|pre|form|table|tbody|thead|tfoot|th|tr|td|li|ol|ul|blockquote|center|";

    var vt = {
        toolbar: "bold,italic,underline,strike,subscript,superscript|left,center,right,justify|font,size,color,removeformat|cut,copy,pastetext|bulletlist,orderedlist,indent,outdent|table|code,quote|horizontalrule,image,email,link,unlink|emoticon,youtube,date,time|ltr,rtl|print,maximize,source",
        toolbarExclude: null,
        style: "jquery.sceditor.default.css",
        fonts: "Arial,Arial Black,Comic Sans MS,Courier New,Georgia,Impact,Sans-serif,Serif,Times New Roman,Trebuchet MS,Verdana",
        colors: "#000000,#44B8FF,#1E92F7,#0074D9,#005DC2,#00369B,#b3d5f4|#444444,#C3FFFF,#9DF9FF,#7FDBFF,#68C4E8,#419DC1,#d9f4ff|#666666,#72FF84,#4CEA5E,#2ECC40,#17B529,#008E02,#c0f0c6|#888888,#FFFF44,#FFFA1E,#FFDC00,#E8C500,#C19E00,#fff5b3|#aaaaaa,#FFC95F,#FFA339,#FF851B,#E86E04,#C14700,#ffdbbb|#cccccc,#FF857A,#FF5F54,#FF4136,#E82A1F,#C10300,#ffc6c3|#eeeeee,#FF56FF,#FF30DC,#F012BE,#D900A7,#B20080,#fbb8ec|#ffffff,#F551FF,#CF2BE7,#B10DC9,#9A00B2,#9A00B2,#e8b6ef",
        locale: f(document.documentElement, "lang") || "en",
        charset: "utf-8",
        emoticonsCompat: !1,
        emoticonsEnabled: !0,
        emoticonsRoot: "",
        emoticons: {
            dropdown: {
                ":)": "emoticons/smile.png",
                ":angel:": "emoticons/angel.png",
                ":angry:": "emoticons/angry.png",
                "8-)": "emoticons/cool.png",
                ":'(": "emoticons/cwy.png",
                ":ermm:": "emoticons/ermm.png",
                ":D": "emoticons/grin.png",
                "<3": "emoticons/heart.png",
                ":(": "emoticons/sad.png",
                ":O": "emoticons/shocked.png",
                ":P": "emoticons/tongue.png",
                ";)": "emoticons/wink.png"
            },
            more: {
                ":alien:": "emoticons/alien.png",
                ":blink:": "emoticons/blink.png",
                ":blush:": "emoticons/blush.png",
                ":cheerful:": "emoticons/cheerful.png",
                ":devil:": "emoticons/devil.png",
                ":dizzy:": "emoticons/dizzy.png",
                ":getlost:": "emoticons/getlost.png",
                ":happy:": "emoticons/happy.png",
                ":kissing:": "emoticons/kissing.png",
                ":ninja:": "emoticons/ninja.png",
                ":pinch:": "emoticons/pinch.png",
                ":pouty:": "emoticons/pouty.png",
                ":sick:": "emoticons/sick.png",
                ":sideways:": "emoticons/sideways.png",
                ":silly:": "emoticons/silly.png",
                ":sleeping:": "emoticons/sleeping.png",
                ":unsure:": "emoticons/unsure.png",
                ":woot:": "emoticons/w00t.png",
                ":wassat:": "emoticons/wassat.png"
            },
            hidden: {
                ":whistling:": "emoticons/whistling.png",
                ":love:": "emoticons/wub.png"
            }
        },
        width: null,
        height: null,
        resizeEnabled: !0,
        resizeMinWidth: null,
        resizeMinHeight: null,
        resizeMaxHeight: null,
        resizeMaxWidth: null,
        resizeHeight: !0,
        resizeWidth: !0,
        dateFormat: "year-month-day",
        toolbarContainer: null,
        enablePasteFiltering: !1,
        disablePasting: !1,
        readOnly: !1,
        rtl: !1,
        autofocus: !1,
        autofocusEnd: !0,
        autoExpand: !1,
        autoUpdate: !1,
        spellcheck: !0,
        runWithoutWysiwygSupport: !1,
        startInSourceMode: !1,
        id: null,
        plugins: "",
        zIndex: null,
        bbcodeTrim: !1,
        disableBlockRemove: !1,
        parserOptions: {},
        dropDownCss: {}
    };

    const bt = navigator.userAgent;

    const yt = (() => {
        let e;
        let t = 3;
        const i = document;
        const n = i.createElement("div");
        const o = n.getElementsByTagName("i");
        do n.innerHTML = `<!--[if gt IE ${++t}]><i></i><![endif]-->`; while (o[0]);
        return i.documentMode && i.all && window.atob && (t = 10), 4 === t && i.documentMode && (t = 11),
          t > 4 ? t : e
    })();

    var wt = "-ms-ime-align" in document.documentElement.style;
    var kt = /iPhone|iPod|iPad| wosbrowser\//i.test(bt);

    var xt = (() => {
        let e;
        let t;
        const i = document.createElement("div");
        return i.contentEditable = !0, "contentEditable" in document.documentElement && "true" === i
          .contentEditable ? (t = /Opera Mobi|Opera Mini/i.test(bt), /Android/i.test(bt) && (t = !1),
        / Silk\//i.test(bt) && (e = /AppleWebKit\/(\d+)/.exec(bt), t = e && e[1] ? e[1] < 534 : !
          0), kt && (t = /OS [0-4](_\d)+ like Mac/i.test(bt)), /Firefox/i.test(bt) && (t = !1),
        /OneBrowser/i.test(bt) && (t = !1), "UCWEB" === navigator.vendor && (t = !1), 9 >= yt && (
          t = !0), !t) : !1
    })();

    var Ct =
      /^(https?|s?ftp|mailto|spotify|skype|ssh|teamspeak|tel):|(\/\/)|data:image\/(png|bmp|gif|p?jpe?g);/i;

    var zt = {
        html: '<!DOCTYPE html><html{attrs}><head><style>.ie * {min-height: auto !important} .ie table td {height:15px} @supports (-ms-ime-align:auto) { * { min-height: auto !important; } }</style><meta http-equiv="Content-Type" content="text/html;charset={charset}" /><link rel="stylesheet" type="text/css" href="{style}" /></head><body contenteditable="true" {spellcheck}><p></p></body></html>',
        toolbarButton: '<a class="sceditor-button sceditor-button-{name}" data-sceditor-command="{name}" unselectable="on"><div unselectable="on">{dispName}</div></a>',
        emoticon: '<img src="{url}" data-sceditor-emoticon="{key}" alt="{key}" title="{tooltip}" />',
        fontOpt: '<a class="sceditor-font-option" href="#" data-font="{font}"><font face="{font}">{font}</font></a>',
        sizeOpt: '<a class="sceditor-fontsize-option" data-size="{size}" href="#"><font size="{size}">{size}</font></a>',
        pastetext: '<div><label for="txt">{label}</label> <textarea cols="20" rows="7" id="txt"></textarea></div><div><input type="button" class="button" value="{insert}" /></div>',
        table: '<div><label for="rows">{rows}</label><input type="text" id="rows" value="2" /></div><div><label for="cols">{cols}</label><input type="text" id="cols" value="2" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        image: '<div><label for="link">{url}</label> <input type="text" id="image" dir="ltr" placeholder="https://" /></div><div><label for="width">{width}</label> <input type="text" id="width" size="2" dir="ltr" /></div><div><label for="height">{height}</label> <input type="text" id="height" size="2" dir="ltr" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        email: '<div><label for="email">{label}</label> <input type="text" id="email" dir="ltr" /></div><div><label for="des">{desc}</label> <input type="text" id="des" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        link: '<div><label for="link">{url}</label> <input type="text" id="link" dir="ltr" placeholder="https://" /></div><div><label for="des">{desc}</label> <input type="text" id="des" /></div><div><input type="button" class="button" value="{ins}" /></div>',
        youtubeMenu: '<div><label for="link">{label}</label> <input type="text" id="link" dir="ltr" placeholder="https://" /></div><div><input type="button" class="button" value="{insert}" /></div>',
        youtube: '<iframe width="560" height="315" frameborder="0" allowfullscreen src="https://www.youtube.com/embed/{id}?wmode=opaque&start={time}" data-youtube-id="{id}"></iframe>'
    };

    const Tt = yt && 11 > yt;

    var St = {
        bold: {
            exec: "bold",
            tooltip: "Bold",
            shortcut: "Ctrl+B"
        },
        italic: {
            exec: "italic",
            tooltip: "Italic",
            shortcut: "Ctrl+I"
        },
        underline: {
            exec: "underline",
            tooltip: "Underline",
            shortcut: "Ctrl+U"
        },
        strike: {
            exec: "strikethrough",
            tooltip: "Strikethrough"
        },
        subscript: {
            exec: "subscript",
            tooltip: "Subscript"
        },
        superscript: {
            exec: "superscript",
            tooltip: "Superscript"
        },
        left: {
            state(e) {
                if (e && 3 === e.nodeType && (e = e.parentNode), e) {
                    const t = "ltr" === y(e, "direction"), i = y(e, "textAlign");
                    return "left" === i || i === (t ? "start" : "end")
                }
            },
            exec: "justifyleft",
            tooltip: "Align left"
        },
        center: {
            exec: "justifycenter",
            tooltip: "Center"
        },
        right: {
            state(e) {
                if (e && 3 === e.nodeType && (e = e.parentNode), e) {
                    const t = "ltr" === y(e, "direction"), i = y(e, "textAlign");
                    return "right" === i || i === (t ? "end" : "start")
                }
            },
            exec: "justifyright",
            tooltip: "Align right"
        },
        justify: {
            exec: "justifyfull",
            tooltip: "Justify"
        },
        font: {
            _dropDown(e, t, i) {
                const n = r("div");
                p(n, "click", "a", function (t) {
                    i(w(this, "font")), e.closeDropDown(!0), t.preventDefault()
                }), e.opts.fonts.split(",")
                  .forEach(e => {
                      d(n, tt("fontOpt", {
                          font: e
                      }, !0))
                  }), e.createDropDown(t, "font-picker", n)
            },
            exec(e) {
                const t = this;
                St.font._dropDown(t, e, e => {
                    t.execCommand("fontname", e)
                })
            },
            tooltip: "Font Name"
        },
        size: {
            _dropDown(e, t, i) {
                const n = r("div");
                p(n, "click", "a", function (t) {
                    i(w(this, "size")), e.closeDropDown(!0), t.preventDefault()
                });
                for (let o = 1; 7 >= o; o++) d(n, tt("sizeOpt", {
                    size: o
                }, !0));
                e.createDropDown(t, "fontsize-picker", n)
            },
            exec(e) {
                const t = this;
                St.size._dropDown(t, e, e => {
                    t.execCommand("fontsize", e)
                })
            },
            tooltip: "Font Size"
        },
        color: {
            _dropDown(e, t, i) {
                const n = r("div");
                let o = "";
                const s = St.color;
                s._htmlCache || (e.opts.colors.split("|")
                  .forEach(e => {
                      o += '<div class="sceditor-color-column">', e.split(",")
                        .forEach(e => {
                            o += `<a href="#" class="sceditor-color-option" style="background-color: ${e}" data-color="${e}"></a>`
                        }), o += "</div>"
                  }), s._htmlCache = o), d(n, R(s._htmlCache)), p(n, "click", "a", function (
                  t) {
                    i(w(this, "color")), e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "color-picker", n)
            },
            exec(e) {
                const t = this;
                St.color._dropDown(t, e, e => {
                    t.execCommand("forecolor", e)
                })
            },
            tooltip: "Font Color"
        },
        removeformat: {
            exec: "removeformat",
            tooltip: "Remove Formatting"
        },
        cut: {
            exec: "cut",
            tooltip: "Cut",
            errorMessage: "Your browser does not allow the cut command. Please use the keyboard shortcut Ctrl/Cmd-X"
        },
        copy: {
            exec: "copy",
            tooltip: "Copy",
            errorMessage: "Your browser does not allow the copy command. Please use the keyboard shortcut Ctrl/Cmd-C"
        },
        paste: {
            exec: "paste",
            tooltip: "Paste",
            errorMessage: "Your browser does not allow the paste command. Please use the keyboard shortcut Ctrl/Cmd-V"
        },
        pastetext: {
            exec(e) {
                let t;
                const i = r("div");
                const n = this;
                d(i, tt("pastetext", {
                    label: n._("Paste your text inside the following box:"),
                    insert: n._("Insert")
                }, !0)), p(i, "click", ".button", e => {
                    t = h(i, "#txt")[0].value, t && n.wysiwygEditorInsertText(t), n
                      .closeDropDown(!0), e.preventDefault()
                }), n.createDropDown(e, "pastetext", i)
            },
            tooltip: "Paste Text"
        },
        bulletlist: {
            exec() {
                it(this), this.execCommand("insertunorderedlist")
            },
            tooltip: "Bullet list"
        },
        orderedlist: {
            exec() {
                it(this), this.execCommand("insertorderedlist")
            },
            tooltip: "Numbered list"
        },
        indent: {
            state(e, t) {
                let i, n, o;
                return k(t, "li") ? 0 : k(t, "ul,ol,menu") && (i = this.getRangeHelper()
                  .selectedRange(), n = i.startContainer.parentNode, o = i.endContainer
                  .parentNode, n !== n.parentNode.firstElementChild || k(o, "li") && o !== o
                  .parentNode.lastElementChild) ? 0 : -1
            },
            exec() {
                const e = this,
                      t = e.getRangeHelper()
                        .getFirstBlockParent();
                e.focus(), c(t, "ul,ol,menu") && e.execCommand("indent")
            },
            tooltip: "Add indent"
        },
        outdent: {
            state(e, t) {
                return c(t, "ul,ol,menu") ? 0 : -1
            },
            exec() {
                const e = this.getRangeHelper()
                  .getFirstBlockParent();
                c(e, "ul,ol,menu") && this.execCommand("outdent")
            },
            tooltip: "Remove one indent"
        },
        table: {
            exec(e) {
                const t = this, i = r("div");
                d(i, tt("table", {
                    rows: t._("Rows:"),
                    cols: t._("Cols:"),
                    insert: t._("Insert")
                }, !0)), p(i, "click", ".button", e => {
                    const n = Number(h(i, "#rows")[0].value);
                    const o = Number(h(i, "#cols")[0].value);
                    let s = "<table>";
                    n > 0 && o > 0 && (s += Array(n + 1)
                      .join(`<tr>${Array(o + 1)
    .join(`<td>${Tt ? "" : "<br />"}</td>`)}</tr>`),
                      s += "</table>", t.wysiwygEditorInsertHtml(s), t.closeDropDown(!
                      0), e.preventDefault())
                }), t.createDropDown(e, "inserttable", i)
            },
            tooltip: "Insert a table"
        },
        horizontalrule: {
            exec: "inserthorizontalrule",
            tooltip: "Insert a horizontal rule"
        },
        code: {
            exec() {
                this.wysiwygEditorInsertHtml("<code>", `${Tt ? "" : "<br />"}</code>`)
            },
            tooltip: "Code"
        },
        image: {
            _dropDown(e, t, i, n) {
                const o = r("div");
                d(o, tt("image", {
                    url: e._("URL:"),
                    width: e._("Width (optional):"),
                    height: e._("Height (optional):"),
                    insert: e._("Insert")
                }, !0));
                const s = h(o, "#image")[0];
                s.value = i, p(o, "click", ".button", t => {
                    s.value && n(s.value, h(o, "#width")[0].value, h(o, "#height")[0].value),
                      e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertimage", o)
            },
            exec(e) {
                const t = this;
                St.image._dropDown(t, e, "", (e, i, n) => {
                    let o = "";
                    i && (o += ` width="${i}"`), n && (o += ` height="${n}"`), t
                      .wysiwygEditorInsertHtml(`<img${o} src="${e}" />`)
                })
            },
            tooltip: "Insert an image"
        },
        email: {
            _dropDown(e, t, i) {
                const n = r("div");
                d(n, tt("email", {
                    label: e._("E-mail:"),
                    desc: e._("Description (optional):"),
                    insert: e._("Insert")
                }, !0)), p(n, "click", ".button", t => {
                    const o = h(n, "#email")[0].value;
                    o && i(o, h(n, "#des")[0].value), e.closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertemail", n)
            },
            exec(e) {
                const t = this;
                St.email._dropDown(t, e, (e, i) => {
                    t.focus(), !t.getRangeHelper()
                      .selectedHtml() || i ? t.wysiwygEditorInsertHtml(`<a href="mailto:${e}">${i || e}</a>`) : t.execCommand("createlink",
                      `mailto:${e}`)
                })
            },
            tooltip: "Insert an email"
        },
        link: {
            _dropDown(e, t, i) {
                function n(t) {
                    s.value && i(s.value, h(o, "#des")[0].value), e.closeDropDown(!0), t
                      .preventDefault()
                }
                var o = r("div");
                d(o, tt("link", {
                    url: e._("URL:"),
                    desc: e._("Description (optional):"),
                    ins: e._("Insert")
                }, !0));
                var s = h(o, "#link")[0];
                p(o, "click", ".button", n), p(o, "keypress", e => {
                    13 === e.which && s.value && n(e)
                }, _t), e.createDropDown(t, "insertlink", o)
            },
            exec(e) {
                const t = this;
                St.link._dropDown(t, e, (e, i) => {
                    t.focus(), i || !t.getRangeHelper()
                      .selectedHtml() ? (i = i || e, t.wysiwygEditorInsertHtml(`<a href="${e}">${i}</a>`)) : t.execCommand("createlink", e)
                })
            },
            tooltip: "Insert a link"
        },
        unlink: {
            state() {
                return c(this.currentNode(), "a") ? 0 : -1
            },
            exec() {
                const e = c(this.currentNode(), "a");
                if (e) {
                    for (; e.firstChild;) z(e.firstChild, e);
                    u(e)
                }
            },
            tooltip: "Unlink"
        },
        quote: {
            exec(e, t, i) {
                let n = "<blockquote>", o = "</blockquote>";
                t ? (i = i ? `<cite>${i}</cite>` : "", n = n + i + t + o, o = null) : "" === this
                  .getRangeHelper()
                  .selectedHtml() && (o = (Tt ? "" : "<br />") + o), this.wysiwygEditorInsertHtml(n,
                  o)
            },
            tooltip: "Insert a Quote"
        },
        emoticon: {
            exec(e) {
                const t = this,
                      i = o => {
                          let a;
                          const l = t.opts;
                          const c = l.emoticonsRoot || "";
                          const u = l.emoticonsCompat;
                          const h = t.getRangeHelper();
                          const m = u && " " !== h.getOuterText(!0, 1) ? " " : "";
                          const _ = u && " " !== h.getOuterText(!1, 1) ? " " : "";
                          const g = r("div");
                          let v = r("div");
                          let b = 0;
                          const y = n({}, l.emoticons.dropdown, o ? l.emoticons.more : {});
                          return d(g, v), b = Math.sqrt(Object.keys(y)
                            .length), p(g, "click", "img", function (e) {
                              t.insert(m + f(this, "alt") + _, null, !1)
                                .closeDropDown(!0), e.preventDefault()
                          }), s(y, (e, t) => {
                              d(v, r("img", {
                                  src: c + (t.url || t),
                                  alt: e,
                                  title: t.tooltip || e
                              })), v.children.length >= b && (v = r("div"), d(g, v))
                          }), !o && l.emoticons.more && (a = r("a", {
                              className: "sceditor-more"
                          }), d(a, document.createTextNode(t._("More"))), p(a, "click",
                            n => {
                                t.createDropDown(e, "more-emoticons", i(!0)), n
                                  .preventDefault()
                            }), d(g, a)), g;
                      };
                t.createDropDown(e, "emoticons", i(!1))
            },
            txtExec(e) {
                St.emoticon.exec.call(this, e)
            },
            tooltip: "Insert an emoticon"
        },
        youtube: {
            _dropDown(e, t, i) {
                const n = r("div");
                d(n, tt("youtubeMenu", {
                    label: e._("Video URL:"),
                    insert: e._("Insert")
                }, !0)), p(n, "click", ".button", t => {
                    const o = h(n, "#link")[0].value;
                    const a = o.match(/(?:v=|v\/|embed\/|youtu.be\/)(.{11})/);
                    const r = o.match(/[&|?](?:star)?t=((\d+[hms]?){1,3})/);
                    let l = 0;
                    r && s(r[1].split(/[hms]/), (e, t) => {
                        "" !== t && (l = 60 * l + Number(t))
                    }), a && /^[a-zA-Z0-9_\-]{11}$/.test(a[1]) && i(a[1], l), e
                      .closeDropDown(!0), t.preventDefault()
                }), e.createDropDown(t, "insertlink", n)
            },
            exec(e) {
                const t = this;
                St.youtube._dropDown(t, e, (e, i) => {
                    t.wysiwygEditorInsertHtml(tt("youtube", {
                        id: e,
                        time: i
                    }))
                })
            },
            tooltip: "Insert a YouTube video"
        },
        date: {
            _date({opts}) {
                const t = new Date;
                let i = t.getYear();
                let n = t.getMonth() + 1;
                let o = t.getDate();
                return 2e3 > i && (i = 1900 + i), 10 > n && (n = `0${n}`), 10 > o && (o = `0${o}`), opts.dateFormat.replace(/year/i, i)
                  .replace(/month/i, n)
                  .replace(/day/i, o);
            },
            exec() {
                this.insertText(St.date._date(this))
            },
            txtExec() {
                this.insertText(St.date._date(this))
            },
            tooltip: "Insert current date"
        },
        time: {
            _time() {
                const e = new Date;
                let t = e.getHours();
                let i = e.getMinutes();
                let n = e.getSeconds();
                return 10 > t && (t = `0${t}`), 10 > i && (i = `0${i}`), 10 > n && (n = `0${n}`), `${t}:${i}:${n}`;
            },
            exec() {
                this.insertText(St.time._time())
            },
            txtExec() {
                this.insertText(St.time._time())
            },
            tooltip: "Insert current time"
        },
        ltr: {
            state(e, t) {
                return t && "ltr" === t.style.direction
            },
            exec() {
                const e = this;
                const t = e.getRangeHelper();
                let i = t.getFirstBlockParent();
                if (e.focus(), i && !k(i, "body") || (e.execCommand("formatBlock", "p"), i = t
                  .getFirstBlockParent(), i && !k(i, "body"))) {
                    const n = "ltr" === y(i, "direction") ? "" : "ltr";
                    y(i, "direction", n)
                }
            },
            tooltip: "Left-to-Right"
        },
        rtl: {
            state(e, t) {
                return t && "rtl" === t.style.direction
            },
            exec() {
                const e = this;
                const t = e.getRangeHelper();
                let i = t.getFirstBlockParent();
                if (e.focus(), i && !k(i, "body") || (e.execCommand("formatBlock", "p"), i = t
                  .getFirstBlockParent(), i && !k(i, "body"))) {
                    const n = "rtl" === y(i, "direction") ? "" : "rtl";
                    y(i, "direction", n)
                }
            },
            tooltip: "Right-to-Left"
        },
        print: {
            exec: "print",
            tooltip: "Print"
        },
        maximize: {
            state() {
                return this.maximize()
            },
            exec() {
                this.maximize(!this.maximize())
            },
            txtExec() {
                this.maximize(!this.maximize())
            },
            tooltip: "Maximize",
            shortcut: "Ctrl+Shift+M"
        },
        source: {
            state() {
                return this.sourceMode()
            },
            exec() {
                this.toggleSourceMode()
            },
            txtExec() {
                this.toggleSourceMode()
            },
            tooltip: "View source",
            shortcut: "Ctrl+Shift+S"
        },
        ignore: {}
    };

    var At = {};
    nt.plugins = At;
    var Et = yt && 11 > yt;

    var Pt = ({startContainer, startOffset}, t, i) => {
        let n, o, s, a, r, l = "", c = startContainer, u = startOffset;
        for (c && 3 !== c.nodeType && (c = c.childNodes[u], u = 0), s = a = u; i > l.length && c && 3 ===
        c.nodeType;) n = c.nodeValue, o = i - l.length, r && (a = n.length, s = 0), r = c, t ? (s =
          Math.max(a - o, 0), u = s, l = n.substr(s, a - s) + l, c = r.previousSibling) : (a = Math
          .min(o, n.length), u = s + a, l += n.substr(s, a), c = r.nextSibling);
        return {
            node: r || c,
            offset: u,
            text: l
        }
    };

    var It = window;
    var Mt = document;
    var jt = yt;
    var Dt = jt && 11 > jt;
    var Nt = /^image\/(p?jpe?g|gif|png|bmp)$/i;
    lt.locale = {}, lt.formats = {}, lt.icons = {}, lt.command = {
        get(e) {
            return St[e] || null
        },
        set(e, t) {
            return e && t ? (t = n(St[e] || {}, t), t.remove = () => {
                lt.command.remove(e)
            }, St[e] = t, this) : !1;
        },
        remove(e) {
            return St[e] && delete St[e], this
        }
    },
      /**
       * SCEditor
       * http://www.sceditor.com/
       *
       * Copyright (C) 2017, Sam Clarke (samclarke.com)
       *
       * SCEditor is licensed under the MIT license:
       *	http://www.opensource.org/licenses/mit-license.php
       *
       * @fileoverview SCEditor - A lightweight WYSIWYG BBCode and HTML editor
       * @author Sam Clarke
       */
      window.sceditor = {
          command: lt.command,
          commands: St,
          defaultOptions: vt,
          ie: yt,
          ios: kt,
          isWysiwygSupported: xt,
          regexEscape: Q,
          escapeEntities: X,
          escapeUriScheme: et,
          dom: {
              css: y,
              attr: f,
              removeAttr: _,
              is: k,
              closest: c,
              width: I,
              height: M,
              traverse: L,
              rTraverse: O,
              parseHTML: R,
              hasStyling: $,
              convertElement: F,
              blockLevelList: gt,
              canHaveChildren: B,
              isInline: H,
              copyCSS: W,
              fixNesting: V,
              findCommonAncestor: q,
              getSibling: U,
              removeWhiteSpace: Z,
              extractContents: G,
              getOffset: K,
              getStyle: Y,
              hasStyle: J
          },
          locale: lt.locale,
          icons: lt.icons,
          utils: {
              each: s,
              isEmptyObject: i,
              extend: n
          },
          plugins: nt.plugins,
          formats: lt.formats,
          create(e, t) {
              t = t || {}, l(e, ".sceditor-container") || (t.runWithoutWysiwygSupport || xt) && new lt(
                e, t)
          },
          instance({_sceditor}) {
              return _sceditor;
          }
      },
      /**
       * SCEditor
       * http://www.sceditor.com/
       *
       * Copyright (C) 2017, Sam Clarke (samclarke.com)
       *
       * SCEditor is licensed under the MIT license:
       *	http://www.opensource.org/licenses/mit-license.php
       *
       * @fileoverview SCEditor - A lightweight WYSIWYG BBCode and HTML editor
       * @author Sam Clarke
       * @requires jQuery
       */
      e.sceditor = window.sceditor, e.fn.sceditor = function (t) {
        let i;
        const n = [];
        return this.each(function () {
            i = this._sceditor, "state" === t ? n.push(!!i) : "instance" === t ? n.push(i) : i ||
              e.sceditor.create(this, t)
        }), n.length ? 1 === n.length ? n[0] : n : this
    }
})(jQuery), /**
 * SCEditor BBCode Plugin
 * http://www.sceditor.com/
 *
 * Copyright (C) 2011-2017, Sam Clarke (samclarke.com)
 *
 * SCEditor is licensed under the MIT license:
 *	http://www.opensource.org/licenses/mit-license.php
 *
 * @fileoverview SCEditor BBCode Format
 * @author Sam Clarke
 */
(e => {
    function t(e, t) {
        return e.replace(/\{([^}]+)\}/g, (e, i) => {
            let n;
            let o = !0;
            return "!" === i.charAt(0) && (o = !1, i = i.substring(1)), "0" === i && (o = !1), t[
              i] === n ? e : o ? d(t[i], !0) : t[i]
        });
    }

    function i(e) {
        let t;
        let i;
        let n;
        const o = document.createElement("div");
        return n = (e, t) => {
            if (!p.hasStyling(e)) {
                if (w || 1 !== e.childNodes.length || !g(e.firstChild, "br"))
                    for (; i = e.firstChild;) o.insertBefore(i, e);
                if (t) {
                    const n = o.lastChild;
                    e !== n && g(n, "div") && e.nextSibling === n && o.insertBefore(document
                      .createElement("br"), e)
                }
                o.removeChild(e)
            }
        }, f(o, "display", "none"), o.innerHTML = e.replace(/<\/div>\n/g, "</div>"), (t = o.firstChild) &&
        g(t, "div") && n(t, !0), (t = o.lastChild) && g(t, "div") && n(t), o.innerHTML;
    }

    function n(e) {
        return "function" == typeof e
    }

    function o(e) {
        return e ? e.replace(/\\(.)/g, "$1")
          .replace(/^(["'])(.*?)\1$/, "$2") : e
    }

    function s(e) {
        let t;
        const i = arguments;
        return e.replace(/\{(\d+)\}/g, (e, n) => i[n - 0 + 1] !== t ? i[n - 0 + 1] : `{${n}}`);
    }

    function a(e, t, i, n, o, s) {
        const a = this;
        a.type = e, a.name = t, a.val = i, a.attrs = n || {}, a.children = o || [], a.closing = s || null
    }

    function r(e) {
        function i(e, t) {
            let i;
            let n;
            let o;
            const r = /\[([^\]\s=]+)(?:([^\]]+))?\]/;
            const l = /\[\/([^\[\]]+)\]/;
            return e === S && (i = t.match(r)) && (o = y(i[1]), i[2] && (i[2] = i[2].trim()) && (n = s(i[
              2]))), e === P && (i = t.match(l)) && (o = y(i[1])), e === E && (o = "#newline"), o && (e !==
              S && e !== P || T[o]) || (e = A, o = "#"), new a(e, o, t, n)
        }

        function s(e) {
            let t;
            const i = /([^\s=]+)=(?:(?:(["'])((?:\\\2|[^\2])*?)\2)|((?:.(?!\s\S+=))*.))/g;
            const n = {};
            if ("=" === e.charAt(0) && e.indexOf("=", 1) < 0) n.defaultattr = o(e.substr(1));
            else
                for ("=" === e.charAt(0) && (e = `defaultattr${e}`); t = i.exec(e);) n[y(t[1])] = o(t[3]) ||
                  t[4];
            return n
        }

        function l(e, t, i) {
            for (let n = i.length; n--;)
                if (i[n].type === t && i[n].name === e) return !0;
            return !1
        }

        function c(e, {name}) {
            const i = e ? T[e.name] : {};
            const n = i.allowedChildren;
            return k.opts.fixInvalidChildren && n ? n.includes(name || "#") : !0;
        }

        function u(e) {
            for (var t, i, n, o, s, a, r = [], u = [], d = [], h = () => b(d), p = e => {
                h() ? h()
                  .children.push(e) : u.push(e)
            }, m = e => h() && (i = T[h()
              .name]) && i.closedBy && i.closedBy.includes(e); t = e.shift();) switch (a = e[0], c(h(), t) || t.type === P && h() && t.name === h()
              .name || (t.name = "#", t.type = A), t.type) {
                case S:
                    m(t.name) && d.pop(), p(t), i = T[t.name], i && !i.isSelfClosing && (i.closedBy || l(t
                      .name, P, e)) ? d.push(t) : i && i.isSelfClosing || (t.type = A);
                    break;
                case P:
                    if (h() && t.name !== h()
                      .name && m(`/${t.name}`) && d.pop(), h() && t.name === h()
                      .name) h()
                      .closing = t, d.pop();
                    else if (l(t.name, S, d)) {
                        for (; n = d.pop();) {
                            if (n.name === t.name) {
                                n.closing = t;
                                break
                            }
                            o = n.clone(), r.length && o.children.push(b(r)), r.push(o)
                        }
                        for (a && a.type === E && (i = T[t.name], i && i.isInline === !1 && (p(a), e
                          .shift())), p(b(r)), s = r.length; s--;) d.push(r[s]);
                        r.length = 0
                    } else t.type = A, p(t);
                    break;
                case E:
                    h() && a && m((a.type === P ? "/" : "") + a.name) && (a.type !== P || a.name !== h()
                      .name) && (i = T[h()
                      .name], i && i.breakAfter ? d.pop() : i && i.isInline === !1 && k.opts
                      .breakAfterBlock && i.breakAfter !== !1 && d.pop()), p(t);
                    break;
                default:
                    p(t)
            }
            return u
        }

        function h(e, t, i) {
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            const d = e.length;
            t && (a = T[t.name]);
            for (let p = d; p--;)
                if (n = e[p])
                    if (n.type === E) {
                        if (o = p > 0 ? e[p - 1] : null, s = d - 1 > p ? e[p + 1] : null, u = !1, !i && a && a
                          .isSelfClosing !== !0 && (o ? l || s || (a.isInline === !1 && k.opts
                          .breakEndBlock && a.breakEnd !== !1 && (u = !0), a.breakEnd && (u = !0),
                          l = u) : (a.isInline === !1 && k.opts.breakStartBlock && a.breakStart !==
                        !1 && (u = !0), a.breakStart && (u = !0))), o && o.type === S && (r = T[o
                          .name]) && (i ? r.isInline === !1 && (u = !0) : (r.isInline === !1 && k.opts
                          .breakAfterBlock && r.breakAfter !== !1 && (u = !0), r.breakAfter && (
                          u = !0))), !i && !c && s && s.type === S && (r = T[s.name]) && (r
                          .isInline === !1 && k.opts.breakBeforeBlock && r.breakBefore !== !1 && (u = !
                          0), r.breakBefore && (u = !0), c = u, u)) {
                            e.splice(p, 1);
                            continue
                        }
                        u && e.splice(p, 1), c = !1
                    } else n.type === S && h(n.children, n, i)
        }

        function p(e, t, i, n) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let u;

            const d = ({name}) => {
                const t = T[name];
                return !t || t.isInline !== !1
            };

            for (t = t || [], n = n || e, s = 0; s < e.length; s++)
                if ((o = e[s]) && o.type === S) {
                    if (i && !d(o)) {
                        if (a = b(t), u = a.splitAt(o), l = t.length > 1 ? t[t.length - 2].children : n, c(o,
                          a)) {
                            const h = a.clone();
                            h.children = o.children, o.children = [h]
                        }
                        if (r = l.indexOf(a), r > -1) {
                            u.children.splice(0, 1), l.splice(r + 1, 0, o, u);
                            const m = u.children[0];
                            return m && m.type === E && (d(o) || (u.children.splice(0, 1), l.splice(r + 2, 0,
                              m))), void 0
                        }
                    }
                    t.push(o), p(o.children, t, i || d(o), n), t.pop()
                }
        }

        function m(e) {
            for (let t,
                i,
                n = e => {
                    for (let t = e.length; t--;) {
                        const i = e[t].type;
                        if (i === S || i === P) return !1;
                        if (i === A && /\S|\u00A0/.test(e[t].val)) return !1
                    }
                    return !0
                },
                o = e.length; o--;)(t = e[o]) && t.type === S && (i = T[t.name], m(t.children), n(t
              .children) && i && !i.isSelfClosing && !i.allowsEmpty && e.splice(...[o, 1]
              .concat(t.children)))
        }

        function f(e, i) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let h;
            let p;
            const m = [];
            for (h = e => (!e || (e.isHtmlInline !== o ? e.isHtmlInline : e.isInline)) !== !1; e.length > 0;)
                if (s = e.shift()) {
                    if (s.type === S) p = s.children[s.children.length - 1] || {}, a = T[s.name], c = i && h(
                      a), r = f(s.children, !1), a && a.html ? (h(a) || !h(T[p.name]) || a
                      .isPreFormatted || a.skipLastLineBreak || w || (r += "<br />"), n(a.html) ? l = a
                      .html.call(k, s, s.attrs, r) : (s.attrs["0"] = r, l = t(a.html, s.attrs))) : l = s
                      .val + r + (s.closing ? s.closing.val : "");
                    else {
                        if (s.type === E) {
                            if (!i) {
                                m.push("<br />");
                                continue
                            }
                            u || m.push("<div>"), w || m.push("<br />"), e.length || m.push("<br />"), m.push(
                              "</div>\n"), u = !1;
                            continue
                        }
                        c = i, l = d(s.val, !0)
                    }
                    c && !u ? (m.push("<div>"), u = !0) : !c && u && (m.push("</div>\n"), u = !1), m.push(l)
                }return u && m.push("</div>\n"), m.join("")
        }

        function _(e) {
            for (var t, i, n, o, s, a, r, l, c, u, d = []; e.length > 0;)
                if (t = e.shift())
                    if (n = T[t.name], o = !(!n || n.isInline !== !1), s = n && n.isSelfClosing, r = o && k
                      .opts.breakBeforeBlock && n.breakBefore !== !1 || n && n.breakBefore, l = o && !s && k
                      .opts.breakStartBlock && n.breakStart !== !1 || n && n.breakStart, c = o && k.opts
                      .breakEndBlock && n.breakEnd !== !1 || n && n.breakEnd, u = o && k.opts
                      .breakAfterBlock && n.breakAfter !== !1 || n && n.breakAfter, a = (n ? n.quoteType :
                      null) || k.opts.quoteType || C.auto, n || t.type !== S)
                        if (t.type === S) {
                            if (r && d.push("\n"), d.push(`[${t.name}`), t.attrs) {
                                t.attrs.defaultattr && (d.push("=", g(t.attrs.defaultattr, a, "defaultattr")),
                                  delete t.attrs.defaultattr);
                                for (i in t.attrs) t.attrs.hasOwnProperty(i) && d.push(" ", i, "=", g(t.attrs[
                                  i], a, i))
                            }
                            d.push("]"), l && d.push("\n"), t.children && d.push(_(t.children)), s || n
                              .excludeClosing || (c && d.push("\n"), d.push(`[/${t.name}]`)), u && d
                              .push("\n"), t.closing && s && d.push(t.closing.val)
                        } else d.push(t.val);
                    else d.push(t.val), t.children && d.push(_(t.children)), t.closing && d.push(t.closing.val);
            return d.join("")
        }

        function g(e, t, i) {
            const o = /\s|=/.test(e);
            return n(t) ? t(e, i) : t === C.never || t === C.auto && !o ? e : `"${e.replace("\\", "\\\\")
  .replace('"', '\\"')}"`;
        }

        function b(e) {
            return e.length ? e[e.length - 1] : null
        }

        function y(e) {
            return e.toLowerCase()
        }
        var k = this;
        k.opts = v({}, r.defaults, e), k.tokenize = e => {
            let t;
            let n;
            let o;
            const s = [];

            const a = [{
                type: A,
                regex: /^([^\[\r\n]+|\[)/
            }, {
                type: E,
                regex: /^(\r\n|\r|\n)/
            }, {
                type: S,
                regex: /^\[[^\[\]]+\]/
            }, {
                type: P,
                regex: /^\[\/[^\[\]]+\]/
            }];

            e: for (; e.length;) {
                for (o = a.length; o--;)
                    if (n = a[o].type, (t = e.match(a[o].regex)) && t[0]) {
                        s.push(i(n, t[0])), e = e.substr(t[0].length);
                        continue e
                    } e.length && s.push(i(A, e)), e = ""
            }
            return s
        }, k.parse = (e, t) => {
            const i = u(k.tokenize(e));
            const n = k.opts;
            return n.fixInvalidNesting && p(i), h(i, null, t), n.removeEmptyTags && m(i), i
        }, k.toHTML = (e, t) => f(k.parse(e, t), !0), k.toBBCode = (e, t) => _(k.parse(e, t))
    }

    function l(e) {
        return e = parseInt(e, 10), isNaN(e) ? "00" : (e = Math.max(0, Math.min(e, 255))
          .toString(16), e.length < 2 ? `0${e}` : e);
    }

    function c(e) {
        let t;
        return e = e || "#000", (t = e.match(/rgb\((\d{1,3}),\s*?(\d{1,3}),\s*?(\d{1,3})\)/i)) ? `#${l(t[
  1])}${l(t[2])}${l(t[3])}` : (t = e.match(/#([0-f])([0-f])([0-f])\s*?$/i)) ? `#${t[1]}${t[1]}${t[
  2]}${t[2]}${t[3]}${t[3]}` : e;
    }

    function u() {
        function e() {
            b(T, e => {
                let t;
                const i = T[e].tags;
                const n = T[e].styles;
                i && b(i, (i, n) => {
                    t = T[e].isInline === !1, m[i] = m[i] || {}, m[i][t] = m[i][t] || {}, m[i]
                      [t][e] = n
                }), n && b(n, (i, n) => {
                    t = T[e].isInline === !1, y[t] = y[t] || {}, y[t][i] = y[t][i] || {}, y[t]
                      [i][e] = n
                })
            })
        }

        function t(e, t, i) {
            let o;
            let a;
            const r = p.getStyle;
            return i = !!i, y[i] ? (b(y[i], (i, l) => {
                o = r(e, i), o && r(e.parentNode, i) !== o && b(l, (i, r) => {
                    (!r || r.includes(o.toString())) && (a = T[i].format, t = n(a) ? a
                      .call(h, e, t) : s(a, t))
                })
            }), t) : t;
        }

        function a(e, t) {
            const i = e.nodeName.toLowerCase();
            const n = p.isInline;
            if (!n(e, !0) || "br" === i) {
                for (var o, s, a, r = e.previousSibling; r && 1 === r.nodeType && !g(r, "br") && n(r, !0) && !
                  r.firstChild;) r = r.previousSibling;
                do s = e.parentNode, a = s && s.lastChild, o = a === e, e = s; while (s && o && n(s, !0));
                (!o || "li" === i || "br" === i && w) && (t += "\n"), "br" !== i && r && !g(r, "br") && n(r, !
                  0) && (t = `\n${t}`)
            }
            return t
        }

        function l(e, t, i) {
            let o;
            let a;
            const r = e.nodeName.toLowerCase();
            return i = !!i, m[r] && m[r][i] && b(m[r][i], (i, r) => {
                (!r || (o = !1, b(r, (t, i) => !_(e, t) || i && !i.includes(_(e, t)) ? void 0 : (o = !0, !1)), o)) && (a = T[i].format, t = n(a) ? a.call(h, e, t) : s(a, t))
            }), t;
        }

        function c(e) {
            const i = (e, n) => {
                let o = "";
                return p.traverse(e, e => {
                    let s = "";
                    const r = e.nodeType;
                    const c = e.nodeName.toLowerCase();
                    let u = x[c];
                    const d = e.firstChild;
                    let h = !0;
                    if ("object" == typeof n && (h = n.includes(c), g(e, "img") && _(e, k) &&
                    (h = !0), h || (u = n)), 3 === r || 1 === r)
                        if (1 === r) {
                            if (g(e, ".sceditor-nlf") && (!d || !w && 1 === e.childNodes.length &&
                              /br/i.test(d.nodeName))) return;
                            "iframe" !== c && (s = i(e, u)), h ? ("code" !== c && (s = t(e, s),
                              s = l(e, s), s = t(e, s, !0)), s = l(e, s, !0), o += a(e,
                              s)) : o += s
                        } else o += e.nodeValue
                }, !1, !0), o;
            };
            return i(e)
        }

        function u(e, t, n) {
            const o = new r(h.opts.parserOptions);
            const s = o.toHTML(h.opts.bbcodeTrim ? t.trim() : t);
            return e || n ? i(s) : s
        }

        function d(e, t, i = document, n) {
            let o;
            let s;
            const a = i.createElement("div");
            const l = i.createElement("div");
            const u = new r(h.opts.parserOptions);
            for (l.innerHTML = t, f(a, "visibility", "hidden"), a.appendChild(l), i.body.appendChild(a), e &&
            (a.insertBefore(i.createTextNode("#"), a.firstChild), a.appendChild(i.createTextNode("#"))),
                 n && f(l, "whiteSpace", f(n, "whiteSpace")), s = l.getElementsByClassName(
              "sceditor-ignore"); s.length;) s[0].parentNode.removeChild(s[0]);
            return p.removeWhiteSpace(a), o = c(l), i.body.removeChild(a), o = u.toBBCode(o, !0), h.opts
              .bbcodeTrim && (o = o.trim()), o
        }
        var h = this;
        h.stripQuotes = o;
        var m = {};
        var y = {};

        var x = {
            ul: ["li", "ol", "ul"],
            ol: ["li", "ol", "ul"],
            table: ["tr"],
            tr: ["td", "th"],
            code: ["br", "p", "div"]
        };

        h.init = function () {
            h.opts = this.opts, h.elementToBbcode = c, e(), this.commands = v(!0, {}, z, this.commands),
              this.toBBCode = h.toSource, this.fromBBCode = h.toHtml
        }, h.toHtml = u.bind(null, !1), h.fragmentToHtml = u.bind(null, !0), h.toSource = d.bind(null, !
          1), h.fragmentToSource = d.bind(null, !0)
    }
    var d = e.escapeEntities;
    const h = e.escapeUriScheme;
    var p = e.dom;
    const m = e.utils;
    var f = p.css;
    var _ = p.attr;
    var g = p.is;
    var v = m.extend;
    var b = m.each;
    const y = e.ie;
    var w = y && 11 > y;
    var k = "data-sceditor-emoticon";
    const x = e.command.get;

    var C = {
        always: 1,
        never: 2,
        auto: 3
    };

    var z = {
        bold: {
            txtExec: ["[b]", "[/b]"]
        },
        italic: {
            txtExec: ["[i]", "[/i]"]
        },
        underline: {
            txtExec: ["[u]", "[/u]"]
        },
        strike: {
            txtExec: ["[s]", "[/s]"]
        },
        subscript: {
            txtExec: ["[sub]", "[/sub]"]
        },
        superscript: {
            txtExec: ["[sup]", "[/sup]"]
        },
        left: {
            txtExec: ["[left]", "[/left]"]
        },
        center: {
            txtExec: ["[center]", "[/center]"]
        },
        right: {
            txtExec: ["[right]", "[/right]"]
        },
        justify: {
            txtExec: ["[justify]", "[/justify]"]
        },
        font: {
            txtExec(e) {
                const t = this;
                x("font")
                  ._dropDown(t, e, e => {
                      t.insertText(`[font=${e}]`, "[/font]")
                  })
            }
        },
        size: {
            txtExec(e) {
                const t = this;
                x("size")
                  ._dropDown(t, e, e => {
                      t.insertText(`[size=${e}]`, "[/size]")
                  })
            }
        },
        color: {
            txtExec(e) {
                const t = this;
                x("color")
                  ._dropDown(t, e, e => {
                      t.insertText(`[color=${e}]`, "[/color]")
                  })
            }
        },
        bulletlist: {
            txtExec(e, t) {
                let i = "";
                b(t.split(/\r?\n/), function () {
                    i += `${i ? "\n" : ""}[li]${this}[/li]`
                }), this.insertText(`[ul]\n${i}\n[/ul]`)
            }
        },
        orderedlist: {
            txtExec(e, t) {
                let i = "";
                b(t.split(/\r?\n/), function () {
                    i += `${i ? "\n" : ""}[li]${this}[/li]`
                }), this.insertText(`[ol]\n${i}\n[/ol]`)
            }
        },
        table: {
            txtExec: ["[table][tr][td]", "[/td][/tr][/table]"]
        },
        horizontalrule: {
            txtExec: ["[hr]"]
        },
        code: {
            txtExec: ["[code]", "[/code]"]
        },
        image: {
            txtExec(e, t) {
                const i = this;
                x("image")
                  ._dropDown(i, e, t, (e, t, n) => {
                      let o = "";
                      t && (o += ` width=${t}`), n && (o += ` height=${n}`), i.insertText(
                        `[img${o}]${e}[/img]`)
                  })
            }
        },
        email: {
            txtExec(e, t) {
                const i = this;
                x("email")
                  ._dropDown(i, e, (e, n) => {
                      i.insertText(`[email=${e}]${n || t || e}[/email]`)
                  })
            }
        },
        link: {
            txtExec(e, t) {
                const i = this;
                x("link")
                  ._dropDown(i, e, (e, n) => {
                      i.insertText(`[url=${e}]${n || t || e}[/url]`)
                  })
            }
        },
        quote: {
            txtExec: ["[quote]", "[/quote]"]
        },
        youtube: {
            txtExec(e) {
                const t = this;
                x("youtube")
                  ._dropDown(t, e, e => {
                      t.insertText(`[youtube]${e}[/youtube]`)
                  })
            }
        },
        rtl: {
            txtExec: ["[rtl]", "[/rtl]"]
        },
        ltr: {
            txtExec: ["[ltr]", "[/ltr]"]
        }
    };

    var T = {
        b: {
            tags: {
                b: null,
                strong: null
            },
            styles: {
                "font-weight": ["bold", "bolder", "401", "700", "800", "900"]
            },
            format: "[b]{0}[/b]",
            html: "<strong>{0}</strong>"
        },
        i: {
            tags: {
                i: null,
                em: null
            },
            styles: {
                "font-style": ["italic", "oblique"]
            },
            format: "[i]{0}[/i]",
            html: "<em>{0}</em>"
        },
        u: {
            tags: {
                u: null
            },
            styles: {
                "text-decoration": ["underline"]
            },
            format: "[u]{0}[/u]",
            html: "<u>{0}</u>"
        },
        s: {
            tags: {
                s: null,
                strike: null
            },
            styles: {
                "text-decoration": ["line-through"]
            },
            format: "[s]{0}[/s]",
            html: "<s>{0}</s>"
        },
        sub: {
            tags: {
                sub: null
            },
            format: "[sub]{0}[/sub]",
            html: "<sub>{0}</sub>"
        },
        sup: {
            tags: {
                sup: null
            },
            format: "[sup]{0}[/sup]",
            html: "<sup>{0}</sup>"
        },
        font: {
            tags: {
                font: {
                    face: null
                }
            },
            styles: {
                "font-family": null
            },
            quoteType: C.never,
            format(e, t) {
                let i;
                return g(e, "font") && (i = _(e, "face")) || (i = f(e, "font-family")), `[font=${o(
  i)}]${t}[/font]`;
            },
            html: '<font face="{defaultattr}">{0}</font>'
        },
        size: {
            tags: {
                font: {
                    size: null
                }
            },
            styles: {
                "font-size": null
            },
            format(e, t) {
                let i = _(e, "size"), n = 2;
                return i || (i = f(e, "fontSize")), i.includes("px") ? (i = i.replace("px", "") -
                  0, 12 > i && (n = 1), i > 15 && (n = 3), i > 17 && (n = 4), i > 23 && (n = 5),
                i > 31 && (n = 6), i > 47 && (n = 7)) : n = i, `[size=${n}]${t}[/size]`;
            },
            html: '<font size="{defaultattr}">{!0}</font>'
        },
        color: {
            tags: {
                font: {
                    color: null
                }
            },
            styles: {
                color: null
            },
            quoteType: C.never,
            format(e, t) {
                let i;
                return g(e, "font") && (i = _(e, "color")) || (i = e.style.color || f(e, "color")),
                `[color=${c(i)}]${t}[/color]`;
            },
            html(e, {defaultattr}, i) {
                return `<font color="${d(c(defaultattr), !0)}">${i}</font>`;
            }
        },
        ul: {
            tags: {
                ul: null
            },
            breakStart: !0,
            isInline: !1,
            skipLastLineBreak: !0,
            format: "[ul]{0}[/ul]",
            html: "<ul>{0}</ul>"
        },
        list: {
            breakStart: !0,
            isInline: !1,
            skipLastLineBreak: !0,
            html: "<ul>{0}</ul>"
        },
        ol: {
            tags: {
                ol: null
            },
            breakStart: !0,
            isInline: !1,
            skipLastLineBreak: !0,
            format: "[ol]{0}[/ol]",
            html: "<ol>{0}</ol>"
        },
        li: {
            tags: {
                li: null
            },
            isInline: !1,
            closedBy: ["/ul", "/ol", "/list", "*", "li"],
            format: "[li]{0}[/li]",
            html: "<li>{0}</li>"
        },
        "*": {
            isInline: !1,
            closedBy: ["/ul", "/ol", "/list", "*", "li"],
            html: "<li>{0}</li>"
        },
        table: {
            tags: {
                table: null
            },
            isInline: !1,
            isHtmlInline: !0,
            skipLastLineBreak: !0,
            format: "[table]{0}[/table]",
            html: "<table>{0}</table>"
        },
        tr: {
            tags: {
                tr: null
            },
            isInline: !1,
            skipLastLineBreak: !0,
            format: "[tr]{0}[/tr]",
            html: "<tr>{0}</tr>"
        },
        th: {
            tags: {
                th: null
            },
            allowsEmpty: !0,
            isInline: !1,
            format: "[th]{0}[/th]",
            html: "<th>{0}</th>"
        },
        td: {
            tags: {
                td: null
            },
            allowsEmpty: !0,
            isInline: !1,
            format: "[td]{0}[/td]",
            html: "<td>{0}</td>"
        },
        emoticon: {
            allowsEmpty: !0,
            tags: {
                img: {
                    src: null,
                    "data-sceditor-emoticon": null
                }
            },
            format(e, t) {
                return _(e, k) + t
            },
            html: "{0}"
        },
        hr: {
            tags: {
                hr: null
            },
            allowsEmpty: !0,
            isSelfClosing: !0,
            isInline: !1,
            format: "[hr]{0}",
            html: "<hr />"
        },
        img: {
            allowsEmpty: !0,
            tags: {
                img: {
                    src: null
                }
            },
            allowedChildren: ["#"],
            quoteType: C.never,
            format(e, t) {
                let i;
                let n;
                let o = "";
                const s = t => e.style ? e.style[t] : null;
                return _(e, k) ? t : (i = _(e, "width") || s("width"), n = _(e, "height") || s(
                  "height"), (e.complete && (i || n) || i && n) && (o = `=${p.width(e)}x${p.height(e)}`), `[img${o}]${_(e, "src")}[/img]`);
            },
            html(e, {width, height, defaultattr}, i) {
                let n, o, s, a, r = "";
                return o = width, s = height, defaultattr && (a = defaultattr.split(/x/i), o =
                  a[0], s = 2 === a.length ? a[1] : a[0]), o !== n && (r += ` width="${d(o, !
  0)}"`), s !== n && (r += ` height="${d(s, !0)}"`), `<img${r} src="${h(i)}" />`;
            }
        },
        url: {
            allowsEmpty: !0,
            tags: {
                a: {
                    href: null
                }
            },
            quoteType: C.never,
            format(e, t) {
                const i = _(e, "href");
                return "mailto:" === i.substr(0, 7) ? `[email="${i.substr(7)}"]${t}[/email]` : `[url=${i}]${t}[/url]`;
            },
            html(e, t, i) {
                return t.defaultattr = d(t.defaultattr, !0) || i, `<a href="${h(t.defaultattr)}">${i}</a>`;
            }
        },
        email: {
            quoteType: C.never,
            html(e, {defaultattr}, i) {
                return `<a href="mailto:${d(defaultattr, !0) || i}">${i}</a>`;
            }
        },
        quote: {
            tags: {
                blockquote: null
            },
            isInline: !1,
            quoteType: C.never,
            format(e, t) {
                for (var i, n = "data-author", o = "", s = e.children, a = 0; !i && a < s.length; a++)
                    g(s[a], "cite") && (i = s[a]);
                return (i || _(e, n)) && (o = i && i.textContent || _(e, n), _(e, n, o), i && e
                  .removeChild(i), t = this.elementToBbcode(e), o = `=${o.replace(
  /(^\s+|\s+$)/g, "")}`, i && e.insertBefore(i, e.firstChild)), `[quote${o}]${t}[/quote]`;
            },
            html(e, {defaultattr}, i) {
                return defaultattr && (i = `<cite>${d(defaultattr)}</cite>${i}`),
                `<blockquote>${i}</blockquote>`;
            }
        },
        code: {
            tags: {
                code: null
            },
            isInline: !1,
            allowedChildren: ["#", "#newline"],
            format: "[code]{0}[/code]",
            html: "<code>{0}</code>"
        },
        left: {
            styles: {
                "text-align": ["left", "-webkit-left", "-moz-left", "-khtml-left"]
            },
            isInline: !1,
            format: "[left]{0}[/left]",
            html: '<div align="left">{0}</div>'
        },
        center: {
            styles: {
                "text-align": ["center", "-webkit-center", "-moz-center", "-khtml-center"]
            },
            isInline: !1,
            format: "[center]{0}[/center]",
            html: '<div align="center">{0}</div>'
        },
        right: {
            styles: {
                "text-align": ["right", "-webkit-right", "-moz-right", "-khtml-right"]
            },
            isInline: !1,
            format: "[right]{0}[/right]",
            html: '<div align="right">{0}</div>'
        },
        justify: {
            styles: {
                "text-align": ["justify", "-webkit-justify", "-moz-justify", "-khtml-justify"]
            },
            isInline: !1,
            format: "[justify]{0}[/justify]",
            html: '<div align="justify">{0}</div>'
        },
        youtube: {
            allowsEmpty: !0,
            tags: {
                iframe: {
                    "data-youtube-id": null
                }
            },
            format(e, t) {
                return e = _(e, "data-youtube-id"), e ? `[youtube]${e}[/youtube]` : t;
            },
            html: '<iframe width="560" height="315" frameborder="0" src="https://www.youtube.com/embed/{0}?wmode=opaque" data-youtube-id="{0}" allowfullscreen></iframe>'
        },
        rtl: {
            styles: {
                direction: ["rtl"]
            },
            isInline: !1,
            format: "[rtl]{0}[/rtl]",
            html: '<div style="direction: rtl">{0}</div>'
        },
        ltr: {
            styles: {
                direction: ["ltr"]
            },
            isInline: !1,
            format: "[ltr]{0}[/ltr]",
            html: '<div style="direction: ltr">{0}</div>'
        },
        ignore: {}
    };

    var S = "open";
    var A = "content";
    var E = "newline";
    var P = "close";
    a.prototype = {
        clone() {
            const e = this;
            return new a(e.type, e.name, e.val, v({}, e.attrs), [], e.closing ? e.closing.clone() :
              null)
        },
        splitAt(e) {
            let t;
            const i = this;
            const n = i.clone();
            const o = i.children.indexOf(e);
            return o > -1 && (t = i.children.length - o, n.children = i.children.splice(o, t)), n
        }
    }, r.QuoteType = C, r.defaults = {
        breakBeforeBlock: !1,
        breakStartBlock: !1,
        breakEndBlock: !1,
        breakAfterBlock: !0,
        removeEmptyTags: !0,
        fixInvalidNesting: !0,
        fixInvalidChildren: !0,
        quoteType: C.auto
    }, u.get = e => T[e] || null, u.set = function (e, t) {
        return e && t && (t = v(T[e] || {}, t), t.remove = () => {
            delete T[e]
        }, T[e] = t), this;
    }, u.rename = function (e, t) {
        return e in T && (T[t] = T[e], delete T[e]), this
    }, u.remove = function (e) {
        return e in T && delete T[e], this
    }, u.formatBBCodeString = t, e.formats.bbcode = u, e.BBCodeParser = r
})(sceditor), (e => {
    let t = !1;
    if ("function" == typeof define && define.amd && (define(e), t = !0), "object" == typeof exports && (
      module.exports = e(), t = !0), !t) {
        const i = window.Cookies;
        const n = window.Cookies = e();
        n.noConflict = () => (window.Cookies = i, n)
    }
})(() => {
    function e(...args) {
        for (var e = 0, t = {}; e < args.length; e++) {
            const i = args[e];
            for (const n in i) t[n] = i[n]
        }
        return t
    }

    function t(i) {
        function n(t, o, s) {
            let a;
            if ("undefined" != typeof document) {
                if (arguments.length > 1) {
                    if (s = e({
                        path: "/"
                    }, n.defaults, s), "number" == typeof s.expires) {
                        const r = new Date;
                        r.setMilliseconds(r.getMilliseconds() + 864e5 * s.expires), s.expires = r
                    }
                    s.expires = s.expires ? s.expires.toUTCString() : "";
                    try {
                        a = JSON.stringify(o), /^[\{\[]/.test(a) && (o = a)
                    } catch (l) {}
                    o = i.write ? i.write(o, t) : encodeURIComponent(String(o))
                      .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,
                        decodeURIComponent), t = encodeURIComponent(String(t)), t = t.replace(
                      /%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent), t = t.replace(/[\(\)]/g,
                      escape);
                    let c = "";
                    for (const u in s) s[u] && (c += `; ${u}`, s[u] !== !0 && (c += `=${s[u]}`));
                    return document.cookie = `${t}=${o}${c}`;
                }
                t || (a = {});
                for (let d = document.cookie ? document.cookie.split("; ") : [], h = /(%[0-9A-Z]{2})+/g, p = 0; p < d.length; p++) {
                    const m = d[p].split("=");

                    let f = m.slice(1)
                      .join("=");

                    this.json || '"' !== f.charAt(0) || (f = f.slice(1, -1));
                    try {
                        const _ = m[0].replace(h, decodeURIComponent);
                        if (f = i.read ? i.read(f, _) : i(f, _) || f.replace(h, decodeURIComponent), this
                          .json) try {
                            f = JSON.parse(f)
                        } catch (l) {}
                        if (t === _) {
                            a = f;
                            break
                        }
                        t || (a[_] = f)
                    } catch (l) {}
                }
                return a
            }
        }
        return n.set = n, n.get = e => n.call(n, e), n.getJSON = function(...args) {
            return n.apply({
                json: !0
            }, [].slice.call(args));
        }, n.defaults = {}, n.remove = (t, i) => {
            n(t, "", e(i, {
                expires: -1
            }))
        }, n.withConverter = t, n;
    }
    return t(() => {});
});
const windowIsTurbolinked = "Turbolinks" in window;

const cookiesEu = {
    init() {
        const e = document.querySelector(".js-cookies-eu-ok");
        e && (this.addListener(e), windowIsTurbolinked && window.Turbolinks.clearCache())
    },
    addListener(e) {
        e.attachEvent ? e.attachEvent("onclick", this.setCookie) : e.addEventListener("click", this
          .setCookie, !1)
    },
    setCookie() {
        const e = "https:" === location.protocol;
        Cookies.set("cookie_eu_consented", !0, {
            path: "/",
            expires: 365,
            secure: e
        });
        const t = document.querySelector(".js-cookies-eu");
        t.parentNode.removeChild(t)
    }
};

!(() => {
    function e(e) {
        return windowIsTurbolinked ? "turbolinks:load" : e
    }

    function t() {
        (!i || windowIsTurbolinked) && (i = !0, cookiesEu.init())
    }
    var i = !1;
    return document.addEventListener ? document.addEventListener(e("DOMContentLoaded"), t, !1) : (window
      .addEventListener ? window.addEventListener(e("load"), t, !1) : window.attachEvent && window
      .attachEvent(e("onload"), t), void 0)
})(),
  /* ========================================================================
 * bootstrap-tour - v0.12.0
 * http://bootstraptour.com
 * ========================================================================
 * Copyright 2012-2015 Ulrich Sossou
 *
 * ========================================================================
 * Licensed under the MIT License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================================
 */
  /* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
  +(e => {
      function t() {
          const e = document.createElement("bootstrap");

          const t = {
              WebkitTransition: "webkitTransitionEnd",
              MozTransition: "transitionend",
              OTransition: "oTransitionEnd otransitionend",
              transition: "transitionend"
          };

          for (const i in t)
              if (void 0 !== e.style[i]) return {
                  end: t[i]
              };
          return !1
      }
      e.fn.emulateTransitionEnd = function (t) {
          let i = !1;
          const n = this;
          e(this)
            .one("bsTransitionEnd", () => {
                i = !0
            });
          const o = () => {
              i || e(n)
                .trigger(e.support.transition.end)
          };
          return setTimeout(o, t), this
      }, e(() => {
          e.support.transition = t(), e.support.transition && (e.event.special.bsTransitionEnd = {
              bindType: e.support.transition.end,
              delegateType: e.support.transition.end,
              handle(t) {
                  return e(t.target)
                    .is(this) ? t.handleObj.handler.apply(this, arguments) : void 0
              }
          })
      })
  })(jQuery),
  /* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
  +(e => {
      function t(t) {
          return this.each(function () {
              const n = e(this);
              let o = n.data("bs.tooltip");
              const s = "object" == typeof t && t;
              (o || !/destroy|hide/.test(t)) && (o || n.data("bs.tooltip", o = new i(this, s)),
              "string" == typeof t && o[t]())
          });
      }
      var i = function (e, t) {
          this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState =
            null, this.$element = null, this.inState = null, this.init("tooltip", e, t)
      };
      i.VERSION = "3.3.7", i.TRANSITION_DURATION = 150, i.DEFAULTS = {
          animation: !0,
          placement: "top",
          selector: !1,
          template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
          trigger: "hover focus",
          title: "",
          delay: 0,
          html: !1,
          container: !1,
          viewport: {
              selector: "body",
              padding: 0
          }
      }, i.prototype.init = function (t, i, n) {
          if (this.enabled = !0, this.type = t, this.$element = e(i), this.options = this.getOptions(n),
            this.$viewport = this.options.viewport && e(e.isFunction(this.options.viewport) ? this.options
              .viewport.call(this, this.$element) : this.options.viewport.selector || this.options
              .viewport), this.inState = {
              click: !1,
              hover: !1,
              focus: !1
          }, this.$element[0] instanceof document.constructor && !this.options.selector)
              throw new Error(`\`selector\` option must be specified when initializing ${this.type} on the window.document object!`);
          for (let o = this.options.trigger.split(" "), s = o.length; s--;) {
              const a = o[s];
              if ("click" == a) this.$element.on(`click.${this.type}`, this.options.selector, e.proxy(this
                .toggle, this));
              else if ("manual" != a) {
                  const r = "hover" == a ? "mouseenter" : "focusin";
                  const l = "hover" == a ? "mouseleave" : "focusout";
                  this.$element.on(`${r}.${this.type}`, this.options.selector, e.proxy(this.enter, this)),
                    this.$element.on(`${l}.${this.type}`, this.options.selector, e.proxy(this.leave,
                      this))
              }
          }
          this.options.selector ? this._options = e.extend({}, this.options, {
              trigger: "manual",
              selector: ""
          }) : this.fixTitle()
      }, i.prototype.getDefaults = () => i.DEFAULTS, i.prototype.getOptions = function (t) {
          return t = e.extend({}, this.getDefaults(), this.$element.data(), t), t.delay && "number" ==
          typeof t.delay && (t.delay = {
              show: t.delay,
              hide: t.delay
          }), t
      }, i.prototype.getDelegateOptions = function () {
          const t = {};
          const i = this.getDefaults();
          return this._options && e.each(this._options, (e, n) => {
              i[e] != n && (t[e] = n)
          }), t;
      }, i.prototype.enter = function (t) {
          let i = t instanceof this.constructor ? t : e(t.currentTarget)
            .data(`bs.${this.type}`);
          return i || (i = new this.constructor(t.currentTarget, this.getDelegateOptions()), e(t
            .currentTarget)
            .data(`bs.${this.type}`, i)), t instanceof e.Event && (i.inState["focusin" == t.type ?
            "focus" : "hover"] = !0), i.tip()
            .hasClass("in") || "in" == i.hoverState ? (i.hoverState = "in", void 0) : (clearTimeout(i
            .timeout), i.hoverState = "in", i.options.delay && i.options.delay.show ? (i.timeout =
            setTimeout(() => {
                "in" == i.hoverState && i.show()
            }, i.options.delay.show), void 0) : i.show());
      }, i.prototype.isInStateTrue = function () {
          for (const e in this.inState)
              if (this.inState[e]) return !0;
          return !1
      }, i.prototype.leave = function (t) {
          let i = t instanceof this.constructor ? t : e(t.currentTarget)
            .data(`bs.${this.type}`);
          return i || (i = new this.constructor(t.currentTarget, this.getDelegateOptions()), e(t
            .currentTarget)
            .data(`bs.${this.type}`, i)), t instanceof e.Event && (i.inState["focusout" == t.type ?
            "focus" : "hover"] = !1), i.isInStateTrue() ? void 0 : (clearTimeout(i.timeout), i
            .hoverState = "out", i.options.delay && i.options.delay.hide ? (i.timeout = setTimeout(
            () => {
                "out" == i.hoverState && i.hide()
            }, i.options.delay.hide), void 0) : i.hide());
      }, i.prototype.show = function () {
          const t = e.Event(`show.bs.${this.type}`);
          if (this.hasContent() && this.enabled) {
              this.$element.trigger(t);
              const n = e.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
              if (t.isDefaultPrevented() || !n) return;
              const o = this;
              const s = this.tip();
              const a = this.getUID(this.type);
              this.setContent(), s.attr("id", a), this.$element.attr("aria-describedby", a), this.options
                .animation && s.addClass("fade");

              let r = "function" == typeof this.options.placement ? this.options.placement.call(this, s[0],
                this.$element[0]) : this.options.placement;

              const l = /\s?auto?\s?/i;
              const c = l.test(r);
              c && (r = r.replace(l, "") || "top"), s.detach()
                .css({
                    top: 0,
                    left: 0,
                    display: "block"
                })
                .addClass(r)
                .data(`bs.${this.type}`, this), this.options.container ? s.appendTo(this.options
                .container) : s.insertAfter(this.$element), this.$element.trigger(`inserted.bs.${this.type}`);
              const u = this.getPosition();
              const d = s[0].offsetWidth;
              const h = s[0].offsetHeight;
              if (c) {
                  const p = r;
                  const m = this.getPosition(this.$viewport);
                  r = "bottom" == r && u.bottom + h > m.bottom ? "top" : "top" == r && u.top - h < m.top ?
                    "bottom" : "right" == r && u.right + d > m.width ? "left" : "left" == r && u.left -
                    d < m.left ? "right" : r, s.removeClass(p)
                    .addClass(r)
              }
              const f = this.getCalculatedOffset(r, u, d, h);
              this.applyPlacement(f, r);
              const _ = () => {
                  const e = o.hoverState;
                  o.$element.trigger(`shown.bs.${o.type}`), o.hoverState = null, "out" == e && o.leave(
                    o)
              };
              e.support.transition && this.$tip.hasClass("fade") ? s.one("bsTransitionEnd", _)
                .emulateTransitionEnd(i.TRANSITION_DURATION) : _()
          }
      }, i.prototype.applyPlacement = function (t, i) {
          const n = this.tip();
          const o = n[0].offsetWidth;
          const s = n[0].offsetHeight;
          let a = parseInt(n.css("margin-top"), 10);
          let r = parseInt(n.css("margin-left"), 10);
          isNaN(a) && (a = 0), isNaN(r) && (r = 0), t.top += a, t.left += r, e.offset.setOffset(n[0], e
            .extend({
                using(e) {
                    n.css({
                        top: Math.round(e.top),
                        left: Math.round(e.left)
                    })
                }
            }, t), 0), n.addClass("in");
          const l = n[0].offsetWidth;
          const c = n[0].offsetHeight;
          "top" == i && c != s && (t.top = t.top + s - c);
          const u = this.getViewportAdjustedDelta(i, t, l, c);
          u.left ? t.left += u.left : t.top += u.top;
          const d = /top|bottom/.test(i);
          const h = d ? 2 * u.left - o + l : 2 * u.top - s + c;
          const p = d ? "offsetWidth" : "offsetHeight";
          n.offset(t), this.replaceArrow(h, n[0][p], d)
      }, i.prototype.replaceArrow = function (e, t, i) {
          this.arrow()
            .css(i ? "left" : "top", `${50 * (1 - e / t)}%`)
            .css(i ? "top" : "left", "")
      }, i.prototype.setContent = function () {
          const e = this.tip();
          const t = this.getTitle();
          e.find(".tooltip-inner")[this.options.html ? "html" : "text"](t), e.removeClass(
            "fade in top bottom left right")
      }, i.prototype.hide = function (t) {
          function n() {
              "in" != o.hoverState && s.detach(), o.$element && o.$element.removeAttr("aria-describedby")
                .trigger(`hidden.bs.${o.type}`), t && t()
          }
          var o = this;
          var s = e(this.$tip);
          const a = e.Event(`hide.bs.${this.type}`);
          return this.$element.trigger(a), a.isDefaultPrevented() ? void 0 : (s.removeClass("in"), e.support
            .transition && s.hasClass("fade") ? s.one("bsTransitionEnd", n)
            .emulateTransitionEnd(i.TRANSITION_DURATION) : n(), this.hoverState = null, this)
      }, i.prototype.fixTitle = function () {
          const e = this.$element;
          (e.attr("title") || "string" != typeof e.attr("data-original-title")) && e.attr(
            "data-original-title", e.attr("title") || "")
            .attr("title", "")
      }, i.prototype.hasContent = function () {
          return this.getTitle()
      }, i.prototype.getPosition = function(t = this.$element) {
          const i = t[0];
          const n = "BODY" == i.tagName;
          let o = i.getBoundingClientRect();
          null == o.width && (o = e.extend({}, o, {
              width: o.right - o.left,
              height: o.bottom - o.top
          }));
          const s = window.SVGElement && i instanceof window.SVGElement;

          const a = n ? {
              top: 0,
              left: 0
          } : s ? null : t.offset();

          const r = {
              scroll: n ? document.documentElement.scrollTop || document.body.scrollTop : t.scrollTop()
          };

          const l = n ? {
              width: e(window)
                .width(),
              height: e(window)
                .height()
          } : null;

          return e.extend({}, o, r, l, a)
      }, i.prototype.getCalculatedOffset = (e, t, i, n) => "bottom" == e ? {
          top: t.top + t.height,
          left: t.left + t.width / 2 - i / 2
      } : "top" == e ? {
          top: t.top - n,
          left: t.left + t.width / 2 - i / 2
      } : "left" == e ? {
          top: t.top + t.height / 2 - n / 2,
          left: t.left - i
      } : {
          top: t.top + t.height / 2 - n / 2,
          left: t.left + t.width
      }, i.prototype.getViewportAdjustedDelta = function (e, t, i, n) {
          const o = {
              top: 0,
              left: 0
          };
          if (!this.$viewport) return o;
          const s = this.options.viewport && this.options.viewport.padding || 0;
          const a = this.getPosition(this.$viewport);
          if (/right|left/.test(e)) {
              const r = t.top - s - a.scroll;
              const l = t.top + s - a.scroll + n;
              r < a.top ? o.top = a.top - r : l > a.top + a.height && (o.top = a.top + a.height - l)
          } else {
              const c = t.left - s;
              const u = t.left + s + i;
              c < a.left ? o.left = a.left - c : u > a.right && (o.left = a.left + a.width - u)
          }
          return o
      }, i.prototype.getTitle = function () {
          let e;
          const t = this.$element;
          const i = this.options;
          return e = t.attr("data-original-title") || ("function" == typeof i.title ? i.title.call(t[0]) : i
            .title)
      }, i.prototype.getUID = e => {
          do e += ~~(1e6 * Math.random()); while (document.getElementById(e));
          return e
      }, i.prototype.tip = function () {
          if (!this.$tip && (this.$tip = e(this.options.template), 1 != this.$tip.length)) throw new Error(
            `${this.type} \`template\` option must consist of exactly 1 top-level element!`);
          return this.$tip
      }, i.prototype.arrow = function () {
          return this.$arrow = this.$arrow || this.tip()
            .find(".tooltip-arrow")
      }, i.prototype.enable = function () {
          this.enabled = !0
      }, i.prototype.disable = function () {
          this.enabled = !1
      }, i.prototype.toggleEnabled = function () {
          this.enabled = !this.enabled
      }, i.prototype.toggle = function (t) {
          let i = this;
          t && (i = e(t.currentTarget)
            .data(`bs.${this.type}`), i || (i = new this.constructor(t.currentTarget, this
            .getDelegateOptions()), e(t.currentTarget)
            .data(`bs.${this.type}`, i))), t ? (i.inState.click = !i.inState.click, i
            .isInStateTrue() ? i.enter(i) : i.leave(i)) : i.tip()
            .hasClass("in") ? i.leave(i) : i.enter(i)
      }, i.prototype.destroy = function () {
          const e = this;
          clearTimeout(this.timeout), this.hide(() => {
              e.$element.off(`.${e.type}`)
                .removeData(`bs.${e.type}`), e.$tip && e.$tip.detach(), e.$tip = null, e.$arrow =
                null, e.$viewport = null, e.$element = null
          })
      };
      const n = e.fn.tooltip;
      e.fn.tooltip = t, e.fn.tooltip.Constructor = i, e.fn.tooltip.noConflict = function () {
          return e.fn.tooltip = n, this
      }
  })(jQuery),
  /* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
  +(e => {
      function t(t) {
          return this.each(function () {
              const n = e(this);
              let o = n.data("bs.popover");
              const s = "object" == typeof t && t;
              (o || !/destroy|hide/.test(t)) && (o || n.data("bs.popover", o = new i(this, s)),
              "string" == typeof t && o[t]())
          });
      }
      var i = function (e, t) {
          this.init("popover", e, t)
      };
      if (!e.fn.tooltip) throw new Error("Popover requires tooltip.js");
      i.VERSION = "3.3.7", i.DEFAULTS = e.extend({}, e.fn.tooltip.Constructor.DEFAULTS, {
          placement: "right",
          trigger: "click",
          content: "",
          template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      }), i.prototype = e.extend({}, e.fn.tooltip.Constructor.prototype), i.prototype.constructor = i, i
        .prototype.getDefaults = () => i.DEFAULTS, i.prototype.setContent = function () {
          const e = this.tip();
          const t = this.getTitle();
          const i = this.getContent();
          e.find(".popover-title")[this.options.html ? "html" : "text"](t), e.find(".popover-content")
            .children()
            .detach()
            .end()[this.options.html ? "string" == typeof i ? "html" : "append" : "text"](i), e
            .removeClass("fade top bottom left right in"), e.find(".popover-title")
            .html() || e.find(".popover-title")
            .hide()
      }, i.prototype.hasContent = function () {
          return this.getTitle() || this.getContent()
      }, i.prototype.getContent = function () {
          const e = this.$element;
          const t = this.options;
          return e.attr("data-content") || ("function" == typeof t.content ? t.content.call(e[0]) : t
            .content)
      }, i.prototype.arrow = function () {
          return this.$arrow = this.$arrow || this.tip()
            .find(".arrow")
      };
      const n = e.fn.popover;
      e.fn.popover = t, e.fn.popover.Constructor = i, e.fn.popover.noConflict = function () {
          return e.fn.popover = n, this
      }
  })(jQuery);
const bind = (e, t) => (function(...args) {
    return e.apply(t, args);
});
!((e, t) => "function" == typeof define && define.amd ? define(["jquery"], i => e.Tour = t(i)) : "object" == typeof exports ? module.exports = t(require("jquery")) : e.Tour = t(e.jQuery))(window, e => {
    let t;
    let i;
    return i = window.document, t = (() => {
        function t(t) {
            this._showPopoverAndOverlay = bind(this._showPopoverAndOverlay, this);
            let i;
            try {
                i = window.localStorage
            } catch (n) {
                i = !1
            }
            this._options = e.extend({
                name: "tour",
                steps: [],
                container: "body",
                autoscroll: !0,
                keyboard: !0,
                storage: i,
                debug: !1,
                backdrop: !1,
                backdropContainer: "body",
                backdropPadding: 0,
                redirect: !0,
                orphan: !1,
                duration: !1,
                delay: !1,
                basePath: "",
                template: '<div class="popover" role="tooltip"> <div class="arrow"></div> <h3 class="popover-title"></h3> <div class="popover-content"></div> <div class="popover-navigation"> <div class="btn-group"> <button class="btn btn-sm btn-default" data-role="prev">&laquo; Prev</button> <button class="btn btn-sm btn-default" data-role="next">Next &raquo;</button> <button class="btn btn-sm btn-default" data-role="pause-resume" data-pause-text="Pause" data-resume-text="Resume">Pause</button> </div> <button class="btn btn-sm btn-default" data-role="end">End tour</button> </div> </div>',
                afterSetState() {},
                afterGetState() {},
                afterRemoveState() {},
                onStart() {},
                onEnd() {},
                onShow() {},
                onShown() {},
                onHide() {},
                onHidden() {},
                onNext() {},
                onPrev() {},
                onPause() {},
                onResume() {},
                onRedirectError() {}
            }, t), this._force = !1, this._inited = !1, this._current = null, this.backdrops = []
        }
        return t.prototype.addSteps = function (e) {
            let t;
            let i;
            let n;
            for (t = 0, i = e.length; i > t; t++) n = e[t], this.addStep(n);
            return this
        }, t.prototype.addStep = function (e) {
            return this._options.steps.push(e), this
        }, t.prototype.getStep = function (t) {
            return null != this._options.steps[t] ? e.extend({
                id: `step-${t}`,
                path: "",
                host: "",
                placement: "right",
                title: "",
                content: "<p></p>",
                next: t === this._options.steps.length - 1 ? -1 : t + 1,
                prev: t - 1,
                animation: !0,
                container: this._options.container,
                autoscroll: this._options.autoscroll,
                backdrop: this._options.backdrop,
                backdropContainer: this._options.backdropContainer,
                backdropPadding: this._options.backdropPadding,
                redirect: this._options.redirect,
                reflexElement: this._options.steps[t].element,
                backdropElement: this._options.steps[t].element,
                orphan: this._options.orphan,
                duration: this._options.duration,
                delay: this._options.delay,
                template: this._options.template,
                onShow: this._options.onShow,
                onShown: this._options.onShown,
                onHide: this._options.onHide,
                onHidden: this._options.onHidden,
                onNext: this._options.onNext,
                onPrev: this._options.onPrev,
                onPause: this._options.onPause,
                onResume: this._options.onResume,
                onRedirectError: this._options.onRedirectError
            }, this._options.steps[t]) : void 0;
        }, t.prototype.init = function (e) {
            return this._force = e, this.ended() ? (this._debug("Tour ended, init prevented."),
              this) : (this.setCurrentStep(), this._initMouseNavigation(), this
              ._initKeyboardNavigation(), this._onResize((e => () => e.showStep(e._current))(this)), this._onScroll((e => () => e._showPopoverAndOverlay(e._current))(this)), null !== this._current && this.showStep(this._current), this
              ._inited = !0, this);
        }, t.prototype.start = function (e) {
            let t;
            return null == e && (e = !1), this._inited || this.init(e), null === this._current &&
            (t = this._makePromise(null != this._options.onStart ? this._options.onStart(
              this) : void 0), this._callOnPromiseDone(t, this.showStep, 0)), this
        }, t.prototype.next = function () {
            let e;
            return e = this.hideStep(this._current, this._current + 1), this._callOnPromiseDone(e,
              this._showNextStep)
        }, t.prototype.prev = function () {
            let e;
            return e = this.hideStep(this._current, this._current - 1), this._callOnPromiseDone(e,
              this._showPrevStep)
        }, t.prototype.goTo = function (e) {
            let t;
            return t = this.hideStep(this._current, e), this._callOnPromiseDone(t, this.showStep,
              e)
        }, t.prototype.end = function () {
            let t;
            let n;
            return t = (t => () => (e(i)
              .off(`click.tour-${t._options.name}`), e(i)
              .off(`keyup.tour-${t._options.name}`), e(window)
              .off(`resize.tour-${t._options.name}`), e(window)
              .off(`scroll.tour-${t._options.name}`), t._setState("end", "yes"), t._inited = !1, t._force = !1, t._clearTimer(), null != t._options
              .onEnd ? t._options.onEnd(t) : void 0))(this), n = this.hideStep(this._current), this._callOnPromiseDone(n, t);
        }, t.prototype.ended = function () {
            return !this._force && !!this._getState("end")
        }, t.prototype.restart = function () {
            return this._removeState("current_step"), this._removeState("end"), this._removeState(
              "redirect_to"), this.start()
        }, t.prototype.pause = function () {
            let e;
            return e = this.getStep(this._current), e && e.duration ? (this._paused = !0, this
              ._duration -= (new Date)
              .getTime() - this._start, window.clearTimeout(this._timer), this._debug(
              `Paused/Stopped step ${this._current + 1} timer (${this
  ._duration} remaining).`), null != e.onPause ? e.onPause(this, this
              ._duration) : void 0) : this;
        }, t.prototype.resume = function () {
            let e;
            return e = this.getStep(this._current), e && e.duration ? (this._paused = !1, this
              ._start = (new Date)
              .getTime(), this._duration = this._duration || e.duration, this._timer =
              window.setTimeout((e => () => e._isLast() ? e.next() : e.end())(this), this._duration), this._debug(`Started step ${this._current + 1} timer with duration ${this._duration}`), null != e.onResume && this
              ._duration !== e.duration ? e.onResume(this, this._duration) : void 0) : this;
        }, t.prototype.hideStep = function (t, i) {
            let n;
            let o;
            let s;
            let a;
            return (a = this.getStep(t)) ? (this._clearTimer(), s = this._makePromise(null != a
              .onHide ? a.onHide(this, t) : void 0), o = (n => () => {
                let o;
                let s;
                return o = e(a.element), o.data("bs.popover") || o.data(
                  "popover") || (o = e("body")), o.popover("destroy")
                  .removeClass(`tour-${n._options.name}-element tour-${n
    ._options.name}-${t}-element`)
                  .removeData("bs.popover"), a.reflex && e(a.reflexElement)
                  .removeClass("tour-step-element-reflex")
                  .off(`${n._reflexEvent(a.reflex)}.tour-${n._options.name}`), a
                  .backdrop && (s = null != i && n.getStep(i), s && s
                  .backdrop && s.backdropElement === a.backdropElement || n
                  ._hideOverlayElement(a)), null != a.onHidden ? a.onHidden(
                  n) : void 0;
            })(this), n = a.delay.hide || a.delay, "[object Number]" === {}.toString.call(
              n) && n > 0 ? (this._debug(`Wait ${n} milliseconds to hide the step ${this._current + 1}`), window
              .setTimeout((e => () => e._callOnPromiseDone(s, o))(this), n)) : this._callOnPromiseDone(s, o), s) : void 0;
        }, t.prototype.showStep = function (e) {
            let t;
            let n;
            let o;
            let s;
            let a;
            let r;
            return this.ended() ? (this._debug("Tour ended, showStep prevented."), this) : (r =
              this.getStep(e), r && (a = e < this._current, n = this._makePromise(null != r
              .onShow ? r.onShow(this, e) : void 0), this.setCurrentStep(e), t =
              function () {
                  switch ({}.toString.call(r.path)) {
                      case "[object Function]":
                          return r.path();
                      case "[object String]":
                          return this._options.basePath + r.path;
                      default:
                          return r.path
                  }
              }.call(this), !r.redirect || !this._isRedirect(r.host, t, i.location) || (
              this._redirect(r, e, t), this._isJustPathHashDifferent(r.host, t, i
                .location))) ? (s = (t => () => {
                if (t._isOrphan(r)) {
                    if (r.orphan === !1) return t._debug(
                      `Skip the orphan step ${t._current + 1}.\nOrphan option is false and the element does not exist or is hidden.`
                    ), a ? t._showPrevStep() : t._showNextStep(),
                      void 0;
                    t._debug(`Show the orphan step ${t._current + 1}. Orphans option is true.`)
                }
                return r.autoscroll ? t._scrollIntoView(e) : t
                  ._showPopoverAndOverlay(e), r.duration ? t.resume() :
                  void 0
            })(this), o = r.delay.show || r.delay, "[object Number]" === {}.toString
              .call(o) && o > 0 ? (this._debug(`Wait ${o} milliseconds to show the step ${this._current + 1}`), window
              .setTimeout((e => () => e._callOnPromiseDone(n, s))(this), o)) : this._callOnPromiseDone(n, s), n) : void 0);
        }, t.prototype.getCurrentStep = function () {
            return this._current
        }, t.prototype.setCurrentStep = function (e) {
            return null != e ? (this._current = e, this._setState("current_step", e)) : (this
              ._current = this._getState("current_step"), this._current = null === this
              ._current ? null : parseInt(this._current, 10)), this
        }, t.prototype.redraw = function () {
            return this._showOverlayElement(this.getStep(this.getCurrentStep()))
        }, t.prototype._setState = function (e, t) {
            let i;
            let n;
            if (this._options.storage) {
                n = `${this._options.name}_${e}`;
                try {
                    this._options.storage.setItem(n, t)
                } catch (o) {
                    i = o, i.code === DOMException.QUOTA_EXCEEDED_ERR && this._debug(
                      "LocalStorage quota exceeded. State storage failed.")
                }
                return this._options.afterSetState(n, t)
            }
            return null == this._state && (this._state = {}), this._state[e] = t
        }, t.prototype._removeState = function (e) {
            let t;
            return this._options.storage ? (t = `${this._options.name}_${e}`, this._options
              .storage.removeItem(t), this._options.afterRemoveState(t)) : null != this
              ._state ? delete this._state[e] : void 0;
        }, t.prototype._getState = function (e) {
            let t;
            let i;
            return this._options.storage ? (t = `${this._options.name}_${e}`, i = this._options
              .storage.getItem(t)) : null != this._state && (i = this._state[e]), (
              void 0 === i || "null" === i) && (i = null), this._options.afterGetState(e,
              i), i;
        }, t.prototype._showNextStep = function () {
            let e;
            let t;
            let i;
            return i = this.getStep(this._current), t = (e => () => e.showStep(i.next))(this), e = this._makePromise(null != i.onNext ? i.onNext(this) : void 0), this
              ._callOnPromiseDone(e, t);
        }, t.prototype._showPrevStep = function () {
            let e;
            let t;
            let i;
            return i = this.getStep(this._current), t = (e => () => e.showStep(i.prev))(this), e = this._makePromise(null != i.onPrev ? i.onPrev(this) : void 0), this
              ._callOnPromiseDone(e, t);
        }, t.prototype._debug = function (e) {
            return this._options.debug ? window.console.log(`Bootstrap Tour '${this._options
  .name}' | ${e}`) : void 0;
        }, t.prototype._isRedirect = function (e, t, i) {
            let n;
            return null != e && "" !== e && ("[object RegExp]" === {}.toString.call(e) && !e.test(
              i.origin) || "[object String]" === {}.toString.call(e) && this
              ._isHostDifferent(e, i)) ? !0 : (n = [i.pathname, i.search, i.hash].join(""),
            null != t && "" !== t && ("[object RegExp]" === {}.toString.call(t) && !t
              .test(n) || "[object String]" === {}.toString.call(t) && this
              ._isPathDifferent(t, n)))
        }, t.prototype._isHostDifferent = function(e, {origin, href}) {
            switch ({}.toString.call(e)) {
                case "[object RegExp]":
                    return !e.test(origin);
                case "[object String]":
                    return this._getProtocol(e) !== this._getProtocol(href) || this._getHost(e) !==
                      this._getHost(href);
                default:
                    return !0
            }
        }, t.prototype._isPathDifferent = function (e, t) {
            return this._getPath(e) !== this._getPath(t) || !this._equal(this._getQuery(e), this
              ._getQuery(t)) || !this._equal(this._getHash(e), this._getHash(t))
        }, t.prototype._isJustPathHashDifferent = function (e, t, i) {
            let n;
            return null != e && "" !== e && this._isHostDifferent(e, i) ? !1 : (n = [i.pathname, i
              .search, i.hash].join(""), "[object String]" === {}.toString.call(t) ?
              this._getPath(t) === this._getPath(n) && this._equal(this._getQuery(t), this
                ._getQuery(n)) && !this._equal(this._getHash(t), this._getHash(n)) : !1)
        }, t.prototype._redirect = function (t, n, o) {
            let s;
            return e.isFunction(t.redirect) ? t.redirect.call(this, o) : (s =
              "[object String]" === {}.toString.call(t.host) ? `${t.host}${o}` : o, this
              ._debug(`Redirect to ${s}`), this._getState("redirect_to") !== `${n}` ? (this
              ._setState("redirect_to", `${n}`), i.location.href = s) : (this._debug(
              `Error redirection loop to ${o}`), this._removeState("redirect_to"),
              null != t.onRedirectError ? t.onRedirectError(this) : void 0));
        }, t.prototype._isOrphan = ({element}) => null == element || !e(element)
          .length || e(element)
          .is(":hidden") && "http://www.w3.org/2000/svg" !== e(element)[0].namespaceURI, t.prototype._isLast = function () {
            return this._current < this._options.steps.length - 1
        }, t.prototype._showPopoverAndOverlay = function (e) {
            let t;
            if (this.getCurrentStep() === e && !this.ended()) return t = this.getStep(e), t
              .backdrop && this._showOverlayElement(t), this._showPopover(t, e), null != t
              .onShown && t.onShown(this), this._debug(`Step ${this._current + 1} of ${this._options.steps.length}`);
        }, t.prototype._showPopover = function (t, i) {
            let n;
            let o;
            let s;
            let a;
            let r;
            return e(`.tour-${this._options.name}`)
              .remove(), a = e.extend({}, this._options), s = this._isOrphan(t), t.template =
              this._template(t, i), s && (t.element = "body", t.placement = "top"), n = e(t
              .element), n.addClass(`tour-${this._options.name}-element tour-${this
  ._options.name}-${i}-element`), t.options && e.extend(a, t.options), t
              .reflex && !s && e(t.reflexElement)
              .addClass("tour-step-element-reflex")
              .off(`${this._reflexEvent(t.reflex)}.tour-${this._options.name}`)
              .on(
                `${this._reflexEvent(t.reflex)}.tour-${this._options.name}`,
                (e => () => e._isLast() ? e.next() : e.end())(this)
            ), r = t.smartPlacement === !0 && -1 === t.placement.search(/auto/i), n
              .popover({
                  placement: r ? `auto ${t.placement}` : t.placement,
                  trigger: "manual",
                  title: t.title,
                  content: t.content,
                  html: !0,
                  animation: t.animation,
                  container: t.container,
                  template: t.template,
                  selector: t.element
              })
              .popover("show"), o = n.data("bs.popover") ? n.data("bs.popover")
              .tip() : n.data("popover")
              .tip(), o.attr("id", t.id), "fixed" === n.css("position") && o.css("position",
              "fixed"), this._reposition(o, t), s ? this._center(o) : void 0;
        }, t.prototype._template = function (t, i) {
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            return l = t.template, this._isOrphan(t) && "[object Boolean]" !== {}.toString.call(t
              .orphan) && (l = t.orphan), r = e.isFunction(l) ? e(l(i, t)) : e(l), n = r
              .find(".popover-navigation"), s = n.find('[data-role="prev"]'), o = n.find(
              '[data-role="next"]'), a = n.find('[data-role="pause-resume"]'), this
              ._isOrphan(t) && r.addClass("orphan"), r.addClass(`tour-${this._options.name} tour-${this._options.name}-${i}`), t.reflex && r.addClass(`tour-${this._options.name}-reflex`), t.prev < 0 && s.addClass("disabled")
              .prop("disabled", !0)
              .prop("tabindex", -1), t.next < 0 && o.addClass("disabled")
              .prop("disabled", !0)
              .prop("tabindex", -1), t.duration || a.remove(), r.clone()
              .wrap("<div>")
              .parent()
              .html();
        }, t.prototype._reflexEvent = e => "[object Boolean]" === {}.toString.call(e) ? "click" : e, t.prototype._reposition = function(t, {placement}) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            if (r = t[0].offsetWidth, s = t[0].offsetHeight, u = t.offset(), l = u.left, c = u
              .top, o = e(i)
              .outerHeight() - u.top - t.outerHeight(), 0 > o && (u.top = u.top + o), a = e(
              "html")
              .outerWidth() - u.left - t.outerWidth(), 0 > a && (u.left = u.left + a), u.top <
            0 && (u.top = 0), u.left < 0 && (u.left = 0), t.offset(u), "bottom" === placement || "top" === placement) {
                if (l !== u.left) return this._replaceArrow(t, 2 * (u.left - l), r, "left")
            } else if (c !== u.top) return this._replaceArrow(t, 2 * (u.top - c), s, "top")
        }, t.prototype._center = t => t.css("top", e(window)
          .outerHeight() / 2 - t.outerHeight() / 2), t.prototype._replaceArrow = (e, t, i, n) => e.find(".arrow")
          .css(n, t ? `${50 * (1 - t / i)}%` : ""), t.prototype._scrollIntoView = function (t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            if (l = this.getStep(t), i = e(l.element), !i.length) return this
              ._showPopoverAndOverlay(t);
            switch (n = e(window), a = i.offset()
              .top, s = i.outerHeight(), c = n.height(), r = 0, l.placement) {
                case "top":
                    r = Math.max(0, a - c / 2);
                    break;
                case "left":
                case "right":
                    r = Math.max(0, a + s / 2 - c / 2);
                    break;
                case "bottom":
                    r = Math.max(0, a + s - c / 2)
            }
            return this._debug(`Scroll into view. ScrollTop: ${r}. Element offset: ${a}. Window height: ${c}.`), o = 0, e("body, html")
              .stop(!0, !0)
              .animate({
                  scrollTop: Math.ceil(r)
              }, (e => () => 2 === ++o ? (e._showPopoverAndOverlay(t), e._debug(
              `Scroll into view.\nAnimation end element offset: ${i.offset()
  .top}.\nWindow height: ${n.height()}.`)) : void 0)(this));
        }, t.prototype._onResize = function (t, i) {
            return e(window)
              .on(`resize.tour-${this._options.name}`, () => (clearTimeout(i), i = setTimeout(t, 100)));
        }, t.prototype._onScroll = function (t, i) {
            return e(window)
              .on(`scroll.tour-${this._options.name}`, () => (clearTimeout(i), i = setTimeout(t, 100)));
        }, t.prototype._initMouseNavigation = function () {
            let t;
            return t = this, e(i)
              .off(`click.tour-${this._options.name}`, `.popover.tour-${this._options.name} *[data-role='prev']`)
              .off(`click.tour-${this._options.name}`, `.popover.tour-${this._options.name} *[data-role='next']`)
              .off(`click.tour-${this._options.name}`, `.popover.tour-${this._options.name} *[data-role='end']`)
              .off(`click.tour-${this._options.name}`, `.popover.tour-${this._options.name} *[data-role='pause-resume']`)
              .on(
                `click.tour-${this._options.name}`,
                `.popover.tour-${this._options.name} *[data-role='next']`,
                (e => t => (t.preventDefault(), e.next()))(this)
            )
              .on(
                `click.tour-${this._options.name}`,
                `.popover.tour-${this._options.name} *[data-role='prev']`,
                (e => t => (t.preventDefault(), e._current > 0 ? e.prev() : void 0))(this)
            )
              .on(
                `click.tour-${this._options.name}`,
                `.popover.tour-${this._options.name} *[data-role='end']`,
                (e => t => (t.preventDefault(), e.end()))(this)
            )
              .on(`click.tour-${this._options.name}`, `.popover.tour-${this._options.name} *[data-role='pause-resume']`,
                function (i) {
                    let n;
                    return i.preventDefault(), n = e(this), n.text(t._paused ? n.data(
                      "pause-text") : n.data("resume-text")), t._paused ? t.resume() : t
                      .pause()
                });
        }, t.prototype._initKeyboardNavigation = function () {
            return this._options.keyboard ? e(i)
              .on(`keyup.tour-${this._options.name}`, (e => t => {
                if (t.which) switch (t.which) {
                    case 39:
                        return t.preventDefault(), e._isLast() ? e.next() : e
                          .end();
                    case 37:
                        if (t.preventDefault(), e._current > 0) return e.prev()
                }
            })(this)) : void 0;
        }, t.prototype._makePromise = t => t && e.isFunction(t.then) ? t : null, t.prototype._callOnPromiseDone = function (e, t, i) {
            return e ? e.then((e => () => t.call(e, i))(this)) : t.call(this, i);
        }, t.prototype._showBackground = function({backdropContainer}, {offset, height, width}) {
            let o;
            let s;
            let a;
            let r;
            let l;
            let c;
            let u;
            let d;
            let h;
            for (a = e(i)
              .height(), h = e(i)
              .width(), u = ["top", "bottom", "left", "right"], d = [], r = 0, l = u.length; l >
                 r; r++) switch (c = u[r], o = null != (s = this.backdrops)[c] ? s[c] : s[c] = e(
              "<div>", {
                  "class": `tour-backdrop ${c}`
              }), e(backdropContainer)
              .append(o), c) {
                case "top":
                    d.push(o.height(offset.top > 0 ? offset.top : 0)
                      .width(h)
                      .offset({
                          top: 0,
                          left: 0
                      }));
                    break;
                case "bottom":
                    d.push(o.offset({
                        top: offset.top + height,
                        left: 0
                    })
                      .height(a - (offset.top + height))
                      .width(h));
                    break;
                case "left":
                    d.push(o.offset({
                        top: offset.top,
                        left: 0
                    })
                      .height(height)
                      .width(offset.left > 0 ? offset.left : 0));
                    break;
                case "right":
                    d.push(o.offset({
                        top: offset.top,
                        left: offset.left + width
                    })
                      .height(height)
                      .width(h - (offset.left + width)));
                    break;
                default:
                    d.push(void 0)
            }
            return d
        }, t.prototype._showOverlayElement = function (t) {
            let i;
            let n;
            return i = e(t.backdropElement), 0 === i.length ? n = {
                width: 0,
                height: 0,
                offset: {
                    top: 0,
                    left: 0
                }
            } : (n = {
                width: i.innerWidth(),
                height: i.innerHeight(),
                offset: i.offset()
            }, i.addClass("tour-step-backdrop"), t.backdropPadding && (n = this
              ._applyBackdropPadding(t.backdropPadding, n))), this._showBackground(t, n)
        }, t.prototype._hideOverlayElement = function({backdropElement}) {
            let i;
            let n;
            let o;
            e(backdropElement)
              .removeClass("tour-step-backdrop"), o = this.backdrops;
            for (n in o) i = o[n], i && void 0 !== i.remove && i.remove();
            return this.backdrops = []
        }, t.prototype._applyBackdropPadding = (e, t) => ("object" == typeof e ? (null == e.top && (e.top = 0), null == e.right && (e
          .right = 0), null == e.bottom && (e.bottom = 0), null == e.left && (e
          .left = 0), t.offset.top = t.offset.top - e.top, t.offset.left = t.offset
          .left - e.left, t.width = t.width + e.left + e.right, t.height = t.height + e
          .top + e.bottom) : (t.offset.top = t.offset.top - e, t.offset.left = t.offset
          .left - e, t.width = t.width + 2 * e, t.height = t.height + 2 * e), t), t.prototype._clearTimer = function () {
            return window.clearTimeout(this._timer), this._timer = null, this._duration = null
        }, t.prototype._getProtocol = e => (e = e.split("://"), e.length > 1 ? e[0] : "http"), t.prototype._getHost = e => (e = e.split("//"), e = e.length > 1 ? e[1] : e[0], e.split("/")[0]), t.prototype._getPath = e => e.replace(/\/?$/, "")
          .split("?")[0].split("#")[0], t.prototype._getQuery = function (e) {
            return this._getParams(e, "?")
        }, t.prototype._getHash = function (e) {
            return this._getParams(e, "#")
        }, t.prototype._getParams = (e, t) => {
            let i;
            let n;
            let o;
            let s;
            let a;
            if (s = e.split(t), 1 === s.length) return {};
            for (s = s[1].split("&"), a = {}, i = 0, n = s.length; n > i; i++) o = s[i], o = o
              .split("="), a[o[0]] = o[1] || "";
            return a
        }, t.prototype._equal = function (e, t) {
            let i;
            let n;
            let o;
            let s;
            let a;
            let r;
            if ("[object Object]" === {}.toString.call(e) && "[object Object]" === {}.toString
              .call(t)) {
                if (s = Object.keys(e), a = Object.keys(t), s.length !== a.length) return !1;
                for (n in e)
                    if (r = e[n], !this._equal(t[n], r)) return !1;
                return !0
            }
            if ("[object Array]" === {}.toString.call(e) && "[object Array]" === {}.toString.call(
              t)) {
                if (e.length !== t.length) return !1;
                for (n = i = 0, o = e.length; o > i; n = ++i)
                    if (r = e[n], !this._equal(r, t[n])) return !1;
                return !0
            }
            return e === t
        }, t;
    })();
});
var tutorial = (() => ({
    init(e, t) {
        this.current_tour_config = null, this.current_tour = null, this.current_step = 0, this
          .continue_tutorial = !1, this.tutorialView = t, this.coin_rewards = 0, this
          .continue_tutorial = e, this.loadTutorial(tutorial.tutorialLoadedHandler)
    },

    start() {
        null != this.current_tour && this.current_tour.end(), null != this.current_tour_config &&
        (this.current_tour = new Tour(tour_config), this.current_tour.init(), this.goToStep(
          tutorial.current_step), this.current_tour.start())
    },

    restart() {
        null == this.current_tour || this.current_tour.ended() || this.goToStep(0)
    },

    goToStep(e) {
        this.current_tour.goTo(e)
    },

    loadTutorial(e) {
        null != tutorial.current_tour && tutorial.current_tour.ended() || $.ajax({
            type: "GET",
            dataType: "json",
            url: "/tutorials/current",
            cache: !1,
            success(t) {
                t ? e(t) : (tutorial.lightBoxCloseListener = null, tutorial
                  .newMissionListener = null)
            }
        })
    },

    tutorialLoadedHandler({current_step, coin_rewards, tutorial_identifier}) {
        tutorial.continue_tutorial && (tutorial.current_step = current_step), tutorial
          .coin_rewards = coin_rewards, tutorial.load_config(tutorial_identifier, tutorial
          .tutorialConfigLoadedHandler)
    },

    tutorialConfigLoadedHandler(e) {
        tutorial.setCurrentTourConfig(e), registerTutorial(this.tutorialView), tutorial
          .append_close_tutorial_modal()
    },

    load_config(e, t) {
        $.ajax({
            type: "GET",
            dataType: "script",
            cache: !1,
            url: `/tutorials/${e}.js`,
            success(e) {
                null != e && e.trim()
                  .length && t(e)
            }
        })
    },

    setCurrentStep(e) {
        this.current_step = e, this.trackStep(e)
    },

    trackStep(e) {
        tutorial.current_tour.ended() || $.ajax({
            type: "POST",
            url: "/tutorials/track",
            data: `step=${e}`,
            cache: !1
        })
    },

    finish() {
        $.ajax({
            type: "POST",
            url: "/tutorials/finish",
            data: {
                identifier: tutorial.current_tour._options.name,
                completed: this.current_step + 1 === tutorial.current_tour._options.steps
                  .length
            },
            cache: !1,
            success() {
                tutorial.mobileComplete(), tutorial.init()
            }
        })
    },

    complete() {
        this.isRunning() && this.current_tour.end()
    },

    setCurrentTourConfig(e) {
        this.current_tour_config = e
    },

    isRunning() {
        return void 0 != this.current_tour && !this.current_tour.ended()
    },

    mobileStep(e) {
        this.isRunning() && mobileBridgeAdd("tutorial_step", {
            step: this.current_step,
            mobile_view: e.mobile_view,
            mobile_rendering: e.mobile_rendering,
            mobile_next_step: e.mobile_next_step,
            content: e.content,
            enable_back_button: e.mobile_enable_back_button
        })
    },

    mobileComplete() {
        mobileBridgeAdd("tutorial_completed", {})
    },

    mobileCloseLightbox() {
        mobileBridgeAdd("close", {})
    },

    callBuildingLoadContentListener(e) {
        null != this.buildingLoadContentListener && (this.buildingLoadContentListener(), e && (
          this.buildingLoadContentListener = null))
    },

    setBuildingLoadContentListener(e) {
        this.buildingLoadContentListener = e
    },

    callNewMissionListener(e) {
        null != this.newMissionListener && (this.newMissionListener(), e && (this
          .newMissionListener = null))
    },

    setNewMissionListener(e) {
        this.newMissionListener = e
    },

    callLightBoxCloseListener() {
        null != this.lightBoxCloseListener && this.lightBoxCloseListener()
    },

    setLightBoxCloseListener(e) {
        this.lightBoxCloseListener = e
    },

    append_close_tutorial_modal() {
        $("body")
          .append(
            `<div id ="close_tutorial_modal" class="modal fade" tabindex="-1" role="dialog">\n  <div class="modal-dialog modal-sm" role="document">\n    <div class="modal-content">\n      <div class="modal-body">\n        <p>${I18n.t("tutorial.commons.skip_hint")}</p>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-primary" data-dismiss="modal">${I18n.t("tutorial.commons.continue")}</button>\n        <button type="button" class="btn btn-danger" onclick='tutorial.close_tutorial()'>${I18n.t("tutorial.commons.skip")}</button>\n      </div>\n    </div><!-- /.modal-content -->\n  </div><!-- /.modal-dialog -->\n</div><!-- /.modal -->`)
    },

    close_tutorial() {
        $("#close_tutorial_modal")
          .modal("hide"), this.current_tour.end()
    }
}))();
/*
 * JS Storage Plugin
 *
 * Copyright (c) 2019 Julien Maurel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 * https://github.com/julien-maurel/js-storage
 *
 * Version: 1.1.0
 */
!(e => {
    let t = !1;
    if ("function" == typeof define && define.amd && (define(e), t = !0), "object" == typeof exports && (
      module.exports = e(), t = !0), !t) {
        const i = window.Storages;
        const n = window.Storages = e();
        n.noConflict = () => (window.Storages = i, n)
    }
})(() => {
    function e(...args) {
        let e;
        let t;
        let i;
        let n;
        let o;
        const s = this._type;
        const a = args.length;
        const r = window[s];
        const l = args;
        const c = l[0];
        if (1 > a) throw new Error("Minimum 1 argument must be given");
        if (Array.isArray(c)) {
            t = {};
            for (n in c)
                if (c.hasOwnProperty(n)) {
                    e = c[n];
                    try {
                        t[e] = JSON.parse(r.getItem(e))
                    } catch (u) {
                        t[e] = r.getItem(e)
                    }
                } return t
        }
        if (1 != a) {
            try {
                if (t = JSON.parse(r.getItem(c)), !t) throw new ReferenceError(`${c} is not defined in this storage`)
            } catch (u) {
                throw new ReferenceError(`${c} is not defined in this storage`)
            }
            for (n = 1; a - 1 > n; n++)
                if (t = t[l[n]], void 0 === t) throw new ReferenceError(`${[].slice.call(l, 0, n + 1)
  .join(".")} is not defined in this storage`);
            if (Array.isArray(l[n])) {
                i = t, t = {};
                for (o in l[n]) l[n].hasOwnProperty(o) && (t[l[n][o]] = i[l[n][o]]);
                return t
            }
            return t[l[n]]
        }
        try {
            return JSON.parse(r.getItem(c))
        } catch (u) {
            return r.getItem(c)
        }
    }

    function t(...args) {
        let e;
        let t;
        let i;
        let n;
        const o = this._type;
        const s = args.length;
        const a = window[o];
        const r = args;
        const l = r[0];
        const u = r[1];
        let d = isNaN(u) ? {} : [];
        if (1 > s || !c(l) && 2 > s) throw new Error(
          "Minimum 2 arguments must be given or first parameter must be an object");
        if (c(l)) {
            for (n in l) l.hasOwnProperty(n) && (e = l[n], c(e) || this.alwaysUseJson ? a.setItem(n, JSON
              .stringify(e)) : a.setItem(n, e));
            return l
        }
        if (2 == s) return "object" == typeof u || this.alwaysUseJson ? a.setItem(l, JSON.stringify(u)) :
          a.setItem(l, u), u;
        try {
            i = a.getItem(l), null != i && (d = JSON.parse(i))
        } catch (h) {}
        for (i = d, n = 1; s - 2 > n; n++) e = r[n], t = isNaN(r[n + 1]) ? "object" : "array", (!i[e] ||
          "object" == t && !c(i[e]) || "array" == t && !Array.isArray(i[e])) && (i[e] = "array" ==
        t ? [] : {}), i = i[e];
        return i[r[n]] = r[n + 1], a.setItem(l, JSON.stringify(d)), d
    }

    function i(...args) {
        let e;
        let t;
        let i;
        let n;
        const o = this._type;
        const s = args.length;
        const a = window[o];
        const r = args;
        const l = r[0];
        if (1 > s) throw new Error("Minimum 1 argument must be given");
        if (Array.isArray(l)) {
            for (i in l) l.hasOwnProperty(i) && a.removeItem(l[i]);
            return !0
        }
        if (1 == s) return a.removeItem(l), !0;
        try {
            e = t = JSON.parse(a.getItem(l))
        } catch (c) {
            throw new ReferenceError(`${l} is not defined in this storage`)
        }
        for (i = 1; s - 1 > i; i++)
            if (t = t[r[i]], void 0 === t) throw new ReferenceError(`${[].slice.call(r, 1, i)
  .join(".")} is not defined in this storage`);
        if (Array.isArray(r[i]))
            for (n in r[i]) r[i].hasOwnProperty(n) && delete t[r[i][n]];
        else delete t[r[i]];
        return a.setItem(l, JSON.stringify(e)), !0
    }

    function n(e) {
        let t;
        const n = a.call(this);
        for (t in n) n.hasOwnProperty(t) && i.call(this, n[t]);
        if (e)
            for (t in v.namespaceStorages) v.namespaceStorages.hasOwnProperty(t) && r(t)
    }

    function o(...args) {
        let t;
        const i = args.length;
        const n = args;
        const s = n[0];
        if (0 == i) return 0 == a.call(this)
          .length;
        if (Array.isArray(s)) {
            for (t = 0; t < s.length; t++)
                if (!o.call(this, s[t])) return !1;
            return !0
        }
        try {
            let r = e.apply(this, args);
            Array.isArray(n[i - 1]) || (r = {
                totest: r
            });
            for (t in r)
                if (r.hasOwnProperty(t) && !(c(r[t]) && u(r[t]) || Array.isArray(r[t]) && !r[t].length ||
                  "boolean" != typeof r[t] && !r[t])) return !1;
            return !0
        } catch (l) {
            return !0
        }
    }

    function s(...args) {
        let t;
        const i = args.length;
        const n = args;
        const o = n[0];
        if (1 > i) throw new Error("Minimum 1 argument must be given");
        if (Array.isArray(o)) {
            for (t = 0; t < o.length; t++)
                if (!s.call(this, o[t])) return !1;
            return !0
        }
        try {
            let a = e.apply(this, args);
            Array.isArray(n[i - 1]) || (a = {
                totest: a
            });
            for (t in a)
                if (a.hasOwnProperty(t) && (void 0 === a[t] || null === a[t])) return !1;
            return !0
        } catch (r) {
            return !1
        }
    }

    function a(...args) {
        const t = this._type;
        const i = args.length;
        const n = window[t];
        const o = [];
        let s = {};
        if (s = i > 0 ? e.apply(this, args) : n, s && s._cookie) {
            const a = Cookies.get();
            for (const r in a) a.hasOwnProperty(r) && "" != r && o.push(r.replace(s._prefix, ""))
        } else
            for (const l in s) s.hasOwnProperty(l) && o.push(l);
        return o
    }

    function r(e) {
        if (!e || "string" != typeof e) throw new Error("First parameter must be a string");
        w ? (window.localStorage.getItem(e) || window.localStorage.setItem(e, "{}"), window.sessionStorage
          .getItem(e) || window.sessionStorage.setItem(e, "{}")) : (window.localCookieStorage
          .getItem(e) || window.localCookieStorage.setItem(e, "{}"), window.sessionCookieStorage
          .getItem(e) || window.sessionCookieStorage.setItem(e, "{}"));
        const t = {
            localStorage: d({}, v.localStorage, {
                _ns: e
            }),
            sessionStorage: d({}, v.sessionStorage, {
                _ns: e
            })
        };
        return k && (window.cookieStorage.getItem(e) || window.cookieStorage.setItem(e, "{}"), t
          .cookieStorage = d({}, v.cookieStorage, {
            _ns: e
        })), v.namespaceStorages[e] = t, t
    }

    function l(e) {
        const t = "jsapi";
        try {
            return window[e] ? (window[e].setItem(t, t), window[e].removeItem(t), !0) : !1
        } catch (i) {
            return !1
        }
    }

    function c(e) {
        let t;
        let i;
        return e && "[object Object]" === p.call(e) ? (t = g(e)) ? (i = m.call(t, "constructor") && t
          .constructor, "function" == typeof i && f.call(i) === _) : !0 : !1
    }

    function u(e) {
        let t;
        for (t in e) return !1;
        return !0
    }

    function d(...args) {
        for (var e = 1, t = args[0]; e < args.length; e++) {
            const i = args[e];
            for (const n in i) i.hasOwnProperty(n) && (t[n] = i[n])
        }
        return t
    }
    var h = {};
    var p = h.toString;
    var m = h.hasOwnProperty;
    var f = m.toString;
    var _ = f.call(Object);
    var g = Object.getPrototypeOf;
    var v = {};
    const b = "ls_";
    const y = "ss_";
    var w = l("localStorage");
    var k = "undefined" != typeof Cookies;

    const x = {
        _type: "",
        _ns: "",
        _callMethod(e, t) {
            t = Array.prototype.slice.call(t);
            const i = [], n = t[0];
            return this._ns && i.push(this._ns), "string" == typeof n && n.includes(".") &&
            (t.shift(), [].unshift.apply(t, n.split("."))), [].push.apply(i, t), e.apply(this,
              i);
        },
        alwaysUseJson: !1,
        get(...args) {
            return w || k ? this._callMethod(e, args) : null;
        },
        set(...args) {
            const e = args.length, i = args, n = i[0];
            if (1 > e || !c(n) && 2 > e) throw new Error(
              "Minimum 2 arguments must be given or first parameter must be an object");
            if (!w && !k) return null;
            if (c(n) && this._ns) {
                for (const o in n) n.hasOwnProperty(o) && this._callMethod(t, [o, n[o]]);
                return n
            }
            const s = this._callMethod(t, i);
            return this._ns ? s[n.split(".")[0]] : s
        },
        remove(...args) {
            if (args.length < 1) throw new Error("Minimum 1 argument must be given");
            return w || k ? this._callMethod(i, args) : null;
        },
        removeAll(e) {
            return w || k ? this._ns ? (this._callMethod(t, [{}]), !0) : this._callMethod(n, [
                e]) : null
        },
        isEmpty(...args) {
            return w || k ? this._callMethod(o, args) : null;
        },
        isSet(...args) {
            if (args.length < 1) throw new Error("Minimum 1 argument must be given");
            return w || k ? this._callMethod(s, args) : null;
        },
        keys(...args) {
            return w || k ? this._callMethod(a, args) : null;
        }
    };

    if (k) {
        window.name || (window.name = Math.floor(1e8 * Math.random()));
        const C = {
            _cookie: !0,
            _prefix: "",
            _expires: null,
            _path: null,
            _domain: null,
            _secure: !1,
            setItem(e, t) {
                Cookies.set(this._prefix + e, t, {
                    expires: this._expires,
                    path: this._path,
                    domain: this._domain,
                    secure: this._secure
                })
            },
            getItem(e) {
                return Cookies.get(this._prefix + e)
            },
            removeItem(e) {
                return Cookies.remove(this._prefix + e, {
                    path: this._path
                })
            },
            clear() {
                const e = Cookies.get();
                for (const t in e) e.hasOwnProperty(t) && "" != t && (!this._prefix && !t.includes(b) && !t.includes(y) || this._prefix && 0 === t.indexOf(this
                  ._prefix)) && Cookies.remove(t)
            },
            setExpires(e) {
                return this._expires = e, this
            },
            setPath(e) {
                return this._path = e, this
            },
            setDomain(e) {
                return this._domain = e, this
            },
            setSecure(e) {
                return this._secure = e, this
            },
            setConf({path, domain, secure, expires}) {
                return path && (this._path = path), domain && (this._domain = domain), secure && (this._secure = secure), expires && (this._expires = expires), this;
            },
            setDefaultConf() {
                this._path = this._domain = this._expires = null, this._secure = !1
            }
        };
        w || (window.localCookieStorage = d({}, C, {
            _prefix: b,
            _expires: 3650,
            _secure: !0
        }), window.sessionCookieStorage = d({}, C, {
            _prefix: `${y + window.name}_`,
            _secure: !0
        })), window.cookieStorage = d({}, C), v.cookieStorage = d({}, x, {
            _type: "cookieStorage",
            setExpires(e) {
                return window.cookieStorage.setExpires(e), this
            },
            setPath(e) {
                return window.cookieStorage.setPath(e), this
            },
            setDomain(e) {
                return window.cookieStorage.setDomain(e), this
            },
            setSecure(e) {
                return window.cookieStorage.setSecure(e), this
            },
            setConf(e) {
                return window.cookieStorage.setConf(e), this
            },
            setDefaultConf() {
                return window.cookieStorage.setDefaultConf(), this
            }
        })
    }
    return v.initNamespaceStorage = e => r(e), w ? (v.localStorage = d({}, x, {
        _type: "localStorage"
    }), v.sessionStorage = d({}, x, {
        _type: "sessionStorage"
    })) : (v.localStorage = d({}, x, {
        _type: "localCookieStorage"
    }), v.sessionStorage = d({}, x, {
        _type: "sessionCookieStorage"
    })), v.namespaceStorages = {}, v.removeAllStorages = e => {
        v.localStorage.removeAll(e), v.sessionStorage.removeAll(e), v.cookieStorage && v.cookieStorage
          .removeAll(e), e || (v.namespaceStorages = {})
    }, v.alwaysUseJsonInStorage = e => {
        x.alwaysUseJson = e, v.localStorage.alwaysUseJson = e, v.sessionStorage.alwaysUseJson = e, v
          .cookieStorage && (v.cookieStorage.alwaysUseJson = e)
    }, v;
}), !(e => {
    let t;
    if ("function" == typeof define && define.amd && (define(e), t = !0), "object" == typeof exports && (
      module.exports = e(), t = !0), !t) {
        const i = window.Cookies;
        const n = window.Cookies = e();
        n.noConflict = () => (window.Cookies = i, n)
    }
})(() => {
    function e(...args) {
        for (var e = 0, t = {}; e < args.length; e++) {
            const i = args[e];
            for (const n in i) t[n] = i[n]
        }
        return t
    }

    function t(e) {
        return e.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
    }

    function i(n) {
        function o() {}

        function s(t, i, s) {
            if ("undefined" != typeof document) {
                s = e({
                    path: "/"
                }, o.defaults, s), "number" == typeof s.expires && (s.expires = new Date(1 *
                  new Date + 864e5 * s.expires)), s.expires = s.expires ? s.expires.toUTCString() :
                  "";
                try {
                    const a = JSON.stringify(i);
                    /^[\{\[]/.test(a) && (i = a)
                } catch (r) {}
                i = n.write ? n.write(i, t) : encodeURIComponent(`${i}`)
                  .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,
                    decodeURIComponent), t = encodeURIComponent(`${t}`)
                  .replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
                  .replace(/[\(\)]/g, escape);
                let l = "";
                for (const c in s) s[c] && (l += `; ${c}`, !0 !== s[c] && (l += `=${s[c].split(";")[0]}`));
                return document.cookie = `${t}=${i}${l}`;
            }
        }

        function a(e, i) {
            if ("undefined" != typeof document) {
                for (var o = {}, s = document.cookie ? document.cookie.split("; ") : [], a = 0; a < s
                  .length; a++) {
                    const r = s[a].split("=");

                    let l = r.slice(1)
                      .join("=");

                    i || '"' !== l.charAt(0) || (l = l.slice(1, -1));
                    try {
                        const c = t(r[0]);
                        if (l = (n.read || n)(l, c) || t(l), i) try {
                            l = JSON.parse(l)
                        } catch (u) {}
                        if (o[c] = l, e === c) break
                    } catch (u) {}
                }
                return e ? o[e] : o
            }
        }
        return o.set = s, o.get = e => a(e, !1), o.getJSON = e => a(e, !0), o.remove = (t, i) => {
            s(t, "", e(i, {
                expires: -1
            }))
        }, o.defaults = {}, o.withConverter = i, o;
    }
    return i(() => {});
});
var STORAGE_KEY_MOBILE_CLIENT_ID = "mc_mobile_client_id";
const STORAGE_KEY_UNIQUE_CLIENT_ID = "mc_unique_client_id";
var STORAGE_KEY_DEACTIVE_MISSION_SELECTION = "deactive_m_selection";
var STORAGE_KEY_DEACTIVE_BUILDING_SELECTION = "deactive_selection";
var STORAGE_KEY_BIG_MAP_WINDOW_POSITIONS = "bigMapWindowPosition";

var mc_storage = (() => ({
    get(e) {
        return this.getFromStorages(Storages, e)
    },

    setToLocalStorage(e, t) {
        Storages.localStorage.set(e, t)
    },

    setToSessionStorage(e, t) {
        Storages.sessionStorage.set(e, t)
    },

    setToCookieStorage(e, t) {
        Storages.cookieStorage.setExpires(356)
          .set(e, t)
    },

    getFromNameSpacedStorage(e, t) {
        return this.getFromStorages(this.getNameSpacedStorage(e), t)
    },

    setToNameSpacedLocalStorage(e, t, i) {
        this.getNameSpacedStorage(e)
          .localStorage.set(t, i)
    },

    setToNameSpacedSessionStorage(e, t, i) {
        this.getNameSpacedStorage(e)
          .sessionStorage.set(t, i)
    },

    setToNameSpacedCookieStorage(e, t, i) {
        this.getNameSpacedStorage(e)
          .cookieStorage.set(t, i)
    },

    getNameSpacedStorage(e) {
        return Storages.initNamespaceStorage(e)
    },

    getFromStorages({cookieStorage, localStorage, sessionStorage}, t) {
        let i;
        return cookieStorage.isSet(t) ? i = cookieStorage.get(t) : localStorage.isSet(t) ?
          i = localStorage.get(t) : sessionStorage.isSet(t) && (i = sessionStorage.get(
          t)), i;
    }
}))();

const map_pois_service = (() => {
    let e = Array();
    return {
        getMissionPoiMarkersArray() {
            return e
        },
        leafletMissionPositionMarkerAdd({latitude, longitude, caption, id}) {
            const i = L.icon({
                iconUrl: "/images/letter_p.png",
                iconSize: [32, 37],
                iconAnchor: iconAnchorCalculate([32, 37])
            });
            marker = L.marker([latitude, longitude], {
                icon: i
            })
              .bindTooltip(caption);
            const n = e => {
                confirm(I18n.t("javascript.poi_delete", {
                    caption: caption
                })) && (map_pois_service.leafletMissionPositionMarkerDelete(e.target
                  ._leaflet_id), $.ajax({
                    url: `/mission_positions/${id}`,
                    type: "POST",
                    data: {
                        _method: "delete"
                    },
                    cache: !1
                }))
            };
            marker.on("click", n), marker.id = id, marker.addTo(map_filters_service
              .getMapFiltersLayers()
              .pois), e.push(marker)
        },
        leafletMissionPositionMarkerDelete(t) {
            marker = map_filters_service.getMapFiltersLayers()
              .pois.getLayer(t), map_filters_service.getMapFiltersLayers()
              .pois.removeLayer(t), index = e.indexOf(marker), -1 !== index && e.splice(index, 1)
        },
        mapkitMissionPositionMarkerAdd({caption, id, latitude, longitude}) {
            const i = function () {
                confirm(I18n.t("javascript.poi_delete", {
                    caption: caption
                })) && (this.mapkitMissionPositionMarkerDelete(id), $.ajax({
                    url: `/mission_positions/${id}`,
                    type: "POST",
                    data: {
                        _method: "delete"
                    },
                    cache: !1
                }))
            };
            if ("undefined" != typeof mapkit) {
                var n = new mapkit.ImageAnnotation(new mapkit.Coordinate(latitude, longitude), {
                    url: {
                        1: "/images/letter_p.png"
                    }
                });
                n.title = caption, n.addEventListener("select", i), map.addAnnotation(n), n.element
                  .className = "mapkit-marker"
            }
            n.id = id, e.push(n)
        },
        mapkitMissionPositionMarkerDelete(t) {
            $.each(e, (e, i) => {
                i.id == t && map.removeAnnotation(i)
            })
        },
        mapkitMissionPositionMarkerDeleteAll() {
            $.each(e, (e, t) => {
                map.removeAnnotation(t)
            }), e = Array()
        }
    };
})();

var map_filters_service = (() => {
    let e;
    let t;
    const i = {};
    const n = {};
    let o = {};
    let s = {};
    let a = !1;
    return {
        initialize(a) {
            o = a.building_types_collection, e = a.mission_types_collection, s = a
              .mission_types_with_filter_ids, t = a.user_id, $.each(a.sorted_map_filters,
              function () {
                  filter_layer = L.layerGroup(), n[map_filters_service.decorateFilterText(this
                    .text, this.filter_id)] = filter_layer, i[this.filter_id] =
                    filter_layer
              })
        },
        getMapFiltersLayersForMap() {
            return n
        },
        getMapFiltersLayers() {
            return i
        },
        getFilterLayerByBuildingParams(e) {
            switch (!0) {
                case e.user_id == t && "undefined" != typeof o[e.building_type]:
                    return i[o[e.building_type]] || map;
                case e.user_id != t && null != e.user_id:
                    return i.alliance_members || map;
                case null == e.user_id:
                    return i.alliance_buildings || map;
                default:
                    return map
            }
        },
        getFilterLayerByMissionParams(e) {
            switch (!0) {
                case e.user_id == t && "undefined" != typeof s[e.mtid]:
                    return i[s[e.mtid]];
                case e.user_id != t:
                    return i.alliance_missions;
                default:
                    return map
            }
        },
        onOverlayChanged({layer, type}) {
            filter_key = Object.keys(i)
              .find(t => i[t] === layer), filter_checked = "overlayadd" == type, a || ($.ajax({
                type: "PUT",
                url: "/map_filters",
                data: {
                    filter_id: filter_key,
                    checked: filter_checked
                },
                cache: !1
            }), ("all_buildings" == filter_key || "user_buildings" == filter_key ||
              "all_missions" == filter_key || "user_missions" == filter_key) && (a = !0,
              setTimeout(() => {
                  map_filters_service.massFiltersChange(filter_key, filter_checked)
              }, 0)))
        },
        massFiltersChange(t, n) {
            switch (filters_keys = [], !0) {
                case "all_buildings" == t:
                    filters_keys = Object.values(o)
                      .concat(["user_buildings", "alliance_buildings", "alliance_members"]);
                    break;
                case "user_buildings" == t:
                    filters_keys = Object.values(o);
                    break;
                case "all_missions" == t:
                    filters_keys = e.concat(["user_missions", "alliance_missions"]);
                    break;
                case "user_missions" == t:
                    filters_keys = e
            }
            $.each(filters_keys, (e, t) => {
                void 0 !== i[t] ? n ? map.addLayer(i[t]) : map.removeLayer(i[t]) : console
                  .log(`missing filter layer: ${t}`)
            }), a = !1
        },
        decorateFilterText(t, i) {
            const n = (e, t, i) => `<a class='list__element list__element--${t} ${i}'>${e}</a>`;
            switch (!0) {
                case Object.values(o)
                  .includes(i):
                    return n(t, "third", "building-filter");
                case e.includes(i):
                    return n(t, "third", "mission-filter");
                case "all_buildings" == i:
                    return n(t, "first", "all-buildings-filter");
                case "all_missions" == i:
                    return n(t, "first", "all-missions-filter");
                case "pois" == i:
                    return n(t, "first", "app-pois-filter");
                case "user_buildings" == i:
                    return n(t, "second", "user-buildings-filter");
                case "user_missions" == i:
                    return n(t, "second", "user-missions-filter");
                case ["alliance_buildings", "alliance_members"].includes(i):
                    return n(t, "second", "alliance-buildings-filter");
                case "alliance_missions" == i:
                    return n(t, "second", "alliance-missions-filter");
                default:
                    return t
            }
        }
    };
})();

mobile_map_filters_collection = {}, !((e, t) => {
    "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"],
      i => t(e, i)) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) :
      e.jQueryBridget = t(e, e.jQuery)
})(window, (e, t) => {
    function i(i, s, r) {
        function l(e, t, n) {
            let o;
            const s = `$().${i}("${t}")`;
            return e.each((e, l) => {
                const c = r.data(l, i);
                if (!c) return void a(`${i} not initialized. Cannot call methods, i.e. ${s}`);
                const u = c[t];
                if (!u || "_" == t.charAt(0)) return void a(`${s} is not a valid method`);
                const d = u.apply(c, n);
                o = void 0 === o ? d : o
            }), void 0 !== o ? o : e;
        }

        function c(e, t) {
            e.each((e, n) => {
                let o = r.data(n, i);
                o ? (o.option(t), o._init()) : (o = new s(n, t), r.data(n, i, o))
            })
        }
        r = r || t || e.jQuery, r && (s.prototype.option || (s.prototype.option = function (e) {
            r.isPlainObject(e) && (this.options = r.extend(!0, this.options, e))
        }), r.fn[i] = function (e) {
            if ("string" == typeof e) {
                const t = o.call(arguments, 1);
                return l(this, e, t)
            }
            return c(this, e), this
        }, n(r))
    }

    function n(e) {
        !e || e && e.bridget || (e.bridget = i)
    }
    var o = Array.prototype.slice;
    const s = e.console;

    var a = "undefined" == typeof s ? () => {} : e => {
        s.error(e)
    };

    return n(t || e.jQuery), i
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" ==
    typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
})("undefined" != typeof window ? window : this, () => {
    function e() {}
    const t = e.prototype;
    return t.on = function (e, t) {
        if (e && t) {
            const i = this._events = this._events || {};
            const n = i[e] = i[e] || [];
            return !n.includes(t) && n.push(t), this;
        }
    }, t.once = function (e, t) {
        if (e && t) {
            this.on(e, t);
            const i = this._onceEvents = this._onceEvents || {};
            const n = i[e] = i[e] || {};
            return n[t] = !0, this
        }
    }, t.off = function (e, t) {
        const i = this._events && this._events[e];
        if (i && i.length) {
            const n = i.indexOf(t);
            return -1 != n && i.splice(n, 1), this
        }
    }, t.emitEvent = function (e, t) {
        let i = this._events && this._events[e];
        if (i && i.length) {
            i = i.slice(0), t = t || [];
            for (let n = this._onceEvents && this._onceEvents[e], o = 0; o < i.length; o++) {
                const s = i[o];
                const a = n && n[s];
                a && (this.off(e, s), delete n[s]), s.apply(this, t)
            }
            return this
        }
    }, t.allOff = function () {
        delete this._events, delete this._onceEvents
    }, e;
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" ==
    typeof module && module.exports ? module.exports = t() : e.getSize = t()
})(window, () => {
    function e(e) {
        const t = parseFloat(e);
        const i = !e.includes("%") && !isNaN(t);
        return i && t
    }

    function t() {}

    function i() {
        for (var e = {
            width: 0,
            height: 0,
            innerWidth: 0,
            innerHeight: 0,
            outerWidth: 0,
            outerHeight: 0
        }, t = 0; c > t; t++) {
            const i = l[t];
            e[i] = 0
        }
        return e
    }

    function n(e) {
        const t = getComputedStyle(e);
        return t || r(`Style returned ${t}. Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1`
        ), t;
    }

    function o() {
        if (!u) {
            u = !0;
            const t = document.createElement("div");
            t.style.width = "200px", t.style.padding = "1px 2px 3px 4px", t.style.borderStyle =
              "solid", t.style.borderWidth = "1px 2px 3px 4px", t.style.boxSizing = "border-box";
            const i = document.body || document.documentElement;
            i.appendChild(t);
            const o = n(t);
            a = 200 == Math.round(e(o.width)), s.isBoxSizeOuter = a, i.removeChild(t)
        }
    }

    function s(t) {
        if (o(), "string" == typeof t && (t = document.querySelector(t)), t && "object" == typeof t &&
        t.nodeType) {
            const s = n(t);
            if ("none" == s.display) return i();
            const r = {};
            r.width = t.offsetWidth, r.height = t.offsetHeight;
            for (var u = r.isBorderBox = "border-box" == s.boxSizing, d = 0; c > d; d++) {
                const h = l[d];
                const p = s[h];
                const m = parseFloat(p);
                r[h] = isNaN(m) ? 0 : m
            }
            const f = r.paddingLeft + r.paddingRight;
            const _ = r.paddingTop + r.paddingBottom;
            const g = r.marginLeft + r.marginRight;
            const v = r.marginTop + r.marginBottom;
            const b = r.borderLeftWidth + r.borderRightWidth;
            const y = r.borderTopWidth + r.borderBottomWidth;
            const w = u && a;
            const k = e(s.width);
            k !== !1 && (r.width = k + (w ? 0 : f + b));
            const x = e(s.height);
            return x !== !1 && (r.height = x + (w ? 0 : _ + y)), r.innerWidth = r.width - (f + b), r
              .innerHeight = r.height - (_ + y), r.outerWidth = r.width + g, r.outerHeight = r
              .height + v, r
        }
    }
    var a;

    var r = "undefined" == typeof console ? t : e => {
          console.error(e)
      };

    var l = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft",
        "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth",
        "borderTopWidth", "borderBottomWidth"];

    var c = l.length;
    var u = !1;
    return s
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) :
      "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t()
})(window, () => {
    const e = (() => {
        const e = window.Element.prototype;
        if (e.matches) return "matches";
        if (e.matchesSelector) return "matchesSelector";
        for (let t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) {
            const n = t[i];
            const o = `${n}MatchesSelector`;
            if (e[o]) return o
        }
    })();
    return (t, i) => t[e](i);
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", [
        "desandro-matches-selector/matches-selector"], i => t(e, i)) : "object" == typeof module && module.exports ? module.exports = t(e, require(
      "desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector)
})(window, (e, t) => {
    const i = {};
    i.extend = (e, t) => {
        for (const i in t) e[i] = t[i];
        return e
    }, i.modulo = (e, t) => (e % t + t) % t;
    const n = Array.prototype.slice;
    i.makeArray = e => {
        if (Array.isArray(e)) return e;
        if (null === e || void 0 === e) return [];
        const t = "object" == typeof e && "number" == typeof e.length;
        return t ? n.call(e) : [e]
    }, i.removeFrom = (e, t) => {
        const i = e.indexOf(t); - 1 != i && e.splice(i, 1)
    }, i.getParent = (e, i) => {
        for (; e.parentNode && e != document.body;)
            if (e = e.parentNode, t(e, i)) return e
    }, i.getQueryElement = e => "string" == typeof e ? document.querySelector(e) : e, i.handleEvent = function (e) {
        const t = `on${e.type}`;
        this[t] && this[t](e)
    }, i.filterFindElements = (e, n) => {
        e = i.makeArray(e);
        const o = [];
        return e.forEach(e => {
            if (e instanceof HTMLElement) {
                if (!n) return void o.push(e);
                t(e, n) && o.push(e);
                for (let i = e.querySelectorAll(n), s = 0; s < i.length; s++) o.push(i[s])
            }
        }), o;
    }, i.debounceMethod = ({prototype}, t, i = 100) => {
        const n = prototype[t];
        const o = `${t}Timeout`;
        prototype[t] = function(...args) {
            const e = this[o];
            clearTimeout(e);
            const t = args;
            const s = this;
            this[o] = setTimeout(() => {
                n.apply(s, t), delete s[o]
            }, i)
        }
    }, i.docReady = e => {
        const t = document.readyState;
        "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener(
          "DOMContentLoaded", e)
    }, i.toDashed = e => e.replace(/(.)([A-Z])/g, (e, t, i) => `${t}-${i}`)
      .toLowerCase();
    const o = e.console;
    return i.htmlInit = (t, n) => {
        i.docReady(() => {
            const s = i.toDashed(n);
            const a = `data-${s}`;
            const r = document.querySelectorAll(`[${a}]`);
            const l = document.querySelectorAll(`.js-${s}`);

            const c = i.makeArray(r)
              .concat(i.makeArray(l));

            const u = `${a}-options`;
            const d = e.jQuery;
            c.forEach(e => {
                let i;
                const s = e.getAttribute(a) || e.getAttribute(u);
                try {
                    i = s && JSON.parse(s)
                } catch (r) {
                    return void(o && o.error(`Error parsing ${a} on ${e
  .className}: ${r}`));
                }
                const l = new t(e, i);
                d && d.data(e, n, l)
            })
        })
    }, i;
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter",
        "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(
      require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e
      .EvEmitter, e.getSize))
})(window, ({prototype}, t) => {
    function i(e) {
        for (var t in e) return !1;
        return t = null, !0
    }

    function n(e, t) {
        e && (this.element = e, this.layout = t, this.position = {
            x: 0,
            y: 0
        }, this._create())
    }

    function o(e) {
        return e.replace(/([A-Z])/g, e => `-${e.toLowerCase()}`);
    }
    const s = document.documentElement.style;
    const a = "string" == typeof s.transition ? "transition" : "WebkitTransition";
    const r = "string" == typeof s.transform ? "transform" : "WebkitTransform";

    const l = {
        WebkitTransition: "webkitTransitionEnd",
        transition: "transitionend"
    } [a];

    const c = {
        transform: r,
        transition: a,
        transitionDuration: `${a}Duration`,
        transitionProperty: `${a}Property`,
        transitionDelay: `${a}Delay`
    };

    const u = n.prototype = Object.create(prototype);
    u.constructor = n, u._create = function () {
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        }, this.css({
            position: "absolute"
        })
    }, u.handleEvent = function (e) {
        const t = `on${e.type}`;
        this[t] && this[t](e)
    }, u.getSize = function () {
        this.size = t(this.element)
    }, u.css = function (e) {
        const t = this.element.style;
        for (const i in e) {
            const n = c[i] || i;
            t[n] = e[i]
        }
    }, u.getPosition = function () {
        const e = getComputedStyle(this.element);
        const t = this.layout._getOption("originLeft");
        const i = this.layout._getOption("originTop");
        const n = e[t ? "left" : "right"];
        const o = e[i ? "top" : "bottom"];
        let s = parseFloat(n);
        let a = parseFloat(o);
        const r = this.layout.size;
        n.includes("%") && (s = s / 100 * r.width), o.includes("%") && (a = a / 100 * r.height), s = isNaN(s) ? 0 : s, a = isNaN(a) ? 0 : a,
              s -= t ? r.paddingLeft : r.paddingRight, a -= i ? r.paddingTop : r.paddingBottom, this
              .position.x = s, this.position.y = a
    }, u.layoutPosition = function () {
        const e = this.layout.size;
        const t = {};
        const i = this.layout._getOption("originLeft");
        const n = this.layout._getOption("originTop");
        const o = i ? "paddingLeft" : "paddingRight";
        const s = i ? "left" : "right";
        const a = i ? "right" : "left";
        const r = this.position.x + e[o];
        t[s] = this.getXValue(r), t[a] = "";
        const l = n ? "paddingTop" : "paddingBottom";
        const c = n ? "top" : "bottom";
        const u = n ? "bottom" : "top";
        const d = this.position.y + e[l];
        t[c] = this.getYValue(d), t[u] = "", this.css(t), this.emitEvent("layout", [this])
    }, u.getXValue = function (e) {
        const t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && !t ? `${100 * (e / this.layout.size.width)}%` : `${e}px`;
    }, u.getYValue = function (e) {
        const t = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && t ? `${100 * (e / this.layout.size.height)}%` : `${e}px`;
    }, u._transitionTo = function (e, t) {
        this.getPosition();
        const i = this.position.x;
        const n = this.position.y;
        const o = e == this.position.x && t == this.position.y;
        if (this.setPosition(e, t), o && !this.isTransitioning) return void this.layoutPosition();
        const s = e - i;
        const a = t - n;
        const r = {};
        r.transform = this.getTranslate(s, a), this.transition({
            to: r,
            onTransitionEnd: {
                transform: this.layoutPosition
            },
            isCleaning: !0
        })
    }, u.getTranslate = function (e, t) {
        const i = this.layout._getOption("originLeft");
        const n = this.layout._getOption("originTop");
        return e = i ? e : -e, t = n ? t : -t, `translate3d(${e}px, ${t}px, 0)`;
    }, u.goTo = function (e, t) {
        this.setPosition(e, t), this.layoutPosition()
    }, u.moveTo = u._transitionTo, u.setPosition = function (e, t) {
        this.position.x = parseFloat(e), this.position.y = parseFloat(t)
    }, u._nonTransition = function({to, isCleaning, onTransitionEnd}) {
        this.css(to), isCleaning && this._removeStyles(to);
        for (const t in onTransitionEnd) onTransitionEnd[t].call(this)
    }, u.transition = function (e) {
        if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(
          e);
        const t = this._transn;
        for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i];
        for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0);
        if (e.from) {
            this.css(e.from);
            let n = this.element.offsetHeight;
            n = null
        }
        this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0
    };
    const d = `opacity,${o(r)}`;
    u.enableTransition = function () {
        if (!this.isTransitioning) {
            let e = this.layout.options.transitionDuration;
            e = "number" == typeof e ? `${e}ms` : e, this.css({
                transitionProperty: d,
                transitionDuration: e,
                transitionDelay: this.staggerDelay || 0
            }), this.element.addEventListener(l, this, !1)
        }
    }, u.onwebkitTransitionEnd = function (e) {
        this.ontransitionend(e)
    }, u.onotransitionend = function (e) {
        this.ontransitionend(e)
    };
    const h = {
        "-webkit-transform": "transform"
    };
    u.ontransitionend = function (e) {
        if (e.target === this.element) {
            const t = this._transn;
            const n = h[e.propertyName] || e.propertyName;
            if (delete t.ingProperties[n], i(t.ingProperties) && this.disableTransition(), n in t
              .clean && (this.element.style[e.propertyName] = "", delete t.clean[n]), n in t
              .onEnd) {
                const o = t.onEnd[n];
                o.call(this), delete t.onEnd[n]
            }
            this.emitEvent("transitionEnd", [this])
        }
    }, u.disableTransition = function () {
        this.removeTransitionStyles(), this.element.removeEventListener(l, this, !1), this
          .isTransitioning = !1
    }, u._removeStyles = function (e) {
        const t = {};
        for (const i in e) t[i] = "";
        this.css(t)
    };
    const p = {
        transitionProperty: "",
        transitionDuration: "",
        transitionDelay: ""
    };
    return u.removeTransitionStyles = function () {
        this.css(p)
    }, u.stagger = function (e) {
        e = isNaN(e) ? 0 : e, this.staggerDelay = `${e}ms`
    }, u.removeElem = function () {
        this.element.parentNode.removeChild(this.element), this.css({
            display: ""
        }), this.emitEvent("remove", [this])
    }, u.remove = function () {
        return a && parseFloat(this.layout.options.transitionDuration) ? (this.once(
          "transitionEnd",
          function () {
              this.removeElem()
          }), void this.hide()) : void this.removeElem()
    }, u.reveal = function () {
        delete this.isHidden, this.css({
            display: ""
        });
        const e = this.layout.options;
        const t = {};
        const i = this.getHideRevealTransitionEndProperty("visibleStyle");
        t[i] = this.onRevealTransitionEnd, this.transition({
            from: e.hiddenStyle,
            to: e.visibleStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, u.onRevealTransitionEnd = function () {
        this.isHidden || this.emitEvent("reveal")
    }, u.getHideRevealTransitionEndProperty = function (e) {
        const t = this.layout.options[e];
        if (t.opacity) return "opacity";
        for (const i in t) return i
    }, u.hide = function () {
        this.isHidden = !0, this.css({
            display: ""
        });
        const e = this.layout.options;
        const t = {};
        const i = this.getHideRevealTransitionEndProperty("hiddenStyle");
        t[i] = this.onHideTransitionEnd, this.transition({
            from: e.visibleStyle,
            to: e.hiddenStyle,
            isCleaning: !0,
            onTransitionEnd: t
        })
    }, u.onHideTransitionEnd = function () {
        this.isHidden && (this.css({
            display: "none"
        }), this.emitEvent("hide"))
    }, u.destroy = function () {
        this.css({
            position: "",
            left: "",
            right: "",
            top: "",
            bottom: "",
            transition: "",
            transform: ""
        })
    }, n;
}), ((e, t) => {
    "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter",
        "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (i, n, o, s) => t(e, i, n, o, s)) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"),
      require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e
      .EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item)
})(window, (e, {prototype}, i, n, o) => {
    function s(e, t) {
        const i = n.getQueryElement(e);
        if (!i) return void(l && l.error(`Bad element for ${this.constructor.namespace}: ${i || e}`));
        this.element = i, c && (this.$element = c(this.element)), this.options = n.extend({}, this
          .constructor.defaults), this.option(t);
        const o = ++d;
        this.element.outlayerGUID = o, h[o] = this, this._create();
        const s = this._getOption("initLayout");
        s && this.layout()
    }

    function a(e) {
        function t(...args) {
            e.apply(this, args)
        }
        return t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t
    }

    function r(e) {
        if ("number" == typeof e) return e;
        const t = e.match(/(^\d*\.?\d*)(\w*)/);
        let i = t && t[1];
        const n = t && t[2];
        if (!i.length) return 0;
        i = parseFloat(i);
        const o = m[n] || 1;
        return i * o
    }
    var l = e.console;
    var c = e.jQuery;
    const u = () => {};
    var d = 0;
    var h = {};
    s.namespace = "outlayer", s.Item = o, s.defaults = {
        containerStyle: {
            position: "relative"
        },
        initLayout: !0,
        originLeft: !0,
        originTop: !0,
        resize: !0,
        resizeContainer: !0,
        transitionDuration: "0.4s",
        hiddenStyle: {
            opacity: 0,
            transform: "scale(0.001)"
        },
        visibleStyle: {
            opacity: 1,
            transform: "scale(1)"
        }
    };
    const p = s.prototype;
    n.extend(p, prototype), p.option = function (e) {
        n.extend(this.options, e)
    }, p._getOption = function (e) {
        const t = this.constructor.compatOptions[e];
        return t && void 0 !== this.options[t] ? this.options[t] : this.options[e]
    }, s.compatOptions = {
        initLayout: "isInitLayout",
        horizontal: "isHorizontal",
        layoutInstant: "isLayoutInstant",
        originLeft: "isOriginLeft",
        originTop: "isOriginTop",
        resize: "isResizeBound",
        resizeContainer: "isResizingContainer"
    }, p._create = function () {
        this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this
          .element.style, this.options.containerStyle);
        const e = this._getOption("resize");
        e && this.bindResize()
    }, p.reloadItems = function () {
        this.items = this._itemize(this.element.children)
    }, p._itemize = function (e) {
        for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], o =
          0; o < t.length; o++) {
            const s = t[o];
            const a = new i(s, this);
            n.push(a)
        }
        return n
    }, p._filterFindItemElements = function (e) {
        return n.filterFindElements(e, this.options.itemSelector)
    }, p.getItemElements = function () {
        return this.items.map(({element}) => element);
    }, p.layout = function () {
        this._resetLayout(), this._manageStamps();
        const e = this._getOption("layoutInstant");
        const t = void 0 !== e ? e : !this._isLayoutInited;
        this.layoutItems(this.items, t), this._isLayoutInited = !0
    }, p._init = p.layout, p._resetLayout = function () {
        this.getSize()
    }, p.getSize = function () {
        this.size = i(this.element)
    }, p._getMeasurement = function (e, t) {
        let n;
        const o = this.options[e];
        o ? ("string" == typeof o ? n = this.element.querySelector(o) :
          o instanceof HTMLElement && (n = o), this[e] = n ? i(n)[t] : o) : this[e] = 0
    }, p.layoutItems = function (e, t) {
        e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout()
    }, p._getItemsForLayout = e => e.filter(({isIgnored}) => !isIgnored), p._layoutItems = function (e, t) {
        if (this._emitCompleteOnItems("layout", e), e && e.length) {
            const i = [];
            e.forEach(function (e) {
                const n = this._getItemLayoutPosition(e);
                n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n)
            }, this), this._processLayoutQueue(i)
        }
    }, p._getItemLayoutPosition = () => ({
        x: 0,
        y: 0
    }), p._processLayoutQueue = function (e) {
        this.updateStagger(), e.forEach(function (e, t) {
            this._positionItem(e.item, e.x, e.y, e.isInstant, t)
        }, this)
    }, p.updateStagger = function () {
        const e = this.options.stagger;
        return null === e || void 0 === e ? void(this.stagger = 0) : (this.stagger = r(e), this
          .stagger)
    }, p._positionItem = function (e, t, i, n, o) {
        n ? e.goTo(t, i) : (e.stagger(o * this.stagger), e.moveTo(t, i))
    }, p._postLayout = function () {
        this.resizeContainer()
    }, p.resizeContainer = function () {
        const e = this._getOption("resizeContainer");
        if (e) {
            const t = this._getContainerSize();
            t && (this._setContainerMeasure(t.width, !0), this._setContainerMeasure(t.height, !1))
        }
    }, p._getContainerSize = u, p._setContainerMeasure = function (e, t) {
        if (void 0 !== e) {
            const i = this.size;
            i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i
              .borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i
              .borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" :
              "height"] = `${e}px`
        }
    }, p._emitCompleteOnItems = function (e, t) {
        function i() {
            o.dispatchEvent(`${e}Complete`, null, [t])
        }

        function n() {
            a++, a == s && i()
        }
        var o = this;
        var s = t.length;
        if (!t || !s) return void i();
        var a = 0;
        t.forEach(t => {
            t.once(e, n)
        })
    }, p.dispatchEvent = function (e, t, i) {
        const n = t ? [t].concat(i) : i;
        if (this.emitEvent(e, n), c)
            if (this.$element = this.$element || c(this.element), t) {
                const o = c.Event(t);
                o.type = e, this.$element.trigger(o, i)
            } else this.$element.trigger(e, i)
    }, p.ignore = function (e) {
        const t = this.getItem(e);
        t && (t.isIgnored = !0)
    }, p.unignore = function (e) {
        const t = this.getItem(e);
        t && delete t.isIgnored
    }, p.stamp = function (e) {
        e = this._find(e), e && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore,
          this))
    }, p.unstamp = function (e) {
        e = this._find(e), e && e.forEach(function (e) {
            n.removeFrom(this.stamps, e), this.unignore(e)
        }, this)
    }, p._find = function (e) {
        return e ? ("string" == typeof e && (e = this.element.querySelectorAll(e)), e = n
          .makeArray(e)) : void 0
    }, p._manageStamps = function () {
        this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this
          ._manageStamp, this))
    }, p._getBoundingRect = function () {
        const e = this.element.getBoundingClientRect();
        const t = this.size;
        this._boundingRect = {
            left: e.left + t.paddingLeft + t.borderLeftWidth,
            top: e.top + t.paddingTop + t.borderTopWidth,
            right: e.right - (t.paddingRight + t.borderRightWidth),
            bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth)
        }
    }, p._manageStamp = u, p._getElementOffset = function (e) {
        const t = e.getBoundingClientRect();
        const n = this._boundingRect;
        const o = i(e);

        const s = {
            left: t.left - n.left - o.marginLeft,
            top: t.top - n.top - o.marginTop,
            right: n.right - t.right - o.marginRight,
            bottom: n.bottom - t.bottom - o.marginBottom
        };

        return s
    }, p.handleEvent = n.handleEvent, p.bindResize = function () {
        e.addEventListener("resize", this), this.isResizeBound = !0
    }, p.unbindResize = function () {
        e.removeEventListener("resize", this), this.isResizeBound = !1
    }, p.onresize = function () {
        this.resize()
    }, n.debounceMethod(s, "onresize", 100), p.resize = function () {
        this.isResizeBound && this.needsResizeLayout() && this.layout()
    }, p.needsResizeLayout = function () {
        const e = i(this.element);
        const t = this.size && e;
        return t && e.innerWidth !== this.size.innerWidth
    }, p.addItems = function (e) {
        const t = this._itemize(e);
        return t.length && (this.items = this.items.concat(t)), t
    }, p.appended = function (e) {
        const t = this.addItems(e);
        t.length && (this.layoutItems(t, !0), this.reveal(t))
    }, p.prepended = function (e) {
        const t = this._itemize(e);
        if (t.length) {
            const i = this.items.slice(0);
            this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(
              t, !0), this.reveal(t), this.layoutItems(i)
        }
    }, p.reveal = function (e) {
        if (this._emitCompleteOnItems("reveal", e), e && e.length) {
            const t = this.updateStagger();
            e.forEach((e, i) => {
                e.stagger(i * t), e.reveal()
            })
        }
    }, p.hide = function (e) {
        if (this._emitCompleteOnItems("hide", e), e && e.length) {
            const t = this.updateStagger();
            e.forEach((e, i) => {
                e.stagger(i * t), e.hide()
            })
        }
    }, p.revealItemElements = function (e) {
        const t = this.getItems(e);
        this.reveal(t)
    }, p.hideItemElements = function (e) {
        const t = this.getItems(e);
        this.hide(t)
    }, p.getItem = function (e) {
        for (let t = 0; t < this.items.length; t++) {
            const i = this.items[t];
            if (i.element == e) return i
        }
    }, p.getItems = function (e) {
        e = n.makeArray(e);
        const t = [];
        return e.forEach(function (e) {
            const i = this.getItem(e);
            i && t.push(i)
        }, this), t;
    }, p.remove = function (e) {
        const t = this.getItems(e);
        this._emitCompleteOnItems("remove", t), t && t.length && t.forEach(function (e) {
            e.remove(), n.removeFrom(this.items, e)
        }, this)
    }, p.destroy = function () {
        const e = this.element.style;
        e.height = "", e.position = "", e.width = "", this.items.forEach(e => {
            e.destroy()
        }), this.unbindResize();
        const t = this.element.outlayerGUID;
        delete h[t], delete this.element.outlayerGUID, c && c.removeData(this.element, this
          .constructor.namespace)
    }, s.data = e => {
        e = n.getQueryElement(e);
        const t = e && e.outlayerGUID;
        return t && h[t]
    }, s.create = (e, t) => {
        const i = a(s);
        return i.defaults = n.extend({}, s.defaults), n.extend(i.defaults, t), i.compatOptions = n
          .extend({}, s.compatOptions), i.namespace = e, i.data = s.data, i.Item = a(o), n
          .htmlInit(i, e), c && c.bridget && c.bridget(e, i), i
    };
    var m = {
        ms: 1,
        s: 1e3
    };
    return s.Item = o, s
}), ((e, t) => {
    "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size"], t) :
      "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require(
        "get-size")) : e.Masonry = t(e.Outlayer, e.getSize)
})(window, (e, t) => {
    const i = e.create("masonry");
    i.compatOptions.fitWidth = "isFitWidth";
    const n = i.prototype;
    return n._resetLayout = function () {
        this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement(
          "gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
        for (let e = 0; e < this.cols; e++) this.colYs.push(0);
        this.maxY = 0, this.horizontalColIndex = 0
    }, n.measureColumns = function () {
        if (this.getContainerWidth(), !this.columnWidth) {
            const e = this.items[0];
            const i = e && e.element;
            this.columnWidth = i && t(i)
              .outerWidth || this.containerWidth
        }
        const n = this.columnWidth += this.gutter;
        const o = this.containerWidth + this.gutter;
        let s = o / n;
        const a = n - o % n;
        const r = a && 1 > a ? "round" : "floor";
        s = Math[r](s), this.cols = Math.max(s, 1)
    }, n.getContainerWidth = function () {
        const e = this._getOption("fitWidth");
        const i = e ? this.element.parentNode : this.element;
        const n = t(i);
        this.containerWidth = n && n.innerWidth
    }, n._getItemLayoutPosition = function (e) {
        e.getSize();
        const t = e.size.outerWidth % this.columnWidth;
        const i = t && 1 > t ? "round" : "ceil";
        let n = Math[i](e.size.outerWidth / this.columnWidth);
        n = Math.min(n, this.cols);
        for (var o = this.options.horizontalOrder ? "_getHorizontalColPosition" :
          "_getTopColPosition", s = this[o](n, e), a = {
            x: this.columnWidth * s.col,
            y: s.y
        }, r = s.y + e.size.outerHeight, l = n + s.col, c = s.col; l > c; c++) this.colYs[
          c] = r;
        return a
    }, n._getTopColPosition = function (e) {
        const t = this._getTopColGroup(e);
        const i = Math.min(...t);
        return {
            col: t.indexOf(i),
            y: i
        }
    }, n._getTopColGroup = function (e) {
        if (2 > e) return this.colYs;
        for (var t = [], i = this.cols + 1 - e, n = 0; i > n; n++) t[n] = this._getColGroupY(n,
          e);
        return t
    }, n._getColGroupY = function (e, t) {
        if (2 > t) return this.colYs[e];
        const i = this.colYs.slice(e, e + t);
        return Math.max(...i);
    }, n._getHorizontalColPosition = function(e, {size}) {
        let i = this.horizontalColIndex % this.cols;
        const n = e > 1 && i + e > this.cols;
        i = n ? 0 : i;
        const o = size.outerWidth && size.outerHeight;
        return this.horizontalColIndex = o ? i + e : this.horizontalColIndex, {
            col: i,
            y: this._getColGroupY(i, e)
        }
    }, n._manageStamp = function (e) {
        const i = t(e);
        const n = this._getElementOffset(e);
        const o = this._getOption("originLeft");
        const s = o ? n.left : n.right;
        const a = s + i.outerWidth;
        let r = Math.floor(s / this.columnWidth);
        r = Math.max(0, r);
        let l = Math.floor(a / this.columnWidth);
        l -= a % this.columnWidth ? 0 : 1, l = Math.min(this.cols - 1, l);
        for (let c = this._getOption("originTop"),
            u = (c ? n.top : n.bottom) + i.outerHeight,
            d =
              r; l >= d; d++) this.colYs[d] = Math.max(u, this.colYs[d])
    }, n._getContainerSize = function () {
        this.maxY = Math.max(...this.colYs);
        const e = {
            height: this.maxY
        };
        return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e
    }, n._getContainerFitWidth = function () {
        for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];) e++;
        return (this.cols - e) * this.columnWidth - this.gutter
    }, n.needsResizeLayout = function () {
        const e = this.containerWidth;
        return this.getContainerWidth(), e != this.containerWidth
    }, i;
});
const originalTranslate = I18n.t.bind(I18n);
I18n.t = (e, t) => {
    if (t = t || {}, !i18nPrefix) return originalTranslate(e, t);
    t.defaults = [{
        scope: e
    }];
    const i = `${i18nPrefix}.${e}`;
    return originalTranslate(i, t)
}, window.flavourAssetOverrides = {
    policechief: [{
        from: "/images/MC_Logo_en_US.png",
        to: "/images/PC_Logo_en_US.png"
    }, {
        from: "/images/logo.en_US.png",
        to: "/images/PC_Logo_en_US.png"
    }, {
        from: "/images/MC_Logo_fr_FR.png",
        to: "/images/PC_Logo_fr_FR.png"
    }, {
        from: "/images/logo.fr_FR.png",
        to: "/images/PC_Logo_fr_FR.png"
    }, {
        from: "/images/MC_Logo_en_GB.png",
        to: "/images/PC_Logo_en_GB.png"
    }, {
        from: "/images/logo.en_GB.png",
        to: "/images/PC_Logo_en_GB.png"
    }, {
        from: "/images/MC_Logo_fi_FI.png",
        to: "/images/PC_Logo_fi_FI.png"
    }, {
        from: "/images/logo.fi_FI.png",
        to: "/images/PC_Logo_fi_FI.png"
    }, {
        from: "/images/MC_Logo_de_DE.png",
        to: "/images/PC_Logo_de_DE.png"
    }, {
        from: "/images/logo.de_DE.png",
        to: "/images/PC_Logo_de_DE.png"
    }, {
        from: "/images/MC_Logo_en_AU.png",
        to: "/images/PC_Logo_en_AU.png"
    }, {
        from: "/images/logo.en_AU.png",
        to: "/images/PC_Logo_en_AU.png"
    }, {
        from: "/images/MC_Logo_it_IT.png",
        to: "/images/PC_Logo_it_IT.png"
    }, {
        from: "/images/logo.it_IT.png",
        to: "/images/PC_Logo_it_IT.png"
    }, {
        from: "/images/MC_Logo_da_DK.png",
        to: "/images/PC_Logo_da_DK.png"
    }, {
        from: "/images/logo.da_DK.png",
        to: "/images/PC_Logo_da_DK.png"
    }, {
        from: "/images/MC_Logo_cs_CZ.png",
        to: "/images/PC_Logo_cs_CZ.png"
    }, {
        from: "/images/logo.cs_CZ.png",
        to: "/images/PC_Logo_cs_CZ.png"
    }, {
        from: "/images/MC_Logo_pl_PL.png",
        to: "/images/PC_Logo_pl_PL.png"
    }, {
        from: "/images/logo.pl_PL.png",
        to: "/images/PC_Logo_pl_PL.png"
    }, {
        from: "/images/MC_Logo_sv_SE.png",
        to: "/images/PC_Logo_sv_SE.png"
    }, {
        from: "/images/logo.sv_SE.png",
        to: "/images/PC_Logo_sv_SE.png"
    }, {
        from: "/images/MC_Logo_nb_NO.png",
        to: "/images/PC_Logo_nb_NO.png"
    }, {
        from: "/images/logo.nb_NO.png",
        to: "/images/PC_Logo_nb_NO.png"
    }, {
        from: "/images/MC_Logo_nl_NL.png",
        to: "/images/PC_Logo_nl_NL.png"
    }, {
        from: "/images/logo.nl_NL.png",
        to: "/images/PC_Logo_nl_NL.png"
    }, {
        from: "/images/MC_Logo_pt_PT.png",
        to: "/images/PC_Logo_pt_PT.png"
    }, {
        from: "/images/logo.pt_PT.png",
        to: "/images/PC_Logo_pt_PT.png"
    }, {
        from: "/images/logo-header.png",
        to: "/images/pc_logo-header.png"
    }, {
        from: "/images/building_polizeiwache.png",
        to: "/images/policechief_building_polizeiwache.png"
    }, {
        from: "/images/building_polizeischule.png",
        to: "/images/policechief_building_polizeischule.png"
    }, {
        from: "/images/building_helipad_polizei.png",
        to: "/images/policechief_building_helipad_polizei.png"
    }, {
        from: "/images/building_polizeisondereinheiten.png",
        to: "/images/policechief_building_polizeisondereinheiten.png"
    }, {
        from: "/images/building_bereitschaftspolizei.png",
        to: "/images/policechief_building_bereitschaftspolizei.png"
    }, {
        from: "/images/building_commerce_police.png",
        to: "/images/policechief_building_commerce_police.png"
    }, {
        from: "/images/building_bomb_disposal.png",
        to: "/images/policechief_building_bomb_disposal.png"
    }, {
        from: "/images/police.png",
        to: "/images/policechief_police.png"
    }, {
        from: "/images/police2.png",
        to: "/images/policechief_police2.png"
    }, {
        from: "/images/pheli2_1.png",
        to: "/images/policechief_pheli2_1.png"
    }, {
        from: "/images/pheli2_2.png",
        to: "/images/policechief_pheli2_2.png"
    }, {
        from: "/images/police_motorrad.png",
        to: "/images/pc_police_motorrad.png"
    }, {
        from: "/images/police_motorrad2.png",
        to: "/images/pc_police_motorrad2.png"
    }, {
        from: "/images/police_trailer.png",
        to: "/images/pc_police_trailer.png"
    }, {
        from: "/images/police_truck.png",
        to: "/images/pc_police_truck.png"
    }, {
        from: "/images/police_bike.png",
        to: "/images/pc_police_bike.png"
    }, {
        from: "/images/police_bucket.png",
        to: "/images/pc_police_bucket.png"
    }, {
        from: "/images/police_boat.png",
        to: "/images/pc_police_boat.png"
    }, {
        from: "/images/police_civil_car.png",
        to: "/images/pc_police_civil_car.png"
    }, {
        from: "/images/sign_up.en_US.png",
        to: "/images/policechief_sign_up.en.png"
    }, {
        from: "/images/sign_up.en_GB.png",
        to: "/images/policechief_sign_up.en.png"
    }, {
        from: "/images/sign_up.en_AU.png",
        to: "/images/policechief_sign_up.en.png"
    }, {
        from: "/images/sign_up.fr_FR.png",
        to: "/images/policechief_sign_up.fr_FR.png"
    }, {
        from: "/images/sign_up.fi_FI.png",
        to: "/images/policechief_sign_up.fi_FI.png"
    }, {
        from: "/images/sign_up.de_DE.png",
        to: "/images/policechief_sign_up.de_DE.png"
    }, {
        from: "/images/sign_up.it_IT.png",
        to: "/images/policechief_sign_up.it_IT.png"
    }, {
        from: "/images/sign_up.da_DK.png",
        to: "/images/policechief_sign_up.da_DK.png"
    }, {
        from: "/images/sign_up.cs_CZ.png",
        to: "/images/policechief_sign_up.cs_CZ.png"
    }, {
        from: "/images/sign_up.pl_PL.png",
        to: "/images/policechief_sign_up.pl_PL.png"
    }, {
        from: "/images/sign_up.sv_SE.png",
        to: "/images/policechief_sign_up.sv_SE.png"
    }, {
        from: "/images/sign_up.nb_NO.png",
        to: "/images/policechief_sign_up.nb_NO.png"
    }, {
        from: "/images/sign_up.nl_NL.png",
        to: "/images/policechief_sign_up.nl_NL.png"
    }, {
        from: "/images/sign_up.pt_PT.png",
        to: "/images/policechief_sign_up.pt_PT.png"
    }, {
        from: "/images/fire_rot.png",
        to: "/images/theft_rot.png",
        scope: "landing"
    }, {
        from: "/images/MC_LandingPage_US.png",
        to: "/images/PC_LandingPage_US.png"
    }],
    missionchief: []
};
